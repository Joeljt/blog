{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/material/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/material/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/browserstack_logo.png","path":"img/browserstack_logo.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/bg.png","path":"img/bg.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/upyun_logo.svg","path":"img/upyun_logo.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/sidebar_header.png","path":"img/sidebar_header.png","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","path":"fonts/MaterialIcons-Regular.woff","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","path":"fonts/MaterialIcons-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/material/source/css/duoshuo.css","path":"css/duoshuo.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/disqus-proxy.css","path":"css/disqus-proxy.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/disqus-proxy.min.css","path":"css/disqus-proxy.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/duoshuo.min.css","path":"css/duoshuo.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/ie-blocker.css","path":"css/ie-blocker.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/fontawesome.min.css","path":"css/fontawesome.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/gallery.min.css","path":"css/gallery.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/material-icons.css","path":"css/material-icons.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify.css","path":"css/prettify.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/uc.css","path":"css/uc.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify.min.css","path":"css/prettify.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","path":"js/hanabi-browser-bundle.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.en.js","path":"js/ie-blocker.en.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/Valine.min.js","path":"js/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/MathJax.js","path":"js/MathJax.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","path":"js/ie-blocker.zhCN.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/lsloader.js","path":"js/lsloader.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/lsloader.min.js","path":"js/lsloader.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/nprogress.js","path":"js/nprogress.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/queue.js","path":"js/queue.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/prettify.min.js","path":"js/prettify.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/queue.min.js","path":"js/queue.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":0,"renderable":1},{"_id":"themes/material/source/img/daily_pic.png","path":"img/daily_pic.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/portrait.jpeg","path":"img/portrait.jpeg","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","path":"fonts/MaterialIcons-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/material/source/css/material.css","path":"css/material.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/material.min.css","path":"css/material.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/js.min.js","path":"js/js.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/js.js","path":"js/js.js","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","path":"img/footer/footer_ico-bilibili.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","path":"img/footer/footer_ico-gplus.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","path":"img/footer/footer_ico-github.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","path":"img/footer/footer_ico-facebook.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","path":"img/footer/footer_ico-linkedin.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","path":"img/footer/footer_ico-instagram.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","path":"img/footer/footer_ico-telegram.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","path":"img/footer/footer_ico-tumblr.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","path":"img/footer/footer_ico-twitter.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","path":"img/footer/footer_ico-v2ex.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","path":"img/footer/footer_ico-zhihu.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","path":"img/footer/footer_ico-weibo.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/gallery/close.svg","path":"img/gallery/close.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/gallery/arrow.svg","path":"img/gallery/arrow.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/gallery/spinner.svg","path":"img/gallery/spinner.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-10.png","path":"img/random/material-10.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-12.png","path":"img/random/material-12.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-17.png","path":"img/random/material-17.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-3.png","path":"img/random/material-3.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-4.png","path":"img/random/material-4.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-6.png","path":"img/random/material-6.png","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","path":"fonts/MaterialIcons-Regular.eot","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-9.png","path":"img/random/material-9.png","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","path":"css/prettify/atelier-cave-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","path":"css/prettify/atelier-dune-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","path":"css/prettify/atelier-dune-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","path":"css/prettify/atelier-forest-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","path":"css/prettify/atelier-estuary-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","path":"css/prettify/atelier-estuary-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","path":"css/prettify/atelier-heath-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","path":"css/prettify/atelier-forest-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","path":"css/prettify/atelier-heath-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","path":"css/prettify/atelier-lakeside-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","path":"css/prettify/atelier-lakeside-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","path":"css/prettify/atelier-plateau-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","path":"css/prettify/atelier-plateau-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","path":"css/prettify/atelier-savanna-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","path":"css/prettify/atelier-savanna-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","path":"css/prettify/atelier-seaside-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","path":"css/prettify/atelier-sulphurpool-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","path":"css/prettify/atelier-sulphurpool-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/github-v2.min.css","path":"css/prettify/github-v2.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","path":"css/prettify/atelier-seaside-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","path":"css/prettify/hemisu-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/github.min.css","path":"css/prettify/github.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","path":"css/prettify/tomorrow-night-blue.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","path":"css/prettify/hemisu-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","path":"css/prettify/tomorrow-night-eighties.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","path":"css/prettify/tomorrow-night.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","path":"css/prettify/tomorrow.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","path":"css/prettify/tranquil-heart.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","path":"css/prettify/vibrant-ink.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","path":"css/prettify/tomorrow-night-bright.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-1.png","path":"img/random/material-1.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-11.png","path":"img/random/material-11.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-13.png","path":"img/random/material-13.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-15.png","path":"img/random/material-15.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-14.png","path":"img/random/material-14.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-16.png","path":"img/random/material-16.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-18.png","path":"img/random/material-18.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-2.png","path":"img/random/material-2.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-5.png","path":"img/random/material-5.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-8.png","path":"img/random/material-8.png","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","path":"css/prettify/atelier-cave-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-19.png","path":"img/random/material-19.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-7.png","path":"img/random/material-7.png","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","path":"fonts/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","path":"fonts/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","path":"fonts/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","path":"fonts/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","path":"fonts/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","path":"fonts/Roboto-Black.ttf","modified":0,"renderable":1}],"Cache":[{"_id":"themes/material/.gitignore","hash":"cf4e2dcaa760ff6f7520fd032ce44574e2970e54","modified":1534241511791},{"_id":"themes/material/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1534241511812},{"_id":"source/CNAME","hash":"fb5a88c062706435767090b234bdbb58a8041c61","modified":1534241511791},{"_id":"source/.DS_Store","hash":"b16cb8f8182b25fb627a41bcba9c834ec5def867","modified":1572339994839},{"_id":"themes/material/_config.yml","hash":"e71e78cabe9be1a1b85f3fdb46b8d66f64f7d7f9","modified":1554897425173},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1567156418279},{"_id":"source/_posts/Android Paint- .measureText() VS .getTextBounds().md","hash":"9e27ea811b6fed5bc5904978b26b552ac84be2e3","modified":1543228986981},{"_id":"source/_posts/Android-collapse-status-bar.md","hash":"b3455dcfb2352c36af04d671e08aa5dad4608f25","modified":1557750862745},{"_id":"source/_posts/Android-MeasureSpec.md","hash":"0082fe0774432bc2a63687c77aab716afcdb6879","modified":1554897291189},{"_id":"source/_posts/Canvas.drawPath().md","hash":"a98307f136d97fd04f6c4631b5d97b60f184743b","modified":1553165748335},{"_id":"source/_posts/Efficient-Android-Threading-chapter-2.md","hash":"9bbf7912a03355fa843f88c406de3b9e1db5afc3","modified":1553165500270},{"_id":"source/_posts/Efficient-Android-Threading-chapter-4-1.md","hash":"2522d69b2ff57e2540cc87a83924e5e76e9632a8","modified":1553165246820},{"_id":"source/_posts/Efficient-Android-Threading-chapter-3.md","hash":"f6795eb94e64bf76004ee54e6ecb217cb0feb684","modified":1553165619443},{"_id":"source/_posts/ConstraintLayout-learning.md","hash":"cacaf35c622970510cafb9f84a6bd99b740c8177","modified":1553251891927},{"_id":"source/_posts/Efficient-Android-Threading-chapter-4-2.md","hash":"dd6ac70e1d7098aaab984bcc15f5416bc4bf946b","modified":1553165257178},{"_id":"source/_posts/TrackColorTextView.md","hash":"982f00029a9d31077177087ab9585e2577340efe","modified":1543228837000},{"_id":"source/_posts/android-view-post.md","hash":"16fb6c6be18537c341c760d4afd827f9f0d3bf21","modified":1553163331549},{"_id":"source/_posts/TextView.md","hash":"e68356d7c4185eb21f2478b5fe763ae610ec3901","modified":1543228957807},{"_id":"source/_posts/bug-of-mysql.md","hash":"da5c59fa94664c595e4fab56ad6edada4cd357b2","modified":1534241511791},{"_id":"source/_posts/can-not-get-height-in-onCreate.md","hash":"d8556462cecb254c4b3a31a47a613bb58d9798c5","modified":1553165448542},{"_id":"source/_posts/ViewDragHelper-source-code.md","hash":"11a21e4c623d917ba8ae6c8f7f5a5bd793322532","modified":1557751411980},{"_id":"source/_posts/color-track-textview.md","hash":"f4ab2d3b2830c02979a564ae4410247c5f3808a5","modified":1553164423994},{"_id":"source/_posts/View-inflate-analysis.md","hash":"c36ab482999c52df4a565e48caa694f2cdf4a04e","modified":1553849279124},{"_id":"source/_posts/custom-view-parallax.md","hash":"0599c77c2b782f4cc376b140765dde4130d02372","modified":1555320253834},{"_id":"source/_posts/design-pattern-factory.md","hash":"43975c6cd50d9095774becd09c504e13b967cc8f","modified":1572339885657},{"_id":"source/_posts/design-pattern-decoration.md","hash":"6715b657a8a11fce60ede7ec7f353d8482521639","modified":1572578560280},{"_id":"source/_posts/design-pattern-builder.md","hash":"ef698c30da40042158e2918937ac21b236d6ee52","modified":1572080508879},{"_id":"source/_posts/design-pattern-template.md","hash":"80436a41b646363bd809362164b0a19b319eda2a","modified":1573116726238},{"_id":"source/_posts/design-pattern-singleton.md","hash":"145ccee5fd5d9f40749296ee03d6a04c113a7a3e","modified":1572077462086},{"_id":"source/_posts/design-pattern-strategy.md","hash":"4c863ce2a63a3838eb36eb38e93794b643f05ea5","modified":1573207188722},{"_id":"source/_posts/differ-of-abstract-interface.md","hash":"bcdbfa670c5ef2a7146bdb9a0bf39277b6157823","modified":1534241511791},{"_id":"source/_posts/java-proxy-pattern.md","hash":"d4adb8c0f1096dc4d1a32cb70e858a9cdd534ccc","modified":1565774119456},{"_id":"source/_posts/message-enqueue-process.md","hash":"c3ce80eb3cee0ade5a16924dee7419bf96efbac1","modified":1572075735935},{"_id":"source/_posts/polymorphism-of-java.md","hash":"760424d75a98da04e3634839194d3438a9094877","modified":1534241511791},{"_id":"source/_posts/what's the fuck is Context.md","hash":"307ad9ccbac6fe2977bfad38c428f28dc1f666ba","modified":1573728272836},{"_id":"source/_posts/start-activity-procedure.md","hash":"b033dfd86334a0c9ed00e3b8cac7098526b47cd2","modified":1567154894858},{"_id":"source/timeline/index.md","hash":"2f904a9468375cb479bdd574c2ce4911ded736d7","modified":1534403512224},{"_id":"source/tags/index.md","hash":"668119f5b5ab4d0ca02d0506eee4dbcb1c7117ba","modified":1534403366881},{"_id":"themes/material/languages/ar.yml","hash":"472d71f052e08f3c03b15dd67d11ad41f2eee7bf","modified":1534241511792},{"_id":"themes/material/languages/de.yml","hash":"bce37d066ffa82f3e249d41d0ee883c913cc2c5f","modified":1534241511792},{"_id":"themes/material/languages/en.yml","hash":"b59136a1b4d0a77e550b0e7e2e430cac44230dd3","modified":1534241511792},{"_id":"themes/material/languages/fr.yml","hash":"f456cf31a72d97f2f18e3bb6cf735285d2b9d2c5","modified":1534241511793},{"_id":"themes/material/languages/es.yml","hash":"d35f5411bc87277cc2d3a58d9499ddb9cfd46f1b","modified":1534241511792},{"_id":"themes/material/languages/nl_NL.yml","hash":"b71e59807716185627d6b9b84e44a79401df639f","modified":1534241511793},{"_id":"themes/material/languages/ja.yml","hash":"768b8330c9c73287efd475e68741ce4ebad29fd1","modified":1534241511793},{"_id":"themes/material/languages/ms.yml","hash":"237a39bbfcce33e7b918f6c5dc0f01bc79900262","modified":1534241511793},{"_id":"themes/material/languages/pt-BR.yml","hash":"a070c2c4d0d3d54f8ca70513cff73c3f7c306db1","modified":1534241511793},{"_id":"themes/material/languages/zh-CN.yml","hash":"c188cad1a16ab0651e2d2d03cb3fa79962cf65ff","modified":1534241511794},{"_id":"themes/material/languages/ru.yml","hash":"fbff2cf48dbde45adcad781e2fd6c30b523a4ac1","modified":1534241511793},{"_id":"themes/material/languages/zh-TW.yml","hash":"ec55953f0330f81bf1ffb37ff34de258dfda642a","modified":1534241511794},{"_id":"themes/material/layout/index.ejs","hash":"aca1abb741f891776913c8ea2e6ff626a0ea5736","modified":1534241511811},{"_id":"themes/material/layout/post.ejs","hash":"4dd572a9e84f3a6baa5e3f16d270e58e3cd31a23","modified":1534241511812},{"_id":"themes/material/layout/layout.ejs","hash":"94f66850b815a262c0f8ff112a32a0a6f43066e3","modified":1534241511811},{"_id":"themes/material/scripts/helper.js","hash":"e7111a8b1f0ab5bf3466378c48c260a4f6e527d6","modified":1534241511812},{"_id":"themes/material/layout/_partial/Isolation-post-info.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534241511794},{"_id":"themes/material/scripts/lib/font_lsload.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534241511812},{"_id":"themes/material/layout/_partial/Paradox-post-info.ejs","hash":"125cfa5cd9e6e1ca5e958026fdd42f3c3141e34f","modified":1534241511794},{"_id":"themes/material/layout/_partial/Paradox-post-thumbnail.ejs","hash":"6f1e9a85c089ce98a36a2954839fb9ce3e53739e","modified":1534241511794},{"_id":"themes/material/layout/_partial/Paradox-post_entry-thumbnail.ejs","hash":"4d740eba338517d4e10d011a157cdefad45a8e1f","modified":1534241511795},{"_id":"themes/material/layout/_partial/Isolation-post_entry.ejs","hash":"134dc82320b7aed7d4d78960be63e16c5c4a30fb","modified":1534241511794},{"_id":"themes/material/layout/_partial/Paradox-search.ejs","hash":"18a6971b04feccd124a096b8c7cecf1fd4bb914e","modified":1534241511795},{"_id":"themes/material/layout/_partial/Paradox-post_entry.ejs","hash":"5f4d67e5bd70f635203706cf344b036d891073e6","modified":1534241511795},{"_id":"themes/material/layout/_partial/blog_info.ejs","hash":"5e95796e6f9a81163554ca4198573860f7328d4e","modified":1534241511795},{"_id":"themes/material/layout/_partial/comment.ejs","hash":"c9fb1f98a18ca484cb52d60e2ad2bad25b56dfb2","modified":1534241511795},{"_id":"themes/material/layout/_partial/config_css.ejs","hash":"2b1e27faa0446a5e756e61ddf3e969e50948f1ce","modified":1534241511795},{"_id":"themes/material/layout/_partial/config_font.ejs","hash":"730abeb681758ce288d5541930c46bc4b041a0b1","modified":1534241511796},{"_id":"themes/material/layout/_partial/footer-left.ejs","hash":"372cdf718e01fea2736b8e427e57bfcfaa8a557f","modified":1534241511796},{"_id":"themes/material/layout/_partial/daily_pic.ejs","hash":"e780fbdb79b5e27091c408545cfd5b64892c9b01","modified":1534241511796},{"_id":"themes/material/layout/_partial/footer-option.ejs","hash":"be20394eaeaf2d20db28946b948962c839da6ea9","modified":1534241511796},{"_id":"themes/material/layout/_partial/footer.ejs","hash":"530626c347882579d09d71df68993e25076ca8e2","modified":1534241511796},{"_id":"themes/material/layout/_partial/footer_top.ejs","hash":"9eaace4feb951c96c0033e7271497f3f300d2476","modified":1534241511796},{"_id":"themes/material/layout/_partial/isolate-sns_list.ejs","hash":"fc5f03ebb847f85975676a9dfee8870e7c908008","modified":1534241511797},{"_id":"themes/material/layout/_partial/import_js.ejs","hash":"961b8a0059875e4044fe80bbe91ca6a225f113e5","modified":1534241511797},{"_id":"themes/material/layout/_partial/head.ejs","hash":"8167f995c7cc21a6a8ddbfbdd03f2f74a7bd904d","modified":1534241511797},{"_id":"themes/material/layout/_partial/isolate_info.ejs","hash":"b8ec76716bfa2e6513b4df6814fe8676536a94c1","modified":1534241511797},{"_id":"themes/material/layout/_partial/post-content.ejs","hash":"ad626e3b60bc4a17bacff02cf9b0a8beaba2ad1e","modified":1534241511797},{"_id":"themes/material/layout/_partial/post-header.ejs","hash":"b0b8973c48db6376a24d4b4b1d2eb15d18d6508c","modified":1534241511798},{"_id":"themes/material/layout/_partial/post-info-share.ejs","hash":"9f28d62bf728c2bd89411688426a65d7ee55400c","modified":1534241511798},{"_id":"themes/material/layout/_partial/post-nav.ejs","hash":"3b6d4568cc46f60c697ad9ec85a4aa5971f3eecc","modified":1534241511798},{"_id":"themes/material/layout/_partial/sidebar-footer.ejs","hash":"6c3486b846473e0d58666f7a8720f5bf4a14e030","modified":1534241511798},{"_id":"themes/material/layout/_partial/sidebar-header.ejs","hash":"06295e01092f55504d30a343c3fdc5091280e495","modified":1534241511799},{"_id":"themes/material/layout/_partial/sidebar-footer_image.ejs","hash":"b9157d2072028a1db3c3419f76bde6637e85cf0e","modified":1534241511799},{"_id":"themes/material/layout/_partial/sidebar.ejs","hash":"c5ce6136e82895cb80dab8a918a7cdf2fe820fea","modified":1534241511799},{"_id":"themes/material/layout/_partial/sidebar-navigation.ejs","hash":"ff44901fdfdd952174b0d22e86df7163d7fba9ba","modified":1534241511799},{"_id":"themes/material/layout/_partial/structured-data.ejs","hash":"d6681d472d6840d2335397790acd0cfa6a8e74d9","modified":1534241511799},{"_id":"themes/material/layout/_partial/toc_button.ejs","hash":"688c3fc12e2548ff27fe60688f79dcce2881fd50","modified":1534241511799},{"_id":"themes/material/layout/_widget/leancloud-views_num.ejs","hash":"e27baba6a2de406463735d276606b15fb40f5eba","modified":1534241511809},{"_id":"themes/material/layout/_widget/leancloud-like.ejs","hash":"e4780fe3bbb049db38d694fc18dee13d799bd51d","modified":1534241511809},{"_id":"themes/material/layout/_widget/leancloud-views.ejs","hash":"211dc183b8e84f71b2c25b3ac6659d162d81662b","modified":1534241511809},{"_id":"themes/material/layout/_widget/dnsprefetch.ejs","hash":"5e4c5359d69a64042183db13f6dd771b1f7f6b31","modified":1534241511809},{"_id":"themes/material/layout/_widget/page-links.ejs","hash":"0ebe18e4326f921d6010df8479a08c2d403ba717","modified":1534241511810},{"_id":"themes/material/layout/_widget/mathjax.ejs","hash":"b68befe1fea84739c8429c344e570a8bc0357401","modified":1534241511810},{"_id":"themes/material/layout/_widget/nprogress.ejs","hash":"901a64600854b312209287c702278183600e06b9","modified":1534241511810},{"_id":"themes/material/layout/_widget/page-gallery.ejs","hash":"81b9410deef7a83ef5bc7cd18ad042df70d70b94","modified":1534241511810},{"_id":"themes/material/layout/_widget/page-tagcloud.ejs","hash":"e71de74e4067cc4e6aef1e09ac429c92bcd178b3","modified":1534241511810},{"_id":"themes/material/layout/_widget/qrcode.ejs","hash":"575e63ad12e856d58dc749cb9de9f256a8f13593","modified":1534241511811},{"_id":"themes/material/layout/_widget/page-timeline.ejs","hash":"9fa0195e08d9fd40aa0333e9279c98bc65acf604","modified":1534241511811},{"_id":"themes/material/layout/_widget/search-swiftype-js.ejs","hash":"7ad1e843e620ccd9b3c041dccfdcee97921247a1","modified":1534241511811},{"_id":"themes/material/layout/_widget/search-local-js.ejs","hash":"f42cc040adf47fc7d74f64b0be3c3230e8a3339e","modified":1534241511811},{"_id":"themes/material/layout/_widget/tagcloud.ejs","hash":"88b2e2cc54e280651af2f4107e5c82dbd4288ddf","modified":1534241511811},{"_id":"themes/material/scripts/lib/css_lsload.js","hash":"179f5f5e3297a7fb7d90545ddd94eb468a11046e","modified":1534241511812},{"_id":"themes/material/scripts/lib/get_file_hex.js","hash":"eb3b9a45f8ca45ef40d5421baef7d4484023982c","modified":1534241511812},{"_id":"themes/material/scripts/lib/js_hex.js","hash":"2704583aa036d538544ce31c2e924c0c125309dd","modified":1534241511813},{"_id":"themes/material/scripts/lib/js_lsload.js","hash":"72f885b13fe0028a0e2acb7168dcc66e39ea1592","modified":1534241511813},{"_id":"themes/material/scripts/lib/path_for.js","hash":"f944e3b53a468962121aa3357cc0bc18ac27a34c","modified":1534241511813},{"_id":"themes/material/source/img/avatar.jpg","hash":"859cc1776449dde1c08526076af2d82e0e8da931","modified":1534241511860},{"_id":"themes/material/source/img/avatar.png","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1534241511860},{"_id":"themes/material/source/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1534241511861},{"_id":"themes/material/source/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1534241511861},{"_id":"themes/material/source/img/favicon.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1534241511861},{"_id":"themes/material/source/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1534241511868},{"_id":"themes/material/source/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1534241511880},{"_id":"themes/material/source/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1534241511879},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1534241511831},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1534241511831},{"_id":"themes/material/source/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1534241511813},{"_id":"themes/material/source/css/disqus-proxy.css","hash":"d5086cda8aaae20b8d3f9dd50f0be5ccb717e42a","modified":1534241511813},{"_id":"themes/material/source/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1534241511813},{"_id":"themes/material/source/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1534241511814},{"_id":"themes/material/source/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1534241511814},{"_id":"themes/material/source/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1534241511814},{"_id":"themes/material/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1534241511814},{"_id":"themes/material/source/css/material-icons.css","hash":"f6f95fe5190f3c65931847246621fb83754eb00c","modified":1534241511815},{"_id":"themes/material/source/css/prettify.css","hash":"c395f20ee64e80c2b6b15c7dade02f9aaaeab2c8","modified":1534241511816},{"_id":"themes/material/source/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1534241511826},{"_id":"themes/material/source/css/prettify.min.css","hash":"62edd8f08656463b0e077dcf893faa3cc8eb5fe4","modified":1534241511816},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","hash":"d646647bda386140c8315d60e3ff4ddbdb15c1ea","modified":1534241511882},{"_id":"themes/material/source/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1534241511882},{"_id":"themes/material/source/js/Valine.min.js","hash":"6a287a99a772a0ea8f98b133523429c9250cc67f","modified":1534241511881},{"_id":"themes/material/source/js/MathJax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1534241511880},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1534241511882},{"_id":"themes/material/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1534241511884},{"_id":"themes/material/source/js/lsloader.js","hash":"2b14e57784fb6b5f58d71584189c61af45f393e8","modified":1534241511885},{"_id":"themes/material/source/js/lsloader.min.js","hash":"1a68a8d267948ea8475245b7d365a1a1bd8f732e","modified":1534241511885},{"_id":"themes/material/source/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1534241511885},{"_id":"themes/material/source/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1534241511886},{"_id":"themes/material/source/js/prettify.min.js","hash":"69908fe0a09cee107c25cb5d769b861723e7b7bb","modified":1534241511885},{"_id":"themes/material/source/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1534241511886},{"_id":"themes/material/source/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1534241511886},{"_id":"themes/material/source/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1534241511861},{"_id":"themes/material/source/img/portrait.jpeg","hash":"1521ba5b86020bb5c417572f250d84109d62c7c2","modified":1534394897343},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1534241511831},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1534241511859},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1534241511860},{"_id":"themes/material/source/css/material.css","hash":"068e2b00f686157b6e8b78b9b808112adbedf4de","modified":1534241511815},{"_id":"themes/material/source/css/material.min.css","hash":"1a19febb9214ab689b02f5bb8ccb23579e6c1181","modified":1534241511816},{"_id":"themes/material/source/css/style.css","hash":"a2f27c40f412dc24e1ed5f62a4117523a226eed0","modified":1534241511826},{"_id":"themes/material/source/css/style.min.css","hash":"a9e9b33e1fcf818f08a04b909c86f2460a05f060","modified":1534241511826},{"_id":"themes/material/source/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1534241511883},{"_id":"themes/material/source/js/js.min.js","hash":"709d347d3be033b841de0493b7cf532b594bb1f6","modified":1534241511884},{"_id":"themes/material/source/js/js.js","hash":"64b3f20e7138674ecf21e6e3982565ea63feae26","modified":1534241511883},{"_id":"themes/material/layout/_widget/analytics/baidu-analytics.ejs","hash":"3866a7fead3c1f94a517f1f9d629f092670b1520","modified":1534241511800},{"_id":"themes/material/layout/_widget/analytics/google-analytics.ejs","hash":"3b10ebf524baf0c24b22dcd110b39d15c5acb9b5","modified":1534241511800},{"_id":"themes/material/layout/_widget/analytics/cnzz-analytics.ejs","hash":"1765e3dcd92961292f40d1812e593186c77b17ef","modified":1534241511800},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1534241511862},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1534241511863},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1534241511863},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1534241511863},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1534241511864},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1534241511863},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1534241511864},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1534241511864},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1534241511865},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","hash":"c5ffaf67a97e534c266d1585a9a3b56f1bfe3052","modified":1534241511865},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1534241511866},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1534241511866},{"_id":"themes/material/source/img/gallery/close.svg","hash":"0739fa52652dd59cebecc861144b702e455adb0c","modified":1534241511867},{"_id":"themes/material/source/img/gallery/arrow.svg","hash":"68799fe01ecc7f5fb721287693b9b0b93f4c067a","modified":1534241511866},{"_id":"themes/material/source/img/gallery/spinner.svg","hash":"ef69a35119feb82d8e9cf4a59656aa25051afebd","modified":1534241511867},{"_id":"themes/material/source/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1534241511869},{"_id":"themes/material/source/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1534241511870},{"_id":"themes/material/source/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1534241511873},{"_id":"themes/material/source/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1534241511875},{"_id":"themes/material/source/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1534241511876},{"_id":"themes/material/source/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1534241511877},{"_id":"themes/material/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1534241511828},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1534241511830},{"_id":"themes/material/source/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1534241511879},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1534241511855},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1534241511859},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","hash":"4b62dc45aa351b071d6a434dc54fe8c2e15c85cc","modified":1534241511816},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","hash":"c5094d99ca0e619d97860c88211bf908fdf830b1","modified":1534241511816},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","hash":"b3ad98483e4d5bde72d52a15423d98e0d086db09","modified":1534241511817},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","hash":"9296b851a5b66785a60afa5da5fe9080bda96bf5","modified":1534241511818},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","hash":"7e3a065cafeb3acc1d7178f64ef4265f5d5ad2b9","modified":1534241511817},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","hash":"1d12d8f7fa9c122a186ee76fdf681c191a68f104","modified":1534241511817},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","hash":"a67199fa580b3aa2df031e5d2028929d29ca3b45","modified":1534241511819},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","hash":"3532f6e86bf4afbba05f7a074b791b73174f9622","modified":1534241511818},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","hash":"954309acd7918422382a3ff2f9c2988aec0ff956","modified":1534241511819},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","hash":"18575fc6dff855e395a39d0383d2f18807091f0d","modified":1534241511819},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","hash":"e20e8ac64432fa1aa6f74792b58196af7cf79c12","modified":1534241511820},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","hash":"137e3c499a720da3c1d57b4dc53264b1d623e1c5","modified":1534241511820},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","hash":"153801640fdcbb74c0de3f15345110f2210eb991","modified":1534241511820},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","hash":"fba92c652fd6704422b8f2bbc11706805a6faed0","modified":1534241511820},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","hash":"d9425ffb7c60d646190c22b9a5f72091ee5f9ace","modified":1534241511820},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","hash":"e0e6bbacc75a349b1e49c236d374b0e42f1fd485","modified":1534241511821},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","hash":"ab1a6200eab648cab443c3df77fde9b237ef27b6","modified":1534241511821},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","hash":"015a35dddaee153fa8bb71d7f3818a6ba4d120d8","modified":1534241511821},{"_id":"themes/material/source/css/prettify/github-v2.min.css","hash":"57630621d20842a529bdea7b17fc90f520e562ef","modified":1534241511821},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","hash":"732750b75389c1c49204f37705e6abeee40ce64f","modified":1534241511821},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","hash":"a671248cfd573292026d2174817e82e593691052","modified":1534241511822},{"_id":"themes/material/source/css/prettify/github.min.css","hash":"19cf828225288fa5c006f1d8f66c39d11f4ef7f2","modified":1534241511821},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","hash":"c442728d96485bcf816151fe6bd96993aae09852","modified":1534241511823},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","hash":"b2556ff41e513fd13d032ec84a37ee260a905815","modified":1534241511823},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","hash":"6ce259d674bb4edda23eea32b2379be17d0e0e6e","modified":1534241511824},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","hash":"d989206d124035494acb4b0cdc7fbc89f3b7d108","modified":1534241511824},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","hash":"b2c6d610b77f0273fefab5aa4ad26a7f58956f87","modified":1534241511824},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","hash":"0f6eefbdda8e410832e9c516a5dd19899217ef06","modified":1534241511824},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","hash":"c265bac6c31cf622b536b29c8a6bc46955d6fe63","modified":1534241511825},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","hash":"cf251fd3edfd736695272a0f1b41d509b7bb1fb9","modified":1534241511823},{"_id":"themes/material/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1534241511881},{"_id":"themes/material/layout/_widget/comment/livere/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534241511807},{"_id":"themes/material/layout/_widget/comment/valine/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534241511808},{"_id":"themes/material/source/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1534241511868},{"_id":"themes/material/source/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1534241511869},{"_id":"themes/material/source/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1534241511871},{"_id":"themes/material/source/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1534241511872},{"_id":"themes/material/source/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1534241511871},{"_id":"themes/material/source/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1534241511873},{"_id":"themes/material/source/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1534241511874},{"_id":"themes/material/source/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1534241511875},{"_id":"themes/material/source/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1534241511876},{"_id":"themes/material/source/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1534241511878},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","hash":"cb0156cdc36500a26b232ae1c81fdc880eba85e7","modified":1534241511816},{"_id":"themes/material/layout/_widget/comment/changyan/enter.ejs","hash":"e3cfb4f37ea35457f112f3e822e130c930086497","modified":1534241511801},{"_id":"themes/material/layout/_widget/comment/changyan/common.ejs","hash":"40e1fc76d6b7f64e226693fb2fe1a6bb17bae245","modified":1534241511801},{"_id":"themes/material/layout/_widget/comment/changyan/main.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1534241511801},{"_id":"themes/material/layout/_widget/comment/disqus/common.ejs","hash":"c11cfceb0906a96399dede5da01ff7fe4787f8a5","modified":1534241511801},{"_id":"themes/material/layout/_widget/comment/disqus/enter.ejs","hash":"39192034766349e47967da63184f9104fdded2ab","modified":1534241511802},{"_id":"themes/material/layout/_widget/comment/disqus/main.ejs","hash":"21e0eeff664191b818d7a0071ae7edcdfc270442","modified":1534241511802},{"_id":"themes/material/layout/_widget/comment/disqus_click/main.ejs","hash":"f53de208ca46c669a868a1922488e39509c6fe3b","modified":1534241511803},{"_id":"themes/material/layout/_widget/comment/disqus_click/common.ejs","hash":"d243f576b366a62191066459efcc6fd0ab79d00a","modified":1534241511802},{"_id":"themes/material/layout/_widget/comment/disqus_click/enter.ejs","hash":"d82f0296f8bae25223ec44e6e05b817d3a234884","modified":1534241511802},{"_id":"themes/material/layout/_widget/comment/gitalk/common.ejs","hash":"f739897518011e1b3de7807c8c5d734984711282","modified":1534241511804},{"_id":"themes/material/layout/_widget/comment/gitment/common.ejs","hash":"9c6c8d1b448c32afb01c2d0351e87f4d4a17ec3c","modified":1534241511806},{"_id":"themes/material/layout/_widget/comment/gitalk/enter.ejs","hash":"4d70d76465469a57def29a221962a5520fb34ebe","modified":1534241511804},{"_id":"themes/material/layout/_widget/comment/gitalk/main.ejs","hash":"1ee7a7b2b9b5ae8c4fa8c4b09c7973b9e085bdf2","modified":1534241511805},{"_id":"themes/material/layout/_widget/comment/gitment/enter.ejs","hash":"46d904fde9233694b95c6a3d91b9a2b7a6805850","modified":1534241511806},{"_id":"themes/material/layout/_widget/comment/livere/enter.ejs","hash":"194b7bb581a3b8608a7ab135b6953d7908f51cc8","modified":1534241511807},{"_id":"themes/material/layout/_widget/comment/gitment/main.ejs","hash":"e622660eda38cda05847aadc2a3e31a228fc519b","modified":1534241511806},{"_id":"themes/material/layout/_widget/comment/livere/main.ejs","hash":"1c4be9ba104a8cbcc11d45f11bf8cfe7704b93a5","modified":1534241511807},{"_id":"themes/material/layout/_widget/comment/valine/enter.ejs","hash":"56e74a1147bd2fa5a14c86375bef517a351a20d2","modified":1534241511808},{"_id":"themes/material/layout/_widget/comment/valine/main.ejs","hash":"0d044c3b8141809ead06a870b5ce65bf95647c14","modified":1534241511809},{"_id":"themes/material/source/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1534241511874},{"_id":"themes/material/source/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1534241511878},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1534241511857},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1534241511842},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1534241511846},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1534241511850},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1534241511854},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1534241511838},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1534241511835},{"_id":"public/atom.xml","hash":"dde317eb3ffb5bac4cd0fb5e597f32bed5ef8c25","modified":1573728350797},{"_id":"public/timeline/index.html","hash":"4a4f7cb94275fe7d87528a241c8c85dcc48706e3","modified":1573728351282},{"_id":"public/tags/index.html","hash":"55d9dc0134154fc83e9a6513e2a689bdf13a5ccd","modified":1573728351282},{"_id":"public/2019/11/08/design-pattern-strategy/index.html","hash":"98db0180a5b7f8175e2e7f976c86e5b5b390f8e9","modified":1573728351283},{"_id":"public/2019/11/14/what's the fuck is Context/index.html","hash":"84ab39a099770c22404d1150b79f95aee042b932","modified":1573728351283},{"_id":"public/2019/11/06/design-pattern-template/index.html","hash":"90e478f8fc961b2237adba51e13aa4bb5e434f6b","modified":1573728351283},{"_id":"public/2019/11/01/design-pattern-decoration/index.html","hash":"b94dc78a0de1db2c1c19593a2d57098927f63b54","modified":1573728351283},{"_id":"public/2019/10/29/design-pattern-factory/index.html","hash":"78a42c0eaac40d96a753c3036454db85f025243f","modified":1573728351283},{"_id":"public/2019/10/26/design-pattern-singleton/index.html","hash":"7ac30b9ed084d9a92a12f6399bcedf07de40f5bc","modified":1573728351283},{"_id":"public/2019/10/26/design-pattern-builder/index.html","hash":"390a359502bd516da104f41bb8113a07a90b895f","modified":1573728351283},{"_id":"public/2019/10/26/message-enqueue-process/index.html","hash":"fbe798a60c0b137251c89e058c2ca1d94472d7e9","modified":1573728351283},{"_id":"public/2019/08/30/start-activity-procedure/index.html","hash":"34d6301e5b66c5811575cdb16142cc977904c2a9","modified":1573728351283},{"_id":"public/2019/08/14/java-proxy-pattern/index.html","hash":"0a79df9bff010f7ae9e736d7816fcbc936f6d7b6","modified":1573728351283},{"_id":"public/2019/05/13/Android-collapse-status-bar/index.html","hash":"bfafd827497766e80a6654056f7bd7c223d3aebd","modified":1573728351283},{"_id":"public/2019/05/13/ViewDragHelper-source-code/index.html","hash":"88bb6cfb77e24e319b548d3fdacee7ce8a9d15a0","modified":1573728351283},{"_id":"public/2019/04/15/custom-view-parallax/index.html","hash":"2d33c6caaf68399cd0e7a6001d466c9208896892","modified":1573728351283},{"_id":"public/2019/04/10/Android-MeasureSpec/index.html","hash":"28692b6dbd8cdd58413689bf6d28bd2a09d7d6cd","modified":1573728351283},{"_id":"public/2019/03/29/View-inflate-analysis/index.html","hash":"e2d6b49befb6c977008aa53e0de3ff6853b12778","modified":1573728351283},{"_id":"public/2019/03/22/ConstraintLayout-learning/index.html","hash":"fd299189b0567d23618846cf829c5d13d8507814","modified":1573728351283},{"_id":"public/2018/09/09/Efficient-Android-Threading-chapter-4-1/index.html","hash":"0e1dcb6f99a25a3c848644fcf0589eea87acb8f1","modified":1573728351283},{"_id":"public/2018/09/09/Efficient-Android-Threading-chapter-4-2/index.html","hash":"e20cf22c28e6697765d2d654859c2c90596dcbd9","modified":1573728351284},{"_id":"public/2018/08/29/Efficient-Android-Threading-chapter-3/index.html","hash":"21de4865a68188c57971bab7665e87376275bcc8","modified":1573728351284},{"_id":"public/2018/08/25/Efficient-Android-Threading-chapter-2/index.html","hash":"905a0390b851b254fe2f0117300c4ef78cbc1ae6","modified":1573728351285},{"_id":"public/2018/08/14/android-view-post/index.html","hash":"b91ca34b276a681b63d74c2f814387cd3345324f","modified":1573728351285},{"_id":"public/2018/08/13/can-not-get-height-in-onCreate/index.html","hash":"d19ed4320ae05afce1ef08553f27e0332703aa2c","modified":1573728351285},{"_id":"public/2018/08/12/color-track-textview/index.html","hash":"5b39e7fb199795869dc7c88de64e24792a723bdd","modified":1573728351285},{"_id":"public/2018/05/28/Canvas.drawPath()/index.html","hash":"cbf0e40490bc937c6c20550ab762e18faf69b378","modified":1573728351285},{"_id":"public/2018/05/28/bug-of-mysql/index.html","hash":"f43cc1af7c8dd1ad9e5559223aa1fb488b01b58b","modified":1573728351285},{"_id":"public/2018/03/29/Android Paint- .measureText() VS .getTextBounds()/index.html","hash":"3d9daa6781dc62489e3111907b3f39211337a906","modified":1573728351285},{"_id":"public/2018/03/19/TrackColorTextView/index.html","hash":"babd3465ef37aedbf543c006f23b0fb382140865","modified":1573728351285},{"_id":"public/2018/03/09/differ-of-abstract-interface/index.html","hash":"5d26314819eb6bea47c580f21f68d0abc58f8b32","modified":1573728351285},{"_id":"public/2018/03/09/polymorphism-of-java/index.html","hash":"f39b412003226363e70c277bfea62571ea4d4a05","modified":1573728351285},{"_id":"public/2018/03/07/TextView/index.html","hash":"841c642d234f990c7115ceea08d3693cc72eb151","modified":1573728351285},{"_id":"public/archives/index.html","hash":"4ab1c5103e2a6b4d42cf4ce37f64c6bb7f217946","modified":1573728351285},{"_id":"public/index.html","hash":"3b685b47de5347b1cbfccbe13c44ec4bd8246cac","modified":1573728351285},{"_id":"public/page/2/index.html","hash":"00f9cd9358339ce88d9fae7c2a2363588b93f7c6","modified":1573728351285},{"_id":"public/page/3/index.html","hash":"4eda5a03b92d28e3c1b93ac1fb41785ab6686841","modified":1573728351285},{"_id":"public/tags/Android/index.html","hash":"9664ca42bbfc9f8c7ea0c3931634a7fc08435313","modified":1573728351285},{"_id":"public/tags/design-pattern/index.html","hash":"205d06cd2a1ffd6d34938abc1e0135a7e9b20b33","modified":1573728351285},{"_id":"public/tags/Android/page/2/index.html","hash":"bc26648756e33c64054899332bfbafe18295a3b7","modified":1573728351286},{"_id":"public/tags/android/index.html","hash":"2aff34dde9b5975b16ca2bbc6cc9cb1a1d0d4725","modified":1573728351286},{"_id":"public/tags/java基础/index.html","hash":"6d493c4ec7c45f577809ec377e98251eb3d1835b","modified":1573728351286},{"_id":"public/tags/读书笔记/index.html","hash":"5216f36e5e566457f35e06276c19b8fb36af20e2","modified":1573728351286},{"_id":"public/tags/Efficient-Android-Threading/index.html","hash":"432186a9ac9f0865a7350c82959b7278c0fb7041","modified":1573728351286},{"_id":"public/tags/源码解析/index.html","hash":"8e2ad526efd539fb308572ddd16f75232afb3a58","modified":1573728351286},{"_id":"public/img/avatar.jpg","hash":"859cc1776449dde1c08526076af2d82e0e8da931","modified":1573728351300},{"_id":"public/CNAME","hash":"fb5a88c062706435767090b234bdbb58a8041c61","modified":1573728351300},{"_id":"public/img/avatar.png","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1573728351300},{"_id":"public/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1573728351300},{"_id":"public/img/favicon.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1573728351300},{"_id":"public/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1573728351300},{"_id":"public/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1573728351300},{"_id":"public/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1573728351300},{"_id":"public/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1573728351300},{"_id":"public/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1573728351300},{"_id":"public/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1573728351301},{"_id":"public/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1573728351301},{"_id":"public/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1573728351301},{"_id":"public/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1573728351301},{"_id":"public/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1573728351301},{"_id":"public/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1573728351301},{"_id":"public/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1573728351301},{"_id":"public/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1573728351301},{"_id":"public/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1573728351301},{"_id":"public/img/footer/footer_ico-v2ex.svg","hash":"c5ffaf67a97e534c266d1585a9a3b56f1bfe3052","modified":1573728351301},{"_id":"public/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1573728351301},{"_id":"public/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1573728351301},{"_id":"public/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1573728351301},{"_id":"public/img/gallery/close.svg","hash":"0739fa52652dd59cebecc861144b702e455adb0c","modified":1573728351301},{"_id":"public/img/gallery/arrow.svg","hash":"68799fe01ecc7f5fb721287693b9b0b93f4c067a","modified":1573728351301},{"_id":"public/img/gallery/spinner.svg","hash":"ef69a35119feb82d8e9cf4a59656aa25051afebd","modified":1573728351301},{"_id":"public/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1573728351301},{"_id":"public/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1573728351301},{"_id":"public/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1573728351301},{"_id":"public/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1573728351301},{"_id":"public/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1573728351302},{"_id":"public/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1573728351302},{"_id":"public/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1573728351302},{"_id":"public/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1573728351302},{"_id":"public/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1573728351311},{"_id":"public/img/portrait.jpeg","hash":"1521ba5b86020bb5c417572f250d84109d62c7c2","modified":1573728351312},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1573728351313},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1573728351313},{"_id":"public/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1573728351313},{"_id":"public/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1573728351313},{"_id":"public/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1573728351313},{"_id":"public/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1573728351313},{"_id":"public/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1573728351313},{"_id":"public/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1573728351314},{"_id":"public/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1573728351314},{"_id":"public/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1573728351314},{"_id":"public/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1573728351314},{"_id":"public/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1573728351314},{"_id":"public/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1573728351314},{"_id":"public/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1573728351326},{"_id":"public/css/prettify.css","hash":"c395f20ee64e80c2b6b15c7dade02f9aaaeab2c8","modified":1573728351326},{"_id":"public/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1573728351326},{"_id":"public/css/prettify.min.css","hash":"62edd8f08656463b0e077dcf893faa3cc8eb5fe4","modified":1573728351327},{"_id":"public/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1573728351327},{"_id":"public/js/hanabi-browser-bundle.js","hash":"d646647bda386140c8315d60e3ff4ddbdb15c1ea","modified":1573728351327},{"_id":"public/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1573728351327},{"_id":"public/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1573728351327},{"_id":"public/js/lsloader.min.js","hash":"1a68a8d267948ea8475245b7d365a1a1bd8f732e","modified":1573728351327},{"_id":"public/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1573728351327},{"_id":"public/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1573728351327},{"_id":"public/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1573728351327},{"_id":"public/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1573728351327},{"_id":"public/css/prettify/atelier-cave-light.min.css","hash":"4b62dc45aa351b071d6a434dc54fe8c2e15c85cc","modified":1573728351327},{"_id":"public/css/prettify/atelier-dune-dark.min.css","hash":"c5094d99ca0e619d97860c88211bf908fdf830b1","modified":1573728351327},{"_id":"public/css/prettify/atelier-dune-light.min.css","hash":"b3ad98483e4d5bde72d52a15423d98e0d086db09","modified":1573728351327},{"_id":"public/css/prettify/atelier-forest-dark.min.css","hash":"9296b851a5b66785a60afa5da5fe9080bda96bf5","modified":1573728351327},{"_id":"public/css/prettify/atelier-estuary-dark.min.css","hash":"7e3a065cafeb3acc1d7178f64ef4265f5d5ad2b9","modified":1573728351327},{"_id":"public/css/prettify/atelier-estuary-light.min.css","hash":"1d12d8f7fa9c122a186ee76fdf681c191a68f104","modified":1573728351327},{"_id":"public/css/prettify/atelier-heath-light.min.css","hash":"a67199fa580b3aa2df031e5d2028929d29ca3b45","modified":1573728351327},{"_id":"public/css/prettify/atelier-forest-light.min.css","hash":"3532f6e86bf4afbba05f7a074b791b73174f9622","modified":1573728351327},{"_id":"public/css/prettify/atelier-heath-dark.min.css","hash":"954309acd7918422382a3ff2f9c2988aec0ff956","modified":1573728351327},{"_id":"public/css/prettify/atelier-lakeside-dark.min.css","hash":"18575fc6dff855e395a39d0383d2f18807091f0d","modified":1573728351327},{"_id":"public/css/prettify/atelier-lakeside-light.min.css","hash":"e20e8ac64432fa1aa6f74792b58196af7cf79c12","modified":1573728351327},{"_id":"public/css/prettify/atelier-plateau-dark.min.css","hash":"137e3c499a720da3c1d57b4dc53264b1d623e1c5","modified":1573728351327},{"_id":"public/css/prettify/atelier-plateau-light.min.css","hash":"153801640fdcbb74c0de3f15345110f2210eb991","modified":1573728351327},{"_id":"public/css/prettify/atelier-savanna-light.min.css","hash":"d9425ffb7c60d646190c22b9a5f72091ee5f9ace","modified":1573728351327},{"_id":"public/css/prettify/atelier-savanna-dark.min.css","hash":"fba92c652fd6704422b8f2bbc11706805a6faed0","modified":1573728351327},{"_id":"public/css/prettify/atelier-sulphurpool-dark.min.css","hash":"015a35dddaee153fa8bb71d7f3818a6ba4d120d8","modified":1573728351327},{"_id":"public/css/prettify/atelier-sulphurpool-light.min.css","hash":"ab1a6200eab648cab443c3df77fde9b237ef27b6","modified":1573728351327},{"_id":"public/css/prettify/atelier-seaside-dark.min.css","hash":"e0e6bbacc75a349b1e49c236d374b0e42f1fd485","modified":1573728351328},{"_id":"public/css/prettify/github-v2.min.css","hash":"57630621d20842a529bdea7b17fc90f520e562ef","modified":1573728351328},{"_id":"public/css/prettify/atelier-seaside-light.min.css","hash":"732750b75389c1c49204f37705e6abeee40ce64f","modified":1573728351328},{"_id":"public/css/prettify/hemisu-dark.min.css","hash":"a671248cfd573292026d2174817e82e593691052","modified":1573728351328},{"_id":"public/css/prettify/tomorrow-night-blue.min.css","hash":"c442728d96485bcf816151fe6bd96993aae09852","modified":1573728351328},{"_id":"public/css/prettify/hemisu-light.min.css","hash":"b2556ff41e513fd13d032ec84a37ee260a905815","modified":1573728351328},{"_id":"public/css/prettify/github.min.css","hash":"19cf828225288fa5c006f1d8f66c39d11f4ef7f2","modified":1573728351328},{"_id":"public/css/prettify/tomorrow-night-eighties.min.css","hash":"6ce259d674bb4edda23eea32b2379be17d0e0e6e","modified":1573728351328},{"_id":"public/css/prettify/tomorrow-night.min.css","hash":"d989206d124035494acb4b0cdc7fbc89f3b7d108","modified":1573728351328},{"_id":"public/css/prettify/tomorrow.min.css","hash":"b2c6d610b77f0273fefab5aa4ad26a7f58956f87","modified":1573728351328},{"_id":"public/css/prettify/tranquil-heart.min.css","hash":"0f6eefbdda8e410832e9c516a5dd19899217ef06","modified":1573728351328},{"_id":"public/css/prettify/vibrant-ink.min.css","hash":"c265bac6c31cf622b536b29c8a6bc46955d6fe63","modified":1573728351328},{"_id":"public/css/prettify/tomorrow-night-bright.min.css","hash":"cf251fd3edfd736695272a0f1b41d509b7bb1fb9","modified":1573728351328},{"_id":"public/css/prettify/atelier-cave-dark.min.css","hash":"cb0156cdc36500a26b232ae1c81fdc880eba85e7","modified":1573728351328},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1573728351328},{"_id":"public/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1573728351333},{"_id":"public/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1573728351333},{"_id":"public/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1573728351333},{"_id":"public/js/lsloader.js","hash":"2b14e57784fb6b5f58d71584189c61af45f393e8","modified":1573728351333},{"_id":"public/js/prettify.min.js","hash":"69908fe0a09cee107c25cb5d769b861723e7b7bb","modified":1573728351333},{"_id":"public/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1573728351333},{"_id":"public/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1573728351334},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1573728351334},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1573728351334},{"_id":"public/css/disqus-proxy.css","hash":"d5086cda8aaae20b8d3f9dd50f0be5ccb717e42a","modified":1573728351334},{"_id":"public/js/Valine.min.js","hash":"6a287a99a772a0ea8f98b133523429c9250cc67f","modified":1573728351334},{"_id":"public/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1573728351362},{"_id":"public/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1573728351362},{"_id":"public/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1573728351362},{"_id":"public/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1573728351381},{"_id":"public/css/material-icons.css","hash":"f6f95fe5190f3c65931847246621fb83754eb00c","modified":1573728351388},{"_id":"public/js/MathJax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1573728351388},{"_id":"public/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1573728351390},{"_id":"public/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1573728351390},{"_id":"public/css/style.min.css","hash":"a9e9b33e1fcf818f08a04b909c86f2460a05f060","modified":1573728351397},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1573728351397},{"_id":"public/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1573728351397},{"_id":"public/css/material.min.css","hash":"1a19febb9214ab689b02f5bb8ccb23579e6c1181","modified":1573728351407},{"_id":"public/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1573728351407},{"_id":"public/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1573728351413},{"_id":"public/css/style.css","hash":"a2f27c40f412dc24e1ed5f62a4117523a226eed0","modified":1573728351413},{"_id":"public/css/material.css","hash":"068e2b00f686157b6e8b78b9b808112adbedf4de","modified":1573728351416},{"_id":"public/js/js.min.js","hash":"709d347d3be033b841de0493b7cf532b594bb1f6","modified":1573728351416},{"_id":"public/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1573728351416},{"_id":"public/js/js.js","hash":"64b3f20e7138674ecf21e6e3982565ea63feae26","modified":1573728351420}],"Category":[],"Data":[],"Page":[{"title":"timeline","date":"2019-08-30T09:13:41.197Z","layout":"timeline","_content":"","source":"timeline/index.md","raw":"---\ntitle: timeline\ndate:\nlayout: timeline\n---\n","updated":"2018-08-16T07:11:52.224Z","path":"timeline/index.html","comments":1,"_id":"ck2yl86bw0005lh1p8picpuc2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-08-30T09:13:41.191Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate:\nlayout: tags\n---\n","updated":"2018-08-16T07:09:26.881Z","path":"tags/index.html","comments":1,"_id":"ck2yl86by0007lh1p2d0e5yeo","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Android Paint .measureText() VS .getTextBounds()","Tags":"android","date":"2018-03-28T16:00:00.000Z","_content":"\n\n\n两个方法可以用来测量文字宽高信息的，只不过 **.getTextBounds()** 还可以获得高度信息，因为其使用一个 Rect 对象对宽高信息进行存储；而 **.measureText()** 则只是返回宽度信息。\n\n<!--more-->\n\n具体使用方法如下：\n\n```java\nfinal String someText = \"Hello. I'm some text!\";\n\nPaint mPaint = new Paint();\n\n// .measureText()\nfloat measuredWidth = mPaint.measureText(someText);\n\n// .getTextBounds()\nRect mBounds = new Rect();\nmPaint.getTextBounds(someText, 0, someText.length, mBounds);\nint measuredWidth = mBounds.width();\nint measuredHeight = mBounds.height();\n\n```\n\n但是，当我们把两个结果打印出来，我们会发现，对于同一个文本信息，使用两个方法得到的宽度是不同的：\n\n```java\n// 打印宽度信息\nLog.d(\"Test\", String.format(\n        \"Text is '%s', measureText %f, getTextBounds %d\",\n        someText,\n        measuredWidth,\n        mBounds.width())\n    );\n\n// 打印结果如下\n// Text is 'Hello. I'm some text!', measureText 115.000000, getTextBounds 105\n```\n\n\n\n经过一系列的探究和资料查看，最后得到的结论是：\n\n> 二者返回结果确实不同，且 measureText() 返回结果会略微大于 getTextBounds() 所得到的宽度信息\n>\n> measureText() 会在文本的左右两侧加上一些额外的宽度，这部分额外的宽度叫做 Glyph's AdvanceX （具体应该是属于字型方面的范畴，我猜测这部分宽度是类似字间距之类的东西）\n>\n> getTextBounds() 返回的则是当前文本所需要的最小宽度，也就是整个文本外切矩形的宽度\n\n\n\n实际上，这两个方法在具体调用时虽然都是不同的方法，但在 native 层的测量算法都是一致的，只不过在最后返回时，measureText() 会在左右两侧加上一些额外的宽度值，而 getTextBounds() 则是返回需要的最小宽度而已。\n\n","source":"_posts/Android Paint- .measureText() VS .getTextBounds().md","raw":"---\ntitle: Android Paint .measureText() VS .getTextBounds()\n\nTags: android\n\ndate: 2018-03-29\n---\n\n\n\n两个方法可以用来测量文字宽高信息的，只不过 **.getTextBounds()** 还可以获得高度信息，因为其使用一个 Rect 对象对宽高信息进行存储；而 **.measureText()** 则只是返回宽度信息。\n\n<!--more-->\n\n具体使用方法如下：\n\n```java\nfinal String someText = \"Hello. I'm some text!\";\n\nPaint mPaint = new Paint();\n\n// .measureText()\nfloat measuredWidth = mPaint.measureText(someText);\n\n// .getTextBounds()\nRect mBounds = new Rect();\nmPaint.getTextBounds(someText, 0, someText.length, mBounds);\nint measuredWidth = mBounds.width();\nint measuredHeight = mBounds.height();\n\n```\n\n但是，当我们把两个结果打印出来，我们会发现，对于同一个文本信息，使用两个方法得到的宽度是不同的：\n\n```java\n// 打印宽度信息\nLog.d(\"Test\", String.format(\n        \"Text is '%s', measureText %f, getTextBounds %d\",\n        someText,\n        measuredWidth,\n        mBounds.width())\n    );\n\n// 打印结果如下\n// Text is 'Hello. I'm some text!', measureText 115.000000, getTextBounds 105\n```\n\n\n\n经过一系列的探究和资料查看，最后得到的结论是：\n\n> 二者返回结果确实不同，且 measureText() 返回结果会略微大于 getTextBounds() 所得到的宽度信息\n>\n> measureText() 会在文本的左右两侧加上一些额外的宽度，这部分额外的宽度叫做 Glyph's AdvanceX （具体应该是属于字型方面的范畴，我猜测这部分宽度是类似字间距之类的东西）\n>\n> getTextBounds() 返回的则是当前文本所需要的最小宽度，也就是整个文本外切矩形的宽度\n\n\n\n实际上，这两个方法在具体调用时虽然都是不同的方法，但在 native 层的测量算法都是一致的，只不过在最后返回时，measureText() 会在左右两侧加上一些额外的宽度值，而 getTextBounds() 则是返回需要的最小宽度而已。\n\n","slug":"Android Paint- .measureText() VS .getTextBounds()","published":1,"updated":"2018-11-26T10:43:06.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86at0000lh1pwwax2k5c","content":"<p>两个方法可以用来测量文字宽高信息的，只不过 <strong>.getTextBounds()</strong> 还可以获得高度信息，因为其使用一个 Rect 对象对宽高信息进行存储；而 <strong>.measureText()</strong> 则只是返回宽度信息。</p>\n<a id=\"more\"></a>\n<p>具体使用方法如下：</p>\n<pre><code class=\"java\">final String someText = &quot;Hello. I&#39;m some text!&quot;;\n\nPaint mPaint = new Paint();\n\n// .measureText()\nfloat measuredWidth = mPaint.measureText(someText);\n\n// .getTextBounds()\nRect mBounds = new Rect();\nmPaint.getTextBounds(someText, 0, someText.length, mBounds);\nint measuredWidth = mBounds.width();\nint measuredHeight = mBounds.height();\n\n</code></pre>\n<p>但是，当我们把两个结果打印出来，我们会发现，对于同一个文本信息，使用两个方法得到的宽度是不同的：</p>\n<pre><code class=\"java\">// 打印宽度信息\nLog.d(&quot;Test&quot;, String.format(\n        &quot;Text is &#39;%s&#39;, measureText %f, getTextBounds %d&quot;,\n        someText,\n        measuredWidth,\n        mBounds.width())\n    );\n\n// 打印结果如下\n// Text is &#39;Hello. I&#39;m some text!&#39;, measureText 115.000000, getTextBounds 105\n</code></pre>\n<p>经过一系列的探究和资料查看，最后得到的结论是：</p>\n<blockquote>\n<p>二者返回结果确实不同，且 measureText() 返回结果会略微大于 getTextBounds() 所得到的宽度信息</p>\n<p>measureText() 会在文本的左右两侧加上一些额外的宽度，这部分额外的宽度叫做 Glyph’s AdvanceX （具体应该是属于字型方面的范畴，我猜测这部分宽度是类似字间距之类的东西）</p>\n<p>getTextBounds() 返回的则是当前文本所需要的最小宽度，也就是整个文本外切矩形的宽度</p>\n</blockquote>\n<p>实际上，这两个方法在具体调用时虽然都是不同的方法，但在 native 层的测量算法都是一致的，只不过在最后返回时，measureText() 会在左右两侧加上一些额外的宽度值，而 getTextBounds() 则是返回需要的最小宽度而已。</p>\n","site":{"data":{}},"excerpt":"<p>两个方法可以用来测量文字宽高信息的，只不过 <strong>.getTextBounds()</strong> 还可以获得高度信息，因为其使用一个 Rect 对象对宽高信息进行存储；而 <strong>.measureText()</strong> 则只是返回宽度信息。</p>","more":"<p>具体使用方法如下：</p>\n<pre><code class=\"java\">final String someText = &quot;Hello. I&#39;m some text!&quot;;\n\nPaint mPaint = new Paint();\n\n// .measureText()\nfloat measuredWidth = mPaint.measureText(someText);\n\n// .getTextBounds()\nRect mBounds = new Rect();\nmPaint.getTextBounds(someText, 0, someText.length, mBounds);\nint measuredWidth = mBounds.width();\nint measuredHeight = mBounds.height();\n\n</code></pre>\n<p>但是，当我们把两个结果打印出来，我们会发现，对于同一个文本信息，使用两个方法得到的宽度是不同的：</p>\n<pre><code class=\"java\">// 打印宽度信息\nLog.d(&quot;Test&quot;, String.format(\n        &quot;Text is &#39;%s&#39;, measureText %f, getTextBounds %d&quot;,\n        someText,\n        measuredWidth,\n        mBounds.width())\n    );\n\n// 打印结果如下\n// Text is &#39;Hello. I&#39;m some text!&#39;, measureText 115.000000, getTextBounds 105\n</code></pre>\n<p>经过一系列的探究和资料查看，最后得到的结论是：</p>\n<blockquote>\n<p>二者返回结果确实不同，且 measureText() 返回结果会略微大于 getTextBounds() 所得到的宽度信息</p>\n<p>measureText() 会在文本的左右两侧加上一些额外的宽度，这部分额外的宽度叫做 Glyph’s AdvanceX （具体应该是属于字型方面的范畴，我猜测这部分宽度是类似字间距之类的东西）</p>\n<p>getTextBounds() 返回的则是当前文本所需要的最小宽度，也就是整个文本外切矩形的宽度</p>\n</blockquote>\n<p>实际上，这两个方法在具体调用时虽然都是不同的方法，但在 native 层的测量算法都是一致的，只不过在最后返回时，measureText() 会在左右两侧加上一些额外的宽度值，而 getTextBounds() 则是返回需要的最小宽度而已。</p>"},{"title":"Android 收起通知栏","thumbnails":null,"data":"2019-05-12T16:00:00.000Z","_content":"\n\n\n\n\n点击通知栏RemoteView中的按钮后要收起通知栏，系统默认是不自动收起的，不过没有找到公开的API可以控制通知栏。\n\n在android.app.StatusBarManager里提供了显示和收缩通知栏的方法，但是这个类没有公开，通过反射可以调用。\n\n需要注意的是API LEVEL>16后，对应的方法名称改变了。\n\n 使用此方法时需要再AndroidManifest.xml中添加如下权限\n\n```xml\n<uses-permission android:name=\"android.permission.EXPAND_STATUS_BAR\" />\n```\n\n```java\nprivate void collapseStatusBar() {\n        int currentApiVersion = android.os.Build.VERSION.SDK_INT;\n        try {\n            Object service = getSystemService(\"statusbar\");\n            Class<?> statusbarManager = Class\n                    .forName(\"android.app.StatusBarManager\");\n            Method collapse = null;\n            if (service != null) {\n                if (currentApiVersion <= 16) {\n                    collapse = statusbarManager.getMethod(\"collapse\");\n                } else {\n                    collapse = statusbarManager.getMethod(\"collapsePanels\");\n                }\n                collapse.setAccessible(true);\n                collapse.invoke(service);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n\n\n","source":"_posts/Android-collapse-status-bar.md","raw":"---\ntitle: Android 收起通知栏\nthumbnails: \ndata: 2019-05-13\ntags: [Android]\n---\n\n\n\n\n\n点击通知栏RemoteView中的按钮后要收起通知栏，系统默认是不自动收起的，不过没有找到公开的API可以控制通知栏。\n\n在android.app.StatusBarManager里提供了显示和收缩通知栏的方法，但是这个类没有公开，通过反射可以调用。\n\n需要注意的是API LEVEL>16后，对应的方法名称改变了。\n\n 使用此方法时需要再AndroidManifest.xml中添加如下权限\n\n```xml\n<uses-permission android:name=\"android.permission.EXPAND_STATUS_BAR\" />\n```\n\n```java\nprivate void collapseStatusBar() {\n        int currentApiVersion = android.os.Build.VERSION.SDK_INT;\n        try {\n            Object service = getSystemService(\"statusbar\");\n            Class<?> statusbarManager = Class\n                    .forName(\"android.app.StatusBarManager\");\n            Method collapse = null;\n            if (service != null) {\n                if (currentApiVersion <= 16) {\n                    collapse = statusbarManager.getMethod(\"collapse\");\n                } else {\n                    collapse = statusbarManager.getMethod(\"collapsePanels\");\n                }\n                collapse.setAccessible(true);\n                collapse.invoke(service);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n\n\n","slug":"Android-collapse-status-bar","published":1,"date":"2019-05-13T12:34:22.745Z","updated":"2019-05-13T12:34:22.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86ay0001lh1pmzb7qwil","content":"<p>点击通知栏RemoteView中的按钮后要收起通知栏，系统默认是不自动收起的，不过没有找到公开的API可以控制通知栏。</p>\n<p>在android.app.StatusBarManager里提供了显示和收缩通知栏的方法，但是这个类没有公开，通过反射可以调用。</p>\n<p>需要注意的是API LEVEL&gt;16后，对应的方法名称改变了。</p>\n<p> 使用此方法时需要再AndroidManifest.xml中添加如下权限</p>\n<pre><code class=\"xml\">&lt;uses-permission android:name=&quot;android.permission.EXPAND_STATUS_BAR&quot; /&gt;\n</code></pre>\n<pre><code class=\"java\">private void collapseStatusBar() {\n        int currentApiVersion = android.os.Build.VERSION.SDK_INT;\n        try {\n            Object service = getSystemService(&quot;statusbar&quot;);\n            Class&lt;?&gt; statusbarManager = Class\n                    .forName(&quot;android.app.StatusBarManager&quot;);\n            Method collapse = null;\n            if (service != null) {\n                if (currentApiVersion &lt;= 16) {\n                    collapse = statusbarManager.getMethod(&quot;collapse&quot;);\n                } else {\n                    collapse = statusbarManager.getMethod(&quot;collapsePanels&quot;);\n                }\n                collapse.setAccessible(true);\n                collapse.invoke(service);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>点击通知栏RemoteView中的按钮后要收起通知栏，系统默认是不自动收起的，不过没有找到公开的API可以控制通知栏。</p>\n<p>在android.app.StatusBarManager里提供了显示和收缩通知栏的方法，但是这个类没有公开，通过反射可以调用。</p>\n<p>需要注意的是API LEVEL&gt;16后，对应的方法名称改变了。</p>\n<p> 使用此方法时需要再AndroidManifest.xml中添加如下权限</p>\n<pre><code class=\"xml\">&lt;uses-permission android:name=&quot;android.permission.EXPAND_STATUS_BAR&quot; /&gt;\n</code></pre>\n<pre><code class=\"java\">private void collapseStatusBar() {\n        int currentApiVersion = android.os.Build.VERSION.SDK_INT;\n        try {\n            Object service = getSystemService(&quot;statusbar&quot;);\n            Class&lt;?&gt; statusbarManager = Class\n                    .forName(&quot;android.app.StatusBarManager&quot;);\n            Method collapse = null;\n            if (service != null) {\n                if (currentApiVersion &lt;= 16) {\n                    collapse = statusbarManager.getMethod(&quot;collapse&quot;);\n                } else {\n                    collapse = statusbarManager.getMethod(&quot;collapsePanels&quot;);\n                }\n                collapse.setAccessible(true);\n                collapse.invoke(service);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n</code></pre>\n"},{"title":"Canvas.drawPath() 简单使用记录","date":"2018-05-27T16:00:00.000Z","_content":"\n\n\n<!-- more -->\n\n\n\n\n> Path类将多种复合路径（多个轮廓，如直线段、二次曲线、立方曲线）封装在其内部的几何路径。\n>\n> 也就是说，我们可以使用 drawPath() 来绘制一个多边形或者不规则图形。\n\n下面以等边三角形为例：\n\n```java\n// 假设在固定大小内绘制一个等边三角形\nprivate void drawTriangle(Canvas canvas, Paint paint) {\n    Path mPath = new Path();\n    \n    // moveTo 移动到某一点，用于确定下笔坐标\n    mPath.moveTo(getWidth() / 2, 0);\n    // 连线到某一点，开始绘制，目标点 y 坐标是长直角边的长度\n    // 等边三角形，从顶点向下做高，短直角边:斜边:长直角边 = 1:2:√3\n    mPath.lineTo(0, getWidth() / 2 * Math.sqrt(3)));\n    mPath.lineTo(getWidth(), getWidth() / 2 * Math.sqrt(3)));\n    // 闭合多边形，即连线回到起始点，完成绘制\n    mPath.close();\n\n    canvas.drawPath(mPath, mPaint);\n}\n```\n\n","source":"_posts/Canvas.drawPath().md","raw":"---\ntitle: Canvas.drawPath() 简单使用记录\n\ntags: [Android]\n\ndate: 2018-05-28\n---\n\n\n\n<!-- more -->\n\n\n\n\n> Path类将多种复合路径（多个轮廓，如直线段、二次曲线、立方曲线）封装在其内部的几何路径。\n>\n> 也就是说，我们可以使用 drawPath() 来绘制一个多边形或者不规则图形。\n\n下面以等边三角形为例：\n\n```java\n// 假设在固定大小内绘制一个等边三角形\nprivate void drawTriangle(Canvas canvas, Paint paint) {\n    Path mPath = new Path();\n    \n    // moveTo 移动到某一点，用于确定下笔坐标\n    mPath.moveTo(getWidth() / 2, 0);\n    // 连线到某一点，开始绘制，目标点 y 坐标是长直角边的长度\n    // 等边三角形，从顶点向下做高，短直角边:斜边:长直角边 = 1:2:√3\n    mPath.lineTo(0, getWidth() / 2 * Math.sqrt(3)));\n    mPath.lineTo(getWidth(), getWidth() / 2 * Math.sqrt(3)));\n    // 闭合多边形，即连线回到起始点，完成绘制\n    mPath.close();\n\n    canvas.drawPath(mPath, mPaint);\n}\n```\n\n","slug":"Canvas.drawPath()","published":1,"updated":"2019-03-21T10:55:48.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86bv0004lh1pcdyds597","content":"<a id=\"more\"></a>\n<blockquote>\n<p>Path类将多种复合路径（多个轮廓，如直线段、二次曲线、立方曲线）封装在其内部的几何路径。</p>\n<p>也就是说，我们可以使用 drawPath() 来绘制一个多边形或者不规则图形。</p>\n</blockquote>\n<p>下面以等边三角形为例：</p>\n<pre><code class=\"java\">// 假设在固定大小内绘制一个等边三角形\nprivate void drawTriangle(Canvas canvas, Paint paint) {\n    Path mPath = new Path();\n\n    // moveTo 移动到某一点，用于确定下笔坐标\n    mPath.moveTo(getWidth() / 2, 0);\n    // 连线到某一点，开始绘制，目标点 y 坐标是长直角边的长度\n    // 等边三角形，从顶点向下做高，短直角边:斜边:长直角边 = 1:2:√3\n    mPath.lineTo(0, getWidth() / 2 * Math.sqrt(3)));\n    mPath.lineTo(getWidth(), getWidth() / 2 * Math.sqrt(3)));\n    // 闭合多边形，即连线回到起始点，完成绘制\n    mPath.close();\n\n    canvas.drawPath(mPath, mPaint);\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Path类将多种复合路径（多个轮廓，如直线段、二次曲线、立方曲线）封装在其内部的几何路径。</p>\n<p>也就是说，我们可以使用 drawPath() 来绘制一个多边形或者不规则图形。</p>\n</blockquote>\n<p>下面以等边三角形为例：</p>\n<pre><code class=\"java\">// 假设在固定大小内绘制一个等边三角形\nprivate void drawTriangle(Canvas canvas, Paint paint) {\n    Path mPath = new Path();\n\n    // moveTo 移动到某一点，用于确定下笔坐标\n    mPath.moveTo(getWidth() / 2, 0);\n    // 连线到某一点，开始绘制，目标点 y 坐标是长直角边的长度\n    // 等边三角形，从顶点向下做高，短直角边:斜边:长直角边 = 1:2:√3\n    mPath.lineTo(0, getWidth() / 2 * Math.sqrt(3)));\n    mPath.lineTo(getWidth(), getWidth() / 2 * Math.sqrt(3)));\n    // 闭合多边形，即连线回到起始点，完成绘制\n    mPath.close();\n\n    canvas.drawPath(mPath, mPaint);\n}\n</code></pre>"},{"title":"字体变色效果实现分析","Tags":"android","date":"2018-03-18T16:00:00.000Z","_content":"\n\n\n> 主要技术点：Canvas.clipRect()\n\n实际上，这个方法可以理解成裁剪画布；\n\n方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；\n\n而这块区域，就是接下来将要进行绘制的区域。\n\n通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。\n\n\n\n```java\n@Override\nprotected void onDraw(Canvas canvas) {\n\n    // 绘制前一半内容\n    drawText(canvas, mChangePaint, 0, getWidth()/2);\n\n    // 使用另一颜色的画笔绘制后一半内容\n    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());\n\n}\n\nprivate void drawText(Canvas canvas, Paint paint, int start, int end) {\n\n    paint.setTextSize(getTextSize());\n\n    // 保存当前画布状态\n    canvas.save();\n\n    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制\n    Rect rect = new Rect(start, 0, end, getHeight());\n    canvas.clipRect(rect);\n\n    // 获取文字的基本宽高信息\n    String text = getText().toString();\n    Rect textBounds = new Rect();\n    paint.getTextBounds(text, 0, text.length(), textBounds);\n    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();\n\n    // 获取起始位置\n    int x = getWidth() / 2 - textBounds.width() / 2;\n    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;\n    canvas.drawText(text, x, y, paint);\n\n    // 清空画布属性，方便接下来绘制变色的部分\n    canvas.restore();\n\n}\n```","source":"_posts/TrackColorTextView.md","raw":"---\ntitle: 字体变色效果实现分析\n\nTags: android\n\ndate: 2018-03-19\n---\n\n\n\n> 主要技术点：Canvas.clipRect()\n\n实际上，这个方法可以理解成裁剪画布；\n\n方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；\n\n而这块区域，就是接下来将要进行绘制的区域。\n\n通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。\n\n\n\n```java\n@Override\nprotected void onDraw(Canvas canvas) {\n\n    // 绘制前一半内容\n    drawText(canvas, mChangePaint, 0, getWidth()/2);\n\n    // 使用另一颜色的画笔绘制后一半内容\n    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());\n\n}\n\nprivate void drawText(Canvas canvas, Paint paint, int start, int end) {\n\n    paint.setTextSize(getTextSize());\n\n    // 保存当前画布状态\n    canvas.save();\n\n    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制\n    Rect rect = new Rect(start, 0, end, getHeight());\n    canvas.clipRect(rect);\n\n    // 获取文字的基本宽高信息\n    String text = getText().toString();\n    Rect textBounds = new Rect();\n    paint.getTextBounds(text, 0, text.length(), textBounds);\n    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();\n\n    // 获取起始位置\n    int x = getWidth() / 2 - textBounds.width() / 2;\n    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;\n    canvas.drawText(text, x, y, paint);\n\n    // 清空画布属性，方便接下来绘制变色的部分\n    canvas.restore();\n\n}\n```","slug":"TrackColorTextView","published":1,"updated":"2018-11-26T10:40:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86bx0006lh1p8m8wlbqy","content":"<blockquote>\n<p>主要技术点：Canvas.clipRect()</p>\n</blockquote>\n<p>实际上，这个方法可以理解成裁剪画布；</p>\n<p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p>\n<p>而这块区域，就是接下来将要进行绘制的区域。</p>\n<p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p>\n<pre><code class=\"java\">@Override\nprotected void onDraw(Canvas canvas) {\n\n    // 绘制前一半内容\n    drawText(canvas, mChangePaint, 0, getWidth()/2);\n\n    // 使用另一颜色的画笔绘制后一半内容\n    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());\n\n}\n\nprivate void drawText(Canvas canvas, Paint paint, int start, int end) {\n\n    paint.setTextSize(getTextSize());\n\n    // 保存当前画布状态\n    canvas.save();\n\n    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制\n    Rect rect = new Rect(start, 0, end, getHeight());\n    canvas.clipRect(rect);\n\n    // 获取文字的基本宽高信息\n    String text = getText().toString();\n    Rect textBounds = new Rect();\n    paint.getTextBounds(text, 0, text.length(), textBounds);\n    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();\n\n    // 获取起始位置\n    int x = getWidth() / 2 - textBounds.width() / 2;\n    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;\n    canvas.drawText(text, x, y, paint);\n\n    // 清空画布属性，方便接下来绘制变色的部分\n    canvas.restore();\n\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>主要技术点：Canvas.clipRect()</p>\n</blockquote>\n<p>实际上，这个方法可以理解成裁剪画布；</p>\n<p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p>\n<p>而这块区域，就是接下来将要进行绘制的区域。</p>\n<p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p>\n<pre><code class=\"java\">@Override\nprotected void onDraw(Canvas canvas) {\n\n    // 绘制前一半内容\n    drawText(canvas, mChangePaint, 0, getWidth()/2);\n\n    // 使用另一颜色的画笔绘制后一半内容\n    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());\n\n}\n\nprivate void drawText(Canvas canvas, Paint paint, int start, int end) {\n\n    paint.setTextSize(getTextSize());\n\n    // 保存当前画布状态\n    canvas.save();\n\n    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制\n    Rect rect = new Rect(start, 0, end, getHeight());\n    canvas.clipRect(rect);\n\n    // 获取文字的基本宽高信息\n    String text = getText().toString();\n    Rect textBounds = new Rect();\n    paint.getTextBounds(text, 0, text.length(), textBounds);\n    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();\n\n    // 获取起始位置\n    int x = getWidth() / 2 - textBounds.width() / 2;\n    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;\n    canvas.drawText(text, x, y, paint);\n\n    // 清空画布属性，方便接下来绘制变色的部分\n    canvas.restore();\n\n}\n</code></pre>\n"},{"title":"解决可视化工具对于 MySQL 8.0 + 无法连接的问题","date":"2018-05-27T16:00:00.000Z","_content":"\n\n\nMySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。\n\n<!-- more -->\n\n同时还更改了加密方式，之前版本的加密方式是「mysql_native_password」，8.0 之后的加密规则更改为「caching_sha2_password 」，这里需要把用户密码加密规则更改为原来的加密方式即可。\n\n\n\n具体方法步骤如下，记录备忘：\n\n>  打开终端，输入命令\n\n```mysql\nmysql -u root -p\n```\n> 需要注意的是，MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，至少 8 个字符；密码是在最开始安装 MySQL 的时候设置的，如果忘记了，上网查询解决方法。\n\n\n\n> 输入密码后，进入 >mysql 的命令行模式\n\n```mysql\n# 切换到 mysql 数据库\nuse mysql;\n\n# 设置用户密码永不过期\nalter user 'root'@'localhost' identified by 'your pwd' password expire never;\n\n# 用「mysql_native_password」加密方式更新 root 用户密码\nalter user 'root'@'localhost' identified with mysql_native_password by 'your pwd';\n\n# 刷新\nflush privileges;\n```\n","source":"_posts/bug-of-mysql.md","raw":"---\ntitle: 解决可视化工具对于 MySQL 8.0 + 无法连接的问题\n\ndate: 2018-05-28\n---\n\n\n\nMySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。\n\n<!-- more -->\n\n同时还更改了加密方式，之前版本的加密方式是「mysql_native_password」，8.0 之后的加密规则更改为「caching_sha2_password 」，这里需要把用户密码加密规则更改为原来的加密方式即可。\n\n\n\n具体方法步骤如下，记录备忘：\n\n>  打开终端，输入命令\n\n```mysql\nmysql -u root -p\n```\n> 需要注意的是，MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，至少 8 个字符；密码是在最开始安装 MySQL 的时候设置的，如果忘记了，上网查询解决方法。\n\n\n\n> 输入密码后，进入 >mysql 的命令行模式\n\n```mysql\n# 切换到 mysql 数据库\nuse mysql;\n\n# 设置用户密码永不过期\nalter user 'root'@'localhost' identified by 'your pwd' password expire never;\n\n# 用「mysql_native_password」加密方式更新 root 用户密码\nalter user 'root'@'localhost' identified with mysql_native_password by 'your pwd';\n\n# 刷新\nflush privileges;\n```\n","slug":"bug-of-mysql","published":1,"updated":"2018-08-14T10:11:51.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86c10009lh1p32pi2f0z","content":"<p>MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。</p>\n<a id=\"more\"></a>\n<p>同时还更改了加密方式，之前版本的加密方式是「mysql_native_password」，8.0 之后的加密规则更改为「caching_sha2_password 」，这里需要把用户密码加密规则更改为原来的加密方式即可。</p>\n<p>具体方法步骤如下，记录备忘：</p>\n<blockquote>\n<p> 打开终端，输入命令</p>\n</blockquote>\n<pre><code class=\"mysql\">mysql -u root -p\n</code></pre>\n<blockquote>\n<p>需要注意的是，MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，至少 8 个字符；密码是在最开始安装 MySQL 的时候设置的，如果忘记了，上网查询解决方法。</p>\n</blockquote>\n<blockquote>\n<p>输入密码后，进入 &gt;mysql 的命令行模式</p>\n</blockquote>\n<pre><code class=\"mysql\"># 切换到 mysql 数据库\nuse mysql;\n\n# 设置用户密码永不过期\nalter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;your pwd&#39; password expire never;\n\n# 用「mysql_native_password」加密方式更新 root 用户密码\nalter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;your pwd&#39;;\n\n# 刷新\nflush privileges;\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。</p>","more":"<p>同时还更改了加密方式，之前版本的加密方式是「mysql_native_password」，8.0 之后的加密规则更改为「caching_sha2_password 」，这里需要把用户密码加密规则更改为原来的加密方式即可。</p>\n<p>具体方法步骤如下，记录备忘：</p>\n<blockquote>\n<p> 打开终端，输入命令</p>\n</blockquote>\n<pre><code class=\"mysql\">mysql -u root -p\n</code></pre>\n<blockquote>\n<p>需要注意的是，MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，至少 8 个字符；密码是在最开始安装 MySQL 的时候设置的，如果忘记了，上网查询解决方法。</p>\n</blockquote>\n<blockquote>\n<p>输入密码后，进入 &gt;mysql 的命令行模式</p>\n</blockquote>\n<pre><code class=\"mysql\"># 切换到 mysql 数据库\nuse mysql;\n\n# 设置用户密码永不过期\nalter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;your pwd&#39; password expire never;\n\n# 用「mysql_native_password」加密方式更新 root 用户密码\nalter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;your pwd&#39;;\n\n# 刷新\nflush privileges;\n</code></pre>"},{"title":"自定义 TextView","date":"2018-03-06T16:00:00.000Z","_content":"\n\n\n### 构造方法\n\n- 一个参数\n\n  在代码中初始化时使用\n\n- 两个参数\n\n  在布局文件中使用时，会经过这个方法；第二个参数 **attrs** 就是传入的自定义属性\n\n- 三个参数\n\n  同样是在布局文件中使用，但是当文件中使用到 style 文件时才会使用，第三个参数是 style 文件\n\n### 测量规格\n\nMeasureSpec 是一个 32 位的 int 值，前 2 位表示 SpecMode，后 30 位表示 SpecSize。\n\nMeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象内存分配，同样在使用到具体的属性时，可以通过解包的方式来获取原始值。\n\n```\n @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 具体在测量控件大小时，宽高的 MeasureSpec 都是由父布局一层层传递下来的\n        // MeasureSpec 可以理解为是父 View 对子 View 的的测量要求\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    }\n\n```\n\n- MeasureSpec 的三种情况\n\n  - AT_MOST\n\n    父容器指定了一个可用大小，即 SpecSize，当前子 View 大小不能超过这个值\n\n    对应布局文件中的 wrap_content\n\n  - EXACTLY\n\n    父容器已经测量出 View 所需要的精确大小，子 View 最终的大小就是测量到的值\n\n    对应布局文件中的 match_parent 或者固定数值\n\n  - UNSECIFIED\n\n    一般系统的控件才会使用到这个，自己自定义 View 的话，很少用到\n\n- ScrollView 嵌套 ListView 的解决方法的原理\n\n  ```\n  public class ListViewForScrollView extends ListView {\n      public ListViewForScrollView(Context context) {\n          super(context);\n      }\n      public ListViewForScrollView(Context context, AttributeSet attrs) {\n          super(context, attrs);\n      }\n      public ListViewForScrollView(Context context, AttributeSet attrs,\n          int defStyle) {\n          super(context, attrs, defStyle);\n      }\n          \n      @Override\n      /**\n       * 重写该方法，达到使ListView适应ScrollView的效果\n       */\n      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n          // 打包方法，重新构造 heightMeasureSpec\n          int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2,\n          MeasureSpec.AT_MOST);\n          super.onMeasure(widthMeasureSpec, expandSpec);\n      }\n  }\n\n  ```\n\n  我们知道，Android 的测绘机制是一个递归的流程，从最顶层的开始，依次递归向下测量子 View ，即调用 measureChild() 方法，一层层测量后，最后再测量最外层的 ViewGroup .\n\n  查看 ScrollView 的源码：\n\n  ```\n  @Override\n      protected void measureChild(View child, int parentWidthMeasureSpec,\n              int parentHeightMeasureSpec) {\n          ViewGroup.LayoutParams lp = child.getLayoutParams();\n\n          int childWidthMeasureSpec;\n          int childHeightMeasureSpec;\n\n          childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft\n                  + mPaddingRight, lp.width);\n          final int verticalPadding = mPaddingTop + mPaddingBottom;\n          \n          // ScrollView 在具体测量子 View 时，向下传递的测量规格为 MeasureSpec.UNSPECIFIED\n          childHeightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(\n                  Math.max(0, MeasureSpec.getSize(parentHeightMeasureSpec) - verticalPadding),\n                  MeasureSpec.UNSPECIFIED);\n\n          child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n      }\n\n  ```\n\n  理论上讲，这时候代码会走到 ListView 的 onMeasure() 方法中：\n\n  ```\n  @Override\n      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n          super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n          final int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n          int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n\n          int childHeight = 0;\n         \n          ... ...\n          \n          // 获取 ListView 的高度，此时应该只有一个条目的高度\n          childHeight = child.getMeasuredHeight();\n\n       \t... ...\n\n          // 重点就在这里\n          // 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + padding\n          if (heightMode == MeasureSpec.UNSPECIFIED) {\n              heightSize = mListPadding.top + mListPadding.bottom + childHeight +\n                      getVerticalFadingEdgeLength() * 2;\n          }\n\n          // 如果为 AT_MOST ，则会调用 measureHeightOfChildren() 方法，重新计算 View 高度\n          if (heightMode == MeasureSpec.AT_MOST) {\n              heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1);\n          }\n\n          setMeasuredDimension(widthSize, heightSize);\n      }\n\n  ```\n\n  而至于 Integer.MAX_VALUE >> 2，则是因为 SpecSize 是一个 30 位的值，使用 Integer.MAX_VALUE 是希望这个值尽可能的大，在后续为各个条目指定测量模式时，因为传下来的是 AT_MOST, 因此 resultSize 即为传下来的 Integer.MAX_VALUE >> 2，保证每个条目的高度自适应。\n\n  ```java\n  public static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n          int specMode = MeasureSpec.getMode(spec);\n          int specSize = MeasureSpec.getSize(spec);\n\n          int size = Math.max(0, specSize - padding);\n\n          int resultSize = 0;\n          int resultMode = 0;\n\n          switch (specMode) { \n                  // Parent has imposed a maximum size on us\n              case MeasureSpec.AT_MOST:\n                  if (childDimension >= 0) {\n                      // Child wants a specific size... so be it\n                      resultSize = childDimension;\n                      resultMode = MeasureSpec.EXACTLY;\n                  } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                      // Child wants to be our size, but our size is not fixed.\n                      // Constrain child to not be bigger than us.\n                      resultSize = size;\n                      resultMode = MeasureSpec.AT_MOST;\n                  } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                      // Child wants to determine its own size. It can't be\n                      // bigger than us.\n                      resultSize = size;\n                      resultMode = MeasureSpec.AT_MOST;\n                  }\n                  break;\n          }\n              \n          //noinspection ResourceType\n          return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n  }\n  ```\n\n  ​\n\n","source":"_posts/TextView.md","raw":"---\ntitle: 自定义 TextView\n\ntags: android \n\ndate: 2018-03-07\n---\n\n\n\n### 构造方法\n\n- 一个参数\n\n  在代码中初始化时使用\n\n- 两个参数\n\n  在布局文件中使用时，会经过这个方法；第二个参数 **attrs** 就是传入的自定义属性\n\n- 三个参数\n\n  同样是在布局文件中使用，但是当文件中使用到 style 文件时才会使用，第三个参数是 style 文件\n\n### 测量规格\n\nMeasureSpec 是一个 32 位的 int 值，前 2 位表示 SpecMode，后 30 位表示 SpecSize。\n\nMeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象内存分配，同样在使用到具体的属性时，可以通过解包的方式来获取原始值。\n\n```\n @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 具体在测量控件大小时，宽高的 MeasureSpec 都是由父布局一层层传递下来的\n        // MeasureSpec 可以理解为是父 View 对子 View 的的测量要求\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    }\n\n```\n\n- MeasureSpec 的三种情况\n\n  - AT_MOST\n\n    父容器指定了一个可用大小，即 SpecSize，当前子 View 大小不能超过这个值\n\n    对应布局文件中的 wrap_content\n\n  - EXACTLY\n\n    父容器已经测量出 View 所需要的精确大小，子 View 最终的大小就是测量到的值\n\n    对应布局文件中的 match_parent 或者固定数值\n\n  - UNSECIFIED\n\n    一般系统的控件才会使用到这个，自己自定义 View 的话，很少用到\n\n- ScrollView 嵌套 ListView 的解决方法的原理\n\n  ```\n  public class ListViewForScrollView extends ListView {\n      public ListViewForScrollView(Context context) {\n          super(context);\n      }\n      public ListViewForScrollView(Context context, AttributeSet attrs) {\n          super(context, attrs);\n      }\n      public ListViewForScrollView(Context context, AttributeSet attrs,\n          int defStyle) {\n          super(context, attrs, defStyle);\n      }\n          \n      @Override\n      /**\n       * 重写该方法，达到使ListView适应ScrollView的效果\n       */\n      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n          // 打包方法，重新构造 heightMeasureSpec\n          int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2,\n          MeasureSpec.AT_MOST);\n          super.onMeasure(widthMeasureSpec, expandSpec);\n      }\n  }\n\n  ```\n\n  我们知道，Android 的测绘机制是一个递归的流程，从最顶层的开始，依次递归向下测量子 View ，即调用 measureChild() 方法，一层层测量后，最后再测量最外层的 ViewGroup .\n\n  查看 ScrollView 的源码：\n\n  ```\n  @Override\n      protected void measureChild(View child, int parentWidthMeasureSpec,\n              int parentHeightMeasureSpec) {\n          ViewGroup.LayoutParams lp = child.getLayoutParams();\n\n          int childWidthMeasureSpec;\n          int childHeightMeasureSpec;\n\n          childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft\n                  + mPaddingRight, lp.width);\n          final int verticalPadding = mPaddingTop + mPaddingBottom;\n          \n          // ScrollView 在具体测量子 View 时，向下传递的测量规格为 MeasureSpec.UNSPECIFIED\n          childHeightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(\n                  Math.max(0, MeasureSpec.getSize(parentHeightMeasureSpec) - verticalPadding),\n                  MeasureSpec.UNSPECIFIED);\n\n          child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n      }\n\n  ```\n\n  理论上讲，这时候代码会走到 ListView 的 onMeasure() 方法中：\n\n  ```\n  @Override\n      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n          super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n          final int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n          int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n\n          int childHeight = 0;\n         \n          ... ...\n          \n          // 获取 ListView 的高度，此时应该只有一个条目的高度\n          childHeight = child.getMeasuredHeight();\n\n       \t... ...\n\n          // 重点就在这里\n          // 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + padding\n          if (heightMode == MeasureSpec.UNSPECIFIED) {\n              heightSize = mListPadding.top + mListPadding.bottom + childHeight +\n                      getVerticalFadingEdgeLength() * 2;\n          }\n\n          // 如果为 AT_MOST ，则会调用 measureHeightOfChildren() 方法，重新计算 View 高度\n          if (heightMode == MeasureSpec.AT_MOST) {\n              heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1);\n          }\n\n          setMeasuredDimension(widthSize, heightSize);\n      }\n\n  ```\n\n  而至于 Integer.MAX_VALUE >> 2，则是因为 SpecSize 是一个 30 位的值，使用 Integer.MAX_VALUE 是希望这个值尽可能的大，在后续为各个条目指定测量模式时，因为传下来的是 AT_MOST, 因此 resultSize 即为传下来的 Integer.MAX_VALUE >> 2，保证每个条目的高度自适应。\n\n  ```java\n  public static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n          int specMode = MeasureSpec.getMode(spec);\n          int specSize = MeasureSpec.getSize(spec);\n\n          int size = Math.max(0, specSize - padding);\n\n          int resultSize = 0;\n          int resultMode = 0;\n\n          switch (specMode) { \n                  // Parent has imposed a maximum size on us\n              case MeasureSpec.AT_MOST:\n                  if (childDimension >= 0) {\n                      // Child wants a specific size... so be it\n                      resultSize = childDimension;\n                      resultMode = MeasureSpec.EXACTLY;\n                  } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                      // Child wants to be our size, but our size is not fixed.\n                      // Constrain child to not be bigger than us.\n                      resultSize = size;\n                      resultMode = MeasureSpec.AT_MOST;\n                  } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                      // Child wants to determine its own size. It can't be\n                      // bigger than us.\n                      resultSize = size;\n                      resultMode = MeasureSpec.AT_MOST;\n                  }\n                  break;\n          }\n              \n          //noinspection ResourceType\n          return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n  }\n  ```\n\n  ​\n\n","slug":"TextView","published":1,"updated":"2018-11-26T10:42:37.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86c3000alh1pygir4rq5","content":"<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><ul>\n<li><p>一个参数</p>\n<p>在代码中初始化时使用</p>\n</li>\n<li><p>两个参数</p>\n<p>在布局文件中使用时，会经过这个方法；第二个参数 <strong>attrs</strong> 就是传入的自定义属性</p>\n</li>\n<li><p>三个参数</p>\n<p>同样是在布局文件中使用，但是当文件中使用到 style 文件时才会使用，第三个参数是 style 文件</p>\n</li>\n</ul>\n<h3 id=\"测量规格\"><a href=\"#测量规格\" class=\"headerlink\" title=\"测量规格\"></a>测量规格</h3><p>MeasureSpec 是一个 32 位的 int 值，前 2 位表示 SpecMode，后 30 位表示 SpecSize。</p>\n<p>MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象内存分配，同样在使用到具体的属性时，可以通过解包的方式来获取原始值。</p>\n<pre><code> @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 具体在测量控件大小时，宽高的 MeasureSpec 都是由父布局一层层传递下来的\n        // MeasureSpec 可以理解为是父 View 对子 View 的的测量要求\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    }\n\n</code></pre><ul>\n<li><p>MeasureSpec 的三种情况</p>\n<ul>\n<li><p>AT_MOST</p>\n<p>父容器指定了一个可用大小，即 SpecSize，当前子 View 大小不能超过这个值</p>\n<p>对应布局文件中的 wrap_content</p>\n</li>\n<li><p>EXACTLY</p>\n<p>父容器已经测量出 View 所需要的精确大小，子 View 最终的大小就是测量到的值</p>\n<p>对应布局文件中的 match_parent 或者固定数值</p>\n</li>\n<li><p>UNSECIFIED</p>\n<p>一般系统的控件才会使用到这个，自己自定义 View 的话，很少用到</p>\n</li>\n</ul>\n</li>\n<li><p>ScrollView 嵌套 ListView 的解决方法的原理</p>\n<pre><code>public class ListViewForScrollView extends ListView {\n    public ListViewForScrollView(Context context) {\n        super(context);\n    }\n    public ListViewForScrollView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n    public ListViewForScrollView(Context context, AttributeSet attrs,\n        int defStyle) {\n        super(context, attrs, defStyle);\n    }\n\n    @Override\n    /**\n     * 重写该方法，达到使ListView适应ScrollView的效果\n     */\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 打包方法，重新构造 heightMeasureSpec\n        int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,\n        MeasureSpec.AT_MOST);\n        super.onMeasure(widthMeasureSpec, expandSpec);\n    }\n}\n\n</code></pre><p>我们知道，Android 的测绘机制是一个递归的流程，从最顶层的开始，依次递归向下测量子 View ，即调用 measureChild() 方法，一层层测量后，最后再测量最外层的 ViewGroup .</p>\n<p>查看 ScrollView 的源码：</p>\n<pre><code>@Override\n    protected void measureChild(View child, int parentWidthMeasureSpec,\n            int parentHeightMeasureSpec) {\n        ViewGroup.LayoutParams lp = child.getLayoutParams();\n\n        int childWidthMeasureSpec;\n        int childHeightMeasureSpec;\n\n        childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft\n                + mPaddingRight, lp.width);\n        final int verticalPadding = mPaddingTop + mPaddingBottom;\n\n        // ScrollView 在具体测量子 View 时，向下传递的测量规格为 MeasureSpec.UNSPECIFIED\n        childHeightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(\n                Math.max(0, MeasureSpec.getSize(parentHeightMeasureSpec) - verticalPadding),\n                MeasureSpec.UNSPECIFIED);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n\n</code></pre><p>理论上讲，这时候代码会走到 ListView 的 onMeasure() 方法中：</p>\n<pre><code>@Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n        int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n\n        int childHeight = 0;\n\n        ... ...\n\n        // 获取 ListView 的高度，此时应该只有一个条目的高度\n        childHeight = child.getMeasuredHeight();\n\n         ... ...\n\n        // 重点就在这里\n        // 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + padding\n        if (heightMode == MeasureSpec.UNSPECIFIED) {\n            heightSize = mListPadding.top + mListPadding.bottom + childHeight +\n                    getVerticalFadingEdgeLength() * 2;\n        }\n\n        // 如果为 AT_MOST ，则会调用 measureHeightOfChildren() 方法，重新计算 View 高度\n        if (heightMode == MeasureSpec.AT_MOST) {\n            heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1);\n        }\n\n        setMeasuredDimension(widthSize, heightSize);\n    }\n\n</code></pre><p>而至于 Integer.MAX_VALUE &gt;&gt; 2，则是因为 SpecSize 是一个 30 位的值，使用 Integer.MAX_VALUE 是希望这个值尽可能的大，在后续为各个条目指定测量模式时，因为传下来的是 AT_MOST, 因此 resultSize 即为传下来的 Integer.MAX_VALUE &gt;&gt; 2，保证每个条目的高度自适应。</p>\n<pre><code class=\"java\">public static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n        int specMode = MeasureSpec.getMode(spec);\n        int specSize = MeasureSpec.getSize(spec);\n\n        int size = Math.max(0, specSize - padding);\n\n        int resultSize = 0;\n        int resultMode = 0;\n\n        switch (specMode) { \n                // Parent has imposed a maximum size on us\n            case MeasureSpec.AT_MOST:\n                if (childDimension &gt;= 0) {\n                    // Child wants a specific size... so be it\n                    resultSize = childDimension;\n                    resultMode = MeasureSpec.EXACTLY;\n                } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                    // Child wants to be our size, but our size is not fixed.\n                    // Constrain child to not be bigger than us.\n                    resultSize = size;\n                    resultMode = MeasureSpec.AT_MOST;\n                } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                    // Child wants to determine its own size. It can&#39;t be\n                    // bigger than us.\n                    resultSize = size;\n                    resultMode = MeasureSpec.AT_MOST;\n                }\n                break;\n        }\n\n        //noinspection ResourceType\n        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n}\n</code></pre>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><ul>\n<li><p>一个参数</p>\n<p>在代码中初始化时使用</p>\n</li>\n<li><p>两个参数</p>\n<p>在布局文件中使用时，会经过这个方法；第二个参数 <strong>attrs</strong> 就是传入的自定义属性</p>\n</li>\n<li><p>三个参数</p>\n<p>同样是在布局文件中使用，但是当文件中使用到 style 文件时才会使用，第三个参数是 style 文件</p>\n</li>\n</ul>\n<h3 id=\"测量规格\"><a href=\"#测量规格\" class=\"headerlink\" title=\"测量规格\"></a>测量规格</h3><p>MeasureSpec 是一个 32 位的 int 值，前 2 位表示 SpecMode，后 30 位表示 SpecSize。</p>\n<p>MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象内存分配，同样在使用到具体的属性时，可以通过解包的方式来获取原始值。</p>\n<pre><code> @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 具体在测量控件大小时，宽高的 MeasureSpec 都是由父布局一层层传递下来的\n        // MeasureSpec 可以理解为是父 View 对子 View 的的测量要求\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    }\n\n</code></pre><ul>\n<li><p>MeasureSpec 的三种情况</p>\n<ul>\n<li><p>AT_MOST</p>\n<p>父容器指定了一个可用大小，即 SpecSize，当前子 View 大小不能超过这个值</p>\n<p>对应布局文件中的 wrap_content</p>\n</li>\n<li><p>EXACTLY</p>\n<p>父容器已经测量出 View 所需要的精确大小，子 View 最终的大小就是测量到的值</p>\n<p>对应布局文件中的 match_parent 或者固定数值</p>\n</li>\n<li><p>UNSECIFIED</p>\n<p>一般系统的控件才会使用到这个，自己自定义 View 的话，很少用到</p>\n</li>\n</ul>\n</li>\n<li><p>ScrollView 嵌套 ListView 的解决方法的原理</p>\n<pre><code>public class ListViewForScrollView extends ListView {\n    public ListViewForScrollView(Context context) {\n        super(context);\n    }\n    public ListViewForScrollView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n    public ListViewForScrollView(Context context, AttributeSet attrs,\n        int defStyle) {\n        super(context, attrs, defStyle);\n    }\n\n    @Override\n    /**\n     * 重写该方法，达到使ListView适应ScrollView的效果\n     */\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 打包方法，重新构造 heightMeasureSpec\n        int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,\n        MeasureSpec.AT_MOST);\n        super.onMeasure(widthMeasureSpec, expandSpec);\n    }\n}\n\n</code></pre><p>我们知道，Android 的测绘机制是一个递归的流程，从最顶层的开始，依次递归向下测量子 View ，即调用 measureChild() 方法，一层层测量后，最后再测量最外层的 ViewGroup .</p>\n<p>查看 ScrollView 的源码：</p>\n<pre><code>@Override\n    protected void measureChild(View child, int parentWidthMeasureSpec,\n            int parentHeightMeasureSpec) {\n        ViewGroup.LayoutParams lp = child.getLayoutParams();\n\n        int childWidthMeasureSpec;\n        int childHeightMeasureSpec;\n\n        childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft\n                + mPaddingRight, lp.width);\n        final int verticalPadding = mPaddingTop + mPaddingBottom;\n\n        // ScrollView 在具体测量子 View 时，向下传递的测量规格为 MeasureSpec.UNSPECIFIED\n        childHeightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(\n                Math.max(0, MeasureSpec.getSize(parentHeightMeasureSpec) - verticalPadding),\n                MeasureSpec.UNSPECIFIED);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n\n</code></pre><p>理论上讲，这时候代码会走到 ListView 的 onMeasure() 方法中：</p>\n<pre><code>@Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n        int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n\n        int childHeight = 0;\n\n        ... ...\n\n        // 获取 ListView 的高度，此时应该只有一个条目的高度\n        childHeight = child.getMeasuredHeight();\n\n         ... ...\n\n        // 重点就在这里\n        // 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + padding\n        if (heightMode == MeasureSpec.UNSPECIFIED) {\n            heightSize = mListPadding.top + mListPadding.bottom + childHeight +\n                    getVerticalFadingEdgeLength() * 2;\n        }\n\n        // 如果为 AT_MOST ，则会调用 measureHeightOfChildren() 方法，重新计算 View 高度\n        if (heightMode == MeasureSpec.AT_MOST) {\n            heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1);\n        }\n\n        setMeasuredDimension(widthSize, heightSize);\n    }\n\n</code></pre><p>而至于 Integer.MAX_VALUE &gt;&gt; 2，则是因为 SpecSize 是一个 30 位的值，使用 Integer.MAX_VALUE 是希望这个值尽可能的大，在后续为各个条目指定测量模式时，因为传下来的是 AT_MOST, 因此 resultSize 即为传下来的 Integer.MAX_VALUE &gt;&gt; 2，保证每个条目的高度自适应。</p>\n<pre><code class=\"java\">public static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n        int specMode = MeasureSpec.getMode(spec);\n        int specSize = MeasureSpec.getSize(spec);\n\n        int size = Math.max(0, specSize - padding);\n\n        int resultSize = 0;\n        int resultMode = 0;\n\n        switch (specMode) { \n                // Parent has imposed a maximum size on us\n            case MeasureSpec.AT_MOST:\n                if (childDimension &gt;= 0) {\n                    // Child wants a specific size... so be it\n                    resultSize = childDimension;\n                    resultMode = MeasureSpec.EXACTLY;\n                } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                    // Child wants to be our size, but our size is not fixed.\n                    // Constrain child to not be bigger than us.\n                    resultSize = size;\n                    resultMode = MeasureSpec.AT_MOST;\n                } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                    // Child wants to determine its own size. It can&#39;t be\n                    // bigger than us.\n                    resultSize = size;\n                    resultMode = MeasureSpec.AT_MOST;\n                }\n                break;\n        }\n\n        //noinspection ResourceType\n        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n}\n</code></pre>\n<p>​</p>\n</li>\n</ul>\n"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181341.jpg","title":"Android 字体变色","date":"2018-08-11T16:00:00.000Z","_content":"\n<!--more-->\n\n> 主要技术点：Canvas.clipRect()\n\n实际上，这个方法可以理解成裁剪画布；\n\n方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；\n\n而这块区域，就是接下来将要进行绘制的区域。\n\n通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。\n\n\n\n```java\n@Override\nprotected void onDraw(Canvas canvas) {\n\n    // 绘制前一半内容\n    drawText(canvas, mChangePaint, 0, getWidth()/2);\n\n    // 使用另一颜色的画笔绘制后一半内容\n    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());\n\n}\n\nprivate void drawText(Canvas canvas, Paint paint, int start, int end) {\n\n    paint.setTextSize(getTextSize());\n\n    // 保存当前画布状态\n    canvas.save();\n\n    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制\n    Rect rect = new Rect(start, 0, end, getHeight());\n    canvas.clipRect(rect);\n\n    // 获取文字的基本宽高信息\n    String text = getText().toString();\n    Rect textBounds = new Rect();\n    paint.getTextBounds(text, 0, text.length(), textBounds);\n    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();\n\n    // 获取起始位置\n    int x = getWidth() / 2 - textBounds.width() / 2;\n    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;\n    canvas.drawText(text, x, y, paint);\n\n    // 清空画布属性，方便接下来绘制变色的部分\n    canvas.restore();\n\n}\n```","source":"_posts/color-track-textview.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181341.jpg\ntitle: Android 字体变色\ntags: [Android]\ndate: 2018-08-12\n---\n\n<!--more-->\n\n> 主要技术点：Canvas.clipRect()\n\n实际上，这个方法可以理解成裁剪画布；\n\n方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；\n\n而这块区域，就是接下来将要进行绘制的区域。\n\n通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。\n\n\n\n```java\n@Override\nprotected void onDraw(Canvas canvas) {\n\n    // 绘制前一半内容\n    drawText(canvas, mChangePaint, 0, getWidth()/2);\n\n    // 使用另一颜色的画笔绘制后一半内容\n    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());\n\n}\n\nprivate void drawText(Canvas canvas, Paint paint, int start, int end) {\n\n    paint.setTextSize(getTextSize());\n\n    // 保存当前画布状态\n    canvas.save();\n\n    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制\n    Rect rect = new Rect(start, 0, end, getHeight());\n    canvas.clipRect(rect);\n\n    // 获取文字的基本宽高信息\n    String text = getText().toString();\n    Rect textBounds = new Rect();\n    paint.getTextBounds(text, 0, text.length(), textBounds);\n    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();\n\n    // 获取起始位置\n    int x = getWidth() / 2 - textBounds.width() / 2;\n    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;\n    canvas.drawText(text, x, y, paint);\n\n    // 清空画布属性，方便接下来绘制变色的部分\n    canvas.restore();\n\n}\n```","slug":"color-track-textview","published":1,"updated":"2019-03-21T10:33:43.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86c5000blh1px246pmbu","content":"<a id=\"more\"></a>\n<blockquote>\n<p>主要技术点：Canvas.clipRect()</p>\n</blockquote>\n<p>实际上，这个方法可以理解成裁剪画布；</p>\n<p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p>\n<p>而这块区域，就是接下来将要进行绘制的区域。</p>\n<p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p>\n<pre><code class=\"java\">@Override\nprotected void onDraw(Canvas canvas) {\n\n    // 绘制前一半内容\n    drawText(canvas, mChangePaint, 0, getWidth()/2);\n\n    // 使用另一颜色的画笔绘制后一半内容\n    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());\n\n}\n\nprivate void drawText(Canvas canvas, Paint paint, int start, int end) {\n\n    paint.setTextSize(getTextSize());\n\n    // 保存当前画布状态\n    canvas.save();\n\n    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制\n    Rect rect = new Rect(start, 0, end, getHeight());\n    canvas.clipRect(rect);\n\n    // 获取文字的基本宽高信息\n    String text = getText().toString();\n    Rect textBounds = new Rect();\n    paint.getTextBounds(text, 0, text.length(), textBounds);\n    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();\n\n    // 获取起始位置\n    int x = getWidth() / 2 - textBounds.width() / 2;\n    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;\n    canvas.drawText(text, x, y, paint);\n\n    // 清空画布属性，方便接下来绘制变色的部分\n    canvas.restore();\n\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>主要技术点：Canvas.clipRect()</p>\n</blockquote>\n<p>实际上，这个方法可以理解成裁剪画布；</p>\n<p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p>\n<p>而这块区域，就是接下来将要进行绘制的区域。</p>\n<p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p>\n<pre><code class=\"java\">@Override\nprotected void onDraw(Canvas canvas) {\n\n    // 绘制前一半内容\n    drawText(canvas, mChangePaint, 0, getWidth()/2);\n\n    // 使用另一颜色的画笔绘制后一半内容\n    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());\n\n}\n\nprivate void drawText(Canvas canvas, Paint paint, int start, int end) {\n\n    paint.setTextSize(getTextSize());\n\n    // 保存当前画布状态\n    canvas.save();\n\n    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制\n    Rect rect = new Rect(start, 0, end, getHeight());\n    canvas.clipRect(rect);\n\n    // 获取文字的基本宽高信息\n    String text = getText().toString();\n    Rect textBounds = new Rect();\n    paint.getTextBounds(text, 0, text.length(), textBounds);\n    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();\n\n    // 获取起始位置\n    int x = getWidth() / 2 - textBounds.width() / 2;\n    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;\n    canvas.drawText(text, x, y, paint);\n\n    // 清空画布属性，方便接下来绘制变色的部分\n    canvas.restore();\n\n}\n</code></pre>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg","title":"工厂设计模式","date":"2019-10-28T16:00:00.000Z","_content":"\n\n\n为什么你们一讲工厂设计模式，就非要弄个工厂生产小汽车？？？\n\n\n\n<!-- more -->\n\n\n#### 模式定义\n\n定义一个创建对象的公共接口（意味着不同类之间会有共性），让子类决定实例化哪个类，而对象的创建统一交由工厂完成，有良好的封装性，既做到了解耦，也保证了最少知识原则。调用者不会了解到具体子类的实现，但是能通过工厂方法做到想做的事情。\n\n工厂模式主要有几种实现方式，分别为简单工厂、工厂方法和抽象工厂。看过太多博客，都是弄个 Factory 就开始生产汽车，我是真的不想生产汽车啊。。\n\n我们这里以数据存储为例，我们可以根据项目需求动态的选择是通过 SharedPreferences 的方式存储到本地，还是利用 LruCache 将数据缓存到内存中，而具体的实现方式就是工厂设计模式的应用。废话不多说，开始吧。\n\n\n\n#### 简单工厂\n\n顾名思义，简单工厂就是较为简单的工厂模式。\n\n```java\nenum IOHandlerFactory {\n    INSTANCE;\n    enum IOType{\n        MEMORY, SP\n    }\n\n    public IOHandler createIOHandler(IOType type) {\n        switch (type) {\n            case MEMORY:\n                return new MemoryIOHandler();\n            case SP:\n                return new SPIOHandler();\n        }\n        return null;\n    }\n}\n\nIOHandlerFactory.INSTANCE.createIOHandler(IOType.SP);\n```\n\n基本就是提供一个方法，方法面向接口，根据不同的 IOType 返回不同的 IOHandler 接口实例对象，但是这种方法的问题在于，一旦有新增加的 IOType，那就要变动很多地方，可维护性不强。\n\n\n\n#### 工厂方法\n\n这种模式在于为每一种 type 都提供一个工厂方法，直接返回目标对象。\n\n```java\npublic interface IOFactory {\n    IOHandler createIOHandler();\n}\n\npublic class MemoryIOFactoty implements IOFactory {\n    @Override\n    public IOHandler createIOHandler() {\n        return new MemoryIOHandler();\n    }\n}\n\npublic class SPIOFactoty implements IOFactory {\n    @Override\n    public IOHandler createIOHandler() {\n        return new SpIOHandler(null);\n    }\n}\n\nnew MemoryIOFactoty().createIOHandler();\n```\n\n这种方式的优点在于清晰明了，通过工厂接口去创建目标对象，但是缺点在于涉及到的类太多，而且逻辑基本相同，代码冗余严重。\n\n\n\n#### 抽象工厂\n\n定义和 BitmapFactory 比较像，和简单工厂也比较像，但是通过泛型和反射机制简化代码。\n\n```java\nenum IOHandlerFactory {\n\n    INSTANCE;\n\n    public IOHandler createIOHandler(Class<? extends IOHandler> ioHandlerClass) {\n        try {\n            return ioHandlerClass.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public IOHandler getMemoryIOHandler() {\n        return createIOHandler(MemoryIOHandler.class);\n    }\n\n    public IOHandler getSPIOHandler() {\n        return createIOHandler(SpIOHandler.class);\n    }\n\n    public IOHandler getDefaultIOHandler() {\n        return getSPIOHandler();\n    }\n\n}\n\nIOHandlerFactory.INSTANCE.getDefaultIOHandler();\n```\n\n这种方式和简单工厂差不多，代码简单，没有太多的类，也利用反射机制避免了每次新增类型时频繁变更代码，是比较推崇的方式。\n\n\n\n","source":"_posts/design-pattern-factory.md","raw":"---\n\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg\ntitle: 工厂设计模式\ntags: [design-pattern]\ndate: 2019-10-29\n---\n\n\n\n为什么你们一讲工厂设计模式，就非要弄个工厂生产小汽车？？？\n\n\n\n<!-- more -->\n\n\n#### 模式定义\n\n定义一个创建对象的公共接口（意味着不同类之间会有共性），让子类决定实例化哪个类，而对象的创建统一交由工厂完成，有良好的封装性，既做到了解耦，也保证了最少知识原则。调用者不会了解到具体子类的实现，但是能通过工厂方法做到想做的事情。\n\n工厂模式主要有几种实现方式，分别为简单工厂、工厂方法和抽象工厂。看过太多博客，都是弄个 Factory 就开始生产汽车，我是真的不想生产汽车啊。。\n\n我们这里以数据存储为例，我们可以根据项目需求动态的选择是通过 SharedPreferences 的方式存储到本地，还是利用 LruCache 将数据缓存到内存中，而具体的实现方式就是工厂设计模式的应用。废话不多说，开始吧。\n\n\n\n#### 简单工厂\n\n顾名思义，简单工厂就是较为简单的工厂模式。\n\n```java\nenum IOHandlerFactory {\n    INSTANCE;\n    enum IOType{\n        MEMORY, SP\n    }\n\n    public IOHandler createIOHandler(IOType type) {\n        switch (type) {\n            case MEMORY:\n                return new MemoryIOHandler();\n            case SP:\n                return new SPIOHandler();\n        }\n        return null;\n    }\n}\n\nIOHandlerFactory.INSTANCE.createIOHandler(IOType.SP);\n```\n\n基本就是提供一个方法，方法面向接口，根据不同的 IOType 返回不同的 IOHandler 接口实例对象，但是这种方法的问题在于，一旦有新增加的 IOType，那就要变动很多地方，可维护性不强。\n\n\n\n#### 工厂方法\n\n这种模式在于为每一种 type 都提供一个工厂方法，直接返回目标对象。\n\n```java\npublic interface IOFactory {\n    IOHandler createIOHandler();\n}\n\npublic class MemoryIOFactoty implements IOFactory {\n    @Override\n    public IOHandler createIOHandler() {\n        return new MemoryIOHandler();\n    }\n}\n\npublic class SPIOFactoty implements IOFactory {\n    @Override\n    public IOHandler createIOHandler() {\n        return new SpIOHandler(null);\n    }\n}\n\nnew MemoryIOFactoty().createIOHandler();\n```\n\n这种方式的优点在于清晰明了，通过工厂接口去创建目标对象，但是缺点在于涉及到的类太多，而且逻辑基本相同，代码冗余严重。\n\n\n\n#### 抽象工厂\n\n定义和 BitmapFactory 比较像，和简单工厂也比较像，但是通过泛型和反射机制简化代码。\n\n```java\nenum IOHandlerFactory {\n\n    INSTANCE;\n\n    public IOHandler createIOHandler(Class<? extends IOHandler> ioHandlerClass) {\n        try {\n            return ioHandlerClass.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public IOHandler getMemoryIOHandler() {\n        return createIOHandler(MemoryIOHandler.class);\n    }\n\n    public IOHandler getSPIOHandler() {\n        return createIOHandler(SpIOHandler.class);\n    }\n\n    public IOHandler getDefaultIOHandler() {\n        return getSPIOHandler();\n    }\n\n}\n\nIOHandlerFactory.INSTANCE.getDefaultIOHandler();\n```\n\n这种方式和简单工厂差不多，代码简单，没有太多的类，也利用反射机制避免了每次新增类型时频繁变更代码，是比较推崇的方式。\n\n\n\n","slug":"design-pattern-factory","published":1,"updated":"2019-10-29T09:04:45.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86c7000dlh1pma10bvvf","content":"<p>为什么你们一讲工厂设计模式，就非要弄个工厂生产小汽车？？？</p>\n<a id=\"more\"></a>\n<h4 id=\"模式定义\"><a href=\"#模式定义\" class=\"headerlink\" title=\"模式定义\"></a>模式定义</h4><p>定义一个创建对象的公共接口（意味着不同类之间会有共性），让子类决定实例化哪个类，而对象的创建统一交由工厂完成，有良好的封装性，既做到了解耦，也保证了最少知识原则。调用者不会了解到具体子类的实现，但是能通过工厂方法做到想做的事情。</p>\n<p>工厂模式主要有几种实现方式，分别为简单工厂、工厂方法和抽象工厂。看过太多博客，都是弄个 Factory 就开始生产汽车，我是真的不想生产汽车啊。。</p>\n<p>我们这里以数据存储为例，我们可以根据项目需求动态的选择是通过 SharedPreferences 的方式存储到本地，还是利用 LruCache 将数据缓存到内存中，而具体的实现方式就是工厂设计模式的应用。废话不多说，开始吧。</p>\n<h4 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h4><p>顾名思义，简单工厂就是较为简单的工厂模式。</p>\n<pre><code class=\"java\">enum IOHandlerFactory {\n    INSTANCE;\n    enum IOType{\n        MEMORY, SP\n    }\n\n    public IOHandler createIOHandler(IOType type) {\n        switch (type) {\n            case MEMORY:\n                return new MemoryIOHandler();\n            case SP:\n                return new SPIOHandler();\n        }\n        return null;\n    }\n}\n\nIOHandlerFactory.INSTANCE.createIOHandler(IOType.SP);\n</code></pre>\n<p>基本就是提供一个方法，方法面向接口，根据不同的 IOType 返回不同的 IOHandler 接口实例对象，但是这种方法的问题在于，一旦有新增加的 IOType，那就要变动很多地方，可维护性不强。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>这种模式在于为每一种 type 都提供一个工厂方法，直接返回目标对象。</p>\n<pre><code class=\"java\">public interface IOFactory {\n    IOHandler createIOHandler();\n}\n\npublic class MemoryIOFactoty implements IOFactory {\n    @Override\n    public IOHandler createIOHandler() {\n        return new MemoryIOHandler();\n    }\n}\n\npublic class SPIOFactoty implements IOFactory {\n    @Override\n    public IOHandler createIOHandler() {\n        return new SpIOHandler(null);\n    }\n}\n\nnew MemoryIOFactoty().createIOHandler();\n</code></pre>\n<p>这种方式的优点在于清晰明了，通过工厂接口去创建目标对象，但是缺点在于涉及到的类太多，而且逻辑基本相同，代码冗余严重。</p>\n<h4 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h4><p>定义和 BitmapFactory 比较像，和简单工厂也比较像，但是通过泛型和反射机制简化代码。</p>\n<pre><code class=\"java\">enum IOHandlerFactory {\n\n    INSTANCE;\n\n    public IOHandler createIOHandler(Class&lt;? extends IOHandler&gt; ioHandlerClass) {\n        try {\n            return ioHandlerClass.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public IOHandler getMemoryIOHandler() {\n        return createIOHandler(MemoryIOHandler.class);\n    }\n\n    public IOHandler getSPIOHandler() {\n        return createIOHandler(SpIOHandler.class);\n    }\n\n    public IOHandler getDefaultIOHandler() {\n        return getSPIOHandler();\n    }\n\n}\n\nIOHandlerFactory.INSTANCE.getDefaultIOHandler();\n</code></pre>\n<p>这种方式和简单工厂差不多，代码简单，没有太多的类，也利用反射机制避免了每次新增类型时频繁变更代码，是比较推崇的方式。</p>\n","site":{"data":{}},"excerpt":"<p>为什么你们一讲工厂设计模式，就非要弄个工厂生产小汽车？？？</p>","more":"<h4 id=\"模式定义\"><a href=\"#模式定义\" class=\"headerlink\" title=\"模式定义\"></a>模式定义</h4><p>定义一个创建对象的公共接口（意味着不同类之间会有共性），让子类决定实例化哪个类，而对象的创建统一交由工厂完成，有良好的封装性，既做到了解耦，也保证了最少知识原则。调用者不会了解到具体子类的实现，但是能通过工厂方法做到想做的事情。</p>\n<p>工厂模式主要有几种实现方式，分别为简单工厂、工厂方法和抽象工厂。看过太多博客，都是弄个 Factory 就开始生产汽车，我是真的不想生产汽车啊。。</p>\n<p>我们这里以数据存储为例，我们可以根据项目需求动态的选择是通过 SharedPreferences 的方式存储到本地，还是利用 LruCache 将数据缓存到内存中，而具体的实现方式就是工厂设计模式的应用。废话不多说，开始吧。</p>\n<h4 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h4><p>顾名思义，简单工厂就是较为简单的工厂模式。</p>\n<pre><code class=\"java\">enum IOHandlerFactory {\n    INSTANCE;\n    enum IOType{\n        MEMORY, SP\n    }\n\n    public IOHandler createIOHandler(IOType type) {\n        switch (type) {\n            case MEMORY:\n                return new MemoryIOHandler();\n            case SP:\n                return new SPIOHandler();\n        }\n        return null;\n    }\n}\n\nIOHandlerFactory.INSTANCE.createIOHandler(IOType.SP);\n</code></pre>\n<p>基本就是提供一个方法，方法面向接口，根据不同的 IOType 返回不同的 IOHandler 接口实例对象，但是这种方法的问题在于，一旦有新增加的 IOType，那就要变动很多地方，可维护性不强。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>这种模式在于为每一种 type 都提供一个工厂方法，直接返回目标对象。</p>\n<pre><code class=\"java\">public interface IOFactory {\n    IOHandler createIOHandler();\n}\n\npublic class MemoryIOFactoty implements IOFactory {\n    @Override\n    public IOHandler createIOHandler() {\n        return new MemoryIOHandler();\n    }\n}\n\npublic class SPIOFactoty implements IOFactory {\n    @Override\n    public IOHandler createIOHandler() {\n        return new SpIOHandler(null);\n    }\n}\n\nnew MemoryIOFactoty().createIOHandler();\n</code></pre>\n<p>这种方式的优点在于清晰明了，通过工厂接口去创建目标对象，但是缺点在于涉及到的类太多，而且逻辑基本相同，代码冗余严重。</p>\n<h4 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h4><p>定义和 BitmapFactory 比较像，和简单工厂也比较像，但是通过泛型和反射机制简化代码。</p>\n<pre><code class=\"java\">enum IOHandlerFactory {\n\n    INSTANCE;\n\n    public IOHandler createIOHandler(Class&lt;? extends IOHandler&gt; ioHandlerClass) {\n        try {\n            return ioHandlerClass.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public IOHandler getMemoryIOHandler() {\n        return createIOHandler(MemoryIOHandler.class);\n    }\n\n    public IOHandler getSPIOHandler() {\n        return createIOHandler(SpIOHandler.class);\n    }\n\n    public IOHandler getDefaultIOHandler() {\n        return getSPIOHandler();\n    }\n\n}\n\nIOHandlerFactory.INSTANCE.getDefaultIOHandler();\n</code></pre>\n<p>这种方式和简单工厂差不多，代码简单，没有太多的类，也利用反射机制避免了每次新增类型时频繁变更代码，是比较推崇的方式。</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg","title":"装饰者设计模式","date":"2019-10-31T16:00:00.000Z","_content":"\n\n\n今天说一下装饰者。\n\n\n\n<!-- more -->\n\n\n#### 模式定义\n\n一般来讲，我们扩展某个类的功能可以使用继承或者接口实现的方式，装饰者模式则是第三种扩展方式，可以动态扩展某个对象的功能。\n\n简单来说就是，在不使用接口或者继承的前提下，以最小侵入性对某个对象的功能进行扩展，使其获得原本不具备的能力。\n\n这里我们通过分析系统源码，来看看 ListView 是怎么优先于 RecyclerView，拥有自己的 addHeaderView() 方法为例，进行装饰者模式的说明。\n\n\n\n#### ListView#addHeaderView\n\n有过开发经验的人都知道，尽管 RecyclerView 在各方面都领先于 ListView，但是有一点却不如 ListView，那就是 ListView 支持添加头部布局，而 RecyclerView 却并不支持。\n\n当我们从 ListView#addHeaderView 的源码入手，看一看 ListView 是怎么实现添加头布局的时候，就会发现 ListView 本身也是不支持添加头部的，系统源码也是使用了装饰者模式，来为 ListView 进行了功能扩展。\n\n下面我们来看一下 ListView#addHeaderView 的源码。\n\n```java\npublic void addHeaderView(View v, Object data, boolean isSelectable) {\n  // Wrap the adapter if it wasn't already wrapped.\n  if (mAdapter != null) {\n    if (!(mAdapter instanceof HeaderViewListAdapter)) {\n      wrapHeaderListAdapterInternal();\n    }\n\n    // In the case of re-adding a header view, or adding one later on,\n    // we need to notify the observer.\n    if (mDataSetObserver != null) {\n      mDataSetObserver.onChanged();\n    }\n  }\n}\n```\n\n在方法内部判断中，我们会发现如果 adapter 不是 HeaderViewListAdapter 的实例的话，会调用 `wrapHeaderListAdapterInternal()` 将它变成该类的实例，然后通过一个观察者来进行 onChanged 更新。再看这个类的名字 HeaderViewListAdapter，很明显 ListView 添加头部和它少不了干系。\n\n```java\npublic class HeaderViewListAdapter implements WrapperListAdapter, Filterable {\n\n    private final ListAdapter mAdapter;\n\n    ArrayList<ListView.FixedViewInfo> mHeaderViewInfos;\n    ArrayList<ListView.FixedViewInfo> mFooterViewInfos;\n\n    public HeaderViewListAdapter(ArrayList<ListView.FixedViewInfo> headerViewInfos,\n                                 ArrayList<ListView.FixedViewInfo> footerViewInfos,\n                                 ListAdapter adapter) {\n        mAdapter = adapter;\n\t\t\t\t\n    }\n\n    public int getHeadersCount() {\n        return mHeaderViewInfos.size();\n    }\n\n    public int getFootersCount() {\n        return mFooterViewInfos.size();\n    }\n\n    public int getCount() {\n        if (mAdapter != null) {\n            return getFootersCount() + getHeadersCount() + mAdapter.getCount();\n        } else {\n            return getFootersCount() + getHeadersCount();\n        }\n    }\n  \n    public View getView(int position, View convertView, ViewGroup parent) {\n        // Header (negative positions will throw an IndexOutOfBoundsException)\n        int numHeaders = getHeadersCount();\n        if (position < numHeaders) {\n            return mHeaderViewInfos.get(position).view;\n        }\n\n        // Adapter\n        final int adjPosition = position - numHeaders;\n        int adapterCount = 0;\n        if (mAdapter != null) {\n            adapterCount = mAdapter.getCount();\n            if (adjPosition < adapterCount) {\n                return mAdapter.getView(adjPosition, convertView, parent);\n            }\n        }\n\n        // Footer (off-limits positions will throw an IndexOutOfBoundsException)\n        return mFooterViewInfos.get(adjPosition - adapterCount).view;\n    }\n\n}\n```\n\n上面是我将 HeaderViewListAdapter 类的代码进行适当删减后留下的样子。我们认真观察后会发现，所谓的头部和底部，都是在这个类中声明的，而原本的 ListAdapter 也是通过此类的构造器传入的。\n\n1. 在 getCount 方法中，正常我们是返回列表集合数据的大小；而在这个带头部底部添加功能的装饰 adapter 中，getCount 的返回值是头部数据 + 列表数据 + 底部数据；\n\n2. 在 getView 方法中，通过对当前位置以及头部集合大小、底部集合大小的对比和校正，来返回适合的数据：\n\n  - 如果当前位置小于头部元素集合，说明当前是头部位置，返回对应的头部元素\n\n    > return mHeaderViewInfos.get(position).view;\n\n  - 利用头部元素集合大小和 adapter 元素大小来做数据校准：当前位置 - 头部大小 = 列表元素位置，列表元素的位置有上限，即 头部元素 + 列表元素总和；\n\n    满足这个区间的数据，都是 adapter 的列表数据，应该由 adapter 自己去处理\n\n    > return mAdapter.getView(adjPosition, convertView, parent);\n\n  - 超出这个范围的，应该都是用户手动添加的底部元素\n\n    > return mFooterViewInfos.get(adjPosition - adapterCount).view;\n\n\n\n#### 总结\n\n同理，我们也可以仿照系统源码来对 RecyclerView 进行添加头部和底部的扩展。\n\n装饰者模式可以非常灵活地为目标对象添加方法，添加新的行为动作，但是相应的，也需要进行更多的代码维护和判断，来保证代码的兼容性和可用性。\n\n举个很简单的例子，我们在上边简单的分析中没有提到，在平时使用的时候，我们一般都是 listView.addHeaderView(), 但是我们会发现在上边的分析中，addHeaderView 的动作是 adapter，而且是 wrapper 类 adapter 来实现的，那我们怎么保证使用 listView 来进行调用，这就是上边我们简单提到的观察者的作用了。\n\n所以很明显，尽管我们为原始的对象添加了功能，但是也因此导致了很多原本不需要的兼容和维护工作。\n\n","source":"_posts/design-pattern-decoration.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg\ntitle: 装饰者设计模式\ntags: [design-pattern]\ndate: 2019-11-01\n---\n\n\n\n今天说一下装饰者。\n\n\n\n<!-- more -->\n\n\n#### 模式定义\n\n一般来讲，我们扩展某个类的功能可以使用继承或者接口实现的方式，装饰者模式则是第三种扩展方式，可以动态扩展某个对象的功能。\n\n简单来说就是，在不使用接口或者继承的前提下，以最小侵入性对某个对象的功能进行扩展，使其获得原本不具备的能力。\n\n这里我们通过分析系统源码，来看看 ListView 是怎么优先于 RecyclerView，拥有自己的 addHeaderView() 方法为例，进行装饰者模式的说明。\n\n\n\n#### ListView#addHeaderView\n\n有过开发经验的人都知道，尽管 RecyclerView 在各方面都领先于 ListView，但是有一点却不如 ListView，那就是 ListView 支持添加头部布局，而 RecyclerView 却并不支持。\n\n当我们从 ListView#addHeaderView 的源码入手，看一看 ListView 是怎么实现添加头布局的时候，就会发现 ListView 本身也是不支持添加头部的，系统源码也是使用了装饰者模式，来为 ListView 进行了功能扩展。\n\n下面我们来看一下 ListView#addHeaderView 的源码。\n\n```java\npublic void addHeaderView(View v, Object data, boolean isSelectable) {\n  // Wrap the adapter if it wasn't already wrapped.\n  if (mAdapter != null) {\n    if (!(mAdapter instanceof HeaderViewListAdapter)) {\n      wrapHeaderListAdapterInternal();\n    }\n\n    // In the case of re-adding a header view, or adding one later on,\n    // we need to notify the observer.\n    if (mDataSetObserver != null) {\n      mDataSetObserver.onChanged();\n    }\n  }\n}\n```\n\n在方法内部判断中，我们会发现如果 adapter 不是 HeaderViewListAdapter 的实例的话，会调用 `wrapHeaderListAdapterInternal()` 将它变成该类的实例，然后通过一个观察者来进行 onChanged 更新。再看这个类的名字 HeaderViewListAdapter，很明显 ListView 添加头部和它少不了干系。\n\n```java\npublic class HeaderViewListAdapter implements WrapperListAdapter, Filterable {\n\n    private final ListAdapter mAdapter;\n\n    ArrayList<ListView.FixedViewInfo> mHeaderViewInfos;\n    ArrayList<ListView.FixedViewInfo> mFooterViewInfos;\n\n    public HeaderViewListAdapter(ArrayList<ListView.FixedViewInfo> headerViewInfos,\n                                 ArrayList<ListView.FixedViewInfo> footerViewInfos,\n                                 ListAdapter adapter) {\n        mAdapter = adapter;\n\t\t\t\t\n    }\n\n    public int getHeadersCount() {\n        return mHeaderViewInfos.size();\n    }\n\n    public int getFootersCount() {\n        return mFooterViewInfos.size();\n    }\n\n    public int getCount() {\n        if (mAdapter != null) {\n            return getFootersCount() + getHeadersCount() + mAdapter.getCount();\n        } else {\n            return getFootersCount() + getHeadersCount();\n        }\n    }\n  \n    public View getView(int position, View convertView, ViewGroup parent) {\n        // Header (negative positions will throw an IndexOutOfBoundsException)\n        int numHeaders = getHeadersCount();\n        if (position < numHeaders) {\n            return mHeaderViewInfos.get(position).view;\n        }\n\n        // Adapter\n        final int adjPosition = position - numHeaders;\n        int adapterCount = 0;\n        if (mAdapter != null) {\n            adapterCount = mAdapter.getCount();\n            if (adjPosition < adapterCount) {\n                return mAdapter.getView(adjPosition, convertView, parent);\n            }\n        }\n\n        // Footer (off-limits positions will throw an IndexOutOfBoundsException)\n        return mFooterViewInfos.get(adjPosition - adapterCount).view;\n    }\n\n}\n```\n\n上面是我将 HeaderViewListAdapter 类的代码进行适当删减后留下的样子。我们认真观察后会发现，所谓的头部和底部，都是在这个类中声明的，而原本的 ListAdapter 也是通过此类的构造器传入的。\n\n1. 在 getCount 方法中，正常我们是返回列表集合数据的大小；而在这个带头部底部添加功能的装饰 adapter 中，getCount 的返回值是头部数据 + 列表数据 + 底部数据；\n\n2. 在 getView 方法中，通过对当前位置以及头部集合大小、底部集合大小的对比和校正，来返回适合的数据：\n\n  - 如果当前位置小于头部元素集合，说明当前是头部位置，返回对应的头部元素\n\n    > return mHeaderViewInfos.get(position).view;\n\n  - 利用头部元素集合大小和 adapter 元素大小来做数据校准：当前位置 - 头部大小 = 列表元素位置，列表元素的位置有上限，即 头部元素 + 列表元素总和；\n\n    满足这个区间的数据，都是 adapter 的列表数据，应该由 adapter 自己去处理\n\n    > return mAdapter.getView(adjPosition, convertView, parent);\n\n  - 超出这个范围的，应该都是用户手动添加的底部元素\n\n    > return mFooterViewInfos.get(adjPosition - adapterCount).view;\n\n\n\n#### 总结\n\n同理，我们也可以仿照系统源码来对 RecyclerView 进行添加头部和底部的扩展。\n\n装饰者模式可以非常灵活地为目标对象添加方法，添加新的行为动作，但是相应的，也需要进行更多的代码维护和判断，来保证代码的兼容性和可用性。\n\n举个很简单的例子，我们在上边简单的分析中没有提到，在平时使用的时候，我们一般都是 listView.addHeaderView(), 但是我们会发现在上边的分析中，addHeaderView 的动作是 adapter，而且是 wrapper 类 adapter 来实现的，那我们怎么保证使用 listView 来进行调用，这就是上边我们简单提到的观察者的作用了。\n\n所以很明显，尽管我们为原始的对象添加了功能，但是也因此导致了很多原本不需要的兼容和维护工作。\n\n","slug":"design-pattern-decoration","published":1,"updated":"2019-11-01T03:22:40.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86ca000flh1pdt4qtfci","content":"<p>今天说一下装饰者。</p>\n<a id=\"more\"></a>\n<h4 id=\"模式定义\"><a href=\"#模式定义\" class=\"headerlink\" title=\"模式定义\"></a>模式定义</h4><p>一般来讲，我们扩展某个类的功能可以使用继承或者接口实现的方式，装饰者模式则是第三种扩展方式，可以动态扩展某个对象的功能。</p>\n<p>简单来说就是，在不使用接口或者继承的前提下，以最小侵入性对某个对象的功能进行扩展，使其获得原本不具备的能力。</p>\n<p>这里我们通过分析系统源码，来看看 ListView 是怎么优先于 RecyclerView，拥有自己的 addHeaderView() 方法为例，进行装饰者模式的说明。</p>\n<h4 id=\"ListView-addHeaderView\"><a href=\"#ListView-addHeaderView\" class=\"headerlink\" title=\"ListView#addHeaderView\"></a>ListView#addHeaderView</h4><p>有过开发经验的人都知道，尽管 RecyclerView 在各方面都领先于 ListView，但是有一点却不如 ListView，那就是 ListView 支持添加头部布局，而 RecyclerView 却并不支持。</p>\n<p>当我们从 ListView#addHeaderView 的源码入手，看一看 ListView 是怎么实现添加头布局的时候，就会发现 ListView 本身也是不支持添加头部的，系统源码也是使用了装饰者模式，来为 ListView 进行了功能扩展。</p>\n<p>下面我们来看一下 ListView#addHeaderView 的源码。</p>\n<pre><code class=\"java\">public void addHeaderView(View v, Object data, boolean isSelectable) {\n  // Wrap the adapter if it wasn&#39;t already wrapped.\n  if (mAdapter != null) {\n    if (!(mAdapter instanceof HeaderViewListAdapter)) {\n      wrapHeaderListAdapterInternal();\n    }\n\n    // In the case of re-adding a header view, or adding one later on,\n    // we need to notify the observer.\n    if (mDataSetObserver != null) {\n      mDataSetObserver.onChanged();\n    }\n  }\n}\n</code></pre>\n<p>在方法内部判断中，我们会发现如果 adapter 不是 HeaderViewListAdapter 的实例的话，会调用 <code>wrapHeaderListAdapterInternal()</code> 将它变成该类的实例，然后通过一个观察者来进行 onChanged 更新。再看这个类的名字 HeaderViewListAdapter，很明显 ListView 添加头部和它少不了干系。</p>\n<pre><code class=\"java\">public class HeaderViewListAdapter implements WrapperListAdapter, Filterable {\n\n    private final ListAdapter mAdapter;\n\n    ArrayList&lt;ListView.FixedViewInfo&gt; mHeaderViewInfos;\n    ArrayList&lt;ListView.FixedViewInfo&gt; mFooterViewInfos;\n\n    public HeaderViewListAdapter(ArrayList&lt;ListView.FixedViewInfo&gt; headerViewInfos,\n                                 ArrayList&lt;ListView.FixedViewInfo&gt; footerViewInfos,\n                                 ListAdapter adapter) {\n        mAdapter = adapter;\n\n    }\n\n    public int getHeadersCount() {\n        return mHeaderViewInfos.size();\n    }\n\n    public int getFootersCount() {\n        return mFooterViewInfos.size();\n    }\n\n    public int getCount() {\n        if (mAdapter != null) {\n            return getFootersCount() + getHeadersCount() + mAdapter.getCount();\n        } else {\n            return getFootersCount() + getHeadersCount();\n        }\n    }\n\n    public View getView(int position, View convertView, ViewGroup parent) {\n        // Header (negative positions will throw an IndexOutOfBoundsException)\n        int numHeaders = getHeadersCount();\n        if (position &lt; numHeaders) {\n            return mHeaderViewInfos.get(position).view;\n        }\n\n        // Adapter\n        final int adjPosition = position - numHeaders;\n        int adapterCount = 0;\n        if (mAdapter != null) {\n            adapterCount = mAdapter.getCount();\n            if (adjPosition &lt; adapterCount) {\n                return mAdapter.getView(adjPosition, convertView, parent);\n            }\n        }\n\n        // Footer (off-limits positions will throw an IndexOutOfBoundsException)\n        return mFooterViewInfos.get(adjPosition - adapterCount).view;\n    }\n\n}\n</code></pre>\n<p>上面是我将 HeaderViewListAdapter 类的代码进行适当删减后留下的样子。我们认真观察后会发现，所谓的头部和底部，都是在这个类中声明的，而原本的 ListAdapter 也是通过此类的构造器传入的。</p>\n<ol>\n<li><p>在 getCount 方法中，正常我们是返回列表集合数据的大小；而在这个带头部底部添加功能的装饰 adapter 中，getCount 的返回值是头部数据 + 列表数据 + 底部数据；</p>\n</li>\n<li><p>在 getView 方法中，通过对当前位置以及头部集合大小、底部集合大小的对比和校正，来返回适合的数据：</p>\n<ul>\n<li><p>如果当前位置小于头部元素集合，说明当前是头部位置，返回对应的头部元素</p>\n<blockquote>\n<p>return mHeaderViewInfos.get(position).view;</p>\n</blockquote>\n</li>\n<li><p>利用头部元素集合大小和 adapter 元素大小来做数据校准：当前位置 - 头部大小 = 列表元素位置，列表元素的位置有上限，即 头部元素 + 列表元素总和；</p>\n<p>满足这个区间的数据，都是 adapter 的列表数据，应该由 adapter 自己去处理</p>\n<blockquote>\n<p>return mAdapter.getView(adjPosition, convertView, parent);</p>\n</blockquote>\n</li>\n<li><p>超出这个范围的，应该都是用户手动添加的底部元素</p>\n<blockquote>\n<p>return mFooterViewInfos.get(adjPosition - adapterCount).view;</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>同理，我们也可以仿照系统源码来对 RecyclerView 进行添加头部和底部的扩展。</p>\n<p>装饰者模式可以非常灵活地为目标对象添加方法，添加新的行为动作，但是相应的，也需要进行更多的代码维护和判断，来保证代码的兼容性和可用性。</p>\n<p>举个很简单的例子，我们在上边简单的分析中没有提到，在平时使用的时候，我们一般都是 listView.addHeaderView(), 但是我们会发现在上边的分析中，addHeaderView 的动作是 adapter，而且是 wrapper 类 adapter 来实现的，那我们怎么保证使用 listView 来进行调用，这就是上边我们简单提到的观察者的作用了。</p>\n<p>所以很明显，尽管我们为原始的对象添加了功能，但是也因此导致了很多原本不需要的兼容和维护工作。</p>\n","site":{"data":{}},"excerpt":"<p>今天说一下装饰者。</p>","more":"<h4 id=\"模式定义\"><a href=\"#模式定义\" class=\"headerlink\" title=\"模式定义\"></a>模式定义</h4><p>一般来讲，我们扩展某个类的功能可以使用继承或者接口实现的方式，装饰者模式则是第三种扩展方式，可以动态扩展某个对象的功能。</p>\n<p>简单来说就是，在不使用接口或者继承的前提下，以最小侵入性对某个对象的功能进行扩展，使其获得原本不具备的能力。</p>\n<p>这里我们通过分析系统源码，来看看 ListView 是怎么优先于 RecyclerView，拥有自己的 addHeaderView() 方法为例，进行装饰者模式的说明。</p>\n<h4 id=\"ListView-addHeaderView\"><a href=\"#ListView-addHeaderView\" class=\"headerlink\" title=\"ListView#addHeaderView\"></a>ListView#addHeaderView</h4><p>有过开发经验的人都知道，尽管 RecyclerView 在各方面都领先于 ListView，但是有一点却不如 ListView，那就是 ListView 支持添加头部布局，而 RecyclerView 却并不支持。</p>\n<p>当我们从 ListView#addHeaderView 的源码入手，看一看 ListView 是怎么实现添加头布局的时候，就会发现 ListView 本身也是不支持添加头部的，系统源码也是使用了装饰者模式，来为 ListView 进行了功能扩展。</p>\n<p>下面我们来看一下 ListView#addHeaderView 的源码。</p>\n<pre><code class=\"java\">public void addHeaderView(View v, Object data, boolean isSelectable) {\n  // Wrap the adapter if it wasn&#39;t already wrapped.\n  if (mAdapter != null) {\n    if (!(mAdapter instanceof HeaderViewListAdapter)) {\n      wrapHeaderListAdapterInternal();\n    }\n\n    // In the case of re-adding a header view, or adding one later on,\n    // we need to notify the observer.\n    if (mDataSetObserver != null) {\n      mDataSetObserver.onChanged();\n    }\n  }\n}\n</code></pre>\n<p>在方法内部判断中，我们会发现如果 adapter 不是 HeaderViewListAdapter 的实例的话，会调用 <code>wrapHeaderListAdapterInternal()</code> 将它变成该类的实例，然后通过一个观察者来进行 onChanged 更新。再看这个类的名字 HeaderViewListAdapter，很明显 ListView 添加头部和它少不了干系。</p>\n<pre><code class=\"java\">public class HeaderViewListAdapter implements WrapperListAdapter, Filterable {\n\n    private final ListAdapter mAdapter;\n\n    ArrayList&lt;ListView.FixedViewInfo&gt; mHeaderViewInfos;\n    ArrayList&lt;ListView.FixedViewInfo&gt; mFooterViewInfos;\n\n    public HeaderViewListAdapter(ArrayList&lt;ListView.FixedViewInfo&gt; headerViewInfos,\n                                 ArrayList&lt;ListView.FixedViewInfo&gt; footerViewInfos,\n                                 ListAdapter adapter) {\n        mAdapter = adapter;\n\n    }\n\n    public int getHeadersCount() {\n        return mHeaderViewInfos.size();\n    }\n\n    public int getFootersCount() {\n        return mFooterViewInfos.size();\n    }\n\n    public int getCount() {\n        if (mAdapter != null) {\n            return getFootersCount() + getHeadersCount() + mAdapter.getCount();\n        } else {\n            return getFootersCount() + getHeadersCount();\n        }\n    }\n\n    public View getView(int position, View convertView, ViewGroup parent) {\n        // Header (negative positions will throw an IndexOutOfBoundsException)\n        int numHeaders = getHeadersCount();\n        if (position &lt; numHeaders) {\n            return mHeaderViewInfos.get(position).view;\n        }\n\n        // Adapter\n        final int adjPosition = position - numHeaders;\n        int adapterCount = 0;\n        if (mAdapter != null) {\n            adapterCount = mAdapter.getCount();\n            if (adjPosition &lt; adapterCount) {\n                return mAdapter.getView(adjPosition, convertView, parent);\n            }\n        }\n\n        // Footer (off-limits positions will throw an IndexOutOfBoundsException)\n        return mFooterViewInfos.get(adjPosition - adapterCount).view;\n    }\n\n}\n</code></pre>\n<p>上面是我将 HeaderViewListAdapter 类的代码进行适当删减后留下的样子。我们认真观察后会发现，所谓的头部和底部，都是在这个类中声明的，而原本的 ListAdapter 也是通过此类的构造器传入的。</p>\n<ol>\n<li><p>在 getCount 方法中，正常我们是返回列表集合数据的大小；而在这个带头部底部添加功能的装饰 adapter 中，getCount 的返回值是头部数据 + 列表数据 + 底部数据；</p>\n</li>\n<li><p>在 getView 方法中，通过对当前位置以及头部集合大小、底部集合大小的对比和校正，来返回适合的数据：</p>\n<ul>\n<li><p>如果当前位置小于头部元素集合，说明当前是头部位置，返回对应的头部元素</p>\n<blockquote>\n<p>return mHeaderViewInfos.get(position).view;</p>\n</blockquote>\n</li>\n<li><p>利用头部元素集合大小和 adapter 元素大小来做数据校准：当前位置 - 头部大小 = 列表元素位置，列表元素的位置有上限，即 头部元素 + 列表元素总和；</p>\n<p>满足这个区间的数据，都是 adapter 的列表数据，应该由 adapter 自己去处理</p>\n<blockquote>\n<p>return mAdapter.getView(adjPosition, convertView, parent);</p>\n</blockquote>\n</li>\n<li><p>超出这个范围的，应该都是用户手动添加的底部元素</p>\n<blockquote>\n<p>return mFooterViewInfos.get(adjPosition - adapterCount).view;</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>同理，我们也可以仿照系统源码来对 RecyclerView 进行添加头部和底部的扩展。</p>\n<p>装饰者模式可以非常灵活地为目标对象添加方法，添加新的行为动作，但是相应的，也需要进行更多的代码维护和判断，来保证代码的兼容性和可用性。</p>\n<p>举个很简单的例子，我们在上边简单的分析中没有提到，在平时使用的时候，我们一般都是 listView.addHeaderView(), 但是我们会发现在上边的分析中，addHeaderView 的动作是 adapter，而且是 wrapper 类 adapter 来实现的，那我们怎么保证使用 listView 来进行调用，这就是上边我们简单提到的观察者的作用了。</p>\n<p>所以很明显，尽管我们为原始的对象添加了功能，但是也因此导致了很多原本不需要的兼容和维护工作。</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg","title":"Builder 设计模式","date":"2019-10-25T16:00:00.000Z","_content":"\n哎呀，你说的这个我知道，Builder 设计模式不就是链式调用嘛！\n\n<!-- more -->\n\n其实 Builder 设计模式还是比较常用的一个设计模式，我们平时的开发中偶尔也经常用到。\n\nBuilder 设计模式，又称为建造者设计模式，主要的目标是将参数构建过程和对象表现过程进行分离，让参数的构建过程更加直观和易用。\n\n具体是示例有 OkHttp，系统的 AlertDialog 都是 Builder 设计模式。Builder 设计模式最直观的表现是，在创建某个对象时不是直接 new 该类的对象，而是通过该类的静态内部类 Builder 来构建，并通过最终的 build 方法来完成对象的实例化。\n\n来一个简单的调用例子：\n\n```java\nPosAlertDialog backAlertDialog = new PosAlertDialog.Builder(mContext)\n                    .setRemindText(\"确定要中断盘点吗？\")\n                    .setPrimaryText(\"继续盘点\")\n                    .setSecondaryText(\"中断盘点\")\n                    .setUseLoadingButton(false)\n                    .setOnCancelClickListener(new PosAlertDialog.OnCancelClickListener() {\n                        @Override\n                        public void onCancelClick(View view, Dialog dialog) {\n                            \n                        }\n                    })\n                    .build();\nbackAlertDialog.show();\n```\n\n我们可以看到，通过 Builder 的方法，对弹窗的具体属性、点击事件等进行声明，并在最终通过 build 方法真正创建并返回 PosAlertDialog 的实例，较为流畅地完成整个弹窗的初始化及展示逻辑。\n\n\n\n### Builder 设计模式 VS 链式调用\n\n那回到最初的问题，Builder 设计模式就是链式调用吗？毕竟在我们的例子中也是使用了链式调用。答案是否定的。Builder 设计模式是一种设计模式，目的在于整合多参数的声明，拆分参数声明和对象创建的过程，使得整个过程更加直观、易用；而链式调用只不过是一种调用方式，只要开发者喜欢，基本上任何方法都可以使用链式调用的方式。比如下面这个例子：\n\n```java\npublic class AppVersionEntity {\n  private String version;\n  private String smVersion;\n  private String updateInfo;\n\n  public void setUpdateInfo(String updateInfo) {\n    this.updateInfo = updateInfo;\n    return this;\n  }\n\n  public void setVersion(String version) {\n    this.version = version;\n    return this;\n  }\n\n  public void setSmVersion(String smVersion) {\n    this.smVersion = smVersion;\n    return this;\n  }\n}\n\nAppVersionEntity entity = new AppVersionEntity()\n   \t\t.setUpdateInfo(\"1\")\n   \t\t.setVersion(\"1\")\n   \t\t.setSmVersion(\"1\");\n```\n\n我们可以看到，这只是一个非常普通的 Java bean，但是我们却可以使用链式调用的方式，一次性为属性批量赋值，但是这很明显不是 Builder 设计模式。\n\n","source":"_posts/design-pattern-builder.md","raw":"---\n\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg\ntitle: Builder 设计模式\ntags: [design-pattern]\ndate: 2019-10-26\n---\n\n哎呀，你说的这个我知道，Builder 设计模式不就是链式调用嘛！\n\n<!-- more -->\n\n其实 Builder 设计模式还是比较常用的一个设计模式，我们平时的开发中偶尔也经常用到。\n\nBuilder 设计模式，又称为建造者设计模式，主要的目标是将参数构建过程和对象表现过程进行分离，让参数的构建过程更加直观和易用。\n\n具体是示例有 OkHttp，系统的 AlertDialog 都是 Builder 设计模式。Builder 设计模式最直观的表现是，在创建某个对象时不是直接 new 该类的对象，而是通过该类的静态内部类 Builder 来构建，并通过最终的 build 方法来完成对象的实例化。\n\n来一个简单的调用例子：\n\n```java\nPosAlertDialog backAlertDialog = new PosAlertDialog.Builder(mContext)\n                    .setRemindText(\"确定要中断盘点吗？\")\n                    .setPrimaryText(\"继续盘点\")\n                    .setSecondaryText(\"中断盘点\")\n                    .setUseLoadingButton(false)\n                    .setOnCancelClickListener(new PosAlertDialog.OnCancelClickListener() {\n                        @Override\n                        public void onCancelClick(View view, Dialog dialog) {\n                            \n                        }\n                    })\n                    .build();\nbackAlertDialog.show();\n```\n\n我们可以看到，通过 Builder 的方法，对弹窗的具体属性、点击事件等进行声明，并在最终通过 build 方法真正创建并返回 PosAlertDialog 的实例，较为流畅地完成整个弹窗的初始化及展示逻辑。\n\n\n\n### Builder 设计模式 VS 链式调用\n\n那回到最初的问题，Builder 设计模式就是链式调用吗？毕竟在我们的例子中也是使用了链式调用。答案是否定的。Builder 设计模式是一种设计模式，目的在于整合多参数的声明，拆分参数声明和对象创建的过程，使得整个过程更加直观、易用；而链式调用只不过是一种调用方式，只要开发者喜欢，基本上任何方法都可以使用链式调用的方式。比如下面这个例子：\n\n```java\npublic class AppVersionEntity {\n  private String version;\n  private String smVersion;\n  private String updateInfo;\n\n  public void setUpdateInfo(String updateInfo) {\n    this.updateInfo = updateInfo;\n    return this;\n  }\n\n  public void setVersion(String version) {\n    this.version = version;\n    return this;\n  }\n\n  public void setSmVersion(String smVersion) {\n    this.smVersion = smVersion;\n    return this;\n  }\n}\n\nAppVersionEntity entity = new AppVersionEntity()\n   \t\t.setUpdateInfo(\"1\")\n   \t\t.setVersion(\"1\")\n   \t\t.setSmVersion(\"1\");\n```\n\n我们可以看到，这只是一个非常普通的 Java bean，但是我们却可以使用链式调用的方式，一次性为属性批量赋值，但是这很明显不是 Builder 设计模式。\n\n","slug":"design-pattern-builder","published":1,"updated":"2019-10-26T09:01:48.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86cc000glh1p0w5h4dho","content":"<p>哎呀，你说的这个我知道，Builder 设计模式不就是链式调用嘛！</p>\n<a id=\"more\"></a>\n<p>其实 Builder 设计模式还是比较常用的一个设计模式，我们平时的开发中偶尔也经常用到。</p>\n<p>Builder 设计模式，又称为建造者设计模式，主要的目标是将参数构建过程和对象表现过程进行分离，让参数的构建过程更加直观和易用。</p>\n<p>具体是示例有 OkHttp，系统的 AlertDialog 都是 Builder 设计模式。Builder 设计模式最直观的表现是，在创建某个对象时不是直接 new 该类的对象，而是通过该类的静态内部类 Builder 来构建，并通过最终的 build 方法来完成对象的实例化。</p>\n<p>来一个简单的调用例子：</p>\n<pre><code class=\"java\">PosAlertDialog backAlertDialog = new PosAlertDialog.Builder(mContext)\n                    .setRemindText(&quot;确定要中断盘点吗？&quot;)\n                    .setPrimaryText(&quot;继续盘点&quot;)\n                    .setSecondaryText(&quot;中断盘点&quot;)\n                    .setUseLoadingButton(false)\n                    .setOnCancelClickListener(new PosAlertDialog.OnCancelClickListener() {\n                        @Override\n                        public void onCancelClick(View view, Dialog dialog) {\n\n                        }\n                    })\n                    .build();\nbackAlertDialog.show();\n</code></pre>\n<p>我们可以看到，通过 Builder 的方法，对弹窗的具体属性、点击事件等进行声明，并在最终通过 build 方法真正创建并返回 PosAlertDialog 的实例，较为流畅地完成整个弹窗的初始化及展示逻辑。</p>\n<h3 id=\"Builder-设计模式-VS-链式调用\"><a href=\"#Builder-设计模式-VS-链式调用\" class=\"headerlink\" title=\"Builder 设计模式 VS 链式调用\"></a>Builder 设计模式 VS 链式调用</h3><p>那回到最初的问题，Builder 设计模式就是链式调用吗？毕竟在我们的例子中也是使用了链式调用。答案是否定的。Builder 设计模式是一种设计模式，目的在于整合多参数的声明，拆分参数声明和对象创建的过程，使得整个过程更加直观、易用；而链式调用只不过是一种调用方式，只要开发者喜欢，基本上任何方法都可以使用链式调用的方式。比如下面这个例子：</p>\n<pre><code class=\"java\">public class AppVersionEntity {\n  private String version;\n  private String smVersion;\n  private String updateInfo;\n\n  public void setUpdateInfo(String updateInfo) {\n    this.updateInfo = updateInfo;\n    return this;\n  }\n\n  public void setVersion(String version) {\n    this.version = version;\n    return this;\n  }\n\n  public void setSmVersion(String smVersion) {\n    this.smVersion = smVersion;\n    return this;\n  }\n}\n\nAppVersionEntity entity = new AppVersionEntity()\n           .setUpdateInfo(&quot;1&quot;)\n           .setVersion(&quot;1&quot;)\n           .setSmVersion(&quot;1&quot;);\n</code></pre>\n<p>我们可以看到，这只是一个非常普通的 Java bean，但是我们却可以使用链式调用的方式，一次性为属性批量赋值，但是这很明显不是 Builder 设计模式。</p>\n","site":{"data":{}},"excerpt":"<p>哎呀，你说的这个我知道，Builder 设计模式不就是链式调用嘛！</p>","more":"<p>其实 Builder 设计模式还是比较常用的一个设计模式，我们平时的开发中偶尔也经常用到。</p>\n<p>Builder 设计模式，又称为建造者设计模式，主要的目标是将参数构建过程和对象表现过程进行分离，让参数的构建过程更加直观和易用。</p>\n<p>具体是示例有 OkHttp，系统的 AlertDialog 都是 Builder 设计模式。Builder 设计模式最直观的表现是，在创建某个对象时不是直接 new 该类的对象，而是通过该类的静态内部类 Builder 来构建，并通过最终的 build 方法来完成对象的实例化。</p>\n<p>来一个简单的调用例子：</p>\n<pre><code class=\"java\">PosAlertDialog backAlertDialog = new PosAlertDialog.Builder(mContext)\n                    .setRemindText(&quot;确定要中断盘点吗？&quot;)\n                    .setPrimaryText(&quot;继续盘点&quot;)\n                    .setSecondaryText(&quot;中断盘点&quot;)\n                    .setUseLoadingButton(false)\n                    .setOnCancelClickListener(new PosAlertDialog.OnCancelClickListener() {\n                        @Override\n                        public void onCancelClick(View view, Dialog dialog) {\n\n                        }\n                    })\n                    .build();\nbackAlertDialog.show();\n</code></pre>\n<p>我们可以看到，通过 Builder 的方法，对弹窗的具体属性、点击事件等进行声明，并在最终通过 build 方法真正创建并返回 PosAlertDialog 的实例，较为流畅地完成整个弹窗的初始化及展示逻辑。</p>\n<h3 id=\"Builder-设计模式-VS-链式调用\"><a href=\"#Builder-设计模式-VS-链式调用\" class=\"headerlink\" title=\"Builder 设计模式 VS 链式调用\"></a>Builder 设计模式 VS 链式调用</h3><p>那回到最初的问题，Builder 设计模式就是链式调用吗？毕竟在我们的例子中也是使用了链式调用。答案是否定的。Builder 设计模式是一种设计模式，目的在于整合多参数的声明，拆分参数声明和对象创建的过程，使得整个过程更加直观、易用；而链式调用只不过是一种调用方式，只要开发者喜欢，基本上任何方法都可以使用链式调用的方式。比如下面这个例子：</p>\n<pre><code class=\"java\">public class AppVersionEntity {\n  private String version;\n  private String smVersion;\n  private String updateInfo;\n\n  public void setUpdateInfo(String updateInfo) {\n    this.updateInfo = updateInfo;\n    return this;\n  }\n\n  public void setVersion(String version) {\n    this.version = version;\n    return this;\n  }\n\n  public void setSmVersion(String smVersion) {\n    this.smVersion = smVersion;\n    return this;\n  }\n}\n\nAppVersionEntity entity = new AppVersionEntity()\n           .setUpdateInfo(&quot;1&quot;)\n           .setVersion(&quot;1&quot;)\n           .setSmVersion(&quot;1&quot;);\n</code></pre>\n<p>我们可以看到，这只是一个非常普通的 Java bean，但是我们却可以使用链式调用的方式，一次性为属性批量赋值，但是这很明显不是 Builder 设计模式。</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg","title":"模板设计模式","date":"2019-11-05T16:00:00.000Z","_content":"\n可能说 base 层封装更好理解一些。\n\n\n\n<!-- more -->\n\n#### 定义\n\n模板模式的官方解释是，**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。**\n\n这么说可能比较抽象，其实简单来说，就是我们平时开发过程中常常会用到的基类封装。\n\n```java\npublic abstract class BaseActivity extends AppCompatActivity {\n  \t\n  \t@Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(getLayoutId());\n      \tinitView();\n    }\n  \n  \tpublic abstract int getLayoutId();\n  \tpublic abstract void initView();\n}\n```\n\n就像上边的代码，**定义一个基本框架**，使用抽象父类和抽象方法，**将一些步骤延迟到子类中**，子类可以通过继承基类，从而**在不改变原本框架结构**的基础上**自定义**特定步骤。\n\n打个比方，\n\n你上学的时候不是很乖，老师经常罚你写检查，于是你灵机一动，在某个风和日丽的午后，写出来十份检查。每份检查的大体内容都是差不多的，只有具体反思错误的部分是留白的，因为你也不知道下一个让你写检查的老师是谁，也不知道是为了什么写检查。天资聪颖的你啊，年纪轻轻就掌握了封装的精髓，长大后成为了一名程序员（误）。\n\n\n\n#### 系统源码对模板模式的应用\n\n模板模式作为一个较常用且简单的模式，在日常开发中有比较广泛的应用。这里简单以 Android View 的绘制流程为例，说明一下源码级别的应用实例。\n\n- View#onDraw()\n\n  View 的绘制流程确实是老生常谈了，[具体流程](https://www.jianshu.com/p/d7ab114ac1f7)我们这里不多讲，只解释一下模板设计模式的具体应用。\n\n  我们在自定义 View 的时候一般会重写一个 onDraw() 方法，当我们去查看父类 View.java 时会发现，其中的 onDraw() 方法是空实现的，没有任何内容；但是当我们在自己重写的方法中，通过画笔进行一系列自定义操作后，我们想要的效果就会实现。\n\n- Activity 生命周期\n\n  我们在平时用的太多，以至于忽略了 Activity 生命周期也是应用了模板设计模式。\n\n  所有自己定义的 Activity 都继承自 Activity ，并且所有的 Activity 的生命周期流程都是一致的，每个 Activity 可以设置不同的页面，实现不同的逻辑。\n\n- AsyncTask\n\n  Android 自带的 AsyncTask 也是对模板模式的应用。\n\n  ```java\n  new AsyncTask<Void, Integer, String>(){\n      @Override\n      protected void onProgressUpdate(Integer... values) {\n        \n      }\n  \n      @Override\n      protected String doInBackground(Void... voids) {\n        return null;\n      }\n  \n      @Override\n      protected void onPostExecute(String s) {\n        \n      }\n  };\n  ```\n\n  框架内定的实现逻辑我们是不能更改，甚至不能看到的；但是我们可以通过暴露出来的方法，来实现完全不同的逻辑和业务。\n\n\n\n\n\n","source":"_posts/design-pattern-template.md","raw":"---\n\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg\ntitle: 模板设计模式\ntags: [design-pattern]\ndate: 2019-11-06\n---\n\n可能说 base 层封装更好理解一些。\n\n\n\n<!-- more -->\n\n#### 定义\n\n模板模式的官方解释是，**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。**\n\n这么说可能比较抽象，其实简单来说，就是我们平时开发过程中常常会用到的基类封装。\n\n```java\npublic abstract class BaseActivity extends AppCompatActivity {\n  \t\n  \t@Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(getLayoutId());\n      \tinitView();\n    }\n  \n  \tpublic abstract int getLayoutId();\n  \tpublic abstract void initView();\n}\n```\n\n就像上边的代码，**定义一个基本框架**，使用抽象父类和抽象方法，**将一些步骤延迟到子类中**，子类可以通过继承基类，从而**在不改变原本框架结构**的基础上**自定义**特定步骤。\n\n打个比方，\n\n你上学的时候不是很乖，老师经常罚你写检查，于是你灵机一动，在某个风和日丽的午后，写出来十份检查。每份检查的大体内容都是差不多的，只有具体反思错误的部分是留白的，因为你也不知道下一个让你写检查的老师是谁，也不知道是为了什么写检查。天资聪颖的你啊，年纪轻轻就掌握了封装的精髓，长大后成为了一名程序员（误）。\n\n\n\n#### 系统源码对模板模式的应用\n\n模板模式作为一个较常用且简单的模式，在日常开发中有比较广泛的应用。这里简单以 Android View 的绘制流程为例，说明一下源码级别的应用实例。\n\n- View#onDraw()\n\n  View 的绘制流程确实是老生常谈了，[具体流程](https://www.jianshu.com/p/d7ab114ac1f7)我们这里不多讲，只解释一下模板设计模式的具体应用。\n\n  我们在自定义 View 的时候一般会重写一个 onDraw() 方法，当我们去查看父类 View.java 时会发现，其中的 onDraw() 方法是空实现的，没有任何内容；但是当我们在自己重写的方法中，通过画笔进行一系列自定义操作后，我们想要的效果就会实现。\n\n- Activity 生命周期\n\n  我们在平时用的太多，以至于忽略了 Activity 生命周期也是应用了模板设计模式。\n\n  所有自己定义的 Activity 都继承自 Activity ，并且所有的 Activity 的生命周期流程都是一致的，每个 Activity 可以设置不同的页面，实现不同的逻辑。\n\n- AsyncTask\n\n  Android 自带的 AsyncTask 也是对模板模式的应用。\n\n  ```java\n  new AsyncTask<Void, Integer, String>(){\n      @Override\n      protected void onProgressUpdate(Integer... values) {\n        \n      }\n  \n      @Override\n      protected String doInBackground(Void... voids) {\n        return null;\n      }\n  \n      @Override\n      protected void onPostExecute(String s) {\n        \n      }\n  };\n  ```\n\n  框架内定的实现逻辑我们是不能更改，甚至不能看到的；但是我们可以通过暴露出来的方法，来实现完全不同的逻辑和业务。\n\n\n\n\n\n","slug":"design-pattern-template","published":1,"updated":"2019-11-07T08:52:06.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86cd000jlh1px5hwn8uk","content":"<p>可能说 base 层封装更好理解一些。</p>\n<a id=\"more\"></a>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>模板模式的官方解释是，<strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</strong></p>\n<p>这么说可能比较抽象，其实简单来说，就是我们平时开发过程中常常会用到的基类封装。</p>\n<pre><code class=\"java\">public abstract class BaseActivity extends AppCompatActivity {\n\n      @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(getLayoutId());\n          initView();\n    }\n\n      public abstract int getLayoutId();\n      public abstract void initView();\n}\n</code></pre>\n<p>就像上边的代码，<strong>定义一个基本框架</strong>，使用抽象父类和抽象方法，<strong>将一些步骤延迟到子类中</strong>，子类可以通过继承基类，从而<strong>在不改变原本框架结构</strong>的基础上<strong>自定义</strong>特定步骤。</p>\n<p>打个比方，</p>\n<p>你上学的时候不是很乖，老师经常罚你写检查，于是你灵机一动，在某个风和日丽的午后，写出来十份检查。每份检查的大体内容都是差不多的，只有具体反思错误的部分是留白的，因为你也不知道下一个让你写检查的老师是谁，也不知道是为了什么写检查。天资聪颖的你啊，年纪轻轻就掌握了封装的精髓，长大后成为了一名程序员（误）。</p>\n<h4 id=\"系统源码对模板模式的应用\"><a href=\"#系统源码对模板模式的应用\" class=\"headerlink\" title=\"系统源码对模板模式的应用\"></a>系统源码对模板模式的应用</h4><p>模板模式作为一个较常用且简单的模式，在日常开发中有比较广泛的应用。这里简单以 Android View 的绘制流程为例，说明一下源码级别的应用实例。</p>\n<ul>\n<li><p>View#onDraw()</p>\n<p>View 的绘制流程确实是老生常谈了，<a href=\"https://www.jianshu.com/p/d7ab114ac1f7\" target=\"_blank\" rel=\"noopener\">具体流程</a>我们这里不多讲，只解释一下模板设计模式的具体应用。</p>\n<p>我们在自定义 View 的时候一般会重写一个 onDraw() 方法，当我们去查看父类 View.java 时会发现，其中的 onDraw() 方法是空实现的，没有任何内容；但是当我们在自己重写的方法中，通过画笔进行一系列自定义操作后，我们想要的效果就会实现。</p>\n</li>\n<li><p>Activity 生命周期</p>\n<p>我们在平时用的太多，以至于忽略了 Activity 生命周期也是应用了模板设计模式。</p>\n<p>所有自己定义的 Activity 都继承自 Activity ，并且所有的 Activity 的生命周期流程都是一致的，每个 Activity 可以设置不同的页面，实现不同的逻辑。</p>\n</li>\n<li><p>AsyncTask</p>\n<p>Android 自带的 AsyncTask 也是对模板模式的应用。</p>\n<pre><code class=\"java\">new AsyncTask&lt;Void, Integer, String&gt;(){\n    @Override\n    protected void onProgressUpdate(Integer... values) {\n\n    }\n\n    @Override\n    protected String doInBackground(Void... voids) {\n      return null;\n    }\n\n    @Override\n    protected void onPostExecute(String s) {\n\n    }\n};\n</code></pre>\n<p>框架内定的实现逻辑我们是不能更改，甚至不能看到的；但是我们可以通过暴露出来的方法，来实现完全不同的逻辑和业务。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>可能说 base 层封装更好理解一些。</p>","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>模板模式的官方解释是，<strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</strong></p>\n<p>这么说可能比较抽象，其实简单来说，就是我们平时开发过程中常常会用到的基类封装。</p>\n<pre><code class=\"java\">public abstract class BaseActivity extends AppCompatActivity {\n\n      @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(getLayoutId());\n          initView();\n    }\n\n      public abstract int getLayoutId();\n      public abstract void initView();\n}\n</code></pre>\n<p>就像上边的代码，<strong>定义一个基本框架</strong>，使用抽象父类和抽象方法，<strong>将一些步骤延迟到子类中</strong>，子类可以通过继承基类，从而<strong>在不改变原本框架结构</strong>的基础上<strong>自定义</strong>特定步骤。</p>\n<p>打个比方，</p>\n<p>你上学的时候不是很乖，老师经常罚你写检查，于是你灵机一动，在某个风和日丽的午后，写出来十份检查。每份检查的大体内容都是差不多的，只有具体反思错误的部分是留白的，因为你也不知道下一个让你写检查的老师是谁，也不知道是为了什么写检查。天资聪颖的你啊，年纪轻轻就掌握了封装的精髓，长大后成为了一名程序员（误）。</p>\n<h4 id=\"系统源码对模板模式的应用\"><a href=\"#系统源码对模板模式的应用\" class=\"headerlink\" title=\"系统源码对模板模式的应用\"></a>系统源码对模板模式的应用</h4><p>模板模式作为一个较常用且简单的模式，在日常开发中有比较广泛的应用。这里简单以 Android View 的绘制流程为例，说明一下源码级别的应用实例。</p>\n<ul>\n<li><p>View#onDraw()</p>\n<p>View 的绘制流程确实是老生常谈了，<a href=\"https://www.jianshu.com/p/d7ab114ac1f7\" target=\"_blank\" rel=\"noopener\">具体流程</a>我们这里不多讲，只解释一下模板设计模式的具体应用。</p>\n<p>我们在自定义 View 的时候一般会重写一个 onDraw() 方法，当我们去查看父类 View.java 时会发现，其中的 onDraw() 方法是空实现的，没有任何内容；但是当我们在自己重写的方法中，通过画笔进行一系列自定义操作后，我们想要的效果就会实现。</p>\n</li>\n<li><p>Activity 生命周期</p>\n<p>我们在平时用的太多，以至于忽略了 Activity 生命周期也是应用了模板设计模式。</p>\n<p>所有自己定义的 Activity 都继承自 Activity ，并且所有的 Activity 的生命周期流程都是一致的，每个 Activity 可以设置不同的页面，实现不同的逻辑。</p>\n</li>\n<li><p>AsyncTask</p>\n<p>Android 自带的 AsyncTask 也是对模板模式的应用。</p>\n<pre><code class=\"java\">new AsyncTask&lt;Void, Integer, String&gt;(){\n    @Override\n    protected void onProgressUpdate(Integer... values) {\n\n    }\n\n    @Override\n    protected String doInBackground(Void... voids) {\n      return null;\n    }\n\n    @Override\n    protected void onPostExecute(String s) {\n\n    }\n};\n</code></pre>\n<p>框架内定的实现逻辑我们是不能更改，甚至不能看到的；但是我们可以通过暴露出来的方法，来实现完全不同的逻辑和业务。</p>\n</li>\n</ul>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg","title":"单例设计模式","date":"2019-10-25T16:00:00.000Z","_content":"\n\n\n茴香的「茴」字有几种写法？\n\n\n\n<!-- more -->\n\n单例模式有很多种写法，都不复杂，大概梳理一下。\n\n#### 饿汉式\n\n私有化构造器，提供共有方法获取实例对象，没什么多说的。静态对象和类一起加载，耗费资源，不推荐。\n\n```java\nclass Singleton {\n\n    public static Singleton sInstance = new Singleton();\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        return sInstance;\n    }\n\n}\n```\n\n\n\n#### 懒汉式\n\n最简单的懒汉单例，但是会有线程安全的问题，需要完善。\n\n```java\nclass Singleton {\n\n    public static Singleton sInstance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      \tif(sInstance == null){\n           sInstance = new Singleton();\n        }\n        return sInstance;\n    }\n\n}\n```\n\n\n\n#### 双重校验锁懒汉单例\n\n有几个需要注意的地方：\n\n1. 单例对象加上 `volatile` 关键字，防止重排序，保证多线程可见性\n\n2. 两个判空都不能省略，第一个 if 用来提升效率，有对象后不再创建；第二个 if 用来保证线程安全。\n\n   > 如果没有第二个 if，虽然被 synchronized 锁在了外面，但是等第一个线程创建完对象，第二个线程还是可以继续往下执行\n   \n3. synchronized 的锁不可以为 new Object(), 锁必须保证唯一性\n\n```java\nclass Singleton {\n    public static volatile Singleton sInstance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n      if(sInstance == null){\n        synchronized (Singleton.class) {\n          if(sInstance == null){\n            sInstance = new Singleton();\n          }\n        }\n      }\n      return sInstance;\n    }\n}\n```\n\n\n\n#### 静态内部类\n\n静态内部类也是个比较推崇的方式了，当一个 Java 类第一次被真正使用到的时候才会去加载静态资源。Java 类加载和初始化的过程都是线程安全的。\n\n```java\nclass Singleton {\n    private Singleton() {}\n    public Singleton getInstance() {\n        return Holder.mInstance;\n    }\n    private static class Holder {\n        private static Singleton sInstance = new Singleton();\n    }\n}\n```\n\n\n\n#### 枚举\n\n枚举单例即为简洁，且无偿提供序列化机制，绝对防止多次实例化，即便用反射都不行。单元素的枚举类型是目前实现 Singleton 的最佳方法。\n\n```java\nenum Singleton{\n  INSTANCE\n}\n```\n\n","source":"_posts/design-pattern-singleton.md","raw":"---\n\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg\ntitle: 单例设计模式\ntags: [design-pattern]\ndate: 2019-10-26\n---\n\n\n\n茴香的「茴」字有几种写法？\n\n\n\n<!-- more -->\n\n单例模式有很多种写法，都不复杂，大概梳理一下。\n\n#### 饿汉式\n\n私有化构造器，提供共有方法获取实例对象，没什么多说的。静态对象和类一起加载，耗费资源，不推荐。\n\n```java\nclass Singleton {\n\n    public static Singleton sInstance = new Singleton();\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        return sInstance;\n    }\n\n}\n```\n\n\n\n#### 懒汉式\n\n最简单的懒汉单例，但是会有线程安全的问题，需要完善。\n\n```java\nclass Singleton {\n\n    public static Singleton sInstance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      \tif(sInstance == null){\n           sInstance = new Singleton();\n        }\n        return sInstance;\n    }\n\n}\n```\n\n\n\n#### 双重校验锁懒汉单例\n\n有几个需要注意的地方：\n\n1. 单例对象加上 `volatile` 关键字，防止重排序，保证多线程可见性\n\n2. 两个判空都不能省略，第一个 if 用来提升效率，有对象后不再创建；第二个 if 用来保证线程安全。\n\n   > 如果没有第二个 if，虽然被 synchronized 锁在了外面，但是等第一个线程创建完对象，第二个线程还是可以继续往下执行\n   \n3. synchronized 的锁不可以为 new Object(), 锁必须保证唯一性\n\n```java\nclass Singleton {\n    public static volatile Singleton sInstance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n      if(sInstance == null){\n        synchronized (Singleton.class) {\n          if(sInstance == null){\n            sInstance = new Singleton();\n          }\n        }\n      }\n      return sInstance;\n    }\n}\n```\n\n\n\n#### 静态内部类\n\n静态内部类也是个比较推崇的方式了，当一个 Java 类第一次被真正使用到的时候才会去加载静态资源。Java 类加载和初始化的过程都是线程安全的。\n\n```java\nclass Singleton {\n    private Singleton() {}\n    public Singleton getInstance() {\n        return Holder.mInstance;\n    }\n    private static class Holder {\n        private static Singleton sInstance = new Singleton();\n    }\n}\n```\n\n\n\n#### 枚举\n\n枚举单例即为简洁，且无偿提供序列化机制，绝对防止多次实例化，即便用反射都不行。单元素的枚举类型是目前实现 Singleton 的最佳方法。\n\n```java\nenum Singleton{\n  INSTANCE\n}\n```\n\n","slug":"design-pattern-singleton","published":1,"updated":"2019-10-26T08:11:02.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86cf000klh1plklptp9a","content":"<p>茴香的「茴」字有几种写法？</p>\n<a id=\"more\"></a>\n<p>单例模式有很多种写法，都不复杂，大概梳理一下。</p>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><p>私有化构造器，提供共有方法获取实例对象，没什么多说的。静态对象和类一起加载，耗费资源，不推荐。</p>\n<pre><code class=\"java\">class Singleton {\n\n    public static Singleton sInstance = new Singleton();\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        return sInstance;\n    }\n\n}\n</code></pre>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><p>最简单的懒汉单例，但是会有线程安全的问题，需要完善。</p>\n<pre><code class=\"java\">class Singleton {\n\n    public static Singleton sInstance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n          if(sInstance == null){\n           sInstance = new Singleton();\n        }\n        return sInstance;\n    }\n\n}\n</code></pre>\n<h4 id=\"双重校验锁懒汉单例\"><a href=\"#双重校验锁懒汉单例\" class=\"headerlink\" title=\"双重校验锁懒汉单例\"></a>双重校验锁懒汉单例</h4><p>有几个需要注意的地方：</p>\n<ol>\n<li><p>单例对象加上 <code>volatile</code> 关键字，防止重排序，保证多线程可见性</p>\n</li>\n<li><p>两个判空都不能省略，第一个 if 用来提升效率，有对象后不再创建；第二个 if 用来保证线程安全。</p>\n<blockquote>\n<p>如果没有第二个 if，虽然被 synchronized 锁在了外面，但是等第一个线程创建完对象，第二个线程还是可以继续往下执行</p>\n</blockquote>\n</li>\n<li><p>synchronized 的锁不可以为 new Object(), 锁必须保证唯一性</p>\n</li>\n</ol>\n<pre><code class=\"java\">class Singleton {\n    public static volatile Singleton sInstance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n      if(sInstance == null){\n        synchronized (Singleton.class) {\n          if(sInstance == null){\n            sInstance = new Singleton();\n          }\n        }\n      }\n      return sInstance;\n    }\n}\n</code></pre>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><p>静态内部类也是个比较推崇的方式了，当一个 Java 类第一次被真正使用到的时候才会去加载静态资源。Java 类加载和初始化的过程都是线程安全的。</p>\n<pre><code class=\"java\">class Singleton {\n    private Singleton() {}\n    public Singleton getInstance() {\n        return Holder.mInstance;\n    }\n    private static class Holder {\n        private static Singleton sInstance = new Singleton();\n    }\n}\n</code></pre>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p>枚举单例即为简洁，且无偿提供序列化机制，绝对防止多次实例化，即便用反射都不行。单元素的枚举类型是目前实现 Singleton 的最佳方法。</p>\n<pre><code class=\"java\">enum Singleton{\n  INSTANCE\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>茴香的「茴」字有几种写法？</p>","more":"<p>单例模式有很多种写法，都不复杂，大概梳理一下。</p>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><p>私有化构造器，提供共有方法获取实例对象，没什么多说的。静态对象和类一起加载，耗费资源，不推荐。</p>\n<pre><code class=\"java\">class Singleton {\n\n    public static Singleton sInstance = new Singleton();\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        return sInstance;\n    }\n\n}\n</code></pre>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><p>最简单的懒汉单例，但是会有线程安全的问题，需要完善。</p>\n<pre><code class=\"java\">class Singleton {\n\n    public static Singleton sInstance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n          if(sInstance == null){\n           sInstance = new Singleton();\n        }\n        return sInstance;\n    }\n\n}\n</code></pre>\n<h4 id=\"双重校验锁懒汉单例\"><a href=\"#双重校验锁懒汉单例\" class=\"headerlink\" title=\"双重校验锁懒汉单例\"></a>双重校验锁懒汉单例</h4><p>有几个需要注意的地方：</p>\n<ol>\n<li><p>单例对象加上 <code>volatile</code> 关键字，防止重排序，保证多线程可见性</p>\n</li>\n<li><p>两个判空都不能省略，第一个 if 用来提升效率，有对象后不再创建；第二个 if 用来保证线程安全。</p>\n<blockquote>\n<p>如果没有第二个 if，虽然被 synchronized 锁在了外面，但是等第一个线程创建完对象，第二个线程还是可以继续往下执行</p>\n</blockquote>\n</li>\n<li><p>synchronized 的锁不可以为 new Object(), 锁必须保证唯一性</p>\n</li>\n</ol>\n<pre><code class=\"java\">class Singleton {\n    public static volatile Singleton sInstance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n      if(sInstance == null){\n        synchronized (Singleton.class) {\n          if(sInstance == null){\n            sInstance = new Singleton();\n          }\n        }\n      }\n      return sInstance;\n    }\n}\n</code></pre>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><p>静态内部类也是个比较推崇的方式了，当一个 Java 类第一次被真正使用到的时候才会去加载静态资源。Java 类加载和初始化的过程都是线程安全的。</p>\n<pre><code class=\"java\">class Singleton {\n    private Singleton() {}\n    public Singleton getInstance() {\n        return Holder.mInstance;\n    }\n    private static class Holder {\n        private static Singleton sInstance = new Singleton();\n    }\n}\n</code></pre>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p>枚举单例即为简洁，且无偿提供序列化机制，绝对防止多次实例化，即便用反射都不行。单元素的枚举类型是目前实现 Singleton 的最佳方法。</p>\n<pre><code class=\"java\">enum Singleton{\n  INSTANCE\n}\n</code></pre>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg","title":"策略设计模式","date":"2019-11-07T16:00:00.000Z","_content":"\n\n\n上班坐公交还是坐地铁？这就是两种不同的策略。\n\n\n\n<!-- more -->\n\n#### 定义\n\n面向同一接口实现一系列算法，然后将他们分别封装起来，再经由同一入口进行调用；不同的策略之间可以相互替换。主要用来解决同一任务，多种条分支的情况下，过多 if-else 分支的情况。\n\n比如属性动画的差值器设置：\n\n```java\nObjectAnimator.ofFloat().setInterpolator(TimeInterpolator value);\n```\n\n我们看到，参数需要的是 TimeInterpolator 对象，我们点进去会发现：\n\n```java\npublic interface TimeInterpolator {\n    float getInterpolation(float input);\n}\n```\n\n而我们平时常用的几个差值器也就都实现了这个接口：\n\n- AccelerateInterpolator\n- DecelerateInterpolator\n- AnticipateInterpolator\n- CycleInterpolator\n- LinearInterpolator\n- ... ...\n\n不同的差值器只是 `getInterpolation()` 的实现不同，所以**面向接口将不同的算法进行封装，再经由同一入口进行调用；不同的策略之间可以相互替换。**\n\n\n\n#### 具体实践案例\n\n下面我们以货币基金收益为例，简单的实践一下策略设计模式。\n\n我们的目标是对于给定的时间和本金，得到不同平台对应的利息。\n\n下面是通用接口：\n\n```java\npublic interface IFinanceInterest{\n  double getInterest(int month, int money);\n}\n```\n\n余额宝：\n\n```java\npublic class AlipayFinance implements IFinanceInterest{\n  @Overide\n  double getInterest(int month, int money){\n  \tswitch(month){\n      case 3:\n        return money * (1 + 0.026 / 12 * 3);\n      case 6:\n        return money * (1 + 0.035 / 12 * 3);\n      case 12:\n        return money * (1 + 0.043 / 12 * 3);\n      default:\n        return money * (1 + 0.02 / 12 * 3);\n    }\n  }\n}\n```\n\n朝朝盈：\n\n```java\npublic class ZhaoShangFinance implements IFinanceInterest{\n  @Overide\n  double getInterest(int month, int money){\n  \tswitch(month){\n      case 3:\n        return money * (1 + 0.028 / 12 * 3);\n      case 6:\n        return money * (1 + 0.037 / 12 * 3);\n      case 12:\n        return money * (1 + 0.052 / 12 * 3);\n      default:\n        return money * (1 + 0.02 / 12 * 3);\n    }\n  }\n}\n```\n\n一般来讲，在策略模式中，我们还需要一个上下文对象，用于不同策略间的转换。\n\n```java\npublic class FinanceContext{\n  \n  private IFinanceInterest mFinance;\n  public FinanceContext(IFinanceInterest interest){\n     mFinance = interest;\n  }\n\n  public void setFinanceInterest(IFinanceInterest interest){\n    mFinance = interest;\n  }\n\t\n  public double getMyInterest(int month, int money){\n    mFinance.getInterest(month, money);\n  }\n  \n}\n```\n\n具体使用：\n\n```java\npublic static void main(String[] args) {\n      FinanceContext context = new FinanceContext(new AlipayFinance());    \n      context.getMyInterest(3, 12000);\n \n      context.setFinanceInterest(new ZhaoShangFinance())\n      context.getMyInterest(12, 12000);\n}\n```\n\n\n\n#### 模式优缺点\n\n- 优点\n  - ","source":"_posts/design-pattern-strategy.md","raw":"---\n\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg\ntitle: 策略设计模式\ntags: [design-pattern]\ndate: 2019-11-08\n---\n\n\n\n上班坐公交还是坐地铁？这就是两种不同的策略。\n\n\n\n<!-- more -->\n\n#### 定义\n\n面向同一接口实现一系列算法，然后将他们分别封装起来，再经由同一入口进行调用；不同的策略之间可以相互替换。主要用来解决同一任务，多种条分支的情况下，过多 if-else 分支的情况。\n\n比如属性动画的差值器设置：\n\n```java\nObjectAnimator.ofFloat().setInterpolator(TimeInterpolator value);\n```\n\n我们看到，参数需要的是 TimeInterpolator 对象，我们点进去会发现：\n\n```java\npublic interface TimeInterpolator {\n    float getInterpolation(float input);\n}\n```\n\n而我们平时常用的几个差值器也就都实现了这个接口：\n\n- AccelerateInterpolator\n- DecelerateInterpolator\n- AnticipateInterpolator\n- CycleInterpolator\n- LinearInterpolator\n- ... ...\n\n不同的差值器只是 `getInterpolation()` 的实现不同，所以**面向接口将不同的算法进行封装，再经由同一入口进行调用；不同的策略之间可以相互替换。**\n\n\n\n#### 具体实践案例\n\n下面我们以货币基金收益为例，简单的实践一下策略设计模式。\n\n我们的目标是对于给定的时间和本金，得到不同平台对应的利息。\n\n下面是通用接口：\n\n```java\npublic interface IFinanceInterest{\n  double getInterest(int month, int money);\n}\n```\n\n余额宝：\n\n```java\npublic class AlipayFinance implements IFinanceInterest{\n  @Overide\n  double getInterest(int month, int money){\n  \tswitch(month){\n      case 3:\n        return money * (1 + 0.026 / 12 * 3);\n      case 6:\n        return money * (1 + 0.035 / 12 * 3);\n      case 12:\n        return money * (1 + 0.043 / 12 * 3);\n      default:\n        return money * (1 + 0.02 / 12 * 3);\n    }\n  }\n}\n```\n\n朝朝盈：\n\n```java\npublic class ZhaoShangFinance implements IFinanceInterest{\n  @Overide\n  double getInterest(int month, int money){\n  \tswitch(month){\n      case 3:\n        return money * (1 + 0.028 / 12 * 3);\n      case 6:\n        return money * (1 + 0.037 / 12 * 3);\n      case 12:\n        return money * (1 + 0.052 / 12 * 3);\n      default:\n        return money * (1 + 0.02 / 12 * 3);\n    }\n  }\n}\n```\n\n一般来讲，在策略模式中，我们还需要一个上下文对象，用于不同策略间的转换。\n\n```java\npublic class FinanceContext{\n  \n  private IFinanceInterest mFinance;\n  public FinanceContext(IFinanceInterest interest){\n     mFinance = interest;\n  }\n\n  public void setFinanceInterest(IFinanceInterest interest){\n    mFinance = interest;\n  }\n\t\n  public double getMyInterest(int month, int money){\n    mFinance.getInterest(month, money);\n  }\n  \n}\n```\n\n具体使用：\n\n```java\npublic static void main(String[] args) {\n      FinanceContext context = new FinanceContext(new AlipayFinance());    \n      context.getMyInterest(3, 12000);\n \n      context.setFinanceInterest(new ZhaoShangFinance())\n      context.getMyInterest(12, 12000);\n}\n```\n\n\n\n#### 模式优缺点\n\n- 优点\n  - ","slug":"design-pattern-strategy","published":1,"updated":"2019-11-08T09:59:48.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86ci000nlh1ps1e2mcj7","content":"<p>上班坐公交还是坐地铁？这就是两种不同的策略。</p>\n<a id=\"more\"></a>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>面向同一接口实现一系列算法，然后将他们分别封装起来，再经由同一入口进行调用；不同的策略之间可以相互替换。主要用来解决同一任务，多种条分支的情况下，过多 if-else 分支的情况。</p>\n<p>比如属性动画的差值器设置：</p>\n<pre><code class=\"java\">ObjectAnimator.ofFloat().setInterpolator(TimeInterpolator value);\n</code></pre>\n<p>我们看到，参数需要的是 TimeInterpolator 对象，我们点进去会发现：</p>\n<pre><code class=\"java\">public interface TimeInterpolator {\n    float getInterpolation(float input);\n}\n</code></pre>\n<p>而我们平时常用的几个差值器也就都实现了这个接口：</p>\n<ul>\n<li>AccelerateInterpolator</li>\n<li>DecelerateInterpolator</li>\n<li>AnticipateInterpolator</li>\n<li>CycleInterpolator</li>\n<li>LinearInterpolator</li>\n<li>… …</li>\n</ul>\n<p>不同的差值器只是 <code>getInterpolation()</code> 的实现不同，所以<strong>面向接口将不同的算法进行封装，再经由同一入口进行调用；不同的策略之间可以相互替换。</strong></p>\n<h4 id=\"具体实践案例\"><a href=\"#具体实践案例\" class=\"headerlink\" title=\"具体实践案例\"></a>具体实践案例</h4><p>下面我们以货币基金收益为例，简单的实践一下策略设计模式。</p>\n<p>我们的目标是对于给定的时间和本金，得到不同平台对应的利息。</p>\n<p>下面是通用接口：</p>\n<pre><code class=\"java\">public interface IFinanceInterest{\n  double getInterest(int month, int money);\n}\n</code></pre>\n<p>余额宝：</p>\n<pre><code class=\"java\">public class AlipayFinance implements IFinanceInterest{\n  @Overide\n  double getInterest(int month, int money){\n      switch(month){\n      case 3:\n        return money * (1 + 0.026 / 12 * 3);\n      case 6:\n        return money * (1 + 0.035 / 12 * 3);\n      case 12:\n        return money * (1 + 0.043 / 12 * 3);\n      default:\n        return money * (1 + 0.02 / 12 * 3);\n    }\n  }\n}\n</code></pre>\n<p>朝朝盈：</p>\n<pre><code class=\"java\">public class ZhaoShangFinance implements IFinanceInterest{\n  @Overide\n  double getInterest(int month, int money){\n      switch(month){\n      case 3:\n        return money * (1 + 0.028 / 12 * 3);\n      case 6:\n        return money * (1 + 0.037 / 12 * 3);\n      case 12:\n        return money * (1 + 0.052 / 12 * 3);\n      default:\n        return money * (1 + 0.02 / 12 * 3);\n    }\n  }\n}\n</code></pre>\n<p>一般来讲，在策略模式中，我们还需要一个上下文对象，用于不同策略间的转换。</p>\n<pre><code class=\"java\">public class FinanceContext{\n\n  private IFinanceInterest mFinance;\n  public FinanceContext(IFinanceInterest interest){\n     mFinance = interest;\n  }\n\n  public void setFinanceInterest(IFinanceInterest interest){\n    mFinance = interest;\n  }\n\n  public double getMyInterest(int month, int money){\n    mFinance.getInterest(month, money);\n  }\n\n}\n</code></pre>\n<p>具体使用：</p>\n<pre><code class=\"java\">public static void main(String[] args) {\n      FinanceContext context = new FinanceContext(new AlipayFinance());    \n      context.getMyInterest(3, 12000);\n\n      context.setFinanceInterest(new ZhaoShangFinance())\n      context.getMyInterest(12, 12000);\n}\n</code></pre>\n<h4 id=\"模式优缺点\"><a href=\"#模式优缺点\" class=\"headerlink\" title=\"模式优缺点\"></a>模式优缺点</h4><ul>\n<li>优点<br>- </li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>上班坐公交还是坐地铁？这就是两种不同的策略。</p>","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>面向同一接口实现一系列算法，然后将他们分别封装起来，再经由同一入口进行调用；不同的策略之间可以相互替换。主要用来解决同一任务，多种条分支的情况下，过多 if-else 分支的情况。</p>\n<p>比如属性动画的差值器设置：</p>\n<pre><code class=\"java\">ObjectAnimator.ofFloat().setInterpolator(TimeInterpolator value);\n</code></pre>\n<p>我们看到，参数需要的是 TimeInterpolator 对象，我们点进去会发现：</p>\n<pre><code class=\"java\">public interface TimeInterpolator {\n    float getInterpolation(float input);\n}\n</code></pre>\n<p>而我们平时常用的几个差值器也就都实现了这个接口：</p>\n<ul>\n<li>AccelerateInterpolator</li>\n<li>DecelerateInterpolator</li>\n<li>AnticipateInterpolator</li>\n<li>CycleInterpolator</li>\n<li>LinearInterpolator</li>\n<li>… …</li>\n</ul>\n<p>不同的差值器只是 <code>getInterpolation()</code> 的实现不同，所以<strong>面向接口将不同的算法进行封装，再经由同一入口进行调用；不同的策略之间可以相互替换。</strong></p>\n<h4 id=\"具体实践案例\"><a href=\"#具体实践案例\" class=\"headerlink\" title=\"具体实践案例\"></a>具体实践案例</h4><p>下面我们以货币基金收益为例，简单的实践一下策略设计模式。</p>\n<p>我们的目标是对于给定的时间和本金，得到不同平台对应的利息。</p>\n<p>下面是通用接口：</p>\n<pre><code class=\"java\">public interface IFinanceInterest{\n  double getInterest(int month, int money);\n}\n</code></pre>\n<p>余额宝：</p>\n<pre><code class=\"java\">public class AlipayFinance implements IFinanceInterest{\n  @Overide\n  double getInterest(int month, int money){\n      switch(month){\n      case 3:\n        return money * (1 + 0.026 / 12 * 3);\n      case 6:\n        return money * (1 + 0.035 / 12 * 3);\n      case 12:\n        return money * (1 + 0.043 / 12 * 3);\n      default:\n        return money * (1 + 0.02 / 12 * 3);\n    }\n  }\n}\n</code></pre>\n<p>朝朝盈：</p>\n<pre><code class=\"java\">public class ZhaoShangFinance implements IFinanceInterest{\n  @Overide\n  double getInterest(int month, int money){\n      switch(month){\n      case 3:\n        return money * (1 + 0.028 / 12 * 3);\n      case 6:\n        return money * (1 + 0.037 / 12 * 3);\n      case 12:\n        return money * (1 + 0.052 / 12 * 3);\n      default:\n        return money * (1 + 0.02 / 12 * 3);\n    }\n  }\n}\n</code></pre>\n<p>一般来讲，在策略模式中，我们还需要一个上下文对象，用于不同策略间的转换。</p>\n<pre><code class=\"java\">public class FinanceContext{\n\n  private IFinanceInterest mFinance;\n  public FinanceContext(IFinanceInterest interest){\n     mFinance = interest;\n  }\n\n  public void setFinanceInterest(IFinanceInterest interest){\n    mFinance = interest;\n  }\n\n  public double getMyInterest(int month, int money){\n    mFinance.getInterest(month, money);\n  }\n\n}\n</code></pre>\n<p>具体使用：</p>\n<pre><code class=\"java\">public static void main(String[] args) {\n      FinanceContext context = new FinanceContext(new AlipayFinance());    \n      context.getMyInterest(3, 12000);\n\n      context.setFinanceInterest(new ZhaoShangFinance())\n      context.getMyInterest(12, 12000);\n}\n</code></pre>\n<h4 id=\"模式优缺点\"><a href=\"#模式优缺点\" class=\"headerlink\" title=\"模式优缺点\"></a>模式优缺点</h4><ul>\n<li>优点<br>- </li>\n</ul>"},{"title":"抽象类和接口的区别","date":"2018-03-08T16:00:00.000Z","_content":"\n\n\n先来一个问题，java中允许多继承吗？\n\n\n\n## 抽象类 - 单继承\n\n* 关键字为abstract, extends, 被类所继承\n* 不可以被final修饰\n* 抽象方法不可以被private修饰，但其他三个不受限制\n* 抽象方法一定存在于抽象类中，但是抽象类中不一定有抽象方法\n* 抽象类的子类必须全部重写抽象方法，如果只重写部分抽象方法，则该子类同样为抽象方法\n* 抽象类中不一定全部都是抽象方法，方法可以有方法体\n* 抽象类不可以实例化对象\n* 抽象类可以实现接口，因为接口的内容也都是抽象的\n\n## 接口 - 多实现\n* 关键字为interface, implements, 被类所实现\n* 同样不可以被final修饰\n* 接口只允许三种成员存在：\n    1. 公共的静态常量 public final static\n    2. 公共的抽象方法 public abstract\n    3. 静态内部类 static class\n* 由上可知，接口的作用域必须为public\n* 接口的抽象方法也必须全部被实现类所重写，否则实现类为抽象类\n* 不同的接口之间为继承关系，而且可以多继承\n* 接口不可以实例化对象\n* 接口不可以继承抽象类，因为抽象类中有可能存在非抽象方法，与接口的概念相悖\n\n## 二者区别\n* 每个类只能继承一个抽象类，但是可以实现多个接口\n* 抽象类可以有非抽象方法，接口全部为抽象方法\n* 从作用域角度看，抽象类中抽象方法不能为private，而接口强制为public abstract\n* 抽象类可以实现接口，但是接口不能继承抽象类\n* 不同的接口可以多继承，但是不同的抽象类只能单继承\n\n以上。","source":"_posts/differ-of-abstract-interface.md","raw":"---\ntitle: 抽象类和接口的区别\ntags: java基础\ndate: 2018-03-9\n---\n\n\n\n先来一个问题，java中允许多继承吗？\n\n\n\n## 抽象类 - 单继承\n\n* 关键字为abstract, extends, 被类所继承\n* 不可以被final修饰\n* 抽象方法不可以被private修饰，但其他三个不受限制\n* 抽象方法一定存在于抽象类中，但是抽象类中不一定有抽象方法\n* 抽象类的子类必须全部重写抽象方法，如果只重写部分抽象方法，则该子类同样为抽象方法\n* 抽象类中不一定全部都是抽象方法，方法可以有方法体\n* 抽象类不可以实例化对象\n* 抽象类可以实现接口，因为接口的内容也都是抽象的\n\n## 接口 - 多实现\n* 关键字为interface, implements, 被类所实现\n* 同样不可以被final修饰\n* 接口只允许三种成员存在：\n    1. 公共的静态常量 public final static\n    2. 公共的抽象方法 public abstract\n    3. 静态内部类 static class\n* 由上可知，接口的作用域必须为public\n* 接口的抽象方法也必须全部被实现类所重写，否则实现类为抽象类\n* 不同的接口之间为继承关系，而且可以多继承\n* 接口不可以实例化对象\n* 接口不可以继承抽象类，因为抽象类中有可能存在非抽象方法，与接口的概念相悖\n\n## 二者区别\n* 每个类只能继承一个抽象类，但是可以实现多个接口\n* 抽象类可以有非抽象方法，接口全部为抽象方法\n* 从作用域角度看，抽象类中抽象方法不能为private，而接口强制为public abstract\n* 抽象类可以实现接口，但是接口不能继承抽象类\n* 不同的接口可以多继承，但是不同的抽象类只能单继承\n\n以上。","slug":"differ-of-abstract-interface","published":1,"updated":"2018-08-14T10:11:51.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86ck000plh1pwfojm0kt","content":"<p>先来一个问题，java中允许多继承吗？</p>\n<h2 id=\"抽象类-单继承\"><a href=\"#抽象类-单继承\" class=\"headerlink\" title=\"抽象类 - 单继承\"></a>抽象类 - 单继承</h2><ul>\n<li>关键字为abstract, extends, 被类所继承</li>\n<li>不可以被final修饰</li>\n<li>抽象方法不可以被private修饰，但其他三个不受限制</li>\n<li>抽象方法一定存在于抽象类中，但是抽象类中不一定有抽象方法</li>\n<li>抽象类的子类必须全部重写抽象方法，如果只重写部分抽象方法，则该子类同样为抽象方法</li>\n<li>抽象类中不一定全部都是抽象方法，方法可以有方法体</li>\n<li>抽象类不可以实例化对象</li>\n<li>抽象类可以实现接口，因为接口的内容也都是抽象的</li>\n</ul>\n<h2 id=\"接口-多实现\"><a href=\"#接口-多实现\" class=\"headerlink\" title=\"接口 - 多实现\"></a>接口 - 多实现</h2><ul>\n<li>关键字为interface, implements, 被类所实现</li>\n<li>同样不可以被final修饰</li>\n<li>接口只允许三种成员存在：<ol>\n<li>公共的静态常量 public final static</li>\n<li>公共的抽象方法 public abstract</li>\n<li>静态内部类 static class</li>\n</ol>\n</li>\n<li>由上可知，接口的作用域必须为public</li>\n<li>接口的抽象方法也必须全部被实现类所重写，否则实现类为抽象类</li>\n<li>不同的接口之间为继承关系，而且可以多继承</li>\n<li>接口不可以实例化对象</li>\n<li>接口不可以继承抽象类，因为抽象类中有可能存在非抽象方法，与接口的概念相悖</li>\n</ul>\n<h2 id=\"二者区别\"><a href=\"#二者区别\" class=\"headerlink\" title=\"二者区别\"></a>二者区别</h2><ul>\n<li>每个类只能继承一个抽象类，但是可以实现多个接口</li>\n<li>抽象类可以有非抽象方法，接口全部为抽象方法</li>\n<li>从作用域角度看，抽象类中抽象方法不能为private，而接口强制为public abstract</li>\n<li>抽象类可以实现接口，但是接口不能继承抽象类</li>\n<li>不同的接口可以多继承，但是不同的抽象类只能单继承</li>\n</ul>\n<p>以上。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>先来一个问题，java中允许多继承吗？</p>\n<h2 id=\"抽象类-单继承\"><a href=\"#抽象类-单继承\" class=\"headerlink\" title=\"抽象类 - 单继承\"></a>抽象类 - 单继承</h2><ul>\n<li>关键字为abstract, extends, 被类所继承</li>\n<li>不可以被final修饰</li>\n<li>抽象方法不可以被private修饰，但其他三个不受限制</li>\n<li>抽象方法一定存在于抽象类中，但是抽象类中不一定有抽象方法</li>\n<li>抽象类的子类必须全部重写抽象方法，如果只重写部分抽象方法，则该子类同样为抽象方法</li>\n<li>抽象类中不一定全部都是抽象方法，方法可以有方法体</li>\n<li>抽象类不可以实例化对象</li>\n<li>抽象类可以实现接口，因为接口的内容也都是抽象的</li>\n</ul>\n<h2 id=\"接口-多实现\"><a href=\"#接口-多实现\" class=\"headerlink\" title=\"接口 - 多实现\"></a>接口 - 多实现</h2><ul>\n<li>关键字为interface, implements, 被类所实现</li>\n<li>同样不可以被final修饰</li>\n<li>接口只允许三种成员存在：<ol>\n<li>公共的静态常量 public final static</li>\n<li>公共的抽象方法 public abstract</li>\n<li>静态内部类 static class</li>\n</ol>\n</li>\n<li>由上可知，接口的作用域必须为public</li>\n<li>接口的抽象方法也必须全部被实现类所重写，否则实现类为抽象类</li>\n<li>不同的接口之间为继承关系，而且可以多继承</li>\n<li>接口不可以实例化对象</li>\n<li>接口不可以继承抽象类，因为抽象类中有可能存在非抽象方法，与接口的概念相悖</li>\n</ul>\n<h2 id=\"二者区别\"><a href=\"#二者区别\" class=\"headerlink\" title=\"二者区别\"></a>二者区别</h2><ul>\n<li>每个类只能继承一个抽象类，但是可以实现多个接口</li>\n<li>抽象类可以有非抽象方法，接口全部为抽象方法</li>\n<li>从作用域角度看，抽象类中抽象方法不能为private，而接口强制为public abstract</li>\n<li>抽象类可以实现接口，但是接口不能继承抽象类</li>\n<li>不同的接口可以多继承，但是不同的抽象类只能单继承</li>\n</ul>\n<p>以上。</p>\n"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg","title":"Message 入队过程分析","date":"2019-10-25T16:00:00.000Z","_content":"\n\n\n熟悉 Handler 的应该都知道 MessageQueue，也就是消息队列的存在。\n\n\n\n<!-- more -->\n\n\n\nHandler 通过 sendMessageAtTime 方法发送消息，实质上就是通过 MessageQueue 对消息进行了一个入队的操作。那我们也知道，消息队列只是名为队列，实际的数据结构是以 Message 的 when 属性排序的链表，但是大部分时候我们都是在网上一些博客文章中了解到的，并没有实际的梳理过源码。今天我们就来看一下 Message 的实际入队流程，以及为什么消息队列要采用链表的方式实现。\n\n\n\n### 源码 show time\n\n前面也说了，入队操作是通过 MessageQueue#enqueueMessage 方法实现的，所以我们今天的重点就是来捋一下这个方法\n\n```java\nMessage mMessages;\nboolean enqueueMessage(Message msg, long when) {\n    msg.when = when; \n    Message p = mMessages;\n    if (p == null || when == 0 || when < p.when) {\n        msg.next = p;\n        mMessages = msg;\n    } else {\n        Message prev;\n        for (; ;) {\n            prev = p;\n            p = p.next;\n            if (p == null || when < p.when) {\n                break;\n            }\n        }\n        msg.next = p;\n        prev.next = msg;\n    }\n    return true;\n}\n```\n\n没错，这个方法只有这么几行代码，我们来看一下。\n\n1. 入参时候的 when 参数，就是我们平时调用 sendMessageDelayed 方法时传入的延时 + 当前系统时间，**为了方便起见，我们在后边的分析中只取延时，忽略系统时间**\n2. 入队之前，先将当前消息的发送时间赋值给当前消息的 when 属性，即 msg.when = when\n3. 使用局部变量 p 来记录当前的消息，默认值为 null，然后开始逻辑判断\n\n\n\n### 消息入队逻辑推演\n\n我们在主线程发送几个消息如下：\n\n```java\nmHandler.sendEmptyMessage(100)；\nmHandler.sendEmptyMessageDelayed(200, 1000)；\nmHandler.sendEmptyMessageDelayed(300, 500)；\n```\n\n现在我们梳理一下这三条消息入队的顺序。\n\n1. 第一条消息进入 enqueueMessage 方法，when = 0\n\n   ```java\n   if (p == null || when == 0 || when < p.when){}\n   ```\n\n   p == null 判断成立，因为 mMessages 默认值为 null；然后将 p 赋值给第一条消息的 next 属性（标准的单链表结构，利用 next 属性相连），然后将第一条消息赋值给全局的 mMessages 对象\n\n2. 第二条消息进入 enqueueMessage 方法，when = 1000\n\n   ```java\n   Message p = mMessages;\n   ```\n\n   现在 mMessages 对象是有值的，是第一条消息对象，mMessages.next = null，mMessages.when = 0。\n\n   那么我们来看 if 判断条件：\n\n   - p == null，不成立，当前 p 是 mMessages 对象，即第一条消息对象\n   - when == 0，不成立，第二条消息的 when 应该是 1000\n   - when < p.when，即 1000 < 0，不成立\n\n   三个条件都不能满足，那就来到 else 分支，我们继续一点点梳理：\n\n   ```java\n   Message prev;\n   for (; ;) {\n       prev = p;\n       p = p.next;\n       if (p == null || when < p.when) {\n         break;\n       }\n   }\n   msg.next = p;\n   prev.next = msg;\n   ```\n\n   - 先声明一个 Message 对象 prev，用来标记前一条消息，即 previous message，然后开启一个死循环\n   - 在循环中，将当前的消息对象 p 赋值给 prev 变量，然后取 p 的下一个节点，赋值给 p，此时判断 p == null 是成立的，因为之前 p.next = null，现在 p = p.next，所以 p == null 也是成立的，跳出循环\n   - 跳出循环时，prev 是 mMessages 对象，即第一条插入的数据，p 是 mMessages.next，是 null\n   - 然后将待插入消息的 next 属性设为 p，即 null，然后将待插入消息赋值给 prev.next，即 mMessages.next，就将先后两条消息连接起来了\n\n   到现在为止，MessageQueue 的样子应该是：\n\n   ```java\n   mMessages = {Message(when = 0, next = {Message(when = 1000, next = null)})}\n   ```\n   \n3. 第三条消息进入 enqueueMessage 方法，when = 500\n  \n  ```java\n  Message p = mMessages;\n  ```\n  \n  同样的，mMessages 不为空，指向首条插入的 Message 对象，when = 0，next 不为空，而传入的 when = 500，很明显 if 条件不能被满足：\n  \n  ```java\n  if (p == null || when == 0 || when < p.when){}\n  \n  // p 不为空，传入的 when = 500，而 p.when = 0，所以 if 条件不能成立\n  ```\n  \n  然后进入 else  分支：\n  \n  ```java\n  Message prev;\n  for (; ;) {\n      prev = p;\n      p = p.next;\n      if (p == null || when < p.when) {\n        break;\n      }\n  }\n  msg.next = p;\n  prev.next = msg;\n  ```\n  \n  依然是开启死循环，从 mMessages 开始依次向后遍历，但是与第二次插入不同的是，当遍历到第二条消息对象时，即 prev = 首条消息，p = p.next(第二条消息) 时：\n  \n  - p == null 不成立\n  - when (500) < p.when (1000) 成立，跳出循环\n  - 跳出循环时，prev = 首条消息，p = 第二条消息\n  \n  然后将待插入消息的 next 指向 p，即原本的第二条消息，将 prev 的 next 指向待插入消息，即将第三条消息插到了原本的第一条和第二条消息中间，到此为止也就完成了消息的插入。\n\n\n\n### 总结\n\n当我们顺着代码逻辑，完整地走过这几次消息入队后，也就很清楚的看到 MessageQueue 的链表本质了。\n\n概括地来说，MessageQueue 只持有一个 mMessages 的消息对象，然后利用 Message 的 next 属性进行多个消息之间的链接，同时使用 when 属性对消息进行排序，when 的值越小，在链表中的排序越靠前。\n\n以我们上边的推演为例，MessageQueue 最后的形式应该是：\n\n```java\nmMessages = {\n  Message(when = 0, next = {\n    Message(when = 500, next = {\n      Message(when = 1000, next = null)\n    })\n  })\n}\n```\n\n\n\n#### 那么为什么 MessageQueue 要使用链表的形式来存储呢？\n\n其实我们出去面试经常会被问到类似的问题，本质山这个问题就是：数组和链表的区别在哪里？\n\n数组的优势在于使用角标查找方便，时间复杂度为 O(1)，但是插入的时候就会很费劲，要把整个数组依次向前向后移动来为新插入的数据腾出空间，时间复杂度可能为 O(n)；相反的，链表的优势却恰恰在于插入。\n\n如果你看完了上面的文章，你会发现我们使用链表插入数据的时候，只需要将原本的 next 指针换一个指向，再将新数据的 next 指向原数据的 指向就可以完成插入，整个时间复杂度也是 O(1) 级别的；但是我们在找目标位置的时候就太痛苦了，需要一个死循环来从头开始遍历 Message 的 next 对象，知道找到目标对象才能完成插入，如果就是要插入到最后一个位置，那整个时间复杂度也是 O(n) 级别的。\n\n而 Handler 的使用场景正是频繁插入，但是每次都只取最前面的消息处理，所以对于这种情况，天然的应该使用链表来进行存储而不是数组。\n\n","source":"_posts/message-enqueue-process.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg\ntitle: Message 入队过程分析\ntags: [Android]\ndate: 2019-10-26\n---\n\n\n\n熟悉 Handler 的应该都知道 MessageQueue，也就是消息队列的存在。\n\n\n\n<!-- more -->\n\n\n\nHandler 通过 sendMessageAtTime 方法发送消息，实质上就是通过 MessageQueue 对消息进行了一个入队的操作。那我们也知道，消息队列只是名为队列，实际的数据结构是以 Message 的 when 属性排序的链表，但是大部分时候我们都是在网上一些博客文章中了解到的，并没有实际的梳理过源码。今天我们就来看一下 Message 的实际入队流程，以及为什么消息队列要采用链表的方式实现。\n\n\n\n### 源码 show time\n\n前面也说了，入队操作是通过 MessageQueue#enqueueMessage 方法实现的，所以我们今天的重点就是来捋一下这个方法\n\n```java\nMessage mMessages;\nboolean enqueueMessage(Message msg, long when) {\n    msg.when = when; \n    Message p = mMessages;\n    if (p == null || when == 0 || when < p.when) {\n        msg.next = p;\n        mMessages = msg;\n    } else {\n        Message prev;\n        for (; ;) {\n            prev = p;\n            p = p.next;\n            if (p == null || when < p.when) {\n                break;\n            }\n        }\n        msg.next = p;\n        prev.next = msg;\n    }\n    return true;\n}\n```\n\n没错，这个方法只有这么几行代码，我们来看一下。\n\n1. 入参时候的 when 参数，就是我们平时调用 sendMessageDelayed 方法时传入的延时 + 当前系统时间，**为了方便起见，我们在后边的分析中只取延时，忽略系统时间**\n2. 入队之前，先将当前消息的发送时间赋值给当前消息的 when 属性，即 msg.when = when\n3. 使用局部变量 p 来记录当前的消息，默认值为 null，然后开始逻辑判断\n\n\n\n### 消息入队逻辑推演\n\n我们在主线程发送几个消息如下：\n\n```java\nmHandler.sendEmptyMessage(100)；\nmHandler.sendEmptyMessageDelayed(200, 1000)；\nmHandler.sendEmptyMessageDelayed(300, 500)；\n```\n\n现在我们梳理一下这三条消息入队的顺序。\n\n1. 第一条消息进入 enqueueMessage 方法，when = 0\n\n   ```java\n   if (p == null || when == 0 || when < p.when){}\n   ```\n\n   p == null 判断成立，因为 mMessages 默认值为 null；然后将 p 赋值给第一条消息的 next 属性（标准的单链表结构，利用 next 属性相连），然后将第一条消息赋值给全局的 mMessages 对象\n\n2. 第二条消息进入 enqueueMessage 方法，when = 1000\n\n   ```java\n   Message p = mMessages;\n   ```\n\n   现在 mMessages 对象是有值的，是第一条消息对象，mMessages.next = null，mMessages.when = 0。\n\n   那么我们来看 if 判断条件：\n\n   - p == null，不成立，当前 p 是 mMessages 对象，即第一条消息对象\n   - when == 0，不成立，第二条消息的 when 应该是 1000\n   - when < p.when，即 1000 < 0，不成立\n\n   三个条件都不能满足，那就来到 else 分支，我们继续一点点梳理：\n\n   ```java\n   Message prev;\n   for (; ;) {\n       prev = p;\n       p = p.next;\n       if (p == null || when < p.when) {\n         break;\n       }\n   }\n   msg.next = p;\n   prev.next = msg;\n   ```\n\n   - 先声明一个 Message 对象 prev，用来标记前一条消息，即 previous message，然后开启一个死循环\n   - 在循环中，将当前的消息对象 p 赋值给 prev 变量，然后取 p 的下一个节点，赋值给 p，此时判断 p == null 是成立的，因为之前 p.next = null，现在 p = p.next，所以 p == null 也是成立的，跳出循环\n   - 跳出循环时，prev 是 mMessages 对象，即第一条插入的数据，p 是 mMessages.next，是 null\n   - 然后将待插入消息的 next 属性设为 p，即 null，然后将待插入消息赋值给 prev.next，即 mMessages.next，就将先后两条消息连接起来了\n\n   到现在为止，MessageQueue 的样子应该是：\n\n   ```java\n   mMessages = {Message(when = 0, next = {Message(when = 1000, next = null)})}\n   ```\n   \n3. 第三条消息进入 enqueueMessage 方法，when = 500\n  \n  ```java\n  Message p = mMessages;\n  ```\n  \n  同样的，mMessages 不为空，指向首条插入的 Message 对象，when = 0，next 不为空，而传入的 when = 500，很明显 if 条件不能被满足：\n  \n  ```java\n  if (p == null || when == 0 || when < p.when){}\n  \n  // p 不为空，传入的 when = 500，而 p.when = 0，所以 if 条件不能成立\n  ```\n  \n  然后进入 else  分支：\n  \n  ```java\n  Message prev;\n  for (; ;) {\n      prev = p;\n      p = p.next;\n      if (p == null || when < p.when) {\n        break;\n      }\n  }\n  msg.next = p;\n  prev.next = msg;\n  ```\n  \n  依然是开启死循环，从 mMessages 开始依次向后遍历，但是与第二次插入不同的是，当遍历到第二条消息对象时，即 prev = 首条消息，p = p.next(第二条消息) 时：\n  \n  - p == null 不成立\n  - when (500) < p.when (1000) 成立，跳出循环\n  - 跳出循环时，prev = 首条消息，p = 第二条消息\n  \n  然后将待插入消息的 next 指向 p，即原本的第二条消息，将 prev 的 next 指向待插入消息，即将第三条消息插到了原本的第一条和第二条消息中间，到此为止也就完成了消息的插入。\n\n\n\n### 总结\n\n当我们顺着代码逻辑，完整地走过这几次消息入队后，也就很清楚的看到 MessageQueue 的链表本质了。\n\n概括地来说，MessageQueue 只持有一个 mMessages 的消息对象，然后利用 Message 的 next 属性进行多个消息之间的链接，同时使用 when 属性对消息进行排序，when 的值越小，在链表中的排序越靠前。\n\n以我们上边的推演为例，MessageQueue 最后的形式应该是：\n\n```java\nmMessages = {\n  Message(when = 0, next = {\n    Message(when = 500, next = {\n      Message(when = 1000, next = null)\n    })\n  })\n}\n```\n\n\n\n#### 那么为什么 MessageQueue 要使用链表的形式来存储呢？\n\n其实我们出去面试经常会被问到类似的问题，本质山这个问题就是：数组和链表的区别在哪里？\n\n数组的优势在于使用角标查找方便，时间复杂度为 O(1)，但是插入的时候就会很费劲，要把整个数组依次向前向后移动来为新插入的数据腾出空间，时间复杂度可能为 O(n)；相反的，链表的优势却恰恰在于插入。\n\n如果你看完了上面的文章，你会发现我们使用链表插入数据的时候，只需要将原本的 next 指针换一个指向，再将新数据的 next 指向原数据的 指向就可以完成插入，整个时间复杂度也是 O(1) 级别的；但是我们在找目标位置的时候就太痛苦了，需要一个死循环来从头开始遍历 Message 的 next 对象，知道找到目标对象才能完成插入，如果就是要插入到最后一个位置，那整个时间复杂度也是 O(n) 级别的。\n\n而 Handler 的使用场景正是频繁插入，但是每次都只取最前面的消息处理，所以对于这种情况，天然的应该使用链表来进行存储而不是数组。\n\n","slug":"message-enqueue-process","published":1,"updated":"2019-10-26T07:42:15.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86cm000slh1poacbevkx","content":"<p>熟悉 Handler 的应该都知道 MessageQueue，也就是消息队列的存在。</p>\n<a id=\"more\"></a>\n<p>Handler 通过 sendMessageAtTime 方法发送消息，实质上就是通过 MessageQueue 对消息进行了一个入队的操作。那我们也知道，消息队列只是名为队列，实际的数据结构是以 Message 的 when 属性排序的链表，但是大部分时候我们都是在网上一些博客文章中了解到的，并没有实际的梳理过源码。今天我们就来看一下 Message 的实际入队流程，以及为什么消息队列要采用链表的方式实现。</p>\n<h3 id=\"源码-show-time\"><a href=\"#源码-show-time\" class=\"headerlink\" title=\"源码 show time\"></a>源码 show time</h3><p>前面也说了，入队操作是通过 MessageQueue#enqueueMessage 方法实现的，所以我们今天的重点就是来捋一下这个方法</p>\n<pre><code class=\"java\">Message mMessages;\nboolean enqueueMessage(Message msg, long when) {\n    msg.when = when; \n    Message p = mMessages;\n    if (p == null || when == 0 || when &lt; p.when) {\n        msg.next = p;\n        mMessages = msg;\n    } else {\n        Message prev;\n        for (; ;) {\n            prev = p;\n            p = p.next;\n            if (p == null || when &lt; p.when) {\n                break;\n            }\n        }\n        msg.next = p;\n        prev.next = msg;\n    }\n    return true;\n}\n</code></pre>\n<p>没错，这个方法只有这么几行代码，我们来看一下。</p>\n<ol>\n<li>入参时候的 when 参数，就是我们平时调用 sendMessageDelayed 方法时传入的延时 + 当前系统时间，<strong>为了方便起见，我们在后边的分析中只取延时，忽略系统时间</strong></li>\n<li>入队之前，先将当前消息的发送时间赋值给当前消息的 when 属性，即 msg.when = when</li>\n<li>使用局部变量 p 来记录当前的消息，默认值为 null，然后开始逻辑判断</li>\n</ol>\n<h3 id=\"消息入队逻辑推演\"><a href=\"#消息入队逻辑推演\" class=\"headerlink\" title=\"消息入队逻辑推演\"></a>消息入队逻辑推演</h3><p>我们在主线程发送几个消息如下：</p>\n<pre><code class=\"java\">mHandler.sendEmptyMessage(100)；\nmHandler.sendEmptyMessageDelayed(200, 1000)；\nmHandler.sendEmptyMessageDelayed(300, 500)；\n</code></pre>\n<p>现在我们梳理一下这三条消息入队的顺序。</p>\n<ol>\n<li><p>第一条消息进入 enqueueMessage 方法，when = 0</p>\n<pre><code class=\"java\">if (p == null || when == 0 || when &lt; p.when){}\n</code></pre>\n<p>p == null 判断成立，因为 mMessages 默认值为 null；然后将 p 赋值给第一条消息的 next 属性（标准的单链表结构，利用 next 属性相连），然后将第一条消息赋值给全局的 mMessages 对象</p>\n</li>\n<li><p>第二条消息进入 enqueueMessage 方法，when = 1000</p>\n<pre><code class=\"java\">Message p = mMessages;\n</code></pre>\n<p>现在 mMessages 对象是有值的，是第一条消息对象，mMessages.next = null，mMessages.when = 0。</p>\n<p>那么我们来看 if 判断条件：</p>\n<ul>\n<li>p == null，不成立，当前 p 是 mMessages 对象，即第一条消息对象</li>\n<li>when == 0，不成立，第二条消息的 when 应该是 1000</li>\n<li>when &lt; p.when，即 1000 &lt; 0，不成立</li>\n</ul>\n<p>三个条件都不能满足，那就来到 else 分支，我们继续一点点梳理：</p>\n<pre><code class=\"java\">Message prev;\nfor (; ;) {\n    prev = p;\n    p = p.next;\n    if (p == null || when &lt; p.when) {\n      break;\n    }\n}\nmsg.next = p;\nprev.next = msg;\n</code></pre>\n<ul>\n<li>先声明一个 Message 对象 prev，用来标记前一条消息，即 previous message，然后开启一个死循环</li>\n<li>在循环中，将当前的消息对象 p 赋值给 prev 变量，然后取 p 的下一个节点，赋值给 p，此时判断 p == null 是成立的，因为之前 p.next = null，现在 p = p.next，所以 p == null 也是成立的，跳出循环</li>\n<li>跳出循环时，prev 是 mMessages 对象，即第一条插入的数据，p 是 mMessages.next，是 null</li>\n<li>然后将待插入消息的 next 属性设为 p，即 null，然后将待插入消息赋值给 prev.next，即 mMessages.next，就将先后两条消息连接起来了</li>\n</ul>\n<p>到现在为止，MessageQueue 的样子应该是：</p>\n<pre><code class=\"java\">mMessages = {Message(when = 0, next = {Message(when = 1000, next = null)})}\n</code></pre>\n</li>\n<li><p>第三条消息进入 enqueueMessage 方法，when = 500</p>\n<pre><code class=\"java\">Message p = mMessages;\n</code></pre>\n<p>同样的，mMessages 不为空，指向首条插入的 Message 对象，when = 0，next 不为空，而传入的 when = 500，很明显 if 条件不能被满足：</p>\n<pre><code class=\"java\">if (p == null || when == 0 || when &lt; p.when){}\n\n// p 不为空，传入的 when = 500，而 p.when = 0，所以 if 条件不能成立\n</code></pre>\n<p>然后进入 else  分支：</p>\n<pre><code class=\"java\">Message prev;\nfor (; ;) {\n   prev = p;\n   p = p.next;\n   if (p == null || when &lt; p.when) {\n     break;\n   }\n}\nmsg.next = p;\nprev.next = msg;\n</code></pre>\n<p>依然是开启死循环，从 mMessages 开始依次向后遍历，但是与第二次插入不同的是，当遍历到第二条消息对象时，即 prev = 首条消息，p = p.next(第二条消息) 时：</p>\n<ul>\n<li>p == null 不成立</li>\n<li>when (500) &lt; p.when (1000) 成立，跳出循环</li>\n<li>跳出循环时，prev = 首条消息，p = 第二条消息</li>\n</ul>\n<p>然后将待插入消息的 next 指向 p，即原本的第二条消息，将 prev 的 next 指向待插入消息，即将第三条消息插到了原本的第一条和第二条消息中间，到此为止也就完成了消息的插入。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当我们顺着代码逻辑，完整地走过这几次消息入队后，也就很清楚的看到 MessageQueue 的链表本质了。</p>\n<p>概括地来说，MessageQueue 只持有一个 mMessages 的消息对象，然后利用 Message 的 next 属性进行多个消息之间的链接，同时使用 when 属性对消息进行排序，when 的值越小，在链表中的排序越靠前。</p>\n<p>以我们上边的推演为例，MessageQueue 最后的形式应该是：</p>\n<pre><code class=\"java\">mMessages = {\n  Message(when = 0, next = {\n    Message(when = 500, next = {\n      Message(when = 1000, next = null)\n    })\n  })\n}\n</code></pre>\n<h4 id=\"那么为什么-MessageQueue-要使用链表的形式来存储呢？\"><a href=\"#那么为什么-MessageQueue-要使用链表的形式来存储呢？\" class=\"headerlink\" title=\"那么为什么 MessageQueue 要使用链表的形式来存储呢？\"></a>那么为什么 MessageQueue 要使用链表的形式来存储呢？</h4><p>其实我们出去面试经常会被问到类似的问题，本质山这个问题就是：数组和链表的区别在哪里？</p>\n<p>数组的优势在于使用角标查找方便，时间复杂度为 O(1)，但是插入的时候就会很费劲，要把整个数组依次向前向后移动来为新插入的数据腾出空间，时间复杂度可能为 O(n)；相反的，链表的优势却恰恰在于插入。</p>\n<p>如果你看完了上面的文章，你会发现我们使用链表插入数据的时候，只需要将原本的 next 指针换一个指向，再将新数据的 next 指向原数据的 指向就可以完成插入，整个时间复杂度也是 O(1) 级别的；但是我们在找目标位置的时候就太痛苦了，需要一个死循环来从头开始遍历 Message 的 next 对象，知道找到目标对象才能完成插入，如果就是要插入到最后一个位置，那整个时间复杂度也是 O(n) 级别的。</p>\n<p>而 Handler 的使用场景正是频繁插入，但是每次都只取最前面的消息处理，所以对于这种情况，天然的应该使用链表来进行存储而不是数组。</p>\n","site":{"data":{}},"excerpt":"<p>熟悉 Handler 的应该都知道 MessageQueue，也就是消息队列的存在。</p>","more":"<p>Handler 通过 sendMessageAtTime 方法发送消息，实质上就是通过 MessageQueue 对消息进行了一个入队的操作。那我们也知道，消息队列只是名为队列，实际的数据结构是以 Message 的 when 属性排序的链表，但是大部分时候我们都是在网上一些博客文章中了解到的，并没有实际的梳理过源码。今天我们就来看一下 Message 的实际入队流程，以及为什么消息队列要采用链表的方式实现。</p>\n<h3 id=\"源码-show-time\"><a href=\"#源码-show-time\" class=\"headerlink\" title=\"源码 show time\"></a>源码 show time</h3><p>前面也说了，入队操作是通过 MessageQueue#enqueueMessage 方法实现的，所以我们今天的重点就是来捋一下这个方法</p>\n<pre><code class=\"java\">Message mMessages;\nboolean enqueueMessage(Message msg, long when) {\n    msg.when = when; \n    Message p = mMessages;\n    if (p == null || when == 0 || when &lt; p.when) {\n        msg.next = p;\n        mMessages = msg;\n    } else {\n        Message prev;\n        for (; ;) {\n            prev = p;\n            p = p.next;\n            if (p == null || when &lt; p.when) {\n                break;\n            }\n        }\n        msg.next = p;\n        prev.next = msg;\n    }\n    return true;\n}\n</code></pre>\n<p>没错，这个方法只有这么几行代码，我们来看一下。</p>\n<ol>\n<li>入参时候的 when 参数，就是我们平时调用 sendMessageDelayed 方法时传入的延时 + 当前系统时间，<strong>为了方便起见，我们在后边的分析中只取延时，忽略系统时间</strong></li>\n<li>入队之前，先将当前消息的发送时间赋值给当前消息的 when 属性，即 msg.when = when</li>\n<li>使用局部变量 p 来记录当前的消息，默认值为 null，然后开始逻辑判断</li>\n</ol>\n<h3 id=\"消息入队逻辑推演\"><a href=\"#消息入队逻辑推演\" class=\"headerlink\" title=\"消息入队逻辑推演\"></a>消息入队逻辑推演</h3><p>我们在主线程发送几个消息如下：</p>\n<pre><code class=\"java\">mHandler.sendEmptyMessage(100)；\nmHandler.sendEmptyMessageDelayed(200, 1000)；\nmHandler.sendEmptyMessageDelayed(300, 500)；\n</code></pre>\n<p>现在我们梳理一下这三条消息入队的顺序。</p>\n<ol>\n<li><p>第一条消息进入 enqueueMessage 方法，when = 0</p>\n<pre><code class=\"java\">if (p == null || when == 0 || when &lt; p.when){}\n</code></pre>\n<p>p == null 判断成立，因为 mMessages 默认值为 null；然后将 p 赋值给第一条消息的 next 属性（标准的单链表结构，利用 next 属性相连），然后将第一条消息赋值给全局的 mMessages 对象</p>\n</li>\n<li><p>第二条消息进入 enqueueMessage 方法，when = 1000</p>\n<pre><code class=\"java\">Message p = mMessages;\n</code></pre>\n<p>现在 mMessages 对象是有值的，是第一条消息对象，mMessages.next = null，mMessages.when = 0。</p>\n<p>那么我们来看 if 判断条件：</p>\n<ul>\n<li>p == null，不成立，当前 p 是 mMessages 对象，即第一条消息对象</li>\n<li>when == 0，不成立，第二条消息的 when 应该是 1000</li>\n<li>when &lt; p.when，即 1000 &lt; 0，不成立</li>\n</ul>\n<p>三个条件都不能满足，那就来到 else 分支，我们继续一点点梳理：</p>\n<pre><code class=\"java\">Message prev;\nfor (; ;) {\n    prev = p;\n    p = p.next;\n    if (p == null || when &lt; p.when) {\n      break;\n    }\n}\nmsg.next = p;\nprev.next = msg;\n</code></pre>\n<ul>\n<li>先声明一个 Message 对象 prev，用来标记前一条消息，即 previous message，然后开启一个死循环</li>\n<li>在循环中，将当前的消息对象 p 赋值给 prev 变量，然后取 p 的下一个节点，赋值给 p，此时判断 p == null 是成立的，因为之前 p.next = null，现在 p = p.next，所以 p == null 也是成立的，跳出循环</li>\n<li>跳出循环时，prev 是 mMessages 对象，即第一条插入的数据，p 是 mMessages.next，是 null</li>\n<li>然后将待插入消息的 next 属性设为 p，即 null，然后将待插入消息赋值给 prev.next，即 mMessages.next，就将先后两条消息连接起来了</li>\n</ul>\n<p>到现在为止，MessageQueue 的样子应该是：</p>\n<pre><code class=\"java\">mMessages = {Message(when = 0, next = {Message(when = 1000, next = null)})}\n</code></pre>\n</li>\n<li><p>第三条消息进入 enqueueMessage 方法，when = 500</p>\n<pre><code class=\"java\">Message p = mMessages;\n</code></pre>\n<p>同样的，mMessages 不为空，指向首条插入的 Message 对象，when = 0，next 不为空，而传入的 when = 500，很明显 if 条件不能被满足：</p>\n<pre><code class=\"java\">if (p == null || when == 0 || when &lt; p.when){}\n\n// p 不为空，传入的 when = 500，而 p.when = 0，所以 if 条件不能成立\n</code></pre>\n<p>然后进入 else  分支：</p>\n<pre><code class=\"java\">Message prev;\nfor (; ;) {\n   prev = p;\n   p = p.next;\n   if (p == null || when &lt; p.when) {\n     break;\n   }\n}\nmsg.next = p;\nprev.next = msg;\n</code></pre>\n<p>依然是开启死循环，从 mMessages 开始依次向后遍历，但是与第二次插入不同的是，当遍历到第二条消息对象时，即 prev = 首条消息，p = p.next(第二条消息) 时：</p>\n<ul>\n<li>p == null 不成立</li>\n<li>when (500) &lt; p.when (1000) 成立，跳出循环</li>\n<li>跳出循环时，prev = 首条消息，p = 第二条消息</li>\n</ul>\n<p>然后将待插入消息的 next 指向 p，即原本的第二条消息，将 prev 的 next 指向待插入消息，即将第三条消息插到了原本的第一条和第二条消息中间，到此为止也就完成了消息的插入。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当我们顺着代码逻辑，完整地走过这几次消息入队后，也就很清楚的看到 MessageQueue 的链表本质了。</p>\n<p>概括地来说，MessageQueue 只持有一个 mMessages 的消息对象，然后利用 Message 的 next 属性进行多个消息之间的链接，同时使用 when 属性对消息进行排序，when 的值越小，在链表中的排序越靠前。</p>\n<p>以我们上边的推演为例，MessageQueue 最后的形式应该是：</p>\n<pre><code class=\"java\">mMessages = {\n  Message(when = 0, next = {\n    Message(when = 500, next = {\n      Message(when = 1000, next = null)\n    })\n  })\n}\n</code></pre>\n<h4 id=\"那么为什么-MessageQueue-要使用链表的形式来存储呢？\"><a href=\"#那么为什么-MessageQueue-要使用链表的形式来存储呢？\" class=\"headerlink\" title=\"那么为什么 MessageQueue 要使用链表的形式来存储呢？\"></a>那么为什么 MessageQueue 要使用链表的形式来存储呢？</h4><p>其实我们出去面试经常会被问到类似的问题，本质山这个问题就是：数组和链表的区别在哪里？</p>\n<p>数组的优势在于使用角标查找方便，时间复杂度为 O(1)，但是插入的时候就会很费劲，要把整个数组依次向前向后移动来为新插入的数据腾出空间，时间复杂度可能为 O(n)；相反的，链表的优势却恰恰在于插入。</p>\n<p>如果你看完了上面的文章，你会发现我们使用链表插入数据的时候，只需要将原本的 next 指针换一个指向，再将新数据的 next 指向原数据的 指向就可以完成插入，整个时间复杂度也是 O(1) 级别的；但是我们在找目标位置的时候就太痛苦了，需要一个死循环来从头开始遍历 Message 的 next 对象，知道找到目标对象才能完成插入，如果就是要插入到最后一个位置，那整个时间复杂度也是 O(n) 级别的。</p>\n<p>而 Handler 的使用场景正是频繁插入，但是每次都只取最前面的消息处理，所以对于这种情况，天然的应该使用链表来进行存储而不是数组。</p>"},{"title":"java中多态的具体应用","date":"2018-03-08T16:00:00.000Z","_content":"\n\n\n实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例\n\n```\n// 父类\npublic class Parent {\n    public int aInt = -1;\n    public void func1() {\n        System.err.print(\" Parent func1 \");\n    }\n    public void func2() {\n        System.err.print(\" Parent func2 \");\n    }\n}\n```\n\n```\n// 子类\npublic class Child extends Parent {\n    public int aInt = 1;\n    public void func1() {\n        System.err.print(\" Child func1 \");\n    }\n    public void func3() {\n        System.err.print(\" Child func3 \");\n    }\n}\n```\n\n#### 成员函数\n```\n// test main()\npublic static void main(String[] args) {\n    Child child = new Child();\n    child.func1();\n    child.func2();\n    child.func3();\n\n    Parent parent = new Child();\n    parent.func1();\n    parent.func2();\n    parent.func3();\n}\n```\n如上所示，将对象声明为Child对象时，三个方法都编译通过，且输入结果如下：\n```\nChild func1\nParent func2\nChild func3\n```\nChild类重写了父类的func1()方法，则在运行时匹配了子类自身的重写方法，即，「运行时遵循右侧声明」。\n但是，如果将对象声明为Parent对象时，parent.fun3()则会报错，因为「编译期遵循左侧实例」，当前对象被声明为Parent实例，而Parent中没有func3()方法，所以编译不通过。同时也正因为「运行时遵循右侧声明」，所以其运行结果如下：\n```\nChild func1 // 尽管声明为Parent实例，但实际调用Child的方法\nParent func2\n```\n综上所述，在多态使用时，成员函数遵循两个原则，即「编译期遵循左侧实例，运行时遵循右侧声明」\n\n#### 成员变量\n```\n// test main()\npublic static void main(String[] args) {\n    Parent parent = new Child();\n    Child child = new Child();\n    System.err.println(parent.aInt);\n    System.err.println(child.aInt);\n}\n```\n运行结果如下：\n```\n-1\n1\n```\n可以发现，打印结果与成员函数有所不同。因为如果是成员函数，运行时遵循右侧声明的话，打印结果应该相等，同为1才对。因此，成员变量在多态情境下的使用，无论编译还是运行，通通遵循左侧实例。\n\n#### 总结\n* 成员函数\n  编译时遵循左侧实例，运行时遵循右侧声明\n* 成员变量\n  编译或者运行一律遵循左侧实例\n\n其实也比较好理解，编译期间，当前类下不存在的成员函数或成员变量，肯定是无法被实例对象获取到的；\n而在运行时，java中子类可以重写父类的方法，因此成员函数运行时会正确指向子类的方法，但是，子类并不可以重写父类的变量，当子类与父类有同名变量时，需要使用this和super关键字进行区分。在这种情况下，成员变量的访问则不可能像方法一样使用多态访问，因此只能是遵循左侧的实例了。","source":"_posts/polymorphism-of-java.md","raw":"---\ntitle: java中多态的具体应用\n\ntags: java基础\n\ndate: 2018-03-9\n---\n\n\n\n实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例\n\n```\n// 父类\npublic class Parent {\n    public int aInt = -1;\n    public void func1() {\n        System.err.print(\" Parent func1 \");\n    }\n    public void func2() {\n        System.err.print(\" Parent func2 \");\n    }\n}\n```\n\n```\n// 子类\npublic class Child extends Parent {\n    public int aInt = 1;\n    public void func1() {\n        System.err.print(\" Child func1 \");\n    }\n    public void func3() {\n        System.err.print(\" Child func3 \");\n    }\n}\n```\n\n#### 成员函数\n```\n// test main()\npublic static void main(String[] args) {\n    Child child = new Child();\n    child.func1();\n    child.func2();\n    child.func3();\n\n    Parent parent = new Child();\n    parent.func1();\n    parent.func2();\n    parent.func3();\n}\n```\n如上所示，将对象声明为Child对象时，三个方法都编译通过，且输入结果如下：\n```\nChild func1\nParent func2\nChild func3\n```\nChild类重写了父类的func1()方法，则在运行时匹配了子类自身的重写方法，即，「运行时遵循右侧声明」。\n但是，如果将对象声明为Parent对象时，parent.fun3()则会报错，因为「编译期遵循左侧实例」，当前对象被声明为Parent实例，而Parent中没有func3()方法，所以编译不通过。同时也正因为「运行时遵循右侧声明」，所以其运行结果如下：\n```\nChild func1 // 尽管声明为Parent实例，但实际调用Child的方法\nParent func2\n```\n综上所述，在多态使用时，成员函数遵循两个原则，即「编译期遵循左侧实例，运行时遵循右侧声明」\n\n#### 成员变量\n```\n// test main()\npublic static void main(String[] args) {\n    Parent parent = new Child();\n    Child child = new Child();\n    System.err.println(parent.aInt);\n    System.err.println(child.aInt);\n}\n```\n运行结果如下：\n```\n-1\n1\n```\n可以发现，打印结果与成员函数有所不同。因为如果是成员函数，运行时遵循右侧声明的话，打印结果应该相等，同为1才对。因此，成员变量在多态情境下的使用，无论编译还是运行，通通遵循左侧实例。\n\n#### 总结\n* 成员函数\n  编译时遵循左侧实例，运行时遵循右侧声明\n* 成员变量\n  编译或者运行一律遵循左侧实例\n\n其实也比较好理解，编译期间，当前类下不存在的成员函数或成员变量，肯定是无法被实例对象获取到的；\n而在运行时，java中子类可以重写父类的方法，因此成员函数运行时会正确指向子类的方法，但是，子类并不可以重写父类的变量，当子类与父类有同名变量时，需要使用this和super关键字进行区分。在这种情况下，成员变量的访问则不可能像方法一样使用多态访问，因此只能是遵循左侧的实例了。","slug":"polymorphism-of-java","published":1,"updated":"2018-08-14T10:11:51.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86co000ulh1p4nyxiwdg","content":"<p>实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例</p>\n<pre><code>// 父类\npublic class Parent {\n    public int aInt = -1;\n    public void func1() {\n        System.err.print(&quot; Parent func1 &quot;);\n    }\n    public void func2() {\n        System.err.print(&quot; Parent func2 &quot;);\n    }\n}\n</code></pre><pre><code>// 子类\npublic class Child extends Parent {\n    public int aInt = 1;\n    public void func1() {\n        System.err.print(&quot; Child func1 &quot;);\n    }\n    public void func3() {\n        System.err.print(&quot; Child func3 &quot;);\n    }\n}\n</code></pre><h4 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><pre><code>// test main()\npublic static void main(String[] args) {\n    Child child = new Child();\n    child.func1();\n    child.func2();\n    child.func3();\n\n    Parent parent = new Child();\n    parent.func1();\n    parent.func2();\n    parent.func3();\n}\n</code></pre><p>如上所示，将对象声明为Child对象时，三个方法都编译通过，且输入结果如下：</p>\n<pre><code>Child func1\nParent func2\nChild func3\n</code></pre><p>Child类重写了父类的func1()方法，则在运行时匹配了子类自身的重写方法，即，「运行时遵循右侧声明」。<br>但是，如果将对象声明为Parent对象时，parent.fun3()则会报错，因为「编译期遵循左侧实例」，当前对象被声明为Parent实例，而Parent中没有func3()方法，所以编译不通过。同时也正因为「运行时遵循右侧声明」，所以其运行结果如下：</p>\n<pre><code>Child func1 // 尽管声明为Parent实例，但实际调用Child的方法\nParent func2\n</code></pre><p>综上所述，在多态使用时，成员函数遵循两个原则，即「编译期遵循左侧实例，运行时遵循右侧声明」</p>\n<h4 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h4><pre><code>// test main()\npublic static void main(String[] args) {\n    Parent parent = new Child();\n    Child child = new Child();\n    System.err.println(parent.aInt);\n    System.err.println(child.aInt);\n}\n</code></pre><p>运行结果如下：</p>\n<pre><code>-1\n1\n</code></pre><p>可以发现，打印结果与成员函数有所不同。因为如果是成员函数，运行时遵循右侧声明的话，打印结果应该相等，同为1才对。因此，成员变量在多态情境下的使用，无论编译还是运行，通通遵循左侧实例。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>成员函数<br>编译时遵循左侧实例，运行时遵循右侧声明</li>\n<li>成员变量<br>编译或者运行一律遵循左侧实例</li>\n</ul>\n<p>其实也比较好理解，编译期间，当前类下不存在的成员函数或成员变量，肯定是无法被实例对象获取到的；<br>而在运行时，java中子类可以重写父类的方法，因此成员函数运行时会正确指向子类的方法，但是，子类并不可以重写父类的变量，当子类与父类有同名变量时，需要使用this和super关键字进行区分。在这种情况下，成员变量的访问则不可能像方法一样使用多态访问，因此只能是遵循左侧的实例了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例</p>\n<pre><code>// 父类\npublic class Parent {\n    public int aInt = -1;\n    public void func1() {\n        System.err.print(&quot; Parent func1 &quot;);\n    }\n    public void func2() {\n        System.err.print(&quot; Parent func2 &quot;);\n    }\n}\n</code></pre><pre><code>// 子类\npublic class Child extends Parent {\n    public int aInt = 1;\n    public void func1() {\n        System.err.print(&quot; Child func1 &quot;);\n    }\n    public void func3() {\n        System.err.print(&quot; Child func3 &quot;);\n    }\n}\n</code></pre><h4 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><pre><code>// test main()\npublic static void main(String[] args) {\n    Child child = new Child();\n    child.func1();\n    child.func2();\n    child.func3();\n\n    Parent parent = new Child();\n    parent.func1();\n    parent.func2();\n    parent.func3();\n}\n</code></pre><p>如上所示，将对象声明为Child对象时，三个方法都编译通过，且输入结果如下：</p>\n<pre><code>Child func1\nParent func2\nChild func3\n</code></pre><p>Child类重写了父类的func1()方法，则在运行时匹配了子类自身的重写方法，即，「运行时遵循右侧声明」。<br>但是，如果将对象声明为Parent对象时，parent.fun3()则会报错，因为「编译期遵循左侧实例」，当前对象被声明为Parent实例，而Parent中没有func3()方法，所以编译不通过。同时也正因为「运行时遵循右侧声明」，所以其运行结果如下：</p>\n<pre><code>Child func1 // 尽管声明为Parent实例，但实际调用Child的方法\nParent func2\n</code></pre><p>综上所述，在多态使用时，成员函数遵循两个原则，即「编译期遵循左侧实例，运行时遵循右侧声明」</p>\n<h4 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h4><pre><code>// test main()\npublic static void main(String[] args) {\n    Parent parent = new Child();\n    Child child = new Child();\n    System.err.println(parent.aInt);\n    System.err.println(child.aInt);\n}\n</code></pre><p>运行结果如下：</p>\n<pre><code>-1\n1\n</code></pre><p>可以发现，打印结果与成员函数有所不同。因为如果是成员函数，运行时遵循右侧声明的话，打印结果应该相等，同为1才对。因此，成员变量在多态情境下的使用，无论编译还是运行，通通遵循左侧实例。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>成员函数<br>编译时遵循左侧实例，运行时遵循右侧声明</li>\n<li>成员变量<br>编译或者运行一律遵循左侧实例</li>\n</ul>\n<p>其实也比较好理解，编译期间，当前类下不存在的成员函数或成员变量，肯定是无法被实例对象获取到的；<br>而在运行时，java中子类可以重写父类的方法，因此成员函数运行时会正确指向子类的方法，但是，子类并不可以重写父类的变量，当子类与父类有同名变量时，需要使用this和super关键字进行区分。在这种情况下，成员变量的访问则不可能像方法一样使用多态访问，因此只能是遵循左侧的实例了。</p>\n"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410195304.jpg","title":"MeasureSpec 那点事儿","date":"2019-04-09T16:00:00.000Z","_content":"\n\n\n\n\n\n\n在自定义 View 的学习过程中，不管怎么样都绕不过 MeasureSpec  的学习；拖拖拉拉很久，在数不清的看了忘，忘了看之后，还是决定写篇博客记录一下，毕竟有效的输出才是检验输入的不二法门。\n\n\n\n<!-- more -->\n\n废话不多说，下面进入正题。\n\n\n\n### MeasureSpec 定义\n\n关于 MeasureSpec 的定义，官方解释如下：\n\n> A MeasureSpec encapsulates the layout requirements passed from parent to child. Each MeasureSpec represents a requirement for either the width or the height. \n\n大意就是，MeasureSpec 封装了父布局传递给子布局的布局要求，每个 MeasureSpec 由 `mode` 和 `size` 组成，包含了父布局对子布局相应的宽高要求。\n\nMeasureSpec 有三种模式：UNSPECIFIED、EXACTLY、AT_MOST。\n\n- UNSPECIFIED\n\n  父布局不对子布局做任何限制，它想多大就多大；一般自定义 View 中用不到；\n\n  > 常见于系统内部控件，例如 ListView、ScrollView\n\n- EXACTLY\n\n  父布局对子布局的宽高大小有明确的要求，不管子布局想要多大，它都不能超过父布局对它的限制；\n\n  > 指定的大小如 100dp，或者 match_parent(实质上就是屏幕大小)，都是确切的尺寸\n\n- AT_MOST\n\n  子布局想要多大就可以多大，但是一般来说不会超过父布局的尺寸；\n\n  > 一般对应的父布局尺寸为 wrap_content，父布局无法确定子布局的尺寸\n\n为了节约内存占用，MeasureSpec 本身就是一个 32 位的 int 值，这个类就是负责将 <size, mode> 的元组转换为 int 值，高 2 位表示 specMode，低 30 位表示 specSize。\n\n\n\n**一个 View 的大小并不是由它自己确定的，而是由其自身的 LayoutParams 以及父布局的 MeasureSpec 确定的。**\n\n那 MeasureSpec 是什么，最初的 MeasureSpec 又是哪里来的？\n\n\n\n### MeasureSpec 缘起\n\n由于 View 的绘制流程入口在 ViewRootImpl 类中，我们最终在 performTraversals 方法中找到如下代码：\n\n```java\n    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);\n \t\tint childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);\n \t\t// Ask host how big it wants to be\n \t\tperformMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n```\n\n很明显在执行测量的最初，系统是通过 `getRootMeasureSpec` 方法获取到宽高的 MeasureSpec 信息的。\n\n```java\nprivate static int getRootMeasureSpec(int windowSize, int rootDimension) {\n    int measureSpec;\n    switch (rootDimension) {\n        case ViewGroup.LayoutParams.MATCH_PARENT:\n            // Window can't resize. Force root view to be windowSize.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);\n            break;\n        case ViewGroup.LayoutParams.WRAP_CONTENT:\n            // Window can resize. Set max size for root view.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);\n            break;\n        default:\n            // Window wants to be an exact size. Force root view to be that size.\n            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);\n            break;\n    }\n    return measureSpec;\n}\n```\n\n很明显，通过这个方法我们可以发现，在 View 测量的入口，specSize 是固定的 windowSize，而 MATCH_PARENT 对应的测量模式是 EXACTLY，WRAP_CONTENT 对应的测量模式是 AT_MOST。我们会发现，每个 MeasureSpec 都是通过 `MeasureSpec.makeMeasureSpec` 生成的。\n\nSpecMode 和 SpecSize 组成了 MeasureSpec，MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象创建，并提供了对应的打包、解包方法：\n\n```java\npublic static int makeMeasureSpec(int size, int mode) {\n    if (sUseBrokenMakeMeasureSpec) {\n        // 二进制的 + ，不是十进制\n      \t// 使用一个32位的二进制数，其中：32和31位代表测量模式（mode）、后30位代表测量大小（size）\n        // 例如size=100(就是十进制的 4)，mode=AT_MOST，measureSpec=100+1000...00=1000..00100  \n        return size + mode;\n    } else {\n        return (size & ~MODE_MASK) | (mode & MODE_MASK);\n    }\n}\n\npublic static int getMode(int measureSpec) {\n  \t// MODE_MASK = 运算遮罩 = 11 00000000000(11后跟30个0)\n  \t// 原理：保留measureSpec的高2位（即测量模式）、使用0替换后30位\n    return (measureSpec & MODE_MASK);\n}\n\npublic static int getSize(int measureSpec) {\n    // 原理：同上，将 MASK 取反，得到 00 1111111111(00后跟30个1) \n    // 将 32,31 替换成 0 也就是去掉了 mode，只保留后30位的size\n    return (measureSpec & ~MODE_MASK);\n}\n```\n\n现在我们得到了 MeasureSpec，现在来看看父布局是怎么通过 MeasureSpec 支配子布局的。\n\n以下代码截取自 LinearLayout 的 measureVertical 方法：\n\n```java\nfinal LayoutParams lp = (LayoutParams) child.getLayoutParams();\nfinal int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(\n        Math.max(0, childWidth), MeasureSpec.EXACTLY);\nfinal int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,\n        mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin,\n        lp.height);\n// 传到各个子 View 的 MeasureSpec 就是在这里生成的\nchild.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n```\n\n我们可以发现，由于是测量竖直方向的线性布局，布局的宽度是固定的，所以直接调用 MeasureSpec 生成宽度的规格，同时为其指定测量模式为 MeasureSpec.EXACTLY；高度因为比较复杂，调用了 `getChildMeasureSpec` 生成，传入了当前 LinearLayout 的父布局为其指定的 MeasureSpec 以及当前子 View 的 LayoutParams：\n\n```java\n/**\n * ViewGroup#getChildMeasureSpec\n * \n * @param spec 父布局的 MeasureSpec\n * @param padding 子布局的 margin+padding\n * @param childDimension 子布局的高度信息，lp.height\n * @return\n */\npublic static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n  \t// 获取父布局，也就是 LinearLayout 的测量模式以及测量大小\n    int specMode = MeasureSpec.getMode(spec);\n    int specSize = MeasureSpec.getSize(spec);\n\n  \t// 记录一下除去 padding 的测量大小，但是不一定会用，具体要看父布局的 mode 以及子布局自身的 size \n    int size = Math.max(0, specSize - padding);\n\n  \t// 当前 child 的 size 和 mode\n    int resultSize = 0;\n    int resultMode = 0;\n\n    // 判断一下父布局的测量规格，看看是 match 还是 wrap\n    switch (specMode) {\n        // 如果是 EXACTLY，说明父布局是有固定大小的，或者是定死的 100dp，或者是 match_parent 的屏幕宽度\n        case MeasureSpec.EXACTLY: // 值为 -2\n        \t\t// 在这种情况下，如果子布局的高度信息是有确定值的，那说明用户声明了固定的 100dp 等信息\n         \t\t// 那就让子布局的宽高信息固定，同时设置测量模式同样为 EXACTLY\n            if (childDimension >= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                // 如果子布局想要充满父布局，那就让它和父布局一样大，然后设置测量模式同样为 EXACTLY\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                // 子布局想自己决定自己的大小，但是它最大不能超过父布局，所以模式是 AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 如果是 AT_MOST，说明父布局是包裹内容，那子布局不能超过父布局的大小\n        case MeasureSpec.AT_MOST:\n            if (childDimension >= 0) {\n                // 全部同上\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n              \t// 父布局都不知道自己的大小，只能告诉子布局最大不能超过自己，所以模式只能是 AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 父布局不对子布局做任何限制，想多大多大，一般多见于ListView、GridView\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension >= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should\n                // be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size.... find out how\n                // big it should be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            }\n            break;\n    }\n    // 用父布局的 MeasureSpec 和 child 的 lp，为其生成自己的测量规格\n    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n}\n```\n\n\n\n### 做个小总结\n\n说到这里，大家也应该能理解「一个 View 的大小是由它的父布局和它自身共同决定的」是什么意思了。\n\n这里简单做个总结：\n\n1. MeasureSpec 的 UNSPECIFIED 测量模式一般见于系统内部，并不多见，不做过多讨论，目前已知的应用就是 ScrollView 嵌套 ListView 只能显示一行，就是由于 ScrollView 在测量子 View 的时候，向下传递的测量模式为 MeasureSpec.UNSPECIFIED ，同时 ListView 的 onMeasure 方法是这样的：\n\n   ```java\n   // 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + padding\n   if (heightMode == MeasureSpec.UNSPECIFIED) {\n      \theightSize = mListPadding.top + mListPadding.bottom + \n        \t\tchildHeight + getVerticalFadingEdgeLength() * 2;\n   }\n   ```\n\n   这就导致了最终 ListView 的高度只有一行，感兴趣的可以看一下[ScrollView 嵌套 ListView 的解决方法的原理](<https://www.jianshu.com/p/061f734af3e9>)，这里就不再过多介绍了；\n\n2. **当子 View 设置了固定值的时候，无论父布局的测量模式是什么，*<u>子 View 的大小都遵循这个固定值，</u>*<u>*即使超出屏幕*</u>，且测量模式都为精确模式，即 MeasureSpec.EXACTLY**；\n\n3. **当子 View 为 match_parent 时，其 specMode 跟随父布局的 specMode**，*<u>父布局固定，那你充满父布局，你肯定也固定，就是 EXACTLY；父布局包裹内容，不能确定自己多大，那你肯定也不能知道自己多大，那就 AT_MOST</u>*；**其 specSize 也就是父布局的 size，不会超过父布局的大小；**\n\n4. **当子 View 为 wrap_content 时，那它的 specMode 是 AT_MOST，specSize 就是父布局的 size，因为虽然其不能确定宽高，但是始终不能超过父布局的大小。**\n\n\n\n### 🌰\n\n一直贴代码，说理论多少有点枯燥，贴点图片，看看🌰\n\n#### 父布局为 EXACTLY\n\n1. ViewGroup: match_parent, Child: 500dp x 500dp\n\n2. ViewGroup: 300dp x 300dp, Child: 500dp x 500dp\n\n   > 父布局测量规格是精确模式，测量大小是屏幕大小；\n   >\n   > 子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式\n\n   ```java\n   // 布局如下\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"300dp\"\n           android:layout_height=\"300dp\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180646.png)\n\n3. ViewGroup: match_parent, child: match_parent\n\n   > 父布局、子布局均充满屏幕，测量模式都为 MeasureSpec.EXACTLY，测量大小均为屏幕大小\n\n   ```JAVA\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"match_parent\"\n           android:layout_height=\"match_parent\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180825.png)\n\n4. ViewGroup: match_parent, child: wrap_content\n\n   > 父布局充满屏幕，测量模式是精确模式，测量大小是屏幕大小；\n   >\n   > 子布局包裹内容，测量模式是 AT_MOST，但是不能超过父布局，测量大小为屏幕大小\n\n   ```java\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"wrap_content\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180934.png)\n\n\n\n#### 父布局为 WRAP_CONTENT\n\n1. ViewGroup: wrap_content, child: match_parent\n\n   > 父布局测量规格是 AT_MOST，测量大小是屏幕大小；\n   >\n   > 子布局测量规格 AT_MOST，但是无法超过父布局大小，测量大小也是屏幕大小；\n\n   ```java\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"wrap_content\"\n       android:layout_height=\"wrap_content\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"match_parent\"\n           android:layout_height=\"match_parent\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181341.png)\n\n2. ViewGroup: wrap_content, child: 300dp x 300dp\n\n   > 父布局测量规格是 AT_MOST，测量大小是屏幕大小；\n   >\n   > 子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式\n\n   ```java\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"wrap_content\"\n       android:layout_height=\"wrap_content\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"300dp\"\n           android:layout_height=\"300dp\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181429.png)\n\n3. ViewGroup: wrap_content, child: wrap_content\n\n   > 父布局测量规格是 AT_MOST，测量大小是屏幕大小；\n   >\n   > 子布局也不知道自己多大，测量规格是 AT_MOST，不能超过父布局，测量大小是屏幕大小；\n\n   ```java\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"wrap_content\"\n       android:layout_height=\"wrap_content\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"wrap_content\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181519.png)\n\n","source":"_posts/Android-MeasureSpec.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410195304.jpg\ntitle: MeasureSpec 那点事儿\ntags: [Android]\ndate: 2019-04-10\n---\n\n\n\n\n\n\n\n在自定义 View 的学习过程中，不管怎么样都绕不过 MeasureSpec  的学习；拖拖拉拉很久，在数不清的看了忘，忘了看之后，还是决定写篇博客记录一下，毕竟有效的输出才是检验输入的不二法门。\n\n\n\n<!-- more -->\n\n废话不多说，下面进入正题。\n\n\n\n### MeasureSpec 定义\n\n关于 MeasureSpec 的定义，官方解释如下：\n\n> A MeasureSpec encapsulates the layout requirements passed from parent to child. Each MeasureSpec represents a requirement for either the width or the height. \n\n大意就是，MeasureSpec 封装了父布局传递给子布局的布局要求，每个 MeasureSpec 由 `mode` 和 `size` 组成，包含了父布局对子布局相应的宽高要求。\n\nMeasureSpec 有三种模式：UNSPECIFIED、EXACTLY、AT_MOST。\n\n- UNSPECIFIED\n\n  父布局不对子布局做任何限制，它想多大就多大；一般自定义 View 中用不到；\n\n  > 常见于系统内部控件，例如 ListView、ScrollView\n\n- EXACTLY\n\n  父布局对子布局的宽高大小有明确的要求，不管子布局想要多大，它都不能超过父布局对它的限制；\n\n  > 指定的大小如 100dp，或者 match_parent(实质上就是屏幕大小)，都是确切的尺寸\n\n- AT_MOST\n\n  子布局想要多大就可以多大，但是一般来说不会超过父布局的尺寸；\n\n  > 一般对应的父布局尺寸为 wrap_content，父布局无法确定子布局的尺寸\n\n为了节约内存占用，MeasureSpec 本身就是一个 32 位的 int 值，这个类就是负责将 <size, mode> 的元组转换为 int 值，高 2 位表示 specMode，低 30 位表示 specSize。\n\n\n\n**一个 View 的大小并不是由它自己确定的，而是由其自身的 LayoutParams 以及父布局的 MeasureSpec 确定的。**\n\n那 MeasureSpec 是什么，最初的 MeasureSpec 又是哪里来的？\n\n\n\n### MeasureSpec 缘起\n\n由于 View 的绘制流程入口在 ViewRootImpl 类中，我们最终在 performTraversals 方法中找到如下代码：\n\n```java\n    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);\n \t\tint childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);\n \t\t// Ask host how big it wants to be\n \t\tperformMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n```\n\n很明显在执行测量的最初，系统是通过 `getRootMeasureSpec` 方法获取到宽高的 MeasureSpec 信息的。\n\n```java\nprivate static int getRootMeasureSpec(int windowSize, int rootDimension) {\n    int measureSpec;\n    switch (rootDimension) {\n        case ViewGroup.LayoutParams.MATCH_PARENT:\n            // Window can't resize. Force root view to be windowSize.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);\n            break;\n        case ViewGroup.LayoutParams.WRAP_CONTENT:\n            // Window can resize. Set max size for root view.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);\n            break;\n        default:\n            // Window wants to be an exact size. Force root view to be that size.\n            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);\n            break;\n    }\n    return measureSpec;\n}\n```\n\n很明显，通过这个方法我们可以发现，在 View 测量的入口，specSize 是固定的 windowSize，而 MATCH_PARENT 对应的测量模式是 EXACTLY，WRAP_CONTENT 对应的测量模式是 AT_MOST。我们会发现，每个 MeasureSpec 都是通过 `MeasureSpec.makeMeasureSpec` 生成的。\n\nSpecMode 和 SpecSize 组成了 MeasureSpec，MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象创建，并提供了对应的打包、解包方法：\n\n```java\npublic static int makeMeasureSpec(int size, int mode) {\n    if (sUseBrokenMakeMeasureSpec) {\n        // 二进制的 + ，不是十进制\n      \t// 使用一个32位的二进制数，其中：32和31位代表测量模式（mode）、后30位代表测量大小（size）\n        // 例如size=100(就是十进制的 4)，mode=AT_MOST，measureSpec=100+1000...00=1000..00100  \n        return size + mode;\n    } else {\n        return (size & ~MODE_MASK) | (mode & MODE_MASK);\n    }\n}\n\npublic static int getMode(int measureSpec) {\n  \t// MODE_MASK = 运算遮罩 = 11 00000000000(11后跟30个0)\n  \t// 原理：保留measureSpec的高2位（即测量模式）、使用0替换后30位\n    return (measureSpec & MODE_MASK);\n}\n\npublic static int getSize(int measureSpec) {\n    // 原理：同上，将 MASK 取反，得到 00 1111111111(00后跟30个1) \n    // 将 32,31 替换成 0 也就是去掉了 mode，只保留后30位的size\n    return (measureSpec & ~MODE_MASK);\n}\n```\n\n现在我们得到了 MeasureSpec，现在来看看父布局是怎么通过 MeasureSpec 支配子布局的。\n\n以下代码截取自 LinearLayout 的 measureVertical 方法：\n\n```java\nfinal LayoutParams lp = (LayoutParams) child.getLayoutParams();\nfinal int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(\n        Math.max(0, childWidth), MeasureSpec.EXACTLY);\nfinal int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,\n        mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin,\n        lp.height);\n// 传到各个子 View 的 MeasureSpec 就是在这里生成的\nchild.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n```\n\n我们可以发现，由于是测量竖直方向的线性布局，布局的宽度是固定的，所以直接调用 MeasureSpec 生成宽度的规格，同时为其指定测量模式为 MeasureSpec.EXACTLY；高度因为比较复杂，调用了 `getChildMeasureSpec` 生成，传入了当前 LinearLayout 的父布局为其指定的 MeasureSpec 以及当前子 View 的 LayoutParams：\n\n```java\n/**\n * ViewGroup#getChildMeasureSpec\n * \n * @param spec 父布局的 MeasureSpec\n * @param padding 子布局的 margin+padding\n * @param childDimension 子布局的高度信息，lp.height\n * @return\n */\npublic static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n  \t// 获取父布局，也就是 LinearLayout 的测量模式以及测量大小\n    int specMode = MeasureSpec.getMode(spec);\n    int specSize = MeasureSpec.getSize(spec);\n\n  \t// 记录一下除去 padding 的测量大小，但是不一定会用，具体要看父布局的 mode 以及子布局自身的 size \n    int size = Math.max(0, specSize - padding);\n\n  \t// 当前 child 的 size 和 mode\n    int resultSize = 0;\n    int resultMode = 0;\n\n    // 判断一下父布局的测量规格，看看是 match 还是 wrap\n    switch (specMode) {\n        // 如果是 EXACTLY，说明父布局是有固定大小的，或者是定死的 100dp，或者是 match_parent 的屏幕宽度\n        case MeasureSpec.EXACTLY: // 值为 -2\n        \t\t// 在这种情况下，如果子布局的高度信息是有确定值的，那说明用户声明了固定的 100dp 等信息\n         \t\t// 那就让子布局的宽高信息固定，同时设置测量模式同样为 EXACTLY\n            if (childDimension >= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                // 如果子布局想要充满父布局，那就让它和父布局一样大，然后设置测量模式同样为 EXACTLY\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                // 子布局想自己决定自己的大小，但是它最大不能超过父布局，所以模式是 AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 如果是 AT_MOST，说明父布局是包裹内容，那子布局不能超过父布局的大小\n        case MeasureSpec.AT_MOST:\n            if (childDimension >= 0) {\n                // 全部同上\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n              \t// 父布局都不知道自己的大小，只能告诉子布局最大不能超过自己，所以模式只能是 AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 父布局不对子布局做任何限制，想多大多大，一般多见于ListView、GridView\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension >= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should\n                // be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size.... find out how\n                // big it should be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            }\n            break;\n    }\n    // 用父布局的 MeasureSpec 和 child 的 lp，为其生成自己的测量规格\n    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n}\n```\n\n\n\n### 做个小总结\n\n说到这里，大家也应该能理解「一个 View 的大小是由它的父布局和它自身共同决定的」是什么意思了。\n\n这里简单做个总结：\n\n1. MeasureSpec 的 UNSPECIFIED 测量模式一般见于系统内部，并不多见，不做过多讨论，目前已知的应用就是 ScrollView 嵌套 ListView 只能显示一行，就是由于 ScrollView 在测量子 View 的时候，向下传递的测量模式为 MeasureSpec.UNSPECIFIED ，同时 ListView 的 onMeasure 方法是这样的：\n\n   ```java\n   // 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + padding\n   if (heightMode == MeasureSpec.UNSPECIFIED) {\n      \theightSize = mListPadding.top + mListPadding.bottom + \n        \t\tchildHeight + getVerticalFadingEdgeLength() * 2;\n   }\n   ```\n\n   这就导致了最终 ListView 的高度只有一行，感兴趣的可以看一下[ScrollView 嵌套 ListView 的解决方法的原理](<https://www.jianshu.com/p/061f734af3e9>)，这里就不再过多介绍了；\n\n2. **当子 View 设置了固定值的时候，无论父布局的测量模式是什么，*<u>子 View 的大小都遵循这个固定值，</u>*<u>*即使超出屏幕*</u>，且测量模式都为精确模式，即 MeasureSpec.EXACTLY**；\n\n3. **当子 View 为 match_parent 时，其 specMode 跟随父布局的 specMode**，*<u>父布局固定，那你充满父布局，你肯定也固定，就是 EXACTLY；父布局包裹内容，不能确定自己多大，那你肯定也不能知道自己多大，那就 AT_MOST</u>*；**其 specSize 也就是父布局的 size，不会超过父布局的大小；**\n\n4. **当子 View 为 wrap_content 时，那它的 specMode 是 AT_MOST，specSize 就是父布局的 size，因为虽然其不能确定宽高，但是始终不能超过父布局的大小。**\n\n\n\n### 🌰\n\n一直贴代码，说理论多少有点枯燥，贴点图片，看看🌰\n\n#### 父布局为 EXACTLY\n\n1. ViewGroup: match_parent, Child: 500dp x 500dp\n\n2. ViewGroup: 300dp x 300dp, Child: 500dp x 500dp\n\n   > 父布局测量规格是精确模式，测量大小是屏幕大小；\n   >\n   > 子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式\n\n   ```java\n   // 布局如下\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"300dp\"\n           android:layout_height=\"300dp\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180646.png)\n\n3. ViewGroup: match_parent, child: match_parent\n\n   > 父布局、子布局均充满屏幕，测量模式都为 MeasureSpec.EXACTLY，测量大小均为屏幕大小\n\n   ```JAVA\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"match_parent\"\n           android:layout_height=\"match_parent\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180825.png)\n\n4. ViewGroup: match_parent, child: wrap_content\n\n   > 父布局充满屏幕，测量模式是精确模式，测量大小是屏幕大小；\n   >\n   > 子布局包裹内容，测量模式是 AT_MOST，但是不能超过父布局，测量大小为屏幕大小\n\n   ```java\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"wrap_content\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180934.png)\n\n\n\n#### 父布局为 WRAP_CONTENT\n\n1. ViewGroup: wrap_content, child: match_parent\n\n   > 父布局测量规格是 AT_MOST，测量大小是屏幕大小；\n   >\n   > 子布局测量规格 AT_MOST，但是无法超过父布局大小，测量大小也是屏幕大小；\n\n   ```java\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"wrap_content\"\n       android:layout_height=\"wrap_content\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"match_parent\"\n           android:layout_height=\"match_parent\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181341.png)\n\n2. ViewGroup: wrap_content, child: 300dp x 300dp\n\n   > 父布局测量规格是 AT_MOST，测量大小是屏幕大小；\n   >\n   > 子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式\n\n   ```java\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"wrap_content\"\n       android:layout_height=\"wrap_content\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"300dp\"\n           android:layout_height=\"300dp\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181429.png)\n\n3. ViewGroup: wrap_content, child: wrap_content\n\n   > 父布局测量规格是 AT_MOST，测量大小是屏幕大小；\n   >\n   > 子布局也不知道自己多大，测量规格是 AT_MOST，不能超过父布局，测量大小是屏幕大小；\n\n   ```java\n   <com.ljt.rvanalysis.spec.MyLinearLayout\n       android:layout_width=\"wrap_content\"\n       android:layout_height=\"wrap_content\"\n       android:orientation=\"vertical\">\n   \n       <com.ljt.rvanalysis.spec.MyTextView\n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"wrap_content\" />\n   \n   </com.ljt.rvanalysis.spec.MyLinearLayout>\n   ```\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181519.png)\n\n","slug":"Android-MeasureSpec","published":1,"updated":"2019-04-10T11:54:51.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86df0012lh1pdh6pyici","content":"<p>在自定义 View 的学习过程中，不管怎么样都绕不过 MeasureSpec  的学习；拖拖拉拉很久，在数不清的看了忘，忘了看之后，还是决定写篇博客记录一下，毕竟有效的输出才是检验输入的不二法门。</p>\n<a id=\"more\"></a>\n<p>废话不多说，下面进入正题。</p>\n<h3 id=\"MeasureSpec-定义\"><a href=\"#MeasureSpec-定义\" class=\"headerlink\" title=\"MeasureSpec 定义\"></a>MeasureSpec 定义</h3><p>关于 MeasureSpec 的定义，官方解释如下：</p>\n<blockquote>\n<p>A MeasureSpec encapsulates the layout requirements passed from parent to child. Each MeasureSpec represents a requirement for either the width or the height. </p>\n</blockquote>\n<p>大意就是，MeasureSpec 封装了父布局传递给子布局的布局要求，每个 MeasureSpec 由 <code>mode</code> 和 <code>size</code> 组成，包含了父布局对子布局相应的宽高要求。</p>\n<p>MeasureSpec 有三种模式：UNSPECIFIED、EXACTLY、AT_MOST。</p>\n<ul>\n<li><p>UNSPECIFIED</p>\n<p>父布局不对子布局做任何限制，它想多大就多大；一般自定义 View 中用不到；</p>\n<blockquote>\n<p>常见于系统内部控件，例如 ListView、ScrollView</p>\n</blockquote>\n</li>\n<li><p>EXACTLY</p>\n<p>父布局对子布局的宽高大小有明确的要求，不管子布局想要多大，它都不能超过父布局对它的限制；</p>\n<blockquote>\n<p>指定的大小如 100dp，或者 match_parent(实质上就是屏幕大小)，都是确切的尺寸</p>\n</blockquote>\n</li>\n<li><p>AT_MOST</p>\n<p>子布局想要多大就可以多大，但是一般来说不会超过父布局的尺寸；</p>\n<blockquote>\n<p>一般对应的父布局尺寸为 wrap_content，父布局无法确定子布局的尺寸</p>\n</blockquote>\n</li>\n</ul>\n<p>为了节约内存占用，MeasureSpec 本身就是一个 32 位的 int 值，这个类就是负责将 &lt;size, mode&gt; 的元组转换为 int 值，高 2 位表示 specMode，低 30 位表示 specSize。</p>\n<p><strong>一个 View 的大小并不是由它自己确定的，而是由其自身的 LayoutParams 以及父布局的 MeasureSpec 确定的。</strong></p>\n<p>那 MeasureSpec 是什么，最初的 MeasureSpec 又是哪里来的？</p>\n<h3 id=\"MeasureSpec-缘起\"><a href=\"#MeasureSpec-缘起\" class=\"headerlink\" title=\"MeasureSpec 缘起\"></a>MeasureSpec 缘起</h3><p>由于 View 的绘制流程入口在 ViewRootImpl 类中，我们最终在 performTraversals 方法中找到如下代码：</p>\n<pre><code class=\"java\">    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);\n         int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);\n         // Ask host how big it wants to be\n         performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n</code></pre>\n<p>很明显在执行测量的最初，系统是通过 <code>getRootMeasureSpec</code> 方法获取到宽高的 MeasureSpec 信息的。</p>\n<pre><code class=\"java\">private static int getRootMeasureSpec(int windowSize, int rootDimension) {\n    int measureSpec;\n    switch (rootDimension) {\n        case ViewGroup.LayoutParams.MATCH_PARENT:\n            // Window can&#39;t resize. Force root view to be windowSize.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);\n            break;\n        case ViewGroup.LayoutParams.WRAP_CONTENT:\n            // Window can resize. Set max size for root view.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);\n            break;\n        default:\n            // Window wants to be an exact size. Force root view to be that size.\n            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);\n            break;\n    }\n    return measureSpec;\n}\n</code></pre>\n<p>很明显，通过这个方法我们可以发现，在 View 测量的入口，specSize 是固定的 windowSize，而 MATCH_PARENT 对应的测量模式是 EXACTLY，WRAP_CONTENT 对应的测量模式是 AT_MOST。我们会发现，每个 MeasureSpec 都是通过 <code>MeasureSpec.makeMeasureSpec</code> 生成的。</p>\n<p>SpecMode 和 SpecSize 组成了 MeasureSpec，MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象创建，并提供了对应的打包、解包方法：</p>\n<pre><code class=\"java\">public static int makeMeasureSpec(int size, int mode) {\n    if (sUseBrokenMakeMeasureSpec) {\n        // 二进制的 + ，不是十进制\n          // 使用一个32位的二进制数，其中：32和31位代表测量模式（mode）、后30位代表测量大小（size）\n        // 例如size=100(就是十进制的 4)，mode=AT_MOST，measureSpec=100+1000...00=1000..00100  \n        return size + mode;\n    } else {\n        return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);\n    }\n}\n\npublic static int getMode(int measureSpec) {\n      // MODE_MASK = 运算遮罩 = 11 00000000000(11后跟30个0)\n      // 原理：保留measureSpec的高2位（即测量模式）、使用0替换后30位\n    return (measureSpec &amp; MODE_MASK);\n}\n\npublic static int getSize(int measureSpec) {\n    // 原理：同上，将 MASK 取反，得到 00 1111111111(00后跟30个1) \n    // 将 32,31 替换成 0 也就是去掉了 mode，只保留后30位的size\n    return (measureSpec &amp; ~MODE_MASK);\n}\n</code></pre>\n<p>现在我们得到了 MeasureSpec，现在来看看父布局是怎么通过 MeasureSpec 支配子布局的。</p>\n<p>以下代码截取自 LinearLayout 的 measureVertical 方法：</p>\n<pre><code class=\"java\">final LayoutParams lp = (LayoutParams) child.getLayoutParams();\nfinal int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(\n        Math.max(0, childWidth), MeasureSpec.EXACTLY);\nfinal int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,\n        mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin,\n        lp.height);\n// 传到各个子 View 的 MeasureSpec 就是在这里生成的\nchild.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n</code></pre>\n<p>我们可以发现，由于是测量竖直方向的线性布局，布局的宽度是固定的，所以直接调用 MeasureSpec 生成宽度的规格，同时为其指定测量模式为 MeasureSpec.EXACTLY；高度因为比较复杂，调用了 <code>getChildMeasureSpec</code> 生成，传入了当前 LinearLayout 的父布局为其指定的 MeasureSpec 以及当前子 View 的 LayoutParams：</p>\n<pre><code class=\"java\">/**\n * ViewGroup#getChildMeasureSpec\n * \n * @param spec 父布局的 MeasureSpec\n * @param padding 子布局的 margin+padding\n * @param childDimension 子布局的高度信息，lp.height\n * @return\n */\npublic static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n      // 获取父布局，也就是 LinearLayout 的测量模式以及测量大小\n    int specMode = MeasureSpec.getMode(spec);\n    int specSize = MeasureSpec.getSize(spec);\n\n      // 记录一下除去 padding 的测量大小，但是不一定会用，具体要看父布局的 mode 以及子布局自身的 size \n    int size = Math.max(0, specSize - padding);\n\n      // 当前 child 的 size 和 mode\n    int resultSize = 0;\n    int resultMode = 0;\n\n    // 判断一下父布局的测量规格，看看是 match 还是 wrap\n    switch (specMode) {\n        // 如果是 EXACTLY，说明父布局是有固定大小的，或者是定死的 100dp，或者是 match_parent 的屏幕宽度\n        case MeasureSpec.EXACTLY: // 值为 -2\n                // 在这种情况下，如果子布局的高度信息是有确定值的，那说明用户声明了固定的 100dp 等信息\n                 // 那就让子布局的宽高信息固定，同时设置测量模式同样为 EXACTLY\n            if (childDimension &gt;= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                // 如果子布局想要充满父布局，那就让它和父布局一样大，然后设置测量模式同样为 EXACTLY\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                // 子布局想自己决定自己的大小，但是它最大不能超过父布局，所以模式是 AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 如果是 AT_MOST，说明父布局是包裹内容，那子布局不能超过父布局的大小\n        case MeasureSpec.AT_MOST:\n            if (childDimension &gt;= 0) {\n                // 全部同上\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                  // 父布局都不知道自己的大小，只能告诉子布局最大不能超过自己，所以模式只能是 AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 父布局不对子布局做任何限制，想多大多大，一般多见于ListView、GridView\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension &gt;= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should\n                // be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size.... find out how\n                // big it should be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            }\n            break;\n    }\n    // 用父布局的 MeasureSpec 和 child 的 lp，为其生成自己的测量规格\n    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n}\n</code></pre>\n<h3 id=\"做个小总结\"><a href=\"#做个小总结\" class=\"headerlink\" title=\"做个小总结\"></a>做个小总结</h3><p>说到这里，大家也应该能理解「一个 View 的大小是由它的父布局和它自身共同决定的」是什么意思了。</p>\n<p>这里简单做个总结：</p>\n<ol>\n<li><p>MeasureSpec 的 UNSPECIFIED 测量模式一般见于系统内部，并不多见，不做过多讨论，目前已知的应用就是 ScrollView 嵌套 ListView 只能显示一行，就是由于 ScrollView 在测量子 View 的时候，向下传递的测量模式为 MeasureSpec.UNSPECIFIED ，同时 ListView 的 onMeasure 方法是这样的：</p>\n<pre><code class=\"java\">// 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + padding\nif (heightMode == MeasureSpec.UNSPECIFIED) {\n       heightSize = mListPadding.top + mListPadding.bottom + \n             childHeight + getVerticalFadingEdgeLength() * 2;\n}\n</code></pre>\n<p>这就导致了最终 ListView 的高度只有一行，感兴趣的可以看一下<a href=\"https://www.jianshu.com/p/061f734af3e9\" target=\"_blank\" rel=\"noopener\">ScrollView 嵌套 ListView 的解决方法的原理</a>，这里就不再过多介绍了；</p>\n</li>\n<li><p><strong>当子 View 设置了固定值的时候，无论父布局的测量模式是什么，<em><u>子 View 的大小都遵循这个固定值，</u></em><u><em>即使超出屏幕</em></u>，且测量模式都为精确模式，即 MeasureSpec.EXACTLY</strong>；</p>\n</li>\n<li><p><strong>当子 View 为 match_parent 时，其 specMode 跟随父布局的 specMode</strong>，<em><u>父布局固定，那你充满父布局，你肯定也固定，就是 EXACTLY；父布局包裹内容，不能确定自己多大，那你肯定也不能知道自己多大，那就 AT_MOST</u></em>；<strong>其 specSize 也就是父布局的 size，不会超过父布局的大小；</strong></p>\n</li>\n<li><p><strong>当子 View 为 wrap_content 时，那它的 specMode 是 AT_MOST，specSize 就是父布局的 size，因为虽然其不能确定宽高，但是始终不能超过父布局的大小。</strong></p>\n</li>\n</ol>\n<h3 id=\"🌰\"><a href=\"#🌰\" class=\"headerlink\" title=\"🌰\"></a>🌰</h3><p>一直贴代码，说理论多少有点枯燥，贴点图片，看看🌰</p>\n<h4 id=\"父布局为-EXACTLY\"><a href=\"#父布局为-EXACTLY\" class=\"headerlink\" title=\"父布局为 EXACTLY\"></a>父布局为 EXACTLY</h4><ol>\n<li><p>ViewGroup: match_parent, Child: 500dp x 500dp</p>\n</li>\n<li><p>ViewGroup: 300dp x 300dp, Child: 500dp x 500dp</p>\n<blockquote>\n<p>父布局测量规格是精确模式，测量大小是屏幕大小；</p>\n<p>子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式</p>\n</blockquote>\n<pre><code class=\"java\">// 布局如下\n&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;300dp&quot;\n        android:layout_height=&quot;300dp&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180646.png\" alt=\"\"></p>\n</li>\n<li><p>ViewGroup: match_parent, child: match_parent</p>\n<blockquote>\n<p>父布局、子布局均充满屏幕，测量模式都为 MeasureSpec.EXACTLY，测量大小均为屏幕大小</p>\n</blockquote>\n<pre><code class=\"JAVA\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180825.png\" alt=\"\"></p>\n</li>\n<li><p>ViewGroup: match_parent, child: wrap_content</p>\n<blockquote>\n<p>父布局充满屏幕，测量模式是精确模式，测量大小是屏幕大小；</p>\n<p>子布局包裹内容，测量模式是 AT_MOST，但是不能超过父布局，测量大小为屏幕大小</p>\n</blockquote>\n<pre><code class=\"java\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180934.png\" alt=\"\"></p>\n</li>\n</ol>\n<h4 id=\"父布局为-WRAP-CONTENT\"><a href=\"#父布局为-WRAP-CONTENT\" class=\"headerlink\" title=\"父布局为 WRAP_CONTENT\"></a>父布局为 WRAP_CONTENT</h4><ol>\n<li><p>ViewGroup: wrap_content, child: match_parent</p>\n<blockquote>\n<p>父布局测量规格是 AT_MOST，测量大小是屏幕大小；</p>\n<p>子布局测量规格 AT_MOST，但是无法超过父布局大小，测量大小也是屏幕大小；</p>\n</blockquote>\n<pre><code class=\"java\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181341.png\" alt=\"\"></p>\n</li>\n<li><p>ViewGroup: wrap_content, child: 300dp x 300dp</p>\n<blockquote>\n<p>父布局测量规格是 AT_MOST，测量大小是屏幕大小；</p>\n<p>子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式</p>\n</blockquote>\n<pre><code class=\"java\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;300dp&quot;\n        android:layout_height=&quot;300dp&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181429.png\" alt=\"\"></p>\n</li>\n<li><p>ViewGroup: wrap_content, child: wrap_content</p>\n<blockquote>\n<p>父布局测量规格是 AT_MOST，测量大小是屏幕大小；</p>\n<p>子布局也不知道自己多大，测量规格是 AT_MOST，不能超过父布局，测量大小是屏幕大小；</p>\n</blockquote>\n<pre><code class=\"java\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181519.png\" alt=\"\"></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在自定义 View 的学习过程中，不管怎么样都绕不过 MeasureSpec  的学习；拖拖拉拉很久，在数不清的看了忘，忘了看之后，还是决定写篇博客记录一下，毕竟有效的输出才是检验输入的不二法门。</p>","more":"<p>废话不多说，下面进入正题。</p>\n<h3 id=\"MeasureSpec-定义\"><a href=\"#MeasureSpec-定义\" class=\"headerlink\" title=\"MeasureSpec 定义\"></a>MeasureSpec 定义</h3><p>关于 MeasureSpec 的定义，官方解释如下：</p>\n<blockquote>\n<p>A MeasureSpec encapsulates the layout requirements passed from parent to child. Each MeasureSpec represents a requirement for either the width or the height. </p>\n</blockquote>\n<p>大意就是，MeasureSpec 封装了父布局传递给子布局的布局要求，每个 MeasureSpec 由 <code>mode</code> 和 <code>size</code> 组成，包含了父布局对子布局相应的宽高要求。</p>\n<p>MeasureSpec 有三种模式：UNSPECIFIED、EXACTLY、AT_MOST。</p>\n<ul>\n<li><p>UNSPECIFIED</p>\n<p>父布局不对子布局做任何限制，它想多大就多大；一般自定义 View 中用不到；</p>\n<blockquote>\n<p>常见于系统内部控件，例如 ListView、ScrollView</p>\n</blockquote>\n</li>\n<li><p>EXACTLY</p>\n<p>父布局对子布局的宽高大小有明确的要求，不管子布局想要多大，它都不能超过父布局对它的限制；</p>\n<blockquote>\n<p>指定的大小如 100dp，或者 match_parent(实质上就是屏幕大小)，都是确切的尺寸</p>\n</blockquote>\n</li>\n<li><p>AT_MOST</p>\n<p>子布局想要多大就可以多大，但是一般来说不会超过父布局的尺寸；</p>\n<blockquote>\n<p>一般对应的父布局尺寸为 wrap_content，父布局无法确定子布局的尺寸</p>\n</blockquote>\n</li>\n</ul>\n<p>为了节约内存占用，MeasureSpec 本身就是一个 32 位的 int 值，这个类就是负责将 &lt;size, mode&gt; 的元组转换为 int 值，高 2 位表示 specMode，低 30 位表示 specSize。</p>\n<p><strong>一个 View 的大小并不是由它自己确定的，而是由其自身的 LayoutParams 以及父布局的 MeasureSpec 确定的。</strong></p>\n<p>那 MeasureSpec 是什么，最初的 MeasureSpec 又是哪里来的？</p>\n<h3 id=\"MeasureSpec-缘起\"><a href=\"#MeasureSpec-缘起\" class=\"headerlink\" title=\"MeasureSpec 缘起\"></a>MeasureSpec 缘起</h3><p>由于 View 的绘制流程入口在 ViewRootImpl 类中，我们最终在 performTraversals 方法中找到如下代码：</p>\n<pre><code class=\"java\">    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);\n         int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);\n         // Ask host how big it wants to be\n         performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n</code></pre>\n<p>很明显在执行测量的最初，系统是通过 <code>getRootMeasureSpec</code> 方法获取到宽高的 MeasureSpec 信息的。</p>\n<pre><code class=\"java\">private static int getRootMeasureSpec(int windowSize, int rootDimension) {\n    int measureSpec;\n    switch (rootDimension) {\n        case ViewGroup.LayoutParams.MATCH_PARENT:\n            // Window can&#39;t resize. Force root view to be windowSize.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);\n            break;\n        case ViewGroup.LayoutParams.WRAP_CONTENT:\n            // Window can resize. Set max size for root view.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);\n            break;\n        default:\n            // Window wants to be an exact size. Force root view to be that size.\n            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);\n            break;\n    }\n    return measureSpec;\n}\n</code></pre>\n<p>很明显，通过这个方法我们可以发现，在 View 测量的入口，specSize 是固定的 windowSize，而 MATCH_PARENT 对应的测量模式是 EXACTLY，WRAP_CONTENT 对应的测量模式是 AT_MOST。我们会发现，每个 MeasureSpec 都是通过 <code>MeasureSpec.makeMeasureSpec</code> 生成的。</p>\n<p>SpecMode 和 SpecSize 组成了 MeasureSpec，MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象创建，并提供了对应的打包、解包方法：</p>\n<pre><code class=\"java\">public static int makeMeasureSpec(int size, int mode) {\n    if (sUseBrokenMakeMeasureSpec) {\n        // 二进制的 + ，不是十进制\n          // 使用一个32位的二进制数，其中：32和31位代表测量模式（mode）、后30位代表测量大小（size）\n        // 例如size=100(就是十进制的 4)，mode=AT_MOST，measureSpec=100+1000...00=1000..00100  \n        return size + mode;\n    } else {\n        return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);\n    }\n}\n\npublic static int getMode(int measureSpec) {\n      // MODE_MASK = 运算遮罩 = 11 00000000000(11后跟30个0)\n      // 原理：保留measureSpec的高2位（即测量模式）、使用0替换后30位\n    return (measureSpec &amp; MODE_MASK);\n}\n\npublic static int getSize(int measureSpec) {\n    // 原理：同上，将 MASK 取反，得到 00 1111111111(00后跟30个1) \n    // 将 32,31 替换成 0 也就是去掉了 mode，只保留后30位的size\n    return (measureSpec &amp; ~MODE_MASK);\n}\n</code></pre>\n<p>现在我们得到了 MeasureSpec，现在来看看父布局是怎么通过 MeasureSpec 支配子布局的。</p>\n<p>以下代码截取自 LinearLayout 的 measureVertical 方法：</p>\n<pre><code class=\"java\">final LayoutParams lp = (LayoutParams) child.getLayoutParams();\nfinal int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(\n        Math.max(0, childWidth), MeasureSpec.EXACTLY);\nfinal int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,\n        mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin,\n        lp.height);\n// 传到各个子 View 的 MeasureSpec 就是在这里生成的\nchild.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n</code></pre>\n<p>我们可以发现，由于是测量竖直方向的线性布局，布局的宽度是固定的，所以直接调用 MeasureSpec 生成宽度的规格，同时为其指定测量模式为 MeasureSpec.EXACTLY；高度因为比较复杂，调用了 <code>getChildMeasureSpec</code> 生成，传入了当前 LinearLayout 的父布局为其指定的 MeasureSpec 以及当前子 View 的 LayoutParams：</p>\n<pre><code class=\"java\">/**\n * ViewGroup#getChildMeasureSpec\n * \n * @param spec 父布局的 MeasureSpec\n * @param padding 子布局的 margin+padding\n * @param childDimension 子布局的高度信息，lp.height\n * @return\n */\npublic static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n      // 获取父布局，也就是 LinearLayout 的测量模式以及测量大小\n    int specMode = MeasureSpec.getMode(spec);\n    int specSize = MeasureSpec.getSize(spec);\n\n      // 记录一下除去 padding 的测量大小，但是不一定会用，具体要看父布局的 mode 以及子布局自身的 size \n    int size = Math.max(0, specSize - padding);\n\n      // 当前 child 的 size 和 mode\n    int resultSize = 0;\n    int resultMode = 0;\n\n    // 判断一下父布局的测量规格，看看是 match 还是 wrap\n    switch (specMode) {\n        // 如果是 EXACTLY，说明父布局是有固定大小的，或者是定死的 100dp，或者是 match_parent 的屏幕宽度\n        case MeasureSpec.EXACTLY: // 值为 -2\n                // 在这种情况下，如果子布局的高度信息是有确定值的，那说明用户声明了固定的 100dp 等信息\n                 // 那就让子布局的宽高信息固定，同时设置测量模式同样为 EXACTLY\n            if (childDimension &gt;= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                // 如果子布局想要充满父布局，那就让它和父布局一样大，然后设置测量模式同样为 EXACTLY\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                // 子布局想自己决定自己的大小，但是它最大不能超过父布局，所以模式是 AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 如果是 AT_MOST，说明父布局是包裹内容，那子布局不能超过父布局的大小\n        case MeasureSpec.AT_MOST:\n            if (childDimension &gt;= 0) {\n                // 全部同上\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                  // 父布局都不知道自己的大小，只能告诉子布局最大不能超过自己，所以模式只能是 AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 父布局不对子布局做任何限制，想多大多大，一般多见于ListView、GridView\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension &gt;= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should\n                // be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size.... find out how\n                // big it should be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            }\n            break;\n    }\n    // 用父布局的 MeasureSpec 和 child 的 lp，为其生成自己的测量规格\n    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n}\n</code></pre>\n<h3 id=\"做个小总结\"><a href=\"#做个小总结\" class=\"headerlink\" title=\"做个小总结\"></a>做个小总结</h3><p>说到这里，大家也应该能理解「一个 View 的大小是由它的父布局和它自身共同决定的」是什么意思了。</p>\n<p>这里简单做个总结：</p>\n<ol>\n<li><p>MeasureSpec 的 UNSPECIFIED 测量模式一般见于系统内部，并不多见，不做过多讨论，目前已知的应用就是 ScrollView 嵌套 ListView 只能显示一行，就是由于 ScrollView 在测量子 View 的时候，向下传递的测量模式为 MeasureSpec.UNSPECIFIED ，同时 ListView 的 onMeasure 方法是这样的：</p>\n<pre><code class=\"java\">// 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + padding\nif (heightMode == MeasureSpec.UNSPECIFIED) {\n       heightSize = mListPadding.top + mListPadding.bottom + \n             childHeight + getVerticalFadingEdgeLength() * 2;\n}\n</code></pre>\n<p>这就导致了最终 ListView 的高度只有一行，感兴趣的可以看一下<a href=\"https://www.jianshu.com/p/061f734af3e9\" target=\"_blank\" rel=\"noopener\">ScrollView 嵌套 ListView 的解决方法的原理</a>，这里就不再过多介绍了；</p>\n</li>\n<li><p><strong>当子 View 设置了固定值的时候，无论父布局的测量模式是什么，<em><u>子 View 的大小都遵循这个固定值，</u></em><u><em>即使超出屏幕</em></u>，且测量模式都为精确模式，即 MeasureSpec.EXACTLY</strong>；</p>\n</li>\n<li><p><strong>当子 View 为 match_parent 时，其 specMode 跟随父布局的 specMode</strong>，<em><u>父布局固定，那你充满父布局，你肯定也固定，就是 EXACTLY；父布局包裹内容，不能确定自己多大，那你肯定也不能知道自己多大，那就 AT_MOST</u></em>；<strong>其 specSize 也就是父布局的 size，不会超过父布局的大小；</strong></p>\n</li>\n<li><p><strong>当子 View 为 wrap_content 时，那它的 specMode 是 AT_MOST，specSize 就是父布局的 size，因为虽然其不能确定宽高，但是始终不能超过父布局的大小。</strong></p>\n</li>\n</ol>\n<h3 id=\"🌰\"><a href=\"#🌰\" class=\"headerlink\" title=\"🌰\"></a>🌰</h3><p>一直贴代码，说理论多少有点枯燥，贴点图片，看看🌰</p>\n<h4 id=\"父布局为-EXACTLY\"><a href=\"#父布局为-EXACTLY\" class=\"headerlink\" title=\"父布局为 EXACTLY\"></a>父布局为 EXACTLY</h4><ol>\n<li><p>ViewGroup: match_parent, Child: 500dp x 500dp</p>\n</li>\n<li><p>ViewGroup: 300dp x 300dp, Child: 500dp x 500dp</p>\n<blockquote>\n<p>父布局测量规格是精确模式，测量大小是屏幕大小；</p>\n<p>子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式</p>\n</blockquote>\n<pre><code class=\"java\">// 布局如下\n&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;300dp&quot;\n        android:layout_height=&quot;300dp&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180646.png\" alt=\"\"></p>\n</li>\n<li><p>ViewGroup: match_parent, child: match_parent</p>\n<blockquote>\n<p>父布局、子布局均充满屏幕，测量模式都为 MeasureSpec.EXACTLY，测量大小均为屏幕大小</p>\n</blockquote>\n<pre><code class=\"JAVA\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180825.png\" alt=\"\"></p>\n</li>\n<li><p>ViewGroup: match_parent, child: wrap_content</p>\n<blockquote>\n<p>父布局充满屏幕，测量模式是精确模式，测量大小是屏幕大小；</p>\n<p>子布局包裹内容，测量模式是 AT_MOST，但是不能超过父布局，测量大小为屏幕大小</p>\n</blockquote>\n<pre><code class=\"java\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180934.png\" alt=\"\"></p>\n</li>\n</ol>\n<h4 id=\"父布局为-WRAP-CONTENT\"><a href=\"#父布局为-WRAP-CONTENT\" class=\"headerlink\" title=\"父布局为 WRAP_CONTENT\"></a>父布局为 WRAP_CONTENT</h4><ol>\n<li><p>ViewGroup: wrap_content, child: match_parent</p>\n<blockquote>\n<p>父布局测量规格是 AT_MOST，测量大小是屏幕大小；</p>\n<p>子布局测量规格 AT_MOST，但是无法超过父布局大小，测量大小也是屏幕大小；</p>\n</blockquote>\n<pre><code class=\"java\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181341.png\" alt=\"\"></p>\n</li>\n<li><p>ViewGroup: wrap_content, child: 300dp x 300dp</p>\n<blockquote>\n<p>父布局测量规格是 AT_MOST，测量大小是屏幕大小；</p>\n<p>子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式</p>\n</blockquote>\n<pre><code class=\"java\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;300dp&quot;\n        android:layout_height=&quot;300dp&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181429.png\" alt=\"\"></p>\n</li>\n<li><p>ViewGroup: wrap_content, child: wrap_content</p>\n<blockquote>\n<p>父布局测量规格是 AT_MOST，测量大小是屏幕大小；</p>\n<p>子布局也不知道自己多大，测量规格是 AT_MOST，不能超过父布局，测量大小是屏幕大小；</p>\n</blockquote>\n<pre><code class=\"java\">&lt;com.ljt.rvanalysis.spec.MyLinearLayout\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;com.ljt.rvanalysis.spec.MyTextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181519.png\" alt=\"\"></p>\n</li>\n</ol>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181408.jpg","title":"Java 中的多线程","date":"2018-08-24T16:00:00.000Z","_content":"\n> Efficient.Android.Threading 第二章读书笔记\n\n<!--more-->\n\n所有 Android 应用都应该进行多线程编程，因为其可以大幅度的提高应用的性能以及响应效果；但是也会由此带来一系列的问题，导致编码的过程更加复杂。\n\n- 处理 Java 并发\n- 在多个线程中保证共享数据的稳定性\n- 定制以及优化不同线程的执行策略\n\n### 线程基础\n\n线程 `thread` 是 CPU 最小调度单元，一般来讲，一个应用中的任务会按代码顺序来执行。线程中待执行的代码被称作任务 `task`。一个线程可以只执行一个任务，也可以按顺序执行多个任务。\n\n#### 线程的执行\n\nAndroid 应用中的常用线程即 `java.lang.Thread`，线程生命周期的长度取决于执行任务的大小以及耗时。\n\n线程支持执行实现了 `java.lang.Runnable` 接口的任务，具体的任务是实现在 `run` 方法中的，具体如下：\n\n```java\nprivate class MyTask implements Runnable { \n    public void run() {\n        // 在 run 方法中直接或间接调用到的所有局部变量，都将存储在该线程本地内存堆栈中\n\t\tint i = 0; \n    }\n}\n```\n\n通过实例化和启动 Thread 对象，来启动任务的执行：\n\n```java\nThread thread = new Thread(new MyTask());\nthread.start();\n```\n\n从操作系统层面来说，线程同时具有指令和堆栈指针。指令指针引用要处理的下一条指令，堆栈指针指向一个私有内存区域（对其他线程不可见），该区域用于存储当前线程的数据。当前线程的数据 `thread local data` 一般指的是在 Java 方法中定义的变量信息。\n\n一般来讲，系统都希望能将 CPU 最大限度的利用起来，但矛盾的地方在于，同一 CPU 在同一时间只能运行一个线程。在这种情况下，为了让用户感知不同的程序正在同时运行，就必须让 CPU 忙起来，在不同的线程之间来回切换，进行任务的执行，这个过程被称为线程的调度` scheduler`。在 Java 中，线程调度的基准是线程的优先级 `priority` ，优先级默认为 5，范围为 1-8 。\n\n但是，如果线程的调度是完全基于优先级的话，就有可能导致低优先级的线程任务永远得不到执行，也就是所谓的饥饿致死。为解决这个问题，Java 调度器在执行线程调度时，还会将线程的执行时间列入考虑的范围。\n\n每次不同线程的切换被称为上下文切换 `context switch` 。每次进行上下文切换时，CPU 会先将当前正在执行的线程状态进行保存，以方便下一次恢复当前线程的执行；其后暂停当前线程，同时恢复另一线程的执行。\n\n具体的线程调度可以通过下图进行理解，图中的 C 就是上下文切换的过程。\n\n![线程调度示例](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182552.jpg)\n\n#### 单线程应用\n\n每个应用至少会有一个线程，也就是我们所熟知的主线程，默认情况下，编写的代码都将在这个线程中进行执行。\n\n单线程编程是最简单的编码方式，但是很多情况下这种方式并不能满足我们的需求，因此，我们就需要将代码分别运行在不同的线程中，从而保证代码执行的高效性以及程序的性能。\n\n#### 多线程应用\n\n如果执行线程的数量超过处理器数量，则无法实现真正的并发，但调度程序在要处理的线程之间快速切换，以便将每个代码路径拆分为按顺序处理的执行间隔。尽管多线程编程会极大的提高应用的性能，但是这是有一定代价的。具体表现为：复杂性的提高，内存开销的增加，不确定的执行顺序等。\n\n##### 复杂性提高，不确定的执行顺序\n\n分析单线程应用程序的执行相对简单，因为执行顺序是已知的。在多线程应用程序中，分析程序如何执行以及代码以何种顺序处理要困难得多。执行顺序在线程之间是不确定的，因为调度器将如何分配执行时间给线程是未知的。因此，多线程的执行过程是不确定的。这种不确定性不仅使代码中的错误调试变得更加困难，而且协调线程的过程中也有很大可能会引入新的错误。\n\n##### 资源开销的增加\n\n线程在内存和处理器使用方面具有开销。之前提到过，每个线程都会申请一块私有内存区域，用来存储线程数据。这片私有内存在线程创建之初就会申请出来备用，直到线程终止才会被回收并重新分配。在这个过程中，只要当前线程是存活的，即便它是闲置或是阻塞状态，也会持续占用系统资源。\n\n处理器的开销主要来自于初始化、回收线程，以及在上下文切换中存储和恢复线程。执行的线程越多，上下文切换就越多，性能就越差。\n\n##### 数据不一致\n\n多线程程序对资源的访问还会产生一个新的问题，就是数据的共享。如果两个或更多线程同时操作某一个数据，则我们无法确定哪个线程正在对这个数据进行什么样的操作，这就导致了最后数据的不可靠性。\n\n因为上下文切换可能发生在一个线程中不应中断的位置(比如正在对某个关键性数据进行操作时），所以必须创建代码指令的原子区域 `atomic region`。如果线程在原子区域中执行，则其他线程将被阻塞，直到在原子区域中没有其他线程执行。因此，Java中的原子区被认为是互斥的，因为它只允许访问一个线程。\n\n可以用不同的方式创建原子区域  `atomic region`，但是最基本的同步机制是 `synchronized` 关键字 ：\n\n```java\nsynchronized (this) { \n    sharedResource++;\n}\n```\n\n如果对共享资源的每次访问都是同步的，那么尽管多线程访问，数据也都将是一致的。\n\n\n\n### 线程安全\n\n在多线程应用中，共享资源有可能会被多方同时访问，同时读写，这就导致了数据的不可靠性。在这种情况下，需要通过使用锁定机制来实现同步。\n\nAndroid 中的锁定机制主要包括两种：\n\n- 对象内在锁定\n\n  `synchronized` 关键字\n\n- 显式锁\n\n  `java.util.concurrent.locks.ReentrantLock`\n  `java.util.concurrent.locks.ReentrantReadWriteLock`\n\n\n#### 内在锁和Java监视器\n\n`synchronized` 关键字适用于每个 Java 对象，其内部包含一个隐式可用的锁。内部锁是互斥的，这意味着同步关键字的代码区域（临界区）中的线程执行是某一个线程独占的。当临界区被占用时，其他线程则会处于阻塞状态，在同步锁释放前，该线程代码无法继续正常执行。\n\n内在锁充当一个监视器的角色，该监视器有三种状态：\n\n1. 阻塞状态 `Blocked`\n\n   当前线程要等待正在被其他线程占用的内在锁，从而处于挂起状态；\n\n2. 运行状态 `Executing`\n\n   当前线程唯一占据内部锁并且正在临界区内执行代码；\n\n3. 等待状态 `Waiting`\n\n   当前线程刚刚将临界区代码执行完毕，主动释放了锁；并等待下次获取内部锁；\n\n![Java监视器示例](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182549.jpg)\n\n一个完整的线程锁工作流大体如下：\n\n1. `Enter the monitor`\n\n   某个线程尝试去操作被同步锁锁住的的代码片段，此时该线程进入 Java 监视器中，如果当前同步锁被其他线程占用，则当前线程挂起；\n\n2. `Acquire the lock`\n\n   如果当前同步锁处于空闲状态，则阻塞状态的线程则可以获取锁，并进入同步代码块开始执行。如果有多个线程阻塞等待，则由调度器决定谁将获取锁，而并不是先来后到的；\n\n3. `Release the lock and wait`\n\n   满足某种条件后，持有锁对象的线程会主动调用锁对象的 `Object.wait()` 将锁资源释放，然后等待满足某种条件后，重新获取执行权；\n\n4. `Acquire the lock after signal`\n\n   如果某个等待状态的线程被调度器选择为下一个执行线程，则它会在其他线程调用 `Object.notify()` 或者 `Objecct.notifyAll()` 时，获得同步锁并进入同步代码块；需要注意的是，等待线程相比较于阻塞线程并没有绝对的优先权，因为二者都想执行这部分同步代码，也就是说最终的选择权在于调度器；\n\n5. `Release the lock and exit the monitor`\n\n   在代码执行完毕后，线程会退出监视器，让其他真正有需要的线程做操作。\n\n\n\n具体的同步代码块示例：\n\n```java\n// (1) \nsynchronized (this) { \n    // Execute code (2) \n    wait(); // (3)\n\t// Execute code (4)\n} \n// (5)\n```\n\n#### 同步对共享资源的访问\n\n在多线程应用中，共享资源可能被多方同时获取及修改，这种情况下就需要有一个有效的同步机制，来保证多线程下数据的统一性。这种机制具体包括同步锁类型的选择，以及同步代码块范围的设定。\n\n##### 使用内部锁\n\n`synchronized` 关键字有多种使用方式：\n\n- 作用在方法上\n\n  ```java\n  synchronized void changeState() { \n      sharedResource++;\n  }\n  ```\n\n- 同步代码块，使用当前类作为同步锁\n\n  ```java\n  void changeState() { \n      synchronized(this) {\n      \tsharedResource++;\n      }\n  }\n  ```\n\n- 同步代码块，使用其他对象作为同步锁\n\n  ```java\n  private final Object mLock = new Object();\n  void changeState() { \n      synchronized(mLock) {\n      \tsharedResource++;\n      } \n  }\n  ```\n\n- 作用于静态方法\n\n  ```java\n  synchronized static void changeState() { \n      staticSharedResource++;\n  }\n  ```\n\n- 静态方法的同步代码块，使用当前类作为同步锁\n\n  ```java\n  static void changeState() { \n      synchronized(this.getClass()) {\n      \tstaticSharedResource++;\n      }\n  }\n  ```\n\n使用 this 在代码块内作为同步锁，与直接在方法上加 `synchronized` 关键字是相同的。但是更建议使用同步代码块，因为不一定方法内的全部代码都需要保证同步，滥用同步有可能导致不必要的性能损耗。\n\n值得注意的是，作用于静态方法的同步锁对象是当前 Class 类对象，而并非其实例对象。\n\n##### 使用显式锁机制\n\n`ReentrantLock` 和 `ReentrantReadWriteLock` 类可以用来替代 `synchronized` 关键字充当监视器。这种情况下，同步代码块的锁定和解锁都是由调用者手动调用的。\n\n```java\n// ReentrantLock 显式锁调用示例\nint sharedResource;\nprivate ReentrantLock mLock = new ReentrantLock();\n\npublic void changeState(){\n    mLock.lock();\n    try{\n        sharedResource ++;\n    }\n    finally{\n        mLock.unlock();\n    }\n}\n```\n\n`ReentrantLock` 和 `synchronized` 关键字语义相同，都会将同步代码块隔离开，保证只有一个线程能够对其进行操作。二者都是一种防御性策略，假设所有并发访问都存在问题，但多线程同时读取共享变量并不是有害的。因此，synchronized 和 ReentrantLock 可能存在过度保护。\n\n`ReentrantReadWriteLock` 则允许多个线程对共享数据同时进行读取，但是仍然禁止同时读写或者同时写入。示例代码如下：\n\n```java\n// ReentrantReadWriteLock 显式锁调用示例\nint sharedResource;\nprivate ReentrantReadWriteLock mLock = new ReentrantReadWriteLock();\n\npublic void changeState() { \n    mLock.writeLock().lock(); \n    try {\n        sharedResource++;\n    }\n    finally{\n        mLock.unlock();\n    }\n}\n\npublic int readState(){\n    mLock.readLock().lock();\n    try{\n        return sharedResource;\n    }\n    finally{\n        mLock.readLock().unlock();\n    }\n}\n```\n\n`ReentrantReadWriteLock` 相对复杂，从而会对性能造成影响。因为相对于 `ReentrantLock` 和 `synchronized` 来讲，`ReentrantReadWriteLock` 要花费更多的时间去判断应不应该阻塞当前线程，这也相当于是让读取操作同步执行的一种妥协。实际上，`ReentrantReadWriteLock` 的典型应用应该是多个线程进行读取，但只有少量线程会进行写入操作。\n\n#### 生产者消费者模型\n\n生产者消费者是线程协作的经典模型，生产者线程和消费者线程共享一个列表，当该列表为空时，生产者线程向其中添加商品；如果列表不为空，则消费者线程会将商品移除。也就是说，当列表为空时，消费者线程应该阻塞等待；当列表已满时，生产者线程应该阻塞等待。\n\n`ComsumerProducer` 类包括两个线程，一个生产者线程，一个消费者线程，二者共享一个 LinkedList 对象，分别对其进行增加和删除操作：\n\n```java\npublic class ConsumerProducer{\n    private LinkedList<Integer> list = new LinkedList<>();\n    private final int LIMIT = 10;\n    private Object lock = new Object();\n    \n    public void produce(){\n        int value = 0;\n        while(true){\n            synchronized(lock){\n                while(list.size() == LIMIT){\n                    lock.wait();\n                }\n                list.add(value++);\n\t\t\t\tlock.notify();\n            }\n        }\n    }\n    \n    public void consume(){\n        int value = 0;\n        while(true){\n            synchronized(lock){\n                while(list.size() == 0){\n                    lock.wait();\n                }\n                list.removeFirst();\n                lock.notify();\n            }\n        }\n    } \n}\n```\n\n生产者线程和消费者线程共用同一把锁，来保证共享数据 list 的一致性。当列表为满时，生产者主动挂起等待；当列表为空时，消费者主动挂起等待。两个线程在挂起的同时，又会调用 `lock.notify()` 给正在等待的对方发送信号，通知其获取同步锁并执行代码，从而完成共享数据的同步。\n\n```java\nfinal ConsumerProducer cp = new ConsumerProducer();\n\n// producer\nnew Thread(new Runnable(){\n    @Override\n    public void run(){\n        cp.produce();\n    }\n}).start();\n\n// consumer\nnew Thread(new Runnable(){\n    @Override\n    public void run(){\n        cp.consume();\n    }\n}).start();\n```\n\n\n\n#### 任务执行策略\n\n一般来讲，两种极端的执行策略如下：\n\n1. 所有的任务都执行在同一线程上\n2. 每一个任务都对应一个线程\n\n很明显上述两种策略都过于极端：前者效率过低，后者大量的线程初始化和回收会造成大量的性能消耗。尽管如此，上述两种策略还是目前最常用的两种执行方式：\n\n1. 顺序执行\n\n   各个任务按照先后顺序进行执行，各任务的执行时间不会有重叠。这样做的优势是数据绝对安全，而且只有一个线程执行，占用内存会比多线程更少；缺点在于吞吐量过低，一个任务的执行与否取决于前一个任务能否成功完成；\n\n2. 并发执行\n\n   所有的任务都并行执行，最大化利用 CPU ，但是会带来数据的不安全性，需要进行同步机制规避。\n\n一个出色的执行策略应该是顺序执行和并发执行并重的。相对独立的任务应该并发执行以提高效率，但是有相对严格执行顺序的任务则应该执行在单一线程中。\n\n##### 并发执行设计原则\n\n- 控制新线程的重复创建，而应该注意对已有线程的复用，从而降低创建、回收线程的频率\n- 提高线程使用效率，多余的线程对于内存和处理器都是一种资源浪费\n\n\n\n#### 总结\n\nAndroid应用程序应该是多线程的，以提高单处理器和多处理器平台的性能。线程可以在单个处理器上顺序执行，或者在多个处理器可用时实现真正的并发。性能的提高是以增加复杂性为代价的，同样需要维护同步机制，以保证线程之间共享资源数据的一致性。\n\n","source":"_posts/Efficient-Android-Threading-chapter-2.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181408.jpg\ntitle: Java 中的多线程\ntags: [读书笔记, Efficient.Android.Threading]\ndate: 2018-08-25\n---\n\n> Efficient.Android.Threading 第二章读书笔记\n\n<!--more-->\n\n所有 Android 应用都应该进行多线程编程，因为其可以大幅度的提高应用的性能以及响应效果；但是也会由此带来一系列的问题，导致编码的过程更加复杂。\n\n- 处理 Java 并发\n- 在多个线程中保证共享数据的稳定性\n- 定制以及优化不同线程的执行策略\n\n### 线程基础\n\n线程 `thread` 是 CPU 最小调度单元，一般来讲，一个应用中的任务会按代码顺序来执行。线程中待执行的代码被称作任务 `task`。一个线程可以只执行一个任务，也可以按顺序执行多个任务。\n\n#### 线程的执行\n\nAndroid 应用中的常用线程即 `java.lang.Thread`，线程生命周期的长度取决于执行任务的大小以及耗时。\n\n线程支持执行实现了 `java.lang.Runnable` 接口的任务，具体的任务是实现在 `run` 方法中的，具体如下：\n\n```java\nprivate class MyTask implements Runnable { \n    public void run() {\n        // 在 run 方法中直接或间接调用到的所有局部变量，都将存储在该线程本地内存堆栈中\n\t\tint i = 0; \n    }\n}\n```\n\n通过实例化和启动 Thread 对象，来启动任务的执行：\n\n```java\nThread thread = new Thread(new MyTask());\nthread.start();\n```\n\n从操作系统层面来说，线程同时具有指令和堆栈指针。指令指针引用要处理的下一条指令，堆栈指针指向一个私有内存区域（对其他线程不可见），该区域用于存储当前线程的数据。当前线程的数据 `thread local data` 一般指的是在 Java 方法中定义的变量信息。\n\n一般来讲，系统都希望能将 CPU 最大限度的利用起来，但矛盾的地方在于，同一 CPU 在同一时间只能运行一个线程。在这种情况下，为了让用户感知不同的程序正在同时运行，就必须让 CPU 忙起来，在不同的线程之间来回切换，进行任务的执行，这个过程被称为线程的调度` scheduler`。在 Java 中，线程调度的基准是线程的优先级 `priority` ，优先级默认为 5，范围为 1-8 。\n\n但是，如果线程的调度是完全基于优先级的话，就有可能导致低优先级的线程任务永远得不到执行，也就是所谓的饥饿致死。为解决这个问题，Java 调度器在执行线程调度时，还会将线程的执行时间列入考虑的范围。\n\n每次不同线程的切换被称为上下文切换 `context switch` 。每次进行上下文切换时，CPU 会先将当前正在执行的线程状态进行保存，以方便下一次恢复当前线程的执行；其后暂停当前线程，同时恢复另一线程的执行。\n\n具体的线程调度可以通过下图进行理解，图中的 C 就是上下文切换的过程。\n\n![线程调度示例](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182552.jpg)\n\n#### 单线程应用\n\n每个应用至少会有一个线程，也就是我们所熟知的主线程，默认情况下，编写的代码都将在这个线程中进行执行。\n\n单线程编程是最简单的编码方式，但是很多情况下这种方式并不能满足我们的需求，因此，我们就需要将代码分别运行在不同的线程中，从而保证代码执行的高效性以及程序的性能。\n\n#### 多线程应用\n\n如果执行线程的数量超过处理器数量，则无法实现真正的并发，但调度程序在要处理的线程之间快速切换，以便将每个代码路径拆分为按顺序处理的执行间隔。尽管多线程编程会极大的提高应用的性能，但是这是有一定代价的。具体表现为：复杂性的提高，内存开销的增加，不确定的执行顺序等。\n\n##### 复杂性提高，不确定的执行顺序\n\n分析单线程应用程序的执行相对简单，因为执行顺序是已知的。在多线程应用程序中，分析程序如何执行以及代码以何种顺序处理要困难得多。执行顺序在线程之间是不确定的，因为调度器将如何分配执行时间给线程是未知的。因此，多线程的执行过程是不确定的。这种不确定性不仅使代码中的错误调试变得更加困难，而且协调线程的过程中也有很大可能会引入新的错误。\n\n##### 资源开销的增加\n\n线程在内存和处理器使用方面具有开销。之前提到过，每个线程都会申请一块私有内存区域，用来存储线程数据。这片私有内存在线程创建之初就会申请出来备用，直到线程终止才会被回收并重新分配。在这个过程中，只要当前线程是存活的，即便它是闲置或是阻塞状态，也会持续占用系统资源。\n\n处理器的开销主要来自于初始化、回收线程，以及在上下文切换中存储和恢复线程。执行的线程越多，上下文切换就越多，性能就越差。\n\n##### 数据不一致\n\n多线程程序对资源的访问还会产生一个新的问题，就是数据的共享。如果两个或更多线程同时操作某一个数据，则我们无法确定哪个线程正在对这个数据进行什么样的操作，这就导致了最后数据的不可靠性。\n\n因为上下文切换可能发生在一个线程中不应中断的位置(比如正在对某个关键性数据进行操作时），所以必须创建代码指令的原子区域 `atomic region`。如果线程在原子区域中执行，则其他线程将被阻塞，直到在原子区域中没有其他线程执行。因此，Java中的原子区被认为是互斥的，因为它只允许访问一个线程。\n\n可以用不同的方式创建原子区域  `atomic region`，但是最基本的同步机制是 `synchronized` 关键字 ：\n\n```java\nsynchronized (this) { \n    sharedResource++;\n}\n```\n\n如果对共享资源的每次访问都是同步的，那么尽管多线程访问，数据也都将是一致的。\n\n\n\n### 线程安全\n\n在多线程应用中，共享资源有可能会被多方同时访问，同时读写，这就导致了数据的不可靠性。在这种情况下，需要通过使用锁定机制来实现同步。\n\nAndroid 中的锁定机制主要包括两种：\n\n- 对象内在锁定\n\n  `synchronized` 关键字\n\n- 显式锁\n\n  `java.util.concurrent.locks.ReentrantLock`\n  `java.util.concurrent.locks.ReentrantReadWriteLock`\n\n\n#### 内在锁和Java监视器\n\n`synchronized` 关键字适用于每个 Java 对象，其内部包含一个隐式可用的锁。内部锁是互斥的，这意味着同步关键字的代码区域（临界区）中的线程执行是某一个线程独占的。当临界区被占用时，其他线程则会处于阻塞状态，在同步锁释放前，该线程代码无法继续正常执行。\n\n内在锁充当一个监视器的角色，该监视器有三种状态：\n\n1. 阻塞状态 `Blocked`\n\n   当前线程要等待正在被其他线程占用的内在锁，从而处于挂起状态；\n\n2. 运行状态 `Executing`\n\n   当前线程唯一占据内部锁并且正在临界区内执行代码；\n\n3. 等待状态 `Waiting`\n\n   当前线程刚刚将临界区代码执行完毕，主动释放了锁；并等待下次获取内部锁；\n\n![Java监视器示例](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182549.jpg)\n\n一个完整的线程锁工作流大体如下：\n\n1. `Enter the monitor`\n\n   某个线程尝试去操作被同步锁锁住的的代码片段，此时该线程进入 Java 监视器中，如果当前同步锁被其他线程占用，则当前线程挂起；\n\n2. `Acquire the lock`\n\n   如果当前同步锁处于空闲状态，则阻塞状态的线程则可以获取锁，并进入同步代码块开始执行。如果有多个线程阻塞等待，则由调度器决定谁将获取锁，而并不是先来后到的；\n\n3. `Release the lock and wait`\n\n   满足某种条件后，持有锁对象的线程会主动调用锁对象的 `Object.wait()` 将锁资源释放，然后等待满足某种条件后，重新获取执行权；\n\n4. `Acquire the lock after signal`\n\n   如果某个等待状态的线程被调度器选择为下一个执行线程，则它会在其他线程调用 `Object.notify()` 或者 `Objecct.notifyAll()` 时，获得同步锁并进入同步代码块；需要注意的是，等待线程相比较于阻塞线程并没有绝对的优先权，因为二者都想执行这部分同步代码，也就是说最终的选择权在于调度器；\n\n5. `Release the lock and exit the monitor`\n\n   在代码执行完毕后，线程会退出监视器，让其他真正有需要的线程做操作。\n\n\n\n具体的同步代码块示例：\n\n```java\n// (1) \nsynchronized (this) { \n    // Execute code (2) \n    wait(); // (3)\n\t// Execute code (4)\n} \n// (5)\n```\n\n#### 同步对共享资源的访问\n\n在多线程应用中，共享资源可能被多方同时获取及修改，这种情况下就需要有一个有效的同步机制，来保证多线程下数据的统一性。这种机制具体包括同步锁类型的选择，以及同步代码块范围的设定。\n\n##### 使用内部锁\n\n`synchronized` 关键字有多种使用方式：\n\n- 作用在方法上\n\n  ```java\n  synchronized void changeState() { \n      sharedResource++;\n  }\n  ```\n\n- 同步代码块，使用当前类作为同步锁\n\n  ```java\n  void changeState() { \n      synchronized(this) {\n      \tsharedResource++;\n      }\n  }\n  ```\n\n- 同步代码块，使用其他对象作为同步锁\n\n  ```java\n  private final Object mLock = new Object();\n  void changeState() { \n      synchronized(mLock) {\n      \tsharedResource++;\n      } \n  }\n  ```\n\n- 作用于静态方法\n\n  ```java\n  synchronized static void changeState() { \n      staticSharedResource++;\n  }\n  ```\n\n- 静态方法的同步代码块，使用当前类作为同步锁\n\n  ```java\n  static void changeState() { \n      synchronized(this.getClass()) {\n      \tstaticSharedResource++;\n      }\n  }\n  ```\n\n使用 this 在代码块内作为同步锁，与直接在方法上加 `synchronized` 关键字是相同的。但是更建议使用同步代码块，因为不一定方法内的全部代码都需要保证同步，滥用同步有可能导致不必要的性能损耗。\n\n值得注意的是，作用于静态方法的同步锁对象是当前 Class 类对象，而并非其实例对象。\n\n##### 使用显式锁机制\n\n`ReentrantLock` 和 `ReentrantReadWriteLock` 类可以用来替代 `synchronized` 关键字充当监视器。这种情况下，同步代码块的锁定和解锁都是由调用者手动调用的。\n\n```java\n// ReentrantLock 显式锁调用示例\nint sharedResource;\nprivate ReentrantLock mLock = new ReentrantLock();\n\npublic void changeState(){\n    mLock.lock();\n    try{\n        sharedResource ++;\n    }\n    finally{\n        mLock.unlock();\n    }\n}\n```\n\n`ReentrantLock` 和 `synchronized` 关键字语义相同，都会将同步代码块隔离开，保证只有一个线程能够对其进行操作。二者都是一种防御性策略，假设所有并发访问都存在问题，但多线程同时读取共享变量并不是有害的。因此，synchronized 和 ReentrantLock 可能存在过度保护。\n\n`ReentrantReadWriteLock` 则允许多个线程对共享数据同时进行读取，但是仍然禁止同时读写或者同时写入。示例代码如下：\n\n```java\n// ReentrantReadWriteLock 显式锁调用示例\nint sharedResource;\nprivate ReentrantReadWriteLock mLock = new ReentrantReadWriteLock();\n\npublic void changeState() { \n    mLock.writeLock().lock(); \n    try {\n        sharedResource++;\n    }\n    finally{\n        mLock.unlock();\n    }\n}\n\npublic int readState(){\n    mLock.readLock().lock();\n    try{\n        return sharedResource;\n    }\n    finally{\n        mLock.readLock().unlock();\n    }\n}\n```\n\n`ReentrantReadWriteLock` 相对复杂，从而会对性能造成影响。因为相对于 `ReentrantLock` 和 `synchronized` 来讲，`ReentrantReadWriteLock` 要花费更多的时间去判断应不应该阻塞当前线程，这也相当于是让读取操作同步执行的一种妥协。实际上，`ReentrantReadWriteLock` 的典型应用应该是多个线程进行读取，但只有少量线程会进行写入操作。\n\n#### 生产者消费者模型\n\n生产者消费者是线程协作的经典模型，生产者线程和消费者线程共享一个列表，当该列表为空时，生产者线程向其中添加商品；如果列表不为空，则消费者线程会将商品移除。也就是说，当列表为空时，消费者线程应该阻塞等待；当列表已满时，生产者线程应该阻塞等待。\n\n`ComsumerProducer` 类包括两个线程，一个生产者线程，一个消费者线程，二者共享一个 LinkedList 对象，分别对其进行增加和删除操作：\n\n```java\npublic class ConsumerProducer{\n    private LinkedList<Integer> list = new LinkedList<>();\n    private final int LIMIT = 10;\n    private Object lock = new Object();\n    \n    public void produce(){\n        int value = 0;\n        while(true){\n            synchronized(lock){\n                while(list.size() == LIMIT){\n                    lock.wait();\n                }\n                list.add(value++);\n\t\t\t\tlock.notify();\n            }\n        }\n    }\n    \n    public void consume(){\n        int value = 0;\n        while(true){\n            synchronized(lock){\n                while(list.size() == 0){\n                    lock.wait();\n                }\n                list.removeFirst();\n                lock.notify();\n            }\n        }\n    } \n}\n```\n\n生产者线程和消费者线程共用同一把锁，来保证共享数据 list 的一致性。当列表为满时，生产者主动挂起等待；当列表为空时，消费者主动挂起等待。两个线程在挂起的同时，又会调用 `lock.notify()` 给正在等待的对方发送信号，通知其获取同步锁并执行代码，从而完成共享数据的同步。\n\n```java\nfinal ConsumerProducer cp = new ConsumerProducer();\n\n// producer\nnew Thread(new Runnable(){\n    @Override\n    public void run(){\n        cp.produce();\n    }\n}).start();\n\n// consumer\nnew Thread(new Runnable(){\n    @Override\n    public void run(){\n        cp.consume();\n    }\n}).start();\n```\n\n\n\n#### 任务执行策略\n\n一般来讲，两种极端的执行策略如下：\n\n1. 所有的任务都执行在同一线程上\n2. 每一个任务都对应一个线程\n\n很明显上述两种策略都过于极端：前者效率过低，后者大量的线程初始化和回收会造成大量的性能消耗。尽管如此，上述两种策略还是目前最常用的两种执行方式：\n\n1. 顺序执行\n\n   各个任务按照先后顺序进行执行，各任务的执行时间不会有重叠。这样做的优势是数据绝对安全，而且只有一个线程执行，占用内存会比多线程更少；缺点在于吞吐量过低，一个任务的执行与否取决于前一个任务能否成功完成；\n\n2. 并发执行\n\n   所有的任务都并行执行，最大化利用 CPU ，但是会带来数据的不安全性，需要进行同步机制规避。\n\n一个出色的执行策略应该是顺序执行和并发执行并重的。相对独立的任务应该并发执行以提高效率，但是有相对严格执行顺序的任务则应该执行在单一线程中。\n\n##### 并发执行设计原则\n\n- 控制新线程的重复创建，而应该注意对已有线程的复用，从而降低创建、回收线程的频率\n- 提高线程使用效率，多余的线程对于内存和处理器都是一种资源浪费\n\n\n\n#### 总结\n\nAndroid应用程序应该是多线程的，以提高单处理器和多处理器平台的性能。线程可以在单个处理器上顺序执行，或者在多个处理器可用时实现真正的并发。性能的提高是以增加复杂性为代价的，同样需要维护同步机制，以保证线程之间共享资源数据的一致性。\n\n","slug":"Efficient-Android-Threading-chapter-2","published":1,"updated":"2019-03-21T10:51:40.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86dh0013lh1pkq0tk3hu","content":"<blockquote>\n<p>Efficient.Android.Threading 第二章读书笔记</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>所有 Android 应用都应该进行多线程编程，因为其可以大幅度的提高应用的性能以及响应效果；但是也会由此带来一系列的问题，导致编码的过程更加复杂。</p>\n<ul>\n<li>处理 Java 并发</li>\n<li>在多个线程中保证共享数据的稳定性</li>\n<li>定制以及优化不同线程的执行策略</li>\n</ul>\n<h3 id=\"线程基础\"><a href=\"#线程基础\" class=\"headerlink\" title=\"线程基础\"></a>线程基础</h3><p>线程 <code>thread</code> 是 CPU 最小调度单元，一般来讲，一个应用中的任务会按代码顺序来执行。线程中待执行的代码被称作任务 <code>task</code>。一个线程可以只执行一个任务，也可以按顺序执行多个任务。</p>\n<h4 id=\"线程的执行\"><a href=\"#线程的执行\" class=\"headerlink\" title=\"线程的执行\"></a>线程的执行</h4><p>Android 应用中的常用线程即 <code>java.lang.Thread</code>，线程生命周期的长度取决于执行任务的大小以及耗时。</p>\n<p>线程支持执行实现了 <code>java.lang.Runnable</code> 接口的任务，具体的任务是实现在 <code>run</code> 方法中的，具体如下：</p>\n<pre><code class=\"java\">private class MyTask implements Runnable { \n    public void run() {\n        // 在 run 方法中直接或间接调用到的所有局部变量，都将存储在该线程本地内存堆栈中\n        int i = 0; \n    }\n}\n</code></pre>\n<p>通过实例化和启动 Thread 对象，来启动任务的执行：</p>\n<pre><code class=\"java\">Thread thread = new Thread(new MyTask());\nthread.start();\n</code></pre>\n<p>从操作系统层面来说，线程同时具有指令和堆栈指针。指令指针引用要处理的下一条指令，堆栈指针指向一个私有内存区域（对其他线程不可见），该区域用于存储当前线程的数据。当前线程的数据 <code>thread local data</code> 一般指的是在 Java 方法中定义的变量信息。</p>\n<p>一般来讲，系统都希望能将 CPU 最大限度的利用起来，但矛盾的地方在于，同一 CPU 在同一时间只能运行一个线程。在这种情况下，为了让用户感知不同的程序正在同时运行，就必须让 CPU 忙起来，在不同的线程之间来回切换，进行任务的执行，这个过程被称为线程的调度<code>scheduler</code>。在 Java 中，线程调度的基准是线程的优先级 <code>priority</code> ，优先级默认为 5，范围为 1-8 。</p>\n<p>但是，如果线程的调度是完全基于优先级的话，就有可能导致低优先级的线程任务永远得不到执行，也就是所谓的饥饿致死。为解决这个问题，Java 调度器在执行线程调度时，还会将线程的执行时间列入考虑的范围。</p>\n<p>每次不同线程的切换被称为上下文切换 <code>context switch</code> 。每次进行上下文切换时，CPU 会先将当前正在执行的线程状态进行保存，以方便下一次恢复当前线程的执行；其后暂停当前线程，同时恢复另一线程的执行。</p>\n<p>具体的线程调度可以通过下图进行理解，图中的 C 就是上下文切换的过程。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182552.jpg\" alt=\"线程调度示例\"></p>\n<h4 id=\"单线程应用\"><a href=\"#单线程应用\" class=\"headerlink\" title=\"单线程应用\"></a>单线程应用</h4><p>每个应用至少会有一个线程，也就是我们所熟知的主线程，默认情况下，编写的代码都将在这个线程中进行执行。</p>\n<p>单线程编程是最简单的编码方式，但是很多情况下这种方式并不能满足我们的需求，因此，我们就需要将代码分别运行在不同的线程中，从而保证代码执行的高效性以及程序的性能。</p>\n<h4 id=\"多线程应用\"><a href=\"#多线程应用\" class=\"headerlink\" title=\"多线程应用\"></a>多线程应用</h4><p>如果执行线程的数量超过处理器数量，则无法实现真正的并发，但调度程序在要处理的线程之间快速切换，以便将每个代码路径拆分为按顺序处理的执行间隔。尽管多线程编程会极大的提高应用的性能，但是这是有一定代价的。具体表现为：复杂性的提高，内存开销的增加，不确定的执行顺序等。</p>\n<h5 id=\"复杂性提高，不确定的执行顺序\"><a href=\"#复杂性提高，不确定的执行顺序\" class=\"headerlink\" title=\"复杂性提高，不确定的执行顺序\"></a>复杂性提高，不确定的执行顺序</h5><p>分析单线程应用程序的执行相对简单，因为执行顺序是已知的。在多线程应用程序中，分析程序如何执行以及代码以何种顺序处理要困难得多。执行顺序在线程之间是不确定的，因为调度器将如何分配执行时间给线程是未知的。因此，多线程的执行过程是不确定的。这种不确定性不仅使代码中的错误调试变得更加困难，而且协调线程的过程中也有很大可能会引入新的错误。</p>\n<h5 id=\"资源开销的增加\"><a href=\"#资源开销的增加\" class=\"headerlink\" title=\"资源开销的增加\"></a>资源开销的增加</h5><p>线程在内存和处理器使用方面具有开销。之前提到过，每个线程都会申请一块私有内存区域，用来存储线程数据。这片私有内存在线程创建之初就会申请出来备用，直到线程终止才会被回收并重新分配。在这个过程中，只要当前线程是存活的，即便它是闲置或是阻塞状态，也会持续占用系统资源。</p>\n<p>处理器的开销主要来自于初始化、回收线程，以及在上下文切换中存储和恢复线程。执行的线程越多，上下文切换就越多，性能就越差。</p>\n<h5 id=\"数据不一致\"><a href=\"#数据不一致\" class=\"headerlink\" title=\"数据不一致\"></a>数据不一致</h5><p>多线程程序对资源的访问还会产生一个新的问题，就是数据的共享。如果两个或更多线程同时操作某一个数据，则我们无法确定哪个线程正在对这个数据进行什么样的操作，这就导致了最后数据的不可靠性。</p>\n<p>因为上下文切换可能发生在一个线程中不应中断的位置(比如正在对某个关键性数据进行操作时），所以必须创建代码指令的原子区域 <code>atomic region</code>。如果线程在原子区域中执行，则其他线程将被阻塞，直到在原子区域中没有其他线程执行。因此，Java中的原子区被认为是互斥的，因为它只允许访问一个线程。</p>\n<p>可以用不同的方式创建原子区域  <code>atomic region</code>，但是最基本的同步机制是 <code>synchronized</code> 关键字 ：</p>\n<pre><code class=\"java\">synchronized (this) { \n    sharedResource++;\n}\n</code></pre>\n<p>如果对共享资源的每次访问都是同步的，那么尽管多线程访问，数据也都将是一致的。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>在多线程应用中，共享资源有可能会被多方同时访问，同时读写，这就导致了数据的不可靠性。在这种情况下，需要通过使用锁定机制来实现同步。</p>\n<p>Android 中的锁定机制主要包括两种：</p>\n<ul>\n<li><p>对象内在锁定</p>\n<p><code>synchronized</code> 关键字</p>\n</li>\n<li><p>显式锁</p>\n<p><code>java.util.concurrent.locks.ReentrantLock</code><br><code>java.util.concurrent.locks.ReentrantReadWriteLock</code></p>\n</li>\n</ul>\n<h4 id=\"内在锁和Java监视器\"><a href=\"#内在锁和Java监视器\" class=\"headerlink\" title=\"内在锁和Java监视器\"></a>内在锁和Java监视器</h4><p><code>synchronized</code> 关键字适用于每个 Java 对象，其内部包含一个隐式可用的锁。内部锁是互斥的，这意味着同步关键字的代码区域（临界区）中的线程执行是某一个线程独占的。当临界区被占用时，其他线程则会处于阻塞状态，在同步锁释放前，该线程代码无法继续正常执行。</p>\n<p>内在锁充当一个监视器的角色，该监视器有三种状态：</p>\n<ol>\n<li><p>阻塞状态 <code>Blocked</code></p>\n<p>当前线程要等待正在被其他线程占用的内在锁，从而处于挂起状态；</p>\n</li>\n<li><p>运行状态 <code>Executing</code></p>\n<p>当前线程唯一占据内部锁并且正在临界区内执行代码；</p>\n</li>\n<li><p>等待状态 <code>Waiting</code></p>\n<p>当前线程刚刚将临界区代码执行完毕，主动释放了锁；并等待下次获取内部锁；</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182549.jpg\" alt=\"Java监视器示例\"></p>\n<p>一个完整的线程锁工作流大体如下：</p>\n<ol>\n<li><p><code>Enter the monitor</code></p>\n<p>某个线程尝试去操作被同步锁锁住的的代码片段，此时该线程进入 Java 监视器中，如果当前同步锁被其他线程占用，则当前线程挂起；</p>\n</li>\n<li><p><code>Acquire the lock</code></p>\n<p>如果当前同步锁处于空闲状态，则阻塞状态的线程则可以获取锁，并进入同步代码块开始执行。如果有多个线程阻塞等待，则由调度器决定谁将获取锁，而并不是先来后到的；</p>\n</li>\n<li><p><code>Release the lock and wait</code></p>\n<p>满足某种条件后，持有锁对象的线程会主动调用锁对象的 <code>Object.wait()</code> 将锁资源释放，然后等待满足某种条件后，重新获取执行权；</p>\n</li>\n<li><p><code>Acquire the lock after signal</code></p>\n<p>如果某个等待状态的线程被调度器选择为下一个执行线程，则它会在其他线程调用 <code>Object.notify()</code> 或者 <code>Objecct.notifyAll()</code> 时，获得同步锁并进入同步代码块；需要注意的是，等待线程相比较于阻塞线程并没有绝对的优先权，因为二者都想执行这部分同步代码，也就是说最终的选择权在于调度器；</p>\n</li>\n<li><p><code>Release the lock and exit the monitor</code></p>\n<p>在代码执行完毕后，线程会退出监视器，让其他真正有需要的线程做操作。</p>\n</li>\n</ol>\n<p>具体的同步代码块示例：</p>\n<pre><code class=\"java\">// (1) \nsynchronized (this) { \n    // Execute code (2) \n    wait(); // (3)\n    // Execute code (4)\n} \n// (5)\n</code></pre>\n<h4 id=\"同步对共享资源的访问\"><a href=\"#同步对共享资源的访问\" class=\"headerlink\" title=\"同步对共享资源的访问\"></a>同步对共享资源的访问</h4><p>在多线程应用中，共享资源可能被多方同时获取及修改，这种情况下就需要有一个有效的同步机制，来保证多线程下数据的统一性。这种机制具体包括同步锁类型的选择，以及同步代码块范围的设定。</p>\n<h5 id=\"使用内部锁\"><a href=\"#使用内部锁\" class=\"headerlink\" title=\"使用内部锁\"></a>使用内部锁</h5><p><code>synchronized</code> 关键字有多种使用方式：</p>\n<ul>\n<li><p>作用在方法上</p>\n<pre><code class=\"java\">synchronized void changeState() { \n    sharedResource++;\n}\n</code></pre>\n</li>\n<li><p>同步代码块，使用当前类作为同步锁</p>\n<pre><code class=\"java\">void changeState() { \n    synchronized(this) {\n        sharedResource++;\n    }\n}\n</code></pre>\n</li>\n<li><p>同步代码块，使用其他对象作为同步锁</p>\n<pre><code class=\"java\">private final Object mLock = new Object();\nvoid changeState() { \n    synchronized(mLock) {\n        sharedResource++;\n    } \n}\n</code></pre>\n</li>\n<li><p>作用于静态方法</p>\n<pre><code class=\"java\">synchronized static void changeState() { \n    staticSharedResource++;\n}\n</code></pre>\n</li>\n<li><p>静态方法的同步代码块，使用当前类作为同步锁</p>\n<pre><code class=\"java\">static void changeState() { \n    synchronized(this.getClass()) {\n        staticSharedResource++;\n    }\n}\n</code></pre>\n</li>\n</ul>\n<p>使用 this 在代码块内作为同步锁，与直接在方法上加 <code>synchronized</code> 关键字是相同的。但是更建议使用同步代码块，因为不一定方法内的全部代码都需要保证同步，滥用同步有可能导致不必要的性能损耗。</p>\n<p>值得注意的是，作用于静态方法的同步锁对象是当前 Class 类对象，而并非其实例对象。</p>\n<h5 id=\"使用显式锁机制\"><a href=\"#使用显式锁机制\" class=\"headerlink\" title=\"使用显式锁机制\"></a>使用显式锁机制</h5><p><code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 类可以用来替代 <code>synchronized</code> 关键字充当监视器。这种情况下，同步代码块的锁定和解锁都是由调用者手动调用的。</p>\n<pre><code class=\"java\">// ReentrantLock 显式锁调用示例\nint sharedResource;\nprivate ReentrantLock mLock = new ReentrantLock();\n\npublic void changeState(){\n    mLock.lock();\n    try{\n        sharedResource ++;\n    }\n    finally{\n        mLock.unlock();\n    }\n}\n</code></pre>\n<p><code>ReentrantLock</code> 和 <code>synchronized</code> 关键字语义相同，都会将同步代码块隔离开，保证只有一个线程能够对其进行操作。二者都是一种防御性策略，假设所有并发访问都存在问题，但多线程同时读取共享变量并不是有害的。因此，synchronized 和 ReentrantLock 可能存在过度保护。</p>\n<p><code>ReentrantReadWriteLock</code> 则允许多个线程对共享数据同时进行读取，但是仍然禁止同时读写或者同时写入。示例代码如下：</p>\n<pre><code class=\"java\">// ReentrantReadWriteLock 显式锁调用示例\nint sharedResource;\nprivate ReentrantReadWriteLock mLock = new ReentrantReadWriteLock();\n\npublic void changeState() { \n    mLock.writeLock().lock(); \n    try {\n        sharedResource++;\n    }\n    finally{\n        mLock.unlock();\n    }\n}\n\npublic int readState(){\n    mLock.readLock().lock();\n    try{\n        return sharedResource;\n    }\n    finally{\n        mLock.readLock().unlock();\n    }\n}\n</code></pre>\n<p><code>ReentrantReadWriteLock</code> 相对复杂，从而会对性能造成影响。因为相对于 <code>ReentrantLock</code> 和 <code>synchronized</code> 来讲，<code>ReentrantReadWriteLock</code> 要花费更多的时间去判断应不应该阻塞当前线程，这也相当于是让读取操作同步执行的一种妥协。实际上，<code>ReentrantReadWriteLock</code> 的典型应用应该是多个线程进行读取，但只有少量线程会进行写入操作。</p>\n<h4 id=\"生产者消费者模型\"><a href=\"#生产者消费者模型\" class=\"headerlink\" title=\"生产者消费者模型\"></a>生产者消费者模型</h4><p>生产者消费者是线程协作的经典模型，生产者线程和消费者线程共享一个列表，当该列表为空时，生产者线程向其中添加商品；如果列表不为空，则消费者线程会将商品移除。也就是说，当列表为空时，消费者线程应该阻塞等待；当列表已满时，生产者线程应该阻塞等待。</p>\n<p><code>ComsumerProducer</code> 类包括两个线程，一个生产者线程，一个消费者线程，二者共享一个 LinkedList 对象，分别对其进行增加和删除操作：</p>\n<pre><code class=\"java\">public class ConsumerProducer{\n    private LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();\n    private final int LIMIT = 10;\n    private Object lock = new Object();\n\n    public void produce(){\n        int value = 0;\n        while(true){\n            synchronized(lock){\n                while(list.size() == LIMIT){\n                    lock.wait();\n                }\n                list.add(value++);\n                lock.notify();\n            }\n        }\n    }\n\n    public void consume(){\n        int value = 0;\n        while(true){\n            synchronized(lock){\n                while(list.size() == 0){\n                    lock.wait();\n                }\n                list.removeFirst();\n                lock.notify();\n            }\n        }\n    } \n}\n</code></pre>\n<p>生产者线程和消费者线程共用同一把锁，来保证共享数据 list 的一致性。当列表为满时，生产者主动挂起等待；当列表为空时，消费者主动挂起等待。两个线程在挂起的同时，又会调用 <code>lock.notify()</code> 给正在等待的对方发送信号，通知其获取同步锁并执行代码，从而完成共享数据的同步。</p>\n<pre><code class=\"java\">final ConsumerProducer cp = new ConsumerProducer();\n\n// producer\nnew Thread(new Runnable(){\n    @Override\n    public void run(){\n        cp.produce();\n    }\n}).start();\n\n// consumer\nnew Thread(new Runnable(){\n    @Override\n    public void run(){\n        cp.consume();\n    }\n}).start();\n</code></pre>\n<h4 id=\"任务执行策略\"><a href=\"#任务执行策略\" class=\"headerlink\" title=\"任务执行策略\"></a>任务执行策略</h4><p>一般来讲，两种极端的执行策略如下：</p>\n<ol>\n<li>所有的任务都执行在同一线程上</li>\n<li>每一个任务都对应一个线程</li>\n</ol>\n<p>很明显上述两种策略都过于极端：前者效率过低，后者大量的线程初始化和回收会造成大量的性能消耗。尽管如此，上述两种策略还是目前最常用的两种执行方式：</p>\n<ol>\n<li><p>顺序执行</p>\n<p>各个任务按照先后顺序进行执行，各任务的执行时间不会有重叠。这样做的优势是数据绝对安全，而且只有一个线程执行，占用内存会比多线程更少；缺点在于吞吐量过低，一个任务的执行与否取决于前一个任务能否成功完成；</p>\n</li>\n<li><p>并发执行</p>\n<p>所有的任务都并行执行，最大化利用 CPU ，但是会带来数据的不安全性，需要进行同步机制规避。</p>\n</li>\n</ol>\n<p>一个出色的执行策略应该是顺序执行和并发执行并重的。相对独立的任务应该并发执行以提高效率，但是有相对严格执行顺序的任务则应该执行在单一线程中。</p>\n<h5 id=\"并发执行设计原则\"><a href=\"#并发执行设计原则\" class=\"headerlink\" title=\"并发执行设计原则\"></a>并发执行设计原则</h5><ul>\n<li>控制新线程的重复创建，而应该注意对已有线程的复用，从而降低创建、回收线程的频率</li>\n<li>提高线程使用效率，多余的线程对于内存和处理器都是一种资源浪费</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>Android应用程序应该是多线程的，以提高单处理器和多处理器平台的性能。线程可以在单个处理器上顺序执行，或者在多个处理器可用时实现真正的并发。性能的提高是以增加复杂性为代价的，同样需要维护同步机制，以保证线程之间共享资源数据的一致性。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Efficient.Android.Threading 第二章读书笔记</p>\n</blockquote>","more":"<p>所有 Android 应用都应该进行多线程编程，因为其可以大幅度的提高应用的性能以及响应效果；但是也会由此带来一系列的问题，导致编码的过程更加复杂。</p>\n<ul>\n<li>处理 Java 并发</li>\n<li>在多个线程中保证共享数据的稳定性</li>\n<li>定制以及优化不同线程的执行策略</li>\n</ul>\n<h3 id=\"线程基础\"><a href=\"#线程基础\" class=\"headerlink\" title=\"线程基础\"></a>线程基础</h3><p>线程 <code>thread</code> 是 CPU 最小调度单元，一般来讲，一个应用中的任务会按代码顺序来执行。线程中待执行的代码被称作任务 <code>task</code>。一个线程可以只执行一个任务，也可以按顺序执行多个任务。</p>\n<h4 id=\"线程的执行\"><a href=\"#线程的执行\" class=\"headerlink\" title=\"线程的执行\"></a>线程的执行</h4><p>Android 应用中的常用线程即 <code>java.lang.Thread</code>，线程生命周期的长度取决于执行任务的大小以及耗时。</p>\n<p>线程支持执行实现了 <code>java.lang.Runnable</code> 接口的任务，具体的任务是实现在 <code>run</code> 方法中的，具体如下：</p>\n<pre><code class=\"java\">private class MyTask implements Runnable { \n    public void run() {\n        // 在 run 方法中直接或间接调用到的所有局部变量，都将存储在该线程本地内存堆栈中\n        int i = 0; \n    }\n}\n</code></pre>\n<p>通过实例化和启动 Thread 对象，来启动任务的执行：</p>\n<pre><code class=\"java\">Thread thread = new Thread(new MyTask());\nthread.start();\n</code></pre>\n<p>从操作系统层面来说，线程同时具有指令和堆栈指针。指令指针引用要处理的下一条指令，堆栈指针指向一个私有内存区域（对其他线程不可见），该区域用于存储当前线程的数据。当前线程的数据 <code>thread local data</code> 一般指的是在 Java 方法中定义的变量信息。</p>\n<p>一般来讲，系统都希望能将 CPU 最大限度的利用起来，但矛盾的地方在于，同一 CPU 在同一时间只能运行一个线程。在这种情况下，为了让用户感知不同的程序正在同时运行，就必须让 CPU 忙起来，在不同的线程之间来回切换，进行任务的执行，这个过程被称为线程的调度<code>scheduler</code>。在 Java 中，线程调度的基准是线程的优先级 <code>priority</code> ，优先级默认为 5，范围为 1-8 。</p>\n<p>但是，如果线程的调度是完全基于优先级的话，就有可能导致低优先级的线程任务永远得不到执行，也就是所谓的饥饿致死。为解决这个问题，Java 调度器在执行线程调度时，还会将线程的执行时间列入考虑的范围。</p>\n<p>每次不同线程的切换被称为上下文切换 <code>context switch</code> 。每次进行上下文切换时，CPU 会先将当前正在执行的线程状态进行保存，以方便下一次恢复当前线程的执行；其后暂停当前线程，同时恢复另一线程的执行。</p>\n<p>具体的线程调度可以通过下图进行理解，图中的 C 就是上下文切换的过程。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182552.jpg\" alt=\"线程调度示例\"></p>\n<h4 id=\"单线程应用\"><a href=\"#单线程应用\" class=\"headerlink\" title=\"单线程应用\"></a>单线程应用</h4><p>每个应用至少会有一个线程，也就是我们所熟知的主线程，默认情况下，编写的代码都将在这个线程中进行执行。</p>\n<p>单线程编程是最简单的编码方式，但是很多情况下这种方式并不能满足我们的需求，因此，我们就需要将代码分别运行在不同的线程中，从而保证代码执行的高效性以及程序的性能。</p>\n<h4 id=\"多线程应用\"><a href=\"#多线程应用\" class=\"headerlink\" title=\"多线程应用\"></a>多线程应用</h4><p>如果执行线程的数量超过处理器数量，则无法实现真正的并发，但调度程序在要处理的线程之间快速切换，以便将每个代码路径拆分为按顺序处理的执行间隔。尽管多线程编程会极大的提高应用的性能，但是这是有一定代价的。具体表现为：复杂性的提高，内存开销的增加，不确定的执行顺序等。</p>\n<h5 id=\"复杂性提高，不确定的执行顺序\"><a href=\"#复杂性提高，不确定的执行顺序\" class=\"headerlink\" title=\"复杂性提高，不确定的执行顺序\"></a>复杂性提高，不确定的执行顺序</h5><p>分析单线程应用程序的执行相对简单，因为执行顺序是已知的。在多线程应用程序中，分析程序如何执行以及代码以何种顺序处理要困难得多。执行顺序在线程之间是不确定的，因为调度器将如何分配执行时间给线程是未知的。因此，多线程的执行过程是不确定的。这种不确定性不仅使代码中的错误调试变得更加困难，而且协调线程的过程中也有很大可能会引入新的错误。</p>\n<h5 id=\"资源开销的增加\"><a href=\"#资源开销的增加\" class=\"headerlink\" title=\"资源开销的增加\"></a>资源开销的增加</h5><p>线程在内存和处理器使用方面具有开销。之前提到过，每个线程都会申请一块私有内存区域，用来存储线程数据。这片私有内存在线程创建之初就会申请出来备用，直到线程终止才会被回收并重新分配。在这个过程中，只要当前线程是存活的，即便它是闲置或是阻塞状态，也会持续占用系统资源。</p>\n<p>处理器的开销主要来自于初始化、回收线程，以及在上下文切换中存储和恢复线程。执行的线程越多，上下文切换就越多，性能就越差。</p>\n<h5 id=\"数据不一致\"><a href=\"#数据不一致\" class=\"headerlink\" title=\"数据不一致\"></a>数据不一致</h5><p>多线程程序对资源的访问还会产生一个新的问题，就是数据的共享。如果两个或更多线程同时操作某一个数据，则我们无法确定哪个线程正在对这个数据进行什么样的操作，这就导致了最后数据的不可靠性。</p>\n<p>因为上下文切换可能发生在一个线程中不应中断的位置(比如正在对某个关键性数据进行操作时），所以必须创建代码指令的原子区域 <code>atomic region</code>。如果线程在原子区域中执行，则其他线程将被阻塞，直到在原子区域中没有其他线程执行。因此，Java中的原子区被认为是互斥的，因为它只允许访问一个线程。</p>\n<p>可以用不同的方式创建原子区域  <code>atomic region</code>，但是最基本的同步机制是 <code>synchronized</code> 关键字 ：</p>\n<pre><code class=\"java\">synchronized (this) { \n    sharedResource++;\n}\n</code></pre>\n<p>如果对共享资源的每次访问都是同步的，那么尽管多线程访问，数据也都将是一致的。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>在多线程应用中，共享资源有可能会被多方同时访问，同时读写，这就导致了数据的不可靠性。在这种情况下，需要通过使用锁定机制来实现同步。</p>\n<p>Android 中的锁定机制主要包括两种：</p>\n<ul>\n<li><p>对象内在锁定</p>\n<p><code>synchronized</code> 关键字</p>\n</li>\n<li><p>显式锁</p>\n<p><code>java.util.concurrent.locks.ReentrantLock</code><br><code>java.util.concurrent.locks.ReentrantReadWriteLock</code></p>\n</li>\n</ul>\n<h4 id=\"内在锁和Java监视器\"><a href=\"#内在锁和Java监视器\" class=\"headerlink\" title=\"内在锁和Java监视器\"></a>内在锁和Java监视器</h4><p><code>synchronized</code> 关键字适用于每个 Java 对象，其内部包含一个隐式可用的锁。内部锁是互斥的，这意味着同步关键字的代码区域（临界区）中的线程执行是某一个线程独占的。当临界区被占用时，其他线程则会处于阻塞状态，在同步锁释放前，该线程代码无法继续正常执行。</p>\n<p>内在锁充当一个监视器的角色，该监视器有三种状态：</p>\n<ol>\n<li><p>阻塞状态 <code>Blocked</code></p>\n<p>当前线程要等待正在被其他线程占用的内在锁，从而处于挂起状态；</p>\n</li>\n<li><p>运行状态 <code>Executing</code></p>\n<p>当前线程唯一占据内部锁并且正在临界区内执行代码；</p>\n</li>\n<li><p>等待状态 <code>Waiting</code></p>\n<p>当前线程刚刚将临界区代码执行完毕，主动释放了锁；并等待下次获取内部锁；</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182549.jpg\" alt=\"Java监视器示例\"></p>\n<p>一个完整的线程锁工作流大体如下：</p>\n<ol>\n<li><p><code>Enter the monitor</code></p>\n<p>某个线程尝试去操作被同步锁锁住的的代码片段，此时该线程进入 Java 监视器中，如果当前同步锁被其他线程占用，则当前线程挂起；</p>\n</li>\n<li><p><code>Acquire the lock</code></p>\n<p>如果当前同步锁处于空闲状态，则阻塞状态的线程则可以获取锁，并进入同步代码块开始执行。如果有多个线程阻塞等待，则由调度器决定谁将获取锁，而并不是先来后到的；</p>\n</li>\n<li><p><code>Release the lock and wait</code></p>\n<p>满足某种条件后，持有锁对象的线程会主动调用锁对象的 <code>Object.wait()</code> 将锁资源释放，然后等待满足某种条件后，重新获取执行权；</p>\n</li>\n<li><p><code>Acquire the lock after signal</code></p>\n<p>如果某个等待状态的线程被调度器选择为下一个执行线程，则它会在其他线程调用 <code>Object.notify()</code> 或者 <code>Objecct.notifyAll()</code> 时，获得同步锁并进入同步代码块；需要注意的是，等待线程相比较于阻塞线程并没有绝对的优先权，因为二者都想执行这部分同步代码，也就是说最终的选择权在于调度器；</p>\n</li>\n<li><p><code>Release the lock and exit the monitor</code></p>\n<p>在代码执行完毕后，线程会退出监视器，让其他真正有需要的线程做操作。</p>\n</li>\n</ol>\n<p>具体的同步代码块示例：</p>\n<pre><code class=\"java\">// (1) \nsynchronized (this) { \n    // Execute code (2) \n    wait(); // (3)\n    // Execute code (4)\n} \n// (5)\n</code></pre>\n<h4 id=\"同步对共享资源的访问\"><a href=\"#同步对共享资源的访问\" class=\"headerlink\" title=\"同步对共享资源的访问\"></a>同步对共享资源的访问</h4><p>在多线程应用中，共享资源可能被多方同时获取及修改，这种情况下就需要有一个有效的同步机制，来保证多线程下数据的统一性。这种机制具体包括同步锁类型的选择，以及同步代码块范围的设定。</p>\n<h5 id=\"使用内部锁\"><a href=\"#使用内部锁\" class=\"headerlink\" title=\"使用内部锁\"></a>使用内部锁</h5><p><code>synchronized</code> 关键字有多种使用方式：</p>\n<ul>\n<li><p>作用在方法上</p>\n<pre><code class=\"java\">synchronized void changeState() { \n    sharedResource++;\n}\n</code></pre>\n</li>\n<li><p>同步代码块，使用当前类作为同步锁</p>\n<pre><code class=\"java\">void changeState() { \n    synchronized(this) {\n        sharedResource++;\n    }\n}\n</code></pre>\n</li>\n<li><p>同步代码块，使用其他对象作为同步锁</p>\n<pre><code class=\"java\">private final Object mLock = new Object();\nvoid changeState() { \n    synchronized(mLock) {\n        sharedResource++;\n    } \n}\n</code></pre>\n</li>\n<li><p>作用于静态方法</p>\n<pre><code class=\"java\">synchronized static void changeState() { \n    staticSharedResource++;\n}\n</code></pre>\n</li>\n<li><p>静态方法的同步代码块，使用当前类作为同步锁</p>\n<pre><code class=\"java\">static void changeState() { \n    synchronized(this.getClass()) {\n        staticSharedResource++;\n    }\n}\n</code></pre>\n</li>\n</ul>\n<p>使用 this 在代码块内作为同步锁，与直接在方法上加 <code>synchronized</code> 关键字是相同的。但是更建议使用同步代码块，因为不一定方法内的全部代码都需要保证同步，滥用同步有可能导致不必要的性能损耗。</p>\n<p>值得注意的是，作用于静态方法的同步锁对象是当前 Class 类对象，而并非其实例对象。</p>\n<h5 id=\"使用显式锁机制\"><a href=\"#使用显式锁机制\" class=\"headerlink\" title=\"使用显式锁机制\"></a>使用显式锁机制</h5><p><code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 类可以用来替代 <code>synchronized</code> 关键字充当监视器。这种情况下，同步代码块的锁定和解锁都是由调用者手动调用的。</p>\n<pre><code class=\"java\">// ReentrantLock 显式锁调用示例\nint sharedResource;\nprivate ReentrantLock mLock = new ReentrantLock();\n\npublic void changeState(){\n    mLock.lock();\n    try{\n        sharedResource ++;\n    }\n    finally{\n        mLock.unlock();\n    }\n}\n</code></pre>\n<p><code>ReentrantLock</code> 和 <code>synchronized</code> 关键字语义相同，都会将同步代码块隔离开，保证只有一个线程能够对其进行操作。二者都是一种防御性策略，假设所有并发访问都存在问题，但多线程同时读取共享变量并不是有害的。因此，synchronized 和 ReentrantLock 可能存在过度保护。</p>\n<p><code>ReentrantReadWriteLock</code> 则允许多个线程对共享数据同时进行读取，但是仍然禁止同时读写或者同时写入。示例代码如下：</p>\n<pre><code class=\"java\">// ReentrantReadWriteLock 显式锁调用示例\nint sharedResource;\nprivate ReentrantReadWriteLock mLock = new ReentrantReadWriteLock();\n\npublic void changeState() { \n    mLock.writeLock().lock(); \n    try {\n        sharedResource++;\n    }\n    finally{\n        mLock.unlock();\n    }\n}\n\npublic int readState(){\n    mLock.readLock().lock();\n    try{\n        return sharedResource;\n    }\n    finally{\n        mLock.readLock().unlock();\n    }\n}\n</code></pre>\n<p><code>ReentrantReadWriteLock</code> 相对复杂，从而会对性能造成影响。因为相对于 <code>ReentrantLock</code> 和 <code>synchronized</code> 来讲，<code>ReentrantReadWriteLock</code> 要花费更多的时间去判断应不应该阻塞当前线程，这也相当于是让读取操作同步执行的一种妥协。实际上，<code>ReentrantReadWriteLock</code> 的典型应用应该是多个线程进行读取，但只有少量线程会进行写入操作。</p>\n<h4 id=\"生产者消费者模型\"><a href=\"#生产者消费者模型\" class=\"headerlink\" title=\"生产者消费者模型\"></a>生产者消费者模型</h4><p>生产者消费者是线程协作的经典模型，生产者线程和消费者线程共享一个列表，当该列表为空时，生产者线程向其中添加商品；如果列表不为空，则消费者线程会将商品移除。也就是说，当列表为空时，消费者线程应该阻塞等待；当列表已满时，生产者线程应该阻塞等待。</p>\n<p><code>ComsumerProducer</code> 类包括两个线程，一个生产者线程，一个消费者线程，二者共享一个 LinkedList 对象，分别对其进行增加和删除操作：</p>\n<pre><code class=\"java\">public class ConsumerProducer{\n    private LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();\n    private final int LIMIT = 10;\n    private Object lock = new Object();\n\n    public void produce(){\n        int value = 0;\n        while(true){\n            synchronized(lock){\n                while(list.size() == LIMIT){\n                    lock.wait();\n                }\n                list.add(value++);\n                lock.notify();\n            }\n        }\n    }\n\n    public void consume(){\n        int value = 0;\n        while(true){\n            synchronized(lock){\n                while(list.size() == 0){\n                    lock.wait();\n                }\n                list.removeFirst();\n                lock.notify();\n            }\n        }\n    } \n}\n</code></pre>\n<p>生产者线程和消费者线程共用同一把锁，来保证共享数据 list 的一致性。当列表为满时，生产者主动挂起等待；当列表为空时，消费者主动挂起等待。两个线程在挂起的同时，又会调用 <code>lock.notify()</code> 给正在等待的对方发送信号，通知其获取同步锁并执行代码，从而完成共享数据的同步。</p>\n<pre><code class=\"java\">final ConsumerProducer cp = new ConsumerProducer();\n\n// producer\nnew Thread(new Runnable(){\n    @Override\n    public void run(){\n        cp.produce();\n    }\n}).start();\n\n// consumer\nnew Thread(new Runnable(){\n    @Override\n    public void run(){\n        cp.consume();\n    }\n}).start();\n</code></pre>\n<h4 id=\"任务执行策略\"><a href=\"#任务执行策略\" class=\"headerlink\" title=\"任务执行策略\"></a>任务执行策略</h4><p>一般来讲，两种极端的执行策略如下：</p>\n<ol>\n<li>所有的任务都执行在同一线程上</li>\n<li>每一个任务都对应一个线程</li>\n</ol>\n<p>很明显上述两种策略都过于极端：前者效率过低，后者大量的线程初始化和回收会造成大量的性能消耗。尽管如此，上述两种策略还是目前最常用的两种执行方式：</p>\n<ol>\n<li><p>顺序执行</p>\n<p>各个任务按照先后顺序进行执行，各任务的执行时间不会有重叠。这样做的优势是数据绝对安全，而且只有一个线程执行，占用内存会比多线程更少；缺点在于吞吐量过低，一个任务的执行与否取决于前一个任务能否成功完成；</p>\n</li>\n<li><p>并发执行</p>\n<p>所有的任务都并行执行，最大化利用 CPU ，但是会带来数据的不安全性，需要进行同步机制规避。</p>\n</li>\n</ol>\n<p>一个出色的执行策略应该是顺序执行和并发执行并重的。相对独立的任务应该并发执行以提高效率，但是有相对严格执行顺序的任务则应该执行在单一线程中。</p>\n<h5 id=\"并发执行设计原则\"><a href=\"#并发执行设计原则\" class=\"headerlink\" title=\"并发执行设计原则\"></a>并发执行设计原则</h5><ul>\n<li>控制新线程的重复创建，而应该注意对已有线程的复用，从而降低创建、回收线程的频率</li>\n<li>提高线程使用效率，多余的线程对于内存和处理器都是一种资源浪费</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>Android应用程序应该是多线程的，以提高单处理器和多处理器平台的性能。线程可以在单个处理器上顺序执行，或者在多个处理器可用时实现真正的并发。性能的提高是以增加复杂性为代价的，同样需要维护同步机制，以保证线程之间共享资源数据的一致性。</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181341.jpg","title":"线程间通信 上篇","date":"2018-09-08T16:00:00.000Z","_content":"\n> Efficient.Android.Threading 第四章读书笔记 上篇\n\n<!--more-->\n\n在多进程应用中，各个任务可以并行执行协作以产出结果。因此，各个线程之间必须进行通信才能满足协作执行的目的。在 Android 系统中，可以使用传统的 Java 线程通信技术，也可以使用 Android 专属的 Handler / Looper 消息机制。基于此，本章的主要内容为：\n\n- 使用单向传输的管道来进行数据传输\n- 共享内存通信\n- 使用 `BlockingQueue` 实现生产者消费者\n- 消息队列的具体操作\n- 将具体任务发回 UI 线程\n\n### 管道\n\n管道 `Pipes` 从属于 `java.io` 包，也就是说，严格意义上讲，它是属于 Java 语言范畴，而非 Android 系统的。一个管道为同一进程的两个线程提供一种交互方式，为二者建立连接，搭建一个单向传输的数据传输通道：生产者线程向管道中写入数据，同时消费者线程从中取数据。\n\nJava 管道与 Unix 系统管道命令 `|` 相比较起来有所不同。Java 管道用来为同一进程中的不同线程提供通信服务；而 Unix 系统管道命令用来将某个命令的输入重定向为另一命令的输入。\n\n管道在内存中表现为一个循环缓冲区，仅适用于两个连接的线程，其他线程无法接触到其中的数据。同时，管道是单向的，只允许一个线程线程写入数据，另一线程读取数据，在这种情况下，线程安全是可以确定的。\n\n![Pipes](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182548.jpg)\n\n管道的典型使用场景为，并行的两个耗时任务，其中一个线程需要不停地给另一个线程传输数据。管道可以用来为 UI 线程减压，从而保证用户界面响应的及时性，从而提升用户体验。\n\n管道可以传输二进制数据或者字节数据。其中，二进制数据的代表为 `PipedOutputStream` 和 `PipedInputStream` ，字节数据的代表为 `PipedWriter` 和 `PipedReader` 。除了传输数据类型的不同以外，以上两种类型的管道没有任何不同。管道的生命周期自两个线程建立连接开始，断开连接时生命周期结束。\n\n#### 管道的基本使用\n\n基本的管道生命周期可以归纳概括为三个步骤：建立连接，数据传输和断开连接。\n\n```java\n// 1.建立连接 - \nint BUFFER_SIZE_IN_CHARS = 1024 * 4; // 默认为 1024，可以自定义\nPipedReader r = new PipedReader(BUFFER_SIZE_IN_CHARS);\nPipedWriter w = new PipedWriter();\nw.connect(r); // r.connect(w);\n\n// 2.将消费者传入线程中, 线程启动后，就准备好从管道中读取数据了\nThread t = new MyReaderThread(r);\nt.start();\n\n// 3. 传输数据\n// 类似这种生产者-消费者模型的通信方式，一般都是带有阻塞机制的。\n// 如果管道已满，则 write() 会处于阻塞状态，直到管道中再次有空余空间；\n// 如果缓存为空，则 read() 会处于阻塞状态。\n// flush() 方法的调用是很有必要的\n// 因为当 read() 线程调用 wait() 后，默认会有至少一秒钟的超时时长\n// flush() 方法相当于 notify()，可以保证消费者马上对新加入的数据做出响应\nw.write('A');\nw.flush();\n\nint i; // 传输的数据会被转为 int 类型，以保证不同编码格式的统一性\nwhile((i = r.read()) != -1){\n    char c = (char)i;\n}\n\n// 4. 关闭连接\n// 如果关闭 writer, 管道关闭但缓存中的数据还会被读取到\n// 如果关闭 reader, 则缓存中的数据会被清除\nw.close();\nr.close();\n```\n\n#### 管道在 Android 系统中的应用\n\n使用管道来对用户输入进行一些简单处理：用户通过 EditText 输入内容，为了保证 UI 线程的即时性，使用管道将用户输入内容发送到工作线程进行某些耗时操作的处理：\n\n```java\nprivate static class TextHandlerTask implements Runnable {\n\tprivate final PipedReader reader;\n\tprivate TextHandlerTask(PipedReader reader) {\n    \tthis.reader = reader;\n    }\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            int i;\n            try {\n                while ((i = reader.read()) != -1) {\n                    char c = (char) i;\n                    Log.e(\"Test\", \"char -> \" + c);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nprivate PipedReader r = new PipedReader();\nprivate PipedWriter w = new PipedWriter();\nw.connect(r);\n\netSearch.addTextChangedListener(new TextWatcher() {\n\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n        if (count > before) { // 输入内容\n            try {\n                w.write(s.subSequence(before, count).toString());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n});\n\nnew Thread(new TextHandlerTask(r)).start();\n\n```\n\n### 共享内存\n\n共享内存是一种通用的线程间通信的方式。应用程序的地址空间存储在堆中，所有线程都可以对其进行访问，即某个线程操作某个数据，该数据同时可以被其他线程所读取。\n\n![不同线程利用共享内存进行通信](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg)\n\n如果某个线程将其数据存储为局部变量（本地变量），那么其他线程是无法对其进行访问的。只有将数据存储在共享内存中，才能够被其他线程访问到，从而完成不同线程间的协作。以下对象一般被认为是存储在共享内存中的：`实例变量`，`类变量`，`方法中声明的对象`。\n\n对象的引用（指针）存储在线程的栈中，但是对象其本身（占用的内存）存储在共享内存中。不同方法之间如果想要互相操作对象，则需要将对象的引用进行传递才可以实现。`不同的线程通过定义实例属性以及类属性来实现通信和任务协作`。\n\n#### 发送信号\n\n由于线程数据安全问题的存在，不同的线程在操作同一数据时需要有阻塞机制，来保证同一时间只有一个线程对共享数据进行操作。Java 内置的唤醒机制就很好的解决了这一问题。\n\n![Thread signal](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182553.jpg)\n\n当某一线程除非满足某个条件，否则无法继续执行时，该线程可以调用 wait() / await() 方法。timeout 参数表示当前线程在下次执行前，需要等待多久。\n\n当其他线程已经将状态更改，也就是现在正在等待的线程已经满足条件了，那么当前线程会通过调用 notify() / notifyAll() 来通知等待的线程；而收到消息的线程则可以继续向下执行。\n\n需要注意的是，很可能并不是只有一个线程在等待，但是只能有一个线程进入同步代码块，也就是说，收到通知消息的消息也并不一定可以继续向下执行。这就要求等待线程需要遵循一定的设计模式，即`在同步代码块中，重复检查条件是否已经满足`。\n\n```java\nsynchronized(this){\n    while(isConditionFulfilled == false){\n\t\twait();\n    }\n    // 代码执行到这里时，才说明状态是对的\n}\n```\n\n以上代码在同步代码块中再次检查了条件是否满足。如果不满足条件，则当前线程挂起等待；当收到通知消息，等待线程被唤醒，它在执行关键代码前会再次校验同步条件是否满足，因为有可能被其他线程捷足先登，如果不满足条件，则其会继续挂起，等待下一个唤醒信号。\n\n以上机制很好的协同了多线程的通信，但是不适合 Android 平台，因为 UI 线程绝不能挂起等待工作线程完成任务后唤醒，之后的文章中介绍 Android 消息分发机制。\n\n### 阻塞队列\n\n线程信令是一种低级，高度可配置的机制，尽管它可以应用在很多场景，但同时这也是一种极容易出错的技术。因此，Java 平台基于线程信令机制，重新构建了一套抽象概念，以期解决线程之间多对象的单向切换。\n\n在这一机制中，线程的挂起和唤醒不再通过消费者和生产者本身来控制，而是通过一个带有阻塞特性的队列来完成，例如，`java.util.concurrent.BlockingQueue`。\n\n![BlockingQueue](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg)\n\n阻塞队列扮演着生产者线程和消费者线程中间的协调者，内部维护一个实现了线程信令机制，可自定义大小的列表。具体使用的时候，如果队列中数据已满，则生产者线程 put() 方法会阻塞，直到消费者从队列中取出数据；如果队列为空，则消费者线程 take() 方法会阻塞，直到生产者向队列中插入数据。\n\n```java\npublic class ConsumerProducer{\n    private final int LIMIT = 10;\n    private BlockingQueue<Integer> blockingQueue = \n        new LinkedBlockingQueue<Integer>(LIMIT);\n    \n    public void produce() throws InterruptedException{\n        int value = 0;\n        while(true){\n            blockingQueue.put(value++);\n        }\n    }\n    \n    public void consume() throws InterruptedException{\n        while(true){\n            int value = blockingQueue.take();\n        }\n    }\n    \n}\n```\n以上是第四章前半部分内容，由于篇幅较长，准备分为两篇来记录。\n\n接下来会介绍 Android 平台的消息分发机制，下篇再见，大家加油~","source":"_posts/Efficient-Android-Threading-chapter-4-1.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181341.jpg\ntitle: 线程间通信 上篇\ntags: [读书笔记, Efficient.Android.Threading]\ndate: 2018-09-09\n---\n\n> Efficient.Android.Threading 第四章读书笔记 上篇\n\n<!--more-->\n\n在多进程应用中，各个任务可以并行执行协作以产出结果。因此，各个线程之间必须进行通信才能满足协作执行的目的。在 Android 系统中，可以使用传统的 Java 线程通信技术，也可以使用 Android 专属的 Handler / Looper 消息机制。基于此，本章的主要内容为：\n\n- 使用单向传输的管道来进行数据传输\n- 共享内存通信\n- 使用 `BlockingQueue` 实现生产者消费者\n- 消息队列的具体操作\n- 将具体任务发回 UI 线程\n\n### 管道\n\n管道 `Pipes` 从属于 `java.io` 包，也就是说，严格意义上讲，它是属于 Java 语言范畴，而非 Android 系统的。一个管道为同一进程的两个线程提供一种交互方式，为二者建立连接，搭建一个单向传输的数据传输通道：生产者线程向管道中写入数据，同时消费者线程从中取数据。\n\nJava 管道与 Unix 系统管道命令 `|` 相比较起来有所不同。Java 管道用来为同一进程中的不同线程提供通信服务；而 Unix 系统管道命令用来将某个命令的输入重定向为另一命令的输入。\n\n管道在内存中表现为一个循环缓冲区，仅适用于两个连接的线程，其他线程无法接触到其中的数据。同时，管道是单向的，只允许一个线程线程写入数据，另一线程读取数据，在这种情况下，线程安全是可以确定的。\n\n![Pipes](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182548.jpg)\n\n管道的典型使用场景为，并行的两个耗时任务，其中一个线程需要不停地给另一个线程传输数据。管道可以用来为 UI 线程减压，从而保证用户界面响应的及时性，从而提升用户体验。\n\n管道可以传输二进制数据或者字节数据。其中，二进制数据的代表为 `PipedOutputStream` 和 `PipedInputStream` ，字节数据的代表为 `PipedWriter` 和 `PipedReader` 。除了传输数据类型的不同以外，以上两种类型的管道没有任何不同。管道的生命周期自两个线程建立连接开始，断开连接时生命周期结束。\n\n#### 管道的基本使用\n\n基本的管道生命周期可以归纳概括为三个步骤：建立连接，数据传输和断开连接。\n\n```java\n// 1.建立连接 - \nint BUFFER_SIZE_IN_CHARS = 1024 * 4; // 默认为 1024，可以自定义\nPipedReader r = new PipedReader(BUFFER_SIZE_IN_CHARS);\nPipedWriter w = new PipedWriter();\nw.connect(r); // r.connect(w);\n\n// 2.将消费者传入线程中, 线程启动后，就准备好从管道中读取数据了\nThread t = new MyReaderThread(r);\nt.start();\n\n// 3. 传输数据\n// 类似这种生产者-消费者模型的通信方式，一般都是带有阻塞机制的。\n// 如果管道已满，则 write() 会处于阻塞状态，直到管道中再次有空余空间；\n// 如果缓存为空，则 read() 会处于阻塞状态。\n// flush() 方法的调用是很有必要的\n// 因为当 read() 线程调用 wait() 后，默认会有至少一秒钟的超时时长\n// flush() 方法相当于 notify()，可以保证消费者马上对新加入的数据做出响应\nw.write('A');\nw.flush();\n\nint i; // 传输的数据会被转为 int 类型，以保证不同编码格式的统一性\nwhile((i = r.read()) != -1){\n    char c = (char)i;\n}\n\n// 4. 关闭连接\n// 如果关闭 writer, 管道关闭但缓存中的数据还会被读取到\n// 如果关闭 reader, 则缓存中的数据会被清除\nw.close();\nr.close();\n```\n\n#### 管道在 Android 系统中的应用\n\n使用管道来对用户输入进行一些简单处理：用户通过 EditText 输入内容，为了保证 UI 线程的即时性，使用管道将用户输入内容发送到工作线程进行某些耗时操作的处理：\n\n```java\nprivate static class TextHandlerTask implements Runnable {\n\tprivate final PipedReader reader;\n\tprivate TextHandlerTask(PipedReader reader) {\n    \tthis.reader = reader;\n    }\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            int i;\n            try {\n                while ((i = reader.read()) != -1) {\n                    char c = (char) i;\n                    Log.e(\"Test\", \"char -> \" + c);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nprivate PipedReader r = new PipedReader();\nprivate PipedWriter w = new PipedWriter();\nw.connect(r);\n\netSearch.addTextChangedListener(new TextWatcher() {\n\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n        if (count > before) { // 输入内容\n            try {\n                w.write(s.subSequence(before, count).toString());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n});\n\nnew Thread(new TextHandlerTask(r)).start();\n\n```\n\n### 共享内存\n\n共享内存是一种通用的线程间通信的方式。应用程序的地址空间存储在堆中，所有线程都可以对其进行访问，即某个线程操作某个数据，该数据同时可以被其他线程所读取。\n\n![不同线程利用共享内存进行通信](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg)\n\n如果某个线程将其数据存储为局部变量（本地变量），那么其他线程是无法对其进行访问的。只有将数据存储在共享内存中，才能够被其他线程访问到，从而完成不同线程间的协作。以下对象一般被认为是存储在共享内存中的：`实例变量`，`类变量`，`方法中声明的对象`。\n\n对象的引用（指针）存储在线程的栈中，但是对象其本身（占用的内存）存储在共享内存中。不同方法之间如果想要互相操作对象，则需要将对象的引用进行传递才可以实现。`不同的线程通过定义实例属性以及类属性来实现通信和任务协作`。\n\n#### 发送信号\n\n由于线程数据安全问题的存在，不同的线程在操作同一数据时需要有阻塞机制，来保证同一时间只有一个线程对共享数据进行操作。Java 内置的唤醒机制就很好的解决了这一问题。\n\n![Thread signal](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182553.jpg)\n\n当某一线程除非满足某个条件，否则无法继续执行时，该线程可以调用 wait() / await() 方法。timeout 参数表示当前线程在下次执行前，需要等待多久。\n\n当其他线程已经将状态更改，也就是现在正在等待的线程已经满足条件了，那么当前线程会通过调用 notify() / notifyAll() 来通知等待的线程；而收到消息的线程则可以继续向下执行。\n\n需要注意的是，很可能并不是只有一个线程在等待，但是只能有一个线程进入同步代码块，也就是说，收到通知消息的消息也并不一定可以继续向下执行。这就要求等待线程需要遵循一定的设计模式，即`在同步代码块中，重复检查条件是否已经满足`。\n\n```java\nsynchronized(this){\n    while(isConditionFulfilled == false){\n\t\twait();\n    }\n    // 代码执行到这里时，才说明状态是对的\n}\n```\n\n以上代码在同步代码块中再次检查了条件是否满足。如果不满足条件，则当前线程挂起等待；当收到通知消息，等待线程被唤醒，它在执行关键代码前会再次校验同步条件是否满足，因为有可能被其他线程捷足先登，如果不满足条件，则其会继续挂起，等待下一个唤醒信号。\n\n以上机制很好的协同了多线程的通信，但是不适合 Android 平台，因为 UI 线程绝不能挂起等待工作线程完成任务后唤醒，之后的文章中介绍 Android 消息分发机制。\n\n### 阻塞队列\n\n线程信令是一种低级，高度可配置的机制，尽管它可以应用在很多场景，但同时这也是一种极容易出错的技术。因此，Java 平台基于线程信令机制，重新构建了一套抽象概念，以期解决线程之间多对象的单向切换。\n\n在这一机制中，线程的挂起和唤醒不再通过消费者和生产者本身来控制，而是通过一个带有阻塞特性的队列来完成，例如，`java.util.concurrent.BlockingQueue`。\n\n![BlockingQueue](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg)\n\n阻塞队列扮演着生产者线程和消费者线程中间的协调者，内部维护一个实现了线程信令机制，可自定义大小的列表。具体使用的时候，如果队列中数据已满，则生产者线程 put() 方法会阻塞，直到消费者从队列中取出数据；如果队列为空，则消费者线程 take() 方法会阻塞，直到生产者向队列中插入数据。\n\n```java\npublic class ConsumerProducer{\n    private final int LIMIT = 10;\n    private BlockingQueue<Integer> blockingQueue = \n        new LinkedBlockingQueue<Integer>(LIMIT);\n    \n    public void produce() throws InterruptedException{\n        int value = 0;\n        while(true){\n            blockingQueue.put(value++);\n        }\n    }\n    \n    public void consume() throws InterruptedException{\n        while(true){\n            int value = blockingQueue.take();\n        }\n    }\n    \n}\n```\n以上是第四章前半部分内容，由于篇幅较长，准备分为两篇来记录。\n\n接下来会介绍 Android 平台的消息分发机制，下篇再见，大家加油~","slug":"Efficient-Android-Threading-chapter-4-1","published":1,"updated":"2019-03-21T10:47:26.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86di0015lh1pu5edl6e8","content":"<blockquote>\n<p>Efficient.Android.Threading 第四章读书笔记 上篇</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>在多进程应用中，各个任务可以并行执行协作以产出结果。因此，各个线程之间必须进行通信才能满足协作执行的目的。在 Android 系统中，可以使用传统的 Java 线程通信技术，也可以使用 Android 专属的 Handler / Looper 消息机制。基于此，本章的主要内容为：</p>\n<ul>\n<li>使用单向传输的管道来进行数据传输</li>\n<li>共享内存通信</li>\n<li>使用 <code>BlockingQueue</code> 实现生产者消费者</li>\n<li>消息队列的具体操作</li>\n<li>将具体任务发回 UI 线程</li>\n</ul>\n<h3 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h3><p>管道 <code>Pipes</code> 从属于 <code>java.io</code> 包，也就是说，严格意义上讲，它是属于 Java 语言范畴，而非 Android 系统的。一个管道为同一进程的两个线程提供一种交互方式，为二者建立连接，搭建一个单向传输的数据传输通道：生产者线程向管道中写入数据，同时消费者线程从中取数据。</p>\n<p>Java 管道与 Unix 系统管道命令 <code>|</code> 相比较起来有所不同。Java 管道用来为同一进程中的不同线程提供通信服务；而 Unix 系统管道命令用来将某个命令的输入重定向为另一命令的输入。</p>\n<p>管道在内存中表现为一个循环缓冲区，仅适用于两个连接的线程，其他线程无法接触到其中的数据。同时，管道是单向的，只允许一个线程线程写入数据，另一线程读取数据，在这种情况下，线程安全是可以确定的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182548.jpg\" alt=\"Pipes\"></p>\n<p>管道的典型使用场景为，并行的两个耗时任务，其中一个线程需要不停地给另一个线程传输数据。管道可以用来为 UI 线程减压，从而保证用户界面响应的及时性，从而提升用户体验。</p>\n<p>管道可以传输二进制数据或者字节数据。其中，二进制数据的代表为 <code>PipedOutputStream</code> 和 <code>PipedInputStream</code> ，字节数据的代表为 <code>PipedWriter</code> 和 <code>PipedReader</code> 。除了传输数据类型的不同以外，以上两种类型的管道没有任何不同。管道的生命周期自两个线程建立连接开始，断开连接时生命周期结束。</p>\n<h4 id=\"管道的基本使用\"><a href=\"#管道的基本使用\" class=\"headerlink\" title=\"管道的基本使用\"></a>管道的基本使用</h4><p>基本的管道生命周期可以归纳概括为三个步骤：建立连接，数据传输和断开连接。</p>\n<pre><code class=\"java\">// 1.建立连接 - \nint BUFFER_SIZE_IN_CHARS = 1024 * 4; // 默认为 1024，可以自定义\nPipedReader r = new PipedReader(BUFFER_SIZE_IN_CHARS);\nPipedWriter w = new PipedWriter();\nw.connect(r); // r.connect(w);\n\n// 2.将消费者传入线程中, 线程启动后，就准备好从管道中读取数据了\nThread t = new MyReaderThread(r);\nt.start();\n\n// 3. 传输数据\n// 类似这种生产者-消费者模型的通信方式，一般都是带有阻塞机制的。\n// 如果管道已满，则 write() 会处于阻塞状态，直到管道中再次有空余空间；\n// 如果缓存为空，则 read() 会处于阻塞状态。\n// flush() 方法的调用是很有必要的\n// 因为当 read() 线程调用 wait() 后，默认会有至少一秒钟的超时时长\n// flush() 方法相当于 notify()，可以保证消费者马上对新加入的数据做出响应\nw.write(&#39;A&#39;);\nw.flush();\n\nint i; // 传输的数据会被转为 int 类型，以保证不同编码格式的统一性\nwhile((i = r.read()) != -1){\n    char c = (char)i;\n}\n\n// 4. 关闭连接\n// 如果关闭 writer, 管道关闭但缓存中的数据还会被读取到\n// 如果关闭 reader, 则缓存中的数据会被清除\nw.close();\nr.close();\n</code></pre>\n<h4 id=\"管道在-Android-系统中的应用\"><a href=\"#管道在-Android-系统中的应用\" class=\"headerlink\" title=\"管道在 Android 系统中的应用\"></a>管道在 Android 系统中的应用</h4><p>使用管道来对用户输入进行一些简单处理：用户通过 EditText 输入内容，为了保证 UI 线程的即时性，使用管道将用户输入内容发送到工作线程进行某些耗时操作的处理：</p>\n<pre><code class=\"java\">private static class TextHandlerTask implements Runnable {\n    private final PipedReader reader;\n    private TextHandlerTask(PipedReader reader) {\n        this.reader = reader;\n    }\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            int i;\n            try {\n                while ((i = reader.read()) != -1) {\n                    char c = (char) i;\n                    Log.e(&quot;Test&quot;, &quot;char -&gt; &quot; + c);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nprivate PipedReader r = new PipedReader();\nprivate PipedWriter w = new PipedWriter();\nw.connect(r);\n\netSearch.addTextChangedListener(new TextWatcher() {\n\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n        if (count &gt; before) { // 输入内容\n            try {\n                w.write(s.subSequence(before, count).toString());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n});\n\nnew Thread(new TextHandlerTask(r)).start();\n\n</code></pre>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>共享内存是一种通用的线程间通信的方式。应用程序的地址空间存储在堆中，所有线程都可以对其进行访问，即某个线程操作某个数据，该数据同时可以被其他线程所读取。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg\" alt=\"不同线程利用共享内存进行通信\"></p>\n<p>如果某个线程将其数据存储为局部变量（本地变量），那么其他线程是无法对其进行访问的。只有将数据存储在共享内存中，才能够被其他线程访问到，从而完成不同线程间的协作。以下对象一般被认为是存储在共享内存中的：<code>实例变量</code>，<code>类变量</code>，<code>方法中声明的对象</code>。</p>\n<p>对象的引用（指针）存储在线程的栈中，但是对象其本身（占用的内存）存储在共享内存中。不同方法之间如果想要互相操作对象，则需要将对象的引用进行传递才可以实现。<code>不同的线程通过定义实例属性以及类属性来实现通信和任务协作</code>。</p>\n<h4 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a>发送信号</h4><p>由于线程数据安全问题的存在，不同的线程在操作同一数据时需要有阻塞机制，来保证同一时间只有一个线程对共享数据进行操作。Java 内置的唤醒机制就很好的解决了这一问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182553.jpg\" alt=\"Thread signal\"></p>\n<p>当某一线程除非满足某个条件，否则无法继续执行时，该线程可以调用 wait() / await() 方法。timeout 参数表示当前线程在下次执行前，需要等待多久。</p>\n<p>当其他线程已经将状态更改，也就是现在正在等待的线程已经满足条件了，那么当前线程会通过调用 notify() / notifyAll() 来通知等待的线程；而收到消息的线程则可以继续向下执行。</p>\n<p>需要注意的是，很可能并不是只有一个线程在等待，但是只能有一个线程进入同步代码块，也就是说，收到通知消息的消息也并不一定可以继续向下执行。这就要求等待线程需要遵循一定的设计模式，即<code>在同步代码块中，重复检查条件是否已经满足</code>。</p>\n<pre><code class=\"java\">synchronized(this){\n    while(isConditionFulfilled == false){\n        wait();\n    }\n    // 代码执行到这里时，才说明状态是对的\n}\n</code></pre>\n<p>以上代码在同步代码块中再次检查了条件是否满足。如果不满足条件，则当前线程挂起等待；当收到通知消息，等待线程被唤醒，它在执行关键代码前会再次校验同步条件是否满足，因为有可能被其他线程捷足先登，如果不满足条件，则其会继续挂起，等待下一个唤醒信号。</p>\n<p>以上机制很好的协同了多线程的通信，但是不适合 Android 平台，因为 UI 线程绝不能挂起等待工作线程完成任务后唤醒，之后的文章中介绍 Android 消息分发机制。</p>\n<h3 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h3><p>线程信令是一种低级，高度可配置的机制，尽管它可以应用在很多场景，但同时这也是一种极容易出错的技术。因此，Java 平台基于线程信令机制，重新构建了一套抽象概念，以期解决线程之间多对象的单向切换。</p>\n<p>在这一机制中，线程的挂起和唤醒不再通过消费者和生产者本身来控制，而是通过一个带有阻塞特性的队列来完成，例如，<code>java.util.concurrent.BlockingQueue</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg\" alt=\"BlockingQueue\"></p>\n<p>阻塞队列扮演着生产者线程和消费者线程中间的协调者，内部维护一个实现了线程信令机制，可自定义大小的列表。具体使用的时候，如果队列中数据已满，则生产者线程 put() 方法会阻塞，直到消费者从队列中取出数据；如果队列为空，则消费者线程 take() 方法会阻塞，直到生产者向队列中插入数据。</p>\n<pre><code class=\"java\">public class ConsumerProducer{\n    private final int LIMIT = 10;\n    private BlockingQueue&lt;Integer&gt; blockingQueue = \n        new LinkedBlockingQueue&lt;Integer&gt;(LIMIT);\n\n    public void produce() throws InterruptedException{\n        int value = 0;\n        while(true){\n            blockingQueue.put(value++);\n        }\n    }\n\n    public void consume() throws InterruptedException{\n        while(true){\n            int value = blockingQueue.take();\n        }\n    }\n\n}\n</code></pre>\n<p>以上是第四章前半部分内容，由于篇幅较长，准备分为两篇来记录。</p>\n<p>接下来会介绍 Android 平台的消息分发机制，下篇再见，大家加油~</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Efficient.Android.Threading 第四章读书笔记 上篇</p>\n</blockquote>","more":"<p>在多进程应用中，各个任务可以并行执行协作以产出结果。因此，各个线程之间必须进行通信才能满足协作执行的目的。在 Android 系统中，可以使用传统的 Java 线程通信技术，也可以使用 Android 专属的 Handler / Looper 消息机制。基于此，本章的主要内容为：</p>\n<ul>\n<li>使用单向传输的管道来进行数据传输</li>\n<li>共享内存通信</li>\n<li>使用 <code>BlockingQueue</code> 实现生产者消费者</li>\n<li>消息队列的具体操作</li>\n<li>将具体任务发回 UI 线程</li>\n</ul>\n<h3 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h3><p>管道 <code>Pipes</code> 从属于 <code>java.io</code> 包，也就是说，严格意义上讲，它是属于 Java 语言范畴，而非 Android 系统的。一个管道为同一进程的两个线程提供一种交互方式，为二者建立连接，搭建一个单向传输的数据传输通道：生产者线程向管道中写入数据，同时消费者线程从中取数据。</p>\n<p>Java 管道与 Unix 系统管道命令 <code>|</code> 相比较起来有所不同。Java 管道用来为同一进程中的不同线程提供通信服务；而 Unix 系统管道命令用来将某个命令的输入重定向为另一命令的输入。</p>\n<p>管道在内存中表现为一个循环缓冲区，仅适用于两个连接的线程，其他线程无法接触到其中的数据。同时，管道是单向的，只允许一个线程线程写入数据，另一线程读取数据，在这种情况下，线程安全是可以确定的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182548.jpg\" alt=\"Pipes\"></p>\n<p>管道的典型使用场景为，并行的两个耗时任务，其中一个线程需要不停地给另一个线程传输数据。管道可以用来为 UI 线程减压，从而保证用户界面响应的及时性，从而提升用户体验。</p>\n<p>管道可以传输二进制数据或者字节数据。其中，二进制数据的代表为 <code>PipedOutputStream</code> 和 <code>PipedInputStream</code> ，字节数据的代表为 <code>PipedWriter</code> 和 <code>PipedReader</code> 。除了传输数据类型的不同以外，以上两种类型的管道没有任何不同。管道的生命周期自两个线程建立连接开始，断开连接时生命周期结束。</p>\n<h4 id=\"管道的基本使用\"><a href=\"#管道的基本使用\" class=\"headerlink\" title=\"管道的基本使用\"></a>管道的基本使用</h4><p>基本的管道生命周期可以归纳概括为三个步骤：建立连接，数据传输和断开连接。</p>\n<pre><code class=\"java\">// 1.建立连接 - \nint BUFFER_SIZE_IN_CHARS = 1024 * 4; // 默认为 1024，可以自定义\nPipedReader r = new PipedReader(BUFFER_SIZE_IN_CHARS);\nPipedWriter w = new PipedWriter();\nw.connect(r); // r.connect(w);\n\n// 2.将消费者传入线程中, 线程启动后，就准备好从管道中读取数据了\nThread t = new MyReaderThread(r);\nt.start();\n\n// 3. 传输数据\n// 类似这种生产者-消费者模型的通信方式，一般都是带有阻塞机制的。\n// 如果管道已满，则 write() 会处于阻塞状态，直到管道中再次有空余空间；\n// 如果缓存为空，则 read() 会处于阻塞状态。\n// flush() 方法的调用是很有必要的\n// 因为当 read() 线程调用 wait() 后，默认会有至少一秒钟的超时时长\n// flush() 方法相当于 notify()，可以保证消费者马上对新加入的数据做出响应\nw.write(&#39;A&#39;);\nw.flush();\n\nint i; // 传输的数据会被转为 int 类型，以保证不同编码格式的统一性\nwhile((i = r.read()) != -1){\n    char c = (char)i;\n}\n\n// 4. 关闭连接\n// 如果关闭 writer, 管道关闭但缓存中的数据还会被读取到\n// 如果关闭 reader, 则缓存中的数据会被清除\nw.close();\nr.close();\n</code></pre>\n<h4 id=\"管道在-Android-系统中的应用\"><a href=\"#管道在-Android-系统中的应用\" class=\"headerlink\" title=\"管道在 Android 系统中的应用\"></a>管道在 Android 系统中的应用</h4><p>使用管道来对用户输入进行一些简单处理：用户通过 EditText 输入内容，为了保证 UI 线程的即时性，使用管道将用户输入内容发送到工作线程进行某些耗时操作的处理：</p>\n<pre><code class=\"java\">private static class TextHandlerTask implements Runnable {\n    private final PipedReader reader;\n    private TextHandlerTask(PipedReader reader) {\n        this.reader = reader;\n    }\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            int i;\n            try {\n                while ((i = reader.read()) != -1) {\n                    char c = (char) i;\n                    Log.e(&quot;Test&quot;, &quot;char -&gt; &quot; + c);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nprivate PipedReader r = new PipedReader();\nprivate PipedWriter w = new PipedWriter();\nw.connect(r);\n\netSearch.addTextChangedListener(new TextWatcher() {\n\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n        if (count &gt; before) { // 输入内容\n            try {\n                w.write(s.subSequence(before, count).toString());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n});\n\nnew Thread(new TextHandlerTask(r)).start();\n\n</code></pre>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>共享内存是一种通用的线程间通信的方式。应用程序的地址空间存储在堆中，所有线程都可以对其进行访问，即某个线程操作某个数据，该数据同时可以被其他线程所读取。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg\" alt=\"不同线程利用共享内存进行通信\"></p>\n<p>如果某个线程将其数据存储为局部变量（本地变量），那么其他线程是无法对其进行访问的。只有将数据存储在共享内存中，才能够被其他线程访问到，从而完成不同线程间的协作。以下对象一般被认为是存储在共享内存中的：<code>实例变量</code>，<code>类变量</code>，<code>方法中声明的对象</code>。</p>\n<p>对象的引用（指针）存储在线程的栈中，但是对象其本身（占用的内存）存储在共享内存中。不同方法之间如果想要互相操作对象，则需要将对象的引用进行传递才可以实现。<code>不同的线程通过定义实例属性以及类属性来实现通信和任务协作</code>。</p>\n<h4 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a>发送信号</h4><p>由于线程数据安全问题的存在，不同的线程在操作同一数据时需要有阻塞机制，来保证同一时间只有一个线程对共享数据进行操作。Java 内置的唤醒机制就很好的解决了这一问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182553.jpg\" alt=\"Thread signal\"></p>\n<p>当某一线程除非满足某个条件，否则无法继续执行时，该线程可以调用 wait() / await() 方法。timeout 参数表示当前线程在下次执行前，需要等待多久。</p>\n<p>当其他线程已经将状态更改，也就是现在正在等待的线程已经满足条件了，那么当前线程会通过调用 notify() / notifyAll() 来通知等待的线程；而收到消息的线程则可以继续向下执行。</p>\n<p>需要注意的是，很可能并不是只有一个线程在等待，但是只能有一个线程进入同步代码块，也就是说，收到通知消息的消息也并不一定可以继续向下执行。这就要求等待线程需要遵循一定的设计模式，即<code>在同步代码块中，重复检查条件是否已经满足</code>。</p>\n<pre><code class=\"java\">synchronized(this){\n    while(isConditionFulfilled == false){\n        wait();\n    }\n    // 代码执行到这里时，才说明状态是对的\n}\n</code></pre>\n<p>以上代码在同步代码块中再次检查了条件是否满足。如果不满足条件，则当前线程挂起等待；当收到通知消息，等待线程被唤醒，它在执行关键代码前会再次校验同步条件是否满足，因为有可能被其他线程捷足先登，如果不满足条件，则其会继续挂起，等待下一个唤醒信号。</p>\n<p>以上机制很好的协同了多线程的通信，但是不适合 Android 平台，因为 UI 线程绝不能挂起等待工作线程完成任务后唤醒，之后的文章中介绍 Android 消息分发机制。</p>\n<h3 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h3><p>线程信令是一种低级，高度可配置的机制，尽管它可以应用在很多场景，但同时这也是一种极容易出错的技术。因此，Java 平台基于线程信令机制，重新构建了一套抽象概念，以期解决线程之间多对象的单向切换。</p>\n<p>在这一机制中，线程的挂起和唤醒不再通过消费者和生产者本身来控制，而是通过一个带有阻塞特性的队列来完成，例如，<code>java.util.concurrent.BlockingQueue</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg\" alt=\"BlockingQueue\"></p>\n<p>阻塞队列扮演着生产者线程和消费者线程中间的协调者，内部维护一个实现了线程信令机制，可自定义大小的列表。具体使用的时候，如果队列中数据已满，则生产者线程 put() 方法会阻塞，直到消费者从队列中取出数据；如果队列为空，则消费者线程 take() 方法会阻塞，直到生产者向队列中插入数据。</p>\n<pre><code class=\"java\">public class ConsumerProducer{\n    private final int LIMIT = 10;\n    private BlockingQueue&lt;Integer&gt; blockingQueue = \n        new LinkedBlockingQueue&lt;Integer&gt;(LIMIT);\n\n    public void produce() throws InterruptedException{\n        int value = 0;\n        while(true){\n            blockingQueue.put(value++);\n        }\n    }\n\n    public void consume() throws InterruptedException{\n        while(true){\n            int value = blockingQueue.take();\n        }\n    }\n\n}\n</code></pre>\n<p>以上是第四章前半部分内容，由于篇幅较长，准备分为两篇来记录。</p>\n<p>接下来会介绍 Android 平台的消息分发机制，下篇再见，大家加油~</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321185255.png","title":"Android 系统中的线程","date":"2018-08-28T16:00:00.000Z","_content":"\n> Efficient.Android.Threading 第三章读书笔记\n\n<!--more-->\n\n每个 Android 应用程序都会运行着很多线程，这些线程一般都与 Linux 进程绑定，并且通过 Dalvik VM 来管理各线程的内部执行。应用主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程，本章主要讨论方向：\n\n-  UI 线程，binder 线程，后台线程的区别\n- Linux thread coupling\n- 应用程序排名会对线程的执行造成怎样的影响\n- 执行 Linux 线程\n\n### Android 应用层线程\n\nAndroid 应用层主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程。\n\n#### UI 线程\n\nUI 线程在应用启动时启动，生命周期与应用相同。作为 Android 应用的主线程，UI 线程主要负责 Android 组件和界面 UI 的绘制与更新。当用户尝试在其他线程更新 UI 时，系统则会抛出异常。尽管这个处理方式看上去很不友好，但却是非常必要的。因为 Android UI Toolkit 不是线程安全的，所以为了规避不必要的麻烦，runtime 只能有一个线程来操作 UI 。\n\nUI 线程是基于消息机制的，按照事件的顺序依次执行。所有的线程都可以通过 Handler 将事件发送到 UI 线程，如果当前线程正在做着排在前面的事件，则该事件会入队等待。\n\n#### Binder 线程\n\nBinder 线程主要是用来为不同进程之间提供通信的。每个进程都维护一个线程池，不会频繁的新建和销毁线程，而是不断复用现有的几个线程来协同工作。Binder 线程处理来自其他进程的请求，具体包括系统服务，intents, content providers, services。大部分涉及不到进程间通信的场景，消息都是通过 UI 线程来进行处理的。一个例外是，当前应用可能提供了一个 `Service` ，其通过 AIDL 接口与其他进程实现了绑定。\n\n#### 后台线程\n\n一个应用程序中，所有需要调用者显式声明的线程，都是后台线程。一般来讲，后台线程是用户手动声明的，也就是说其默认没有任何实现，全部的工作都由调用者来定义。后台线程本质上属于 UI 线程的后代，所以它继承了一部分 UI 线程的特性，比如优先级。\n\n在 Android 应用层，UI 线程与后台线程处理的工作是完全不同的；但是在 Linux 系统层面，二者是没有任何区别的。UI 界面的更新只能通过 UI 线程来进行，并不是被 Linux 限定的，而是通过 Application Framework 层的 Window Manager 来限制的。\n\n### Linux 进程与线程\n\nAndroid 系统是基于 Linux 内核的，每个应用程序实际上都是一个 Linux 程序。Android 系统的每个应用都有一个隐藏的 Linux 进程，其 fork 自 Zygote 进程，有以下几个值得注意的属性：\n\n- User ID(UID)\n\n  Linux 系统是多用户系统，在 Android 系统中，每个应用就代表一个用户，当应用安装到系统中时，会被指定一个 User ID\n\n- Process identifier (PID)\n\n  当前进程的唯一标识\n\n- Parent process identifier  (PPID)\n\n  系统启动后，每个进程都是依附于其他进程而创建的。因此，所有正在运行中的进程会构成一个进程树，所有每个应用都有一个父亲进程。就 Android 系统来讲，所有进程的父进程都是 Zygote 进程\n\n- Stack\n\n  存储本地方法的变量和指针\n\n- Heap\n\n  当前进程私有化的地址数据信息，无法被其他进程获取到\n\n进程和线程一个很重要的区别就是，不同进程之间无法共享地址数据，但是同一进程的不同线程可以共享数据。这就直接导致了，线程间通信速度比进程间通信速度快得多。进程间通信需要进行一些远程操作调用，而这个过程开销比较大。\n\n一般来讲，应用启动以后，会创建不超过十个线程；第一个创建的线程便是我们所熟知的 UI 线程，之后所有的线程都是 UI 线程繁衍出来的。具体表现在，UI 线程的 PID 是 4257，之后所有线程的 PPID 都是 UI 线程的 PID：\n\n![adb shell ps](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182600.jpg)\n\n#### 线程的调度\n\nLinux 中线程为最小调度单元，而并非进程。一个程序中的某个线程需要和其他所有线程进行执行机会的争夺，在 Android 程序中，线程的调度都是直接交给 Linux 内核来处理的，而并非 Dalvik 虚拟机，也就是说每个线程都要和整个系统中的所有应用的所有线程做资源的争夺。\n\nLinux 的线程调度器又被称为完全公平调度程序 `completely fair scheduler` ，原因就在于它执行调度时不只根据优先级，还会参考具体线程的执行时间来做判断。如果某个线程之前很少有机会被处理器执行，那么即使它优先级很低，那它也会优先得到执行；如果某个线程很少需要执行，那 CFS 会降低它的优先级，以保证它不会过分争抢资源。\n\nLinux 平台主要有两种方式来影响线程的调度：\n\n1. 更改线程优先级\n2. 更改 Android 专有的控制组 `control group`\n\n##### 优先级\n\n线程的优先级在 Linux 中被称为友善度 `niceness` / `nicevalue` ，指的是当前线程对其他线程的友善程度。也就是说，友善度越低，即越不友善，则优先级越高。在 Android 中，Linux 线程的友善度从低到高为 -20 到 19，默认值为 0。\n\n某个线程的优先级与初始化该线程所在的线程优先级相同，除非其被系统显式修改。一个应用可以通过以下两种方式更改线程的优先级：\n\n- java.lang.Thread\n\n```java\n// Java 线程优先级，从 0 到 10 依次递增\nsetPriority(int priority);\n```\n\n- android.os.Process\n\n```java\nProcess.setThreadPriority(int priority);\nProcess.setThreadPriority(int threadId, int priority);\n```\n\n##### 控制组\n\nAndroid 平台不是单纯依赖 Linux 的 CFS 调度系统的，还对所有的线程进行控制组控制。所谓控制组，实际上是一个 Linux 容器，该容器用来管理当前容器中所有执行线程的处理器执行时间。一个应用中创建的所有线程都会属于某一个控制组。\n\nAndroid 系统中定义了很多控制组，但是最重要的是前台组和后台组。\n\n其中，前台组相较于后台组会得到更多的执行机会，后台组中所有的线程加一起，也得不到超过 10% 的执行时间，Android 系统就是利用这个特点来保证前台进程会得到更多的执行机会，从而保证性能和效果。\n\n具体某个线程是否展示在前台，则与其所在进程的级别和类型有关系：\n\n![](http://p5zd0id9p.bkt.clouddn.com/18-8-30/70891310.jpg)\n\n如图所示，如果某个进程执行在前台页面或者其他前台进程中，那么该进程创建的线程就会属于前台组，同时得到绝大部分的执行时间；而剩下的时间就会被分配给后台组来执行任务。\n\n当用户进行应用切换操作时，某个线程的控制组也会实时跟着更新：按下 Home 键时，原本的前台进程会退居后台，其内部线程也会进入后台控制组；而原来的后台组也会来到前台，占据大部分的 cpu 执行时间。\n\n这种方式极大的提高了前台应用的执行效率，一定程度上也降低了后台应用抢占系统资源的可能性，从而提高应用的性能。\n\n尽管控制组可以一定程度上避免后台应用进程过分抢占资源，但是用户仍然可以在后台进程中创建大量线程来和 UI 线程抢占 cpu 资源。由于其在主线程创建，所以那些子线程与 UI 线程有着同样的优先级和控制组，所以这部分线程会极大的威胁到 UI 线程的正确执行。因此，有时候用户创建大量的后台进程来处理任务，本意可能是不影响 UI 线程正常工作，但是很有可能会适得其反。\n\n像我们之前说到的，前台组和后台组是根据当前应用是否处于用户可见来界定划分的，也就是说，用户可见的应用程序中的后台线程，也是属于前台组的，会获得大部分的执行机会。在这种情况下，大量的后台线程就会影响到 UI 线程的工作，为解决这个问题，开发者可以通过将后台线程与其创建时的控制组，也就是 UI 线程所在的控制组，进行解耦分离。这个过程可以通过给线程设置足够低的优先级来实现，这样一来，这些后台线程会永远属于后台控制组，即使是其所在的进程当前是处于前台界面展示的。\n\n```java\n// 这个方法不但可以降低优先级；\n// 还能保证当前线程与进程解耦分离，保证其永远处于后台控制组\nProcess.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n```\n\n### 总结\n\nAndroid 系统中所有的线程类型：UI，binder，后台，本质上都属于 Linux Posix 线程。其中，UI 线程和 binder 线程是在应用启动时自动创建的，后台线程则完全是开发者按需创建的。Android 中所有的组件任务都是默认执行在 UI 线程的，但是为了避免界面效果卡顿以及 ANR 异常，长时间的耗时操作应该在后台进程中执行。尽管 UI 线程是最重要的执行线程，但是由于系统并不知道谁是 UI 线程，所以应该在开发时就明确注意，不要让后台线程喧宾夺主，扰乱 UI 线程的工作。这个效果通常来讲有两种实现方式，一是降低优先级，二是让不是那么重要的后台线程进入后台控制组执行。\n\n\n\n","source":"_posts/Efficient-Android-Threading-chapter-3.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321185255.png\ntitle: Android 系统中的线程\ntags: [读书笔记, Efficient.Android.Threading]\ndate: 2018-08-29\n---\n\n> Efficient.Android.Threading 第三章读书笔记\n\n<!--more-->\n\n每个 Android 应用程序都会运行着很多线程，这些线程一般都与 Linux 进程绑定，并且通过 Dalvik VM 来管理各线程的内部执行。应用主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程，本章主要讨论方向：\n\n-  UI 线程，binder 线程，后台线程的区别\n- Linux thread coupling\n- 应用程序排名会对线程的执行造成怎样的影响\n- 执行 Linux 线程\n\n### Android 应用层线程\n\nAndroid 应用层主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程。\n\n#### UI 线程\n\nUI 线程在应用启动时启动，生命周期与应用相同。作为 Android 应用的主线程，UI 线程主要负责 Android 组件和界面 UI 的绘制与更新。当用户尝试在其他线程更新 UI 时，系统则会抛出异常。尽管这个处理方式看上去很不友好，但却是非常必要的。因为 Android UI Toolkit 不是线程安全的，所以为了规避不必要的麻烦，runtime 只能有一个线程来操作 UI 。\n\nUI 线程是基于消息机制的，按照事件的顺序依次执行。所有的线程都可以通过 Handler 将事件发送到 UI 线程，如果当前线程正在做着排在前面的事件，则该事件会入队等待。\n\n#### Binder 线程\n\nBinder 线程主要是用来为不同进程之间提供通信的。每个进程都维护一个线程池，不会频繁的新建和销毁线程，而是不断复用现有的几个线程来协同工作。Binder 线程处理来自其他进程的请求，具体包括系统服务，intents, content providers, services。大部分涉及不到进程间通信的场景，消息都是通过 UI 线程来进行处理的。一个例外是，当前应用可能提供了一个 `Service` ，其通过 AIDL 接口与其他进程实现了绑定。\n\n#### 后台线程\n\n一个应用程序中，所有需要调用者显式声明的线程，都是后台线程。一般来讲，后台线程是用户手动声明的，也就是说其默认没有任何实现，全部的工作都由调用者来定义。后台线程本质上属于 UI 线程的后代，所以它继承了一部分 UI 线程的特性，比如优先级。\n\n在 Android 应用层，UI 线程与后台线程处理的工作是完全不同的；但是在 Linux 系统层面，二者是没有任何区别的。UI 界面的更新只能通过 UI 线程来进行，并不是被 Linux 限定的，而是通过 Application Framework 层的 Window Manager 来限制的。\n\n### Linux 进程与线程\n\nAndroid 系统是基于 Linux 内核的，每个应用程序实际上都是一个 Linux 程序。Android 系统的每个应用都有一个隐藏的 Linux 进程，其 fork 自 Zygote 进程，有以下几个值得注意的属性：\n\n- User ID(UID)\n\n  Linux 系统是多用户系统，在 Android 系统中，每个应用就代表一个用户，当应用安装到系统中时，会被指定一个 User ID\n\n- Process identifier (PID)\n\n  当前进程的唯一标识\n\n- Parent process identifier  (PPID)\n\n  系统启动后，每个进程都是依附于其他进程而创建的。因此，所有正在运行中的进程会构成一个进程树，所有每个应用都有一个父亲进程。就 Android 系统来讲，所有进程的父进程都是 Zygote 进程\n\n- Stack\n\n  存储本地方法的变量和指针\n\n- Heap\n\n  当前进程私有化的地址数据信息，无法被其他进程获取到\n\n进程和线程一个很重要的区别就是，不同进程之间无法共享地址数据，但是同一进程的不同线程可以共享数据。这就直接导致了，线程间通信速度比进程间通信速度快得多。进程间通信需要进行一些远程操作调用，而这个过程开销比较大。\n\n一般来讲，应用启动以后，会创建不超过十个线程；第一个创建的线程便是我们所熟知的 UI 线程，之后所有的线程都是 UI 线程繁衍出来的。具体表现在，UI 线程的 PID 是 4257，之后所有线程的 PPID 都是 UI 线程的 PID：\n\n![adb shell ps](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182600.jpg)\n\n#### 线程的调度\n\nLinux 中线程为最小调度单元，而并非进程。一个程序中的某个线程需要和其他所有线程进行执行机会的争夺，在 Android 程序中，线程的调度都是直接交给 Linux 内核来处理的，而并非 Dalvik 虚拟机，也就是说每个线程都要和整个系统中的所有应用的所有线程做资源的争夺。\n\nLinux 的线程调度器又被称为完全公平调度程序 `completely fair scheduler` ，原因就在于它执行调度时不只根据优先级，还会参考具体线程的执行时间来做判断。如果某个线程之前很少有机会被处理器执行，那么即使它优先级很低，那它也会优先得到执行；如果某个线程很少需要执行，那 CFS 会降低它的优先级，以保证它不会过分争抢资源。\n\nLinux 平台主要有两种方式来影响线程的调度：\n\n1. 更改线程优先级\n2. 更改 Android 专有的控制组 `control group`\n\n##### 优先级\n\n线程的优先级在 Linux 中被称为友善度 `niceness` / `nicevalue` ，指的是当前线程对其他线程的友善程度。也就是说，友善度越低，即越不友善，则优先级越高。在 Android 中，Linux 线程的友善度从低到高为 -20 到 19，默认值为 0。\n\n某个线程的优先级与初始化该线程所在的线程优先级相同，除非其被系统显式修改。一个应用可以通过以下两种方式更改线程的优先级：\n\n- java.lang.Thread\n\n```java\n// Java 线程优先级，从 0 到 10 依次递增\nsetPriority(int priority);\n```\n\n- android.os.Process\n\n```java\nProcess.setThreadPriority(int priority);\nProcess.setThreadPriority(int threadId, int priority);\n```\n\n##### 控制组\n\nAndroid 平台不是单纯依赖 Linux 的 CFS 调度系统的，还对所有的线程进行控制组控制。所谓控制组，实际上是一个 Linux 容器，该容器用来管理当前容器中所有执行线程的处理器执行时间。一个应用中创建的所有线程都会属于某一个控制组。\n\nAndroid 系统中定义了很多控制组，但是最重要的是前台组和后台组。\n\n其中，前台组相较于后台组会得到更多的执行机会，后台组中所有的线程加一起，也得不到超过 10% 的执行时间，Android 系统就是利用这个特点来保证前台进程会得到更多的执行机会，从而保证性能和效果。\n\n具体某个线程是否展示在前台，则与其所在进程的级别和类型有关系：\n\n![](http://p5zd0id9p.bkt.clouddn.com/18-8-30/70891310.jpg)\n\n如图所示，如果某个进程执行在前台页面或者其他前台进程中，那么该进程创建的线程就会属于前台组，同时得到绝大部分的执行时间；而剩下的时间就会被分配给后台组来执行任务。\n\n当用户进行应用切换操作时，某个线程的控制组也会实时跟着更新：按下 Home 键时，原本的前台进程会退居后台，其内部线程也会进入后台控制组；而原来的后台组也会来到前台，占据大部分的 cpu 执行时间。\n\n这种方式极大的提高了前台应用的执行效率，一定程度上也降低了后台应用抢占系统资源的可能性，从而提高应用的性能。\n\n尽管控制组可以一定程度上避免后台应用进程过分抢占资源，但是用户仍然可以在后台进程中创建大量线程来和 UI 线程抢占 cpu 资源。由于其在主线程创建，所以那些子线程与 UI 线程有着同样的优先级和控制组，所以这部分线程会极大的威胁到 UI 线程的正确执行。因此，有时候用户创建大量的后台进程来处理任务，本意可能是不影响 UI 线程正常工作，但是很有可能会适得其反。\n\n像我们之前说到的，前台组和后台组是根据当前应用是否处于用户可见来界定划分的，也就是说，用户可见的应用程序中的后台线程，也是属于前台组的，会获得大部分的执行机会。在这种情况下，大量的后台线程就会影响到 UI 线程的工作，为解决这个问题，开发者可以通过将后台线程与其创建时的控制组，也就是 UI 线程所在的控制组，进行解耦分离。这个过程可以通过给线程设置足够低的优先级来实现，这样一来，这些后台线程会永远属于后台控制组，即使是其所在的进程当前是处于前台界面展示的。\n\n```java\n// 这个方法不但可以降低优先级；\n// 还能保证当前线程与进程解耦分离，保证其永远处于后台控制组\nProcess.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n```\n\n### 总结\n\nAndroid 系统中所有的线程类型：UI，binder，后台，本质上都属于 Linux Posix 线程。其中，UI 线程和 binder 线程是在应用启动时自动创建的，后台线程则完全是开发者按需创建的。Android 中所有的组件任务都是默认执行在 UI 线程的，但是为了避免界面效果卡顿以及 ANR 异常，长时间的耗时操作应该在后台进程中执行。尽管 UI 线程是最重要的执行线程，但是由于系统并不知道谁是 UI 线程，所以应该在开发时就明确注意，不要让后台线程喧宾夺主，扰乱 UI 线程的工作。这个效果通常来讲有两种实现方式，一是降低优先级，二是让不是那么重要的后台线程进入后台控制组执行。\n\n\n\n","slug":"Efficient-Android-Threading-chapter-3","published":1,"updated":"2019-03-21T10:53:39.443Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86dk0017lh1p03r88n5a","content":"<blockquote>\n<p>Efficient.Android.Threading 第三章读书笔记</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>每个 Android 应用程序都会运行着很多线程，这些线程一般都与 Linux 进程绑定，并且通过 Dalvik VM 来管理各线程的内部执行。应用主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程，本章主要讨论方向：</p>\n<ul>\n<li>UI 线程，binder 线程，后台线程的区别</li>\n<li>Linux thread coupling</li>\n<li>应用程序排名会对线程的执行造成怎样的影响</li>\n<li>执行 Linux 线程</li>\n</ul>\n<h3 id=\"Android-应用层线程\"><a href=\"#Android-应用层线程\" class=\"headerlink\" title=\"Android 应用层线程\"></a>Android 应用层线程</h3><p>Android 应用层主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程。</p>\n<h4 id=\"UI-线程\"><a href=\"#UI-线程\" class=\"headerlink\" title=\"UI 线程\"></a>UI 线程</h4><p>UI 线程在应用启动时启动，生命周期与应用相同。作为 Android 应用的主线程，UI 线程主要负责 Android 组件和界面 UI 的绘制与更新。当用户尝试在其他线程更新 UI 时，系统则会抛出异常。尽管这个处理方式看上去很不友好，但却是非常必要的。因为 Android UI Toolkit 不是线程安全的，所以为了规避不必要的麻烦，runtime 只能有一个线程来操作 UI 。</p>\n<p>UI 线程是基于消息机制的，按照事件的顺序依次执行。所有的线程都可以通过 Handler 将事件发送到 UI 线程，如果当前线程正在做着排在前面的事件，则该事件会入队等待。</p>\n<h4 id=\"Binder-线程\"><a href=\"#Binder-线程\" class=\"headerlink\" title=\"Binder 线程\"></a>Binder 线程</h4><p>Binder 线程主要是用来为不同进程之间提供通信的。每个进程都维护一个线程池，不会频繁的新建和销毁线程，而是不断复用现有的几个线程来协同工作。Binder 线程处理来自其他进程的请求，具体包括系统服务，intents, content providers, services。大部分涉及不到进程间通信的场景，消息都是通过 UI 线程来进行处理的。一个例外是，当前应用可能提供了一个 <code>Service</code> ，其通过 AIDL 接口与其他进程实现了绑定。</p>\n<h4 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h4><p>一个应用程序中，所有需要调用者显式声明的线程，都是后台线程。一般来讲，后台线程是用户手动声明的，也就是说其默认没有任何实现，全部的工作都由调用者来定义。后台线程本质上属于 UI 线程的后代，所以它继承了一部分 UI 线程的特性，比如优先级。</p>\n<p>在 Android 应用层，UI 线程与后台线程处理的工作是完全不同的；但是在 Linux 系统层面，二者是没有任何区别的。UI 界面的更新只能通过 UI 线程来进行，并不是被 Linux 限定的，而是通过 Application Framework 层的 Window Manager 来限制的。</p>\n<h3 id=\"Linux-进程与线程\"><a href=\"#Linux-进程与线程\" class=\"headerlink\" title=\"Linux 进程与线程\"></a>Linux 进程与线程</h3><p>Android 系统是基于 Linux 内核的，每个应用程序实际上都是一个 Linux 程序。Android 系统的每个应用都有一个隐藏的 Linux 进程，其 fork 自 Zygote 进程，有以下几个值得注意的属性：</p>\n<ul>\n<li><p>User ID(UID)</p>\n<p>Linux 系统是多用户系统，在 Android 系统中，每个应用就代表一个用户，当应用安装到系统中时，会被指定一个 User ID</p>\n</li>\n<li><p>Process identifier (PID)</p>\n<p>当前进程的唯一标识</p>\n</li>\n<li><p>Parent process identifier  (PPID)</p>\n<p>系统启动后，每个进程都是依附于其他进程而创建的。因此，所有正在运行中的进程会构成一个进程树，所有每个应用都有一个父亲进程。就 Android 系统来讲，所有进程的父进程都是 Zygote 进程</p>\n</li>\n<li><p>Stack</p>\n<p>存储本地方法的变量和指针</p>\n</li>\n<li><p>Heap</p>\n<p>当前进程私有化的地址数据信息，无法被其他进程获取到</p>\n</li>\n</ul>\n<p>进程和线程一个很重要的区别就是，不同进程之间无法共享地址数据，但是同一进程的不同线程可以共享数据。这就直接导致了，线程间通信速度比进程间通信速度快得多。进程间通信需要进行一些远程操作调用，而这个过程开销比较大。</p>\n<p>一般来讲，应用启动以后，会创建不超过十个线程；第一个创建的线程便是我们所熟知的 UI 线程，之后所有的线程都是 UI 线程繁衍出来的。具体表现在，UI 线程的 PID 是 4257，之后所有线程的 PPID 都是 UI 线程的 PID：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182600.jpg\" alt=\"adb shell ps\"></p>\n<h4 id=\"线程的调度\"><a href=\"#线程的调度\" class=\"headerlink\" title=\"线程的调度\"></a>线程的调度</h4><p>Linux 中线程为最小调度单元，而并非进程。一个程序中的某个线程需要和其他所有线程进行执行机会的争夺，在 Android 程序中，线程的调度都是直接交给 Linux 内核来处理的，而并非 Dalvik 虚拟机，也就是说每个线程都要和整个系统中的所有应用的所有线程做资源的争夺。</p>\n<p>Linux 的线程调度器又被称为完全公平调度程序 <code>completely fair scheduler</code> ，原因就在于它执行调度时不只根据优先级，还会参考具体线程的执行时间来做判断。如果某个线程之前很少有机会被处理器执行，那么即使它优先级很低，那它也会优先得到执行；如果某个线程很少需要执行，那 CFS 会降低它的优先级，以保证它不会过分争抢资源。</p>\n<p>Linux 平台主要有两种方式来影响线程的调度：</p>\n<ol>\n<li>更改线程优先级</li>\n<li>更改 Android 专有的控制组 <code>control group</code></li>\n</ol>\n<h5 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h5><p>线程的优先级在 Linux 中被称为友善度 <code>niceness</code> / <code>nicevalue</code> ，指的是当前线程对其他线程的友善程度。也就是说，友善度越低，即越不友善，则优先级越高。在 Android 中，Linux 线程的友善度从低到高为 -20 到 19，默认值为 0。</p>\n<p>某个线程的优先级与初始化该线程所在的线程优先级相同，除非其被系统显式修改。一个应用可以通过以下两种方式更改线程的优先级：</p>\n<ul>\n<li>java.lang.Thread</li>\n</ul>\n<pre><code class=\"java\">// Java 线程优先级，从 0 到 10 依次递增\nsetPriority(int priority);\n</code></pre>\n<ul>\n<li>android.os.Process</li>\n</ul>\n<pre><code class=\"java\">Process.setThreadPriority(int priority);\nProcess.setThreadPriority(int threadId, int priority);\n</code></pre>\n<h5 id=\"控制组\"><a href=\"#控制组\" class=\"headerlink\" title=\"控制组\"></a>控制组</h5><p>Android 平台不是单纯依赖 Linux 的 CFS 调度系统的，还对所有的线程进行控制组控制。所谓控制组，实际上是一个 Linux 容器，该容器用来管理当前容器中所有执行线程的处理器执行时间。一个应用中创建的所有线程都会属于某一个控制组。</p>\n<p>Android 系统中定义了很多控制组，但是最重要的是前台组和后台组。</p>\n<p>其中，前台组相较于后台组会得到更多的执行机会，后台组中所有的线程加一起，也得不到超过 10% 的执行时间，Android 系统就是利用这个特点来保证前台进程会得到更多的执行机会，从而保证性能和效果。</p>\n<p>具体某个线程是否展示在前台，则与其所在进程的级别和类型有关系：</p>\n<p><img src=\"http://p5zd0id9p.bkt.clouddn.com/18-8-30/70891310.jpg\" alt=\"\"></p>\n<p>如图所示，如果某个进程执行在前台页面或者其他前台进程中，那么该进程创建的线程就会属于前台组，同时得到绝大部分的执行时间；而剩下的时间就会被分配给后台组来执行任务。</p>\n<p>当用户进行应用切换操作时，某个线程的控制组也会实时跟着更新：按下 Home 键时，原本的前台进程会退居后台，其内部线程也会进入后台控制组；而原来的后台组也会来到前台，占据大部分的 cpu 执行时间。</p>\n<p>这种方式极大的提高了前台应用的执行效率，一定程度上也降低了后台应用抢占系统资源的可能性，从而提高应用的性能。</p>\n<p>尽管控制组可以一定程度上避免后台应用进程过分抢占资源，但是用户仍然可以在后台进程中创建大量线程来和 UI 线程抢占 cpu 资源。由于其在主线程创建，所以那些子线程与 UI 线程有着同样的优先级和控制组，所以这部分线程会极大的威胁到 UI 线程的正确执行。因此，有时候用户创建大量的后台进程来处理任务，本意可能是不影响 UI 线程正常工作，但是很有可能会适得其反。</p>\n<p>像我们之前说到的，前台组和后台组是根据当前应用是否处于用户可见来界定划分的，也就是说，用户可见的应用程序中的后台线程，也是属于前台组的，会获得大部分的执行机会。在这种情况下，大量的后台线程就会影响到 UI 线程的工作，为解决这个问题，开发者可以通过将后台线程与其创建时的控制组，也就是 UI 线程所在的控制组，进行解耦分离。这个过程可以通过给线程设置足够低的优先级来实现，这样一来，这些后台线程会永远属于后台控制组，即使是其所在的进程当前是处于前台界面展示的。</p>\n<pre><code class=\"java\">// 这个方法不但可以降低优先级；\n// 还能保证当前线程与进程解耦分离，保证其永远处于后台控制组\nProcess.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Android 系统中所有的线程类型：UI，binder，后台，本质上都属于 Linux Posix 线程。其中，UI 线程和 binder 线程是在应用启动时自动创建的，后台线程则完全是开发者按需创建的。Android 中所有的组件任务都是默认执行在 UI 线程的，但是为了避免界面效果卡顿以及 ANR 异常，长时间的耗时操作应该在后台进程中执行。尽管 UI 线程是最重要的执行线程，但是由于系统并不知道谁是 UI 线程，所以应该在开发时就明确注意，不要让后台线程喧宾夺主，扰乱 UI 线程的工作。这个效果通常来讲有两种实现方式，一是降低优先级，二是让不是那么重要的后台线程进入后台控制组执行。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Efficient.Android.Threading 第三章读书笔记</p>\n</blockquote>","more":"<p>每个 Android 应用程序都会运行着很多线程，这些线程一般都与 Linux 进程绑定，并且通过 Dalvik VM 来管理各线程的内部执行。应用主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程，本章主要讨论方向：</p>\n<ul>\n<li>UI 线程，binder 线程，后台线程的区别</li>\n<li>Linux thread coupling</li>\n<li>应用程序排名会对线程的执行造成怎样的影响</li>\n<li>执行 Linux 线程</li>\n</ul>\n<h3 id=\"Android-应用层线程\"><a href=\"#Android-应用层线程\" class=\"headerlink\" title=\"Android 应用层线程\"></a>Android 应用层线程</h3><p>Android 应用层主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程。</p>\n<h4 id=\"UI-线程\"><a href=\"#UI-线程\" class=\"headerlink\" title=\"UI 线程\"></a>UI 线程</h4><p>UI 线程在应用启动时启动，生命周期与应用相同。作为 Android 应用的主线程，UI 线程主要负责 Android 组件和界面 UI 的绘制与更新。当用户尝试在其他线程更新 UI 时，系统则会抛出异常。尽管这个处理方式看上去很不友好，但却是非常必要的。因为 Android UI Toolkit 不是线程安全的，所以为了规避不必要的麻烦，runtime 只能有一个线程来操作 UI 。</p>\n<p>UI 线程是基于消息机制的，按照事件的顺序依次执行。所有的线程都可以通过 Handler 将事件发送到 UI 线程，如果当前线程正在做着排在前面的事件，则该事件会入队等待。</p>\n<h4 id=\"Binder-线程\"><a href=\"#Binder-线程\" class=\"headerlink\" title=\"Binder 线程\"></a>Binder 线程</h4><p>Binder 线程主要是用来为不同进程之间提供通信的。每个进程都维护一个线程池，不会频繁的新建和销毁线程，而是不断复用现有的几个线程来协同工作。Binder 线程处理来自其他进程的请求，具体包括系统服务，intents, content providers, services。大部分涉及不到进程间通信的场景，消息都是通过 UI 线程来进行处理的。一个例外是，当前应用可能提供了一个 <code>Service</code> ，其通过 AIDL 接口与其他进程实现了绑定。</p>\n<h4 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h4><p>一个应用程序中，所有需要调用者显式声明的线程，都是后台线程。一般来讲，后台线程是用户手动声明的，也就是说其默认没有任何实现，全部的工作都由调用者来定义。后台线程本质上属于 UI 线程的后代，所以它继承了一部分 UI 线程的特性，比如优先级。</p>\n<p>在 Android 应用层，UI 线程与后台线程处理的工作是完全不同的；但是在 Linux 系统层面，二者是没有任何区别的。UI 界面的更新只能通过 UI 线程来进行，并不是被 Linux 限定的，而是通过 Application Framework 层的 Window Manager 来限制的。</p>\n<h3 id=\"Linux-进程与线程\"><a href=\"#Linux-进程与线程\" class=\"headerlink\" title=\"Linux 进程与线程\"></a>Linux 进程与线程</h3><p>Android 系统是基于 Linux 内核的，每个应用程序实际上都是一个 Linux 程序。Android 系统的每个应用都有一个隐藏的 Linux 进程，其 fork 自 Zygote 进程，有以下几个值得注意的属性：</p>\n<ul>\n<li><p>User ID(UID)</p>\n<p>Linux 系统是多用户系统，在 Android 系统中，每个应用就代表一个用户，当应用安装到系统中时，会被指定一个 User ID</p>\n</li>\n<li><p>Process identifier (PID)</p>\n<p>当前进程的唯一标识</p>\n</li>\n<li><p>Parent process identifier  (PPID)</p>\n<p>系统启动后，每个进程都是依附于其他进程而创建的。因此，所有正在运行中的进程会构成一个进程树，所有每个应用都有一个父亲进程。就 Android 系统来讲，所有进程的父进程都是 Zygote 进程</p>\n</li>\n<li><p>Stack</p>\n<p>存储本地方法的变量和指针</p>\n</li>\n<li><p>Heap</p>\n<p>当前进程私有化的地址数据信息，无法被其他进程获取到</p>\n</li>\n</ul>\n<p>进程和线程一个很重要的区别就是，不同进程之间无法共享地址数据，但是同一进程的不同线程可以共享数据。这就直接导致了，线程间通信速度比进程间通信速度快得多。进程间通信需要进行一些远程操作调用，而这个过程开销比较大。</p>\n<p>一般来讲，应用启动以后，会创建不超过十个线程；第一个创建的线程便是我们所熟知的 UI 线程，之后所有的线程都是 UI 线程繁衍出来的。具体表现在，UI 线程的 PID 是 4257，之后所有线程的 PPID 都是 UI 线程的 PID：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182600.jpg\" alt=\"adb shell ps\"></p>\n<h4 id=\"线程的调度\"><a href=\"#线程的调度\" class=\"headerlink\" title=\"线程的调度\"></a>线程的调度</h4><p>Linux 中线程为最小调度单元，而并非进程。一个程序中的某个线程需要和其他所有线程进行执行机会的争夺，在 Android 程序中，线程的调度都是直接交给 Linux 内核来处理的，而并非 Dalvik 虚拟机，也就是说每个线程都要和整个系统中的所有应用的所有线程做资源的争夺。</p>\n<p>Linux 的线程调度器又被称为完全公平调度程序 <code>completely fair scheduler</code> ，原因就在于它执行调度时不只根据优先级，还会参考具体线程的执行时间来做判断。如果某个线程之前很少有机会被处理器执行，那么即使它优先级很低，那它也会优先得到执行；如果某个线程很少需要执行，那 CFS 会降低它的优先级，以保证它不会过分争抢资源。</p>\n<p>Linux 平台主要有两种方式来影响线程的调度：</p>\n<ol>\n<li>更改线程优先级</li>\n<li>更改 Android 专有的控制组 <code>control group</code></li>\n</ol>\n<h5 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h5><p>线程的优先级在 Linux 中被称为友善度 <code>niceness</code> / <code>nicevalue</code> ，指的是当前线程对其他线程的友善程度。也就是说，友善度越低，即越不友善，则优先级越高。在 Android 中，Linux 线程的友善度从低到高为 -20 到 19，默认值为 0。</p>\n<p>某个线程的优先级与初始化该线程所在的线程优先级相同，除非其被系统显式修改。一个应用可以通过以下两种方式更改线程的优先级：</p>\n<ul>\n<li>java.lang.Thread</li>\n</ul>\n<pre><code class=\"java\">// Java 线程优先级，从 0 到 10 依次递增\nsetPriority(int priority);\n</code></pre>\n<ul>\n<li>android.os.Process</li>\n</ul>\n<pre><code class=\"java\">Process.setThreadPriority(int priority);\nProcess.setThreadPriority(int threadId, int priority);\n</code></pre>\n<h5 id=\"控制组\"><a href=\"#控制组\" class=\"headerlink\" title=\"控制组\"></a>控制组</h5><p>Android 平台不是单纯依赖 Linux 的 CFS 调度系统的，还对所有的线程进行控制组控制。所谓控制组，实际上是一个 Linux 容器，该容器用来管理当前容器中所有执行线程的处理器执行时间。一个应用中创建的所有线程都会属于某一个控制组。</p>\n<p>Android 系统中定义了很多控制组，但是最重要的是前台组和后台组。</p>\n<p>其中，前台组相较于后台组会得到更多的执行机会，后台组中所有的线程加一起，也得不到超过 10% 的执行时间，Android 系统就是利用这个特点来保证前台进程会得到更多的执行机会，从而保证性能和效果。</p>\n<p>具体某个线程是否展示在前台，则与其所在进程的级别和类型有关系：</p>\n<p><img src=\"http://p5zd0id9p.bkt.clouddn.com/18-8-30/70891310.jpg\" alt=\"\"></p>\n<p>如图所示，如果某个进程执行在前台页面或者其他前台进程中，那么该进程创建的线程就会属于前台组，同时得到绝大部分的执行时间；而剩下的时间就会被分配给后台组来执行任务。</p>\n<p>当用户进行应用切换操作时，某个线程的控制组也会实时跟着更新：按下 Home 键时，原本的前台进程会退居后台，其内部线程也会进入后台控制组；而原来的后台组也会来到前台，占据大部分的 cpu 执行时间。</p>\n<p>这种方式极大的提高了前台应用的执行效率，一定程度上也降低了后台应用抢占系统资源的可能性，从而提高应用的性能。</p>\n<p>尽管控制组可以一定程度上避免后台应用进程过分抢占资源，但是用户仍然可以在后台进程中创建大量线程来和 UI 线程抢占 cpu 资源。由于其在主线程创建，所以那些子线程与 UI 线程有着同样的优先级和控制组，所以这部分线程会极大的威胁到 UI 线程的正确执行。因此，有时候用户创建大量的后台进程来处理任务，本意可能是不影响 UI 线程正常工作，但是很有可能会适得其反。</p>\n<p>像我们之前说到的，前台组和后台组是根据当前应用是否处于用户可见来界定划分的，也就是说，用户可见的应用程序中的后台线程，也是属于前台组的，会获得大部分的执行机会。在这种情况下，大量的后台线程就会影响到 UI 线程的工作，为解决这个问题，开发者可以通过将后台线程与其创建时的控制组，也就是 UI 线程所在的控制组，进行解耦分离。这个过程可以通过给线程设置足够低的优先级来实现，这样一来，这些后台线程会永远属于后台控制组，即使是其所在的进程当前是处于前台界面展示的。</p>\n<pre><code class=\"java\">// 这个方法不但可以降低优先级；\n// 还能保证当前线程与进程解耦分离，保证其永远处于后台控制组\nProcess.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Android 系统中所有的线程类型：UI，binder，后台，本质上都属于 Linux Posix 线程。其中，UI 线程和 binder 线程是在应用启动时自动创建的，后台线程则完全是开发者按需创建的。Android 中所有的组件任务都是默认执行在 UI 线程的，但是为了避免界面效果卡顿以及 ANR 异常，长时间的耗时操作应该在后台进程中执行。尽管 UI 线程是最重要的执行线程，但是由于系统并不知道谁是 UI 线程，所以应该在开发时就明确注意，不要让后台线程喧宾夺主，扰乱 UI 线程的工作。这个效果通常来讲有两种实现方式，一是降低优先级，二是让不是那么重要的后台线程进入后台控制组执行。</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321184908.jpg","title":"为何 Android 在 onCreate 中获取不到宽高","date":"2018-08-12T16:00:00.000Z","_content":"\n经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。\n\n<!--more-->\n\n具体代码如下：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @BindView(R.id.tv_test)\n    private TextView mTextView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mTv.getHeight(); // 0\n\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        mTv.getHeight(); // 0\n    }\n\n}\n```\n\n要弄清这个问题，首先需要知道代码中涉及到的方法具体做了什么工作，以及具体 View 是在什么时候完成测量的。\n\n### setContentView()\n\n很明显，我们在 onCreate() 方法中调用了 setContentView() 方法，而**设置布局**这个动作会给你一种可以获取到宽高的错觉；那么我们从源码的角度来看看，setContentView() 到底干了点什么。\n\n```java\n// 1. AppCompatDelegate 的抽象方法，根据注释，会调用到 Activity 的实现方法中\npublic abstract void setContentView(@LayoutRes int resId);\n\n// 2. Activity 的实现方法\npublic void setContentView(@LayoutRes int layoutResID) {\n    // Window 是一个抽象类，其唯一实现类是 PhoneWindow\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n\n@Override\npublic void setContentView(int layoutResID) {\n    if (mContentParent == null) {\n        // 3. 初始化 DecorView\n        installDecor();\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        mContentParent.removeAllViews();\n    }\n    ... ...\n}\n\nprivate void installDecor() {\n    mForceDecorInstall = false;\n    if (mDecor == null) {\n        // 4. 第一次加载窗口，mDecor 为空时，生成一个 DecorView 对象\n        // generateDecor(-1) : return new DecorView()\n        mDecor = generateDecor(-1);\n        ... ...\n    } else {\n        mDecor.setWindow(this);\n    }\n\n    if (mContentParent == null) {\n        // 5. 初始化父布局\n        mContentParent = generateLayout(mDecor);\n    }\n}\n\n// 继续跟踪到 generateLayout(mDecor) 方法内部\nprotected ViewGroup generateLayout(DecorView decor) {\n    // 此处根据设置的主题进行一些基础设置，没什么决定性作用\n    TypedArray a = getWindowStyle();\n    ... ...\n\n    // 接下来的一大段代码是根据各种主题设置默认布局，篇幅原因，此处有大量源码删减\n    int layoutResource;\n    int features = getLocalFeatures();\n    if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {\n        layoutResource = R.layout.screen_swipe_dismiss;\n        setCloseOnSwipeEnabled(true);\n    } else if ((features & (1 << FEATURE_NO_TITLE)) == 0) {\n        if (mIsFloating) {\n            TypedValue res = new TypedValue();\n            getContext().getTheme().resolveAttribute(\n                R.attr.dialogTitleDecorLayout, res, true);\n            layoutResource = res.resourceId;\n        } else if ((features & (1 << FEATURE_ACTION_BAR)) != 0) {\n            layoutResource = a.getResourceId(\n                R.styleable.Window_windowActionBarFullscreenDecorLayout,\n                R.layout.screen_action_bar);\n        } else {\n            layoutResource = R.layout.screen_title;\n        }\n    } else {\n        // 默认布局样式\n        layoutResource = R.layout.screen_simple;\n    }\n\n    // 6. 重点来了：将对应的布局加载到 DecorView 中\n    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);\n    return contentParent;\n}\n\nvoid onResourcesLoaded(LayoutInflater inflater, int layoutResource) {\n    // 加载资源文件\n    final View root = inflater.inflate(layoutResource, null);\n\t... ...\n    // 7. 将 View 加载到当前 DecorView 中\n    addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n}\n\npublic void addView(View child, int index, LayoutParams params) {\n    // 页面发生变化的话，请求重新摆放布局以及重新绘制\n    // 注意，此处的 requestLayout 是 View 的方法\n    requestLayout();\n    invalidate(true);\n    addViewInner(child, index, params, false);\n}\n```\n\n说出来你可能不信，但是 setContentView() 到这里就差不多结束了。\n\n很明显，我们并没有发现任何关于 View 的测量的代码，最后的 requestLayout() 和 invalidate() 也和 View 的 measure() 关系不大，毕竟还没测量，哪里谈得上 layout 和 draw 呢？\n\n所以， setContentView() 和 View 的测量没啥关系，那么在其之后也就自然获取不到 View 宽高的值了。\n\n\n\n### 测量流程到底是从哪里开始的\n\n有了上面的经验，我们已经知道，setContentView() 并不会触发 View 的测量，而只是为 DecorView 指定了布局；那么接下来的问题就是，测量流程到底是从哪里开始的呢？\n\n我们简单回顾一下 Activity 的启动流程，然后来找到这个答案。\n\n```java\npublic void handleMessage(Message msg) {\n    switch (msg.what) {\n        case LAUNCH_ACTIVITY: {\n            // 1. ActivityThread 内部类 H，处理 LAUNCH_ACTIVITY 的消息\n            handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n        } break;\n }\n\n// 2. 直接从 ActivityThread 的 handleLaunchActivity() 开始了\nprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {\n\n    // 3. 执行 performLaunchActivity() 方法\n    Activity a = performLaunchActivity(r, customIntent);\n\n    if (a != null) {\n        r.createdConfig = new Configuration(mConfiguration);\n        reportSizeConfigurations(r);\n        Bundle oldState = r.state;\n        // 4. 执行 handleResumeActivity() 方法\n        handleResumeActivity(r.token, false, r.isForward,\n                             !r.activity.mFinished && !r.startsNotResumed,\n                             r.lastProcessedSeq, reason);\n    }\n}\n\n// 3. performLaunchActivity()\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    // 基于反射，利用 Instrumentation 对象创建当前 Activity 的实例\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(\n            cl, component.getClassName(), r.intent);\n        StrictMode.incrementExpectedActivityCount(activity.getClass());\n        r.intent.setExtrasClassLoader(cl);\n        r.intent.prepareToEnterProcess();\n        if (r.state != null) {\n            r.state.setClassLoader(cl);\n        }\n    }\n\n    try {\n        if (activity != null) {\n            // attach() 方法做了一系列最基本的初始化\n            activity.attach(appContext, this, getInstrumentation(), r.token,\n                            r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                            r.embeddedID, r.lastNonConfigurationInstances, config,\n                            r.referrer, r.voiceInteractor, window, r.configCallback);\n\n            activity.mCalled = false;\n            // 3.1 依然使用 Instrumentation 对象调用 Activity 的 onCreate() 方法\n            if (r.isPersistable()) {\n                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            } else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            // 强制校验 super 调用\n            if (!activity.mCalled) {\n                throw new SuperNotCalledException(\n                    \"Activity \" + r.intent.getComponent().toShortString() +\n                    \" did not call through to super.onCreate()\");\n            }\n        }\n    }\n    return activity;\n}\n\npublic void callActivityOnCreate(Activity activity, Bundle icicle,PersistableBundle persistentState) {\n    prePerformCreate(activity);\n    // 3.2 调用 Activity 的 performCreate() 方法\n    activity.performCreate(icicle, persistentState);\n    postPerformCreate(activity);\n}\n\n// 3.3 最终得以调用到实际实现的 onCreate()\nfinal void performCreate(Bundle icicle, PersistableBundle persistentState) {\n    restoreHasCurrentPermissionRequest(icicle);\n    onCreate(icicle, persistentState);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n\n// 4 performLaunchActivity() 执行完毕后，根据代码来看，会继续执行 handleResumeActivity()\n// 同样的，这个方法会调用到一个 performResumeActivity()，在该方法内部也会最终执行到 onResume()\n final void handleResumeActivity( ... ... ) {\n     // 最终会执行到 onResume()，不是重点\n     r = performResumeActivity(token, clearHide, reason);\n\n     if (r != null) {\n         final Activity a = r.activity;\n\n         if (r.window == null && !a.mFinished && willBeVisible) {\n             r.window = r.activity.getWindow();\n             View decor = r.window.getDecorView();\n             ViewManager wm = a.getWindowManager();\n             // 5. 执行到 WindowManagerImpl 的 addView()\n             // 然后会跳转到 WindowManagerGlobal 的 addView()\n             if (a.mVisibleFromClient) {\n                 if (!a.mWindowAdded) {\n                     a.mWindowAdded = true;\n                     wm.addView(decor, l);\n                 }\n             }\n         }\n     }\n }\n\npublic void addView( ... ... ) {\n     ViewRootImpl root;\n     synchronized (mLock) {\n         // 初始化一个 ViewRootImpl 的实例\n         root = new ViewRootImpl(view.getContext(), display);\n         try {\n             // 调用 setView，为 root 布局 setView\n             // 其中 view 为传下来的 DecorView 对象\n             // 也就是说，实际上根布局并不是我们认为的 DecorView，而是 ViewRootImpl\n             root.setView(view, wparams, panelParentView);\n         }\n     }\n}\n\n// 6. 将 DecorView 加载到 WindowManager, View 的绘制流程从此刻才开始\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n    // 请求对 View 进行测量和绘制\n    // 与 setContentView() 不同，此处的方法是 ViewRootImpl 的方法\n    requestLayout();\n}\n\n@Override\npublic void requestLayout() {\n    if (!mHandlingLayoutInLayoutRequest) {\n        checkThread();\n        mLayoutRequested = true;\n        // 7. 此方法内部有一个 post 了一个 Runnable 对象\n        // 在其中又调用一个 doTraversal() 方法；\n        // 再之后又会调用到 performTraversals() 方法，然后 View 的测绘流程就从此处开始了\n        scheduleTraversals();\n    }\n}\n\nprivate void performTraversals() {\n\t... ...\n    // Ask host how big it wants to be\n    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n    ... ...\n    performLayout(lp, mWidth, mHeight);\n    ... ...\n    performDraw();\n    ... ...\n}\n```\n\n\n\n问题到这里就差不多得到了解答，View 的测绘流程是在 performTraversals() 才开始的；而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的宽高信息也就很容易理解了。\n\n\n","source":"_posts/can-not-get-height-in-onCreate.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321184908.jpg\ntitle: 为何 Android 在 onCreate 中获取不到宽高\ntags: [Android]\ndate: 2018-08-13\n---\n\n经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。\n\n<!--more-->\n\n具体代码如下：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @BindView(R.id.tv_test)\n    private TextView mTextView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mTv.getHeight(); // 0\n\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        mTv.getHeight(); // 0\n    }\n\n}\n```\n\n要弄清这个问题，首先需要知道代码中涉及到的方法具体做了什么工作，以及具体 View 是在什么时候完成测量的。\n\n### setContentView()\n\n很明显，我们在 onCreate() 方法中调用了 setContentView() 方法，而**设置布局**这个动作会给你一种可以获取到宽高的错觉；那么我们从源码的角度来看看，setContentView() 到底干了点什么。\n\n```java\n// 1. AppCompatDelegate 的抽象方法，根据注释，会调用到 Activity 的实现方法中\npublic abstract void setContentView(@LayoutRes int resId);\n\n// 2. Activity 的实现方法\npublic void setContentView(@LayoutRes int layoutResID) {\n    // Window 是一个抽象类，其唯一实现类是 PhoneWindow\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n\n@Override\npublic void setContentView(int layoutResID) {\n    if (mContentParent == null) {\n        // 3. 初始化 DecorView\n        installDecor();\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        mContentParent.removeAllViews();\n    }\n    ... ...\n}\n\nprivate void installDecor() {\n    mForceDecorInstall = false;\n    if (mDecor == null) {\n        // 4. 第一次加载窗口，mDecor 为空时，生成一个 DecorView 对象\n        // generateDecor(-1) : return new DecorView()\n        mDecor = generateDecor(-1);\n        ... ...\n    } else {\n        mDecor.setWindow(this);\n    }\n\n    if (mContentParent == null) {\n        // 5. 初始化父布局\n        mContentParent = generateLayout(mDecor);\n    }\n}\n\n// 继续跟踪到 generateLayout(mDecor) 方法内部\nprotected ViewGroup generateLayout(DecorView decor) {\n    // 此处根据设置的主题进行一些基础设置，没什么决定性作用\n    TypedArray a = getWindowStyle();\n    ... ...\n\n    // 接下来的一大段代码是根据各种主题设置默认布局，篇幅原因，此处有大量源码删减\n    int layoutResource;\n    int features = getLocalFeatures();\n    if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {\n        layoutResource = R.layout.screen_swipe_dismiss;\n        setCloseOnSwipeEnabled(true);\n    } else if ((features & (1 << FEATURE_NO_TITLE)) == 0) {\n        if (mIsFloating) {\n            TypedValue res = new TypedValue();\n            getContext().getTheme().resolveAttribute(\n                R.attr.dialogTitleDecorLayout, res, true);\n            layoutResource = res.resourceId;\n        } else if ((features & (1 << FEATURE_ACTION_BAR)) != 0) {\n            layoutResource = a.getResourceId(\n                R.styleable.Window_windowActionBarFullscreenDecorLayout,\n                R.layout.screen_action_bar);\n        } else {\n            layoutResource = R.layout.screen_title;\n        }\n    } else {\n        // 默认布局样式\n        layoutResource = R.layout.screen_simple;\n    }\n\n    // 6. 重点来了：将对应的布局加载到 DecorView 中\n    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);\n    return contentParent;\n}\n\nvoid onResourcesLoaded(LayoutInflater inflater, int layoutResource) {\n    // 加载资源文件\n    final View root = inflater.inflate(layoutResource, null);\n\t... ...\n    // 7. 将 View 加载到当前 DecorView 中\n    addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n}\n\npublic void addView(View child, int index, LayoutParams params) {\n    // 页面发生变化的话，请求重新摆放布局以及重新绘制\n    // 注意，此处的 requestLayout 是 View 的方法\n    requestLayout();\n    invalidate(true);\n    addViewInner(child, index, params, false);\n}\n```\n\n说出来你可能不信，但是 setContentView() 到这里就差不多结束了。\n\n很明显，我们并没有发现任何关于 View 的测量的代码，最后的 requestLayout() 和 invalidate() 也和 View 的 measure() 关系不大，毕竟还没测量，哪里谈得上 layout 和 draw 呢？\n\n所以， setContentView() 和 View 的测量没啥关系，那么在其之后也就自然获取不到 View 宽高的值了。\n\n\n\n### 测量流程到底是从哪里开始的\n\n有了上面的经验，我们已经知道，setContentView() 并不会触发 View 的测量，而只是为 DecorView 指定了布局；那么接下来的问题就是，测量流程到底是从哪里开始的呢？\n\n我们简单回顾一下 Activity 的启动流程，然后来找到这个答案。\n\n```java\npublic void handleMessage(Message msg) {\n    switch (msg.what) {\n        case LAUNCH_ACTIVITY: {\n            // 1. ActivityThread 内部类 H，处理 LAUNCH_ACTIVITY 的消息\n            handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n        } break;\n }\n\n// 2. 直接从 ActivityThread 的 handleLaunchActivity() 开始了\nprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {\n\n    // 3. 执行 performLaunchActivity() 方法\n    Activity a = performLaunchActivity(r, customIntent);\n\n    if (a != null) {\n        r.createdConfig = new Configuration(mConfiguration);\n        reportSizeConfigurations(r);\n        Bundle oldState = r.state;\n        // 4. 执行 handleResumeActivity() 方法\n        handleResumeActivity(r.token, false, r.isForward,\n                             !r.activity.mFinished && !r.startsNotResumed,\n                             r.lastProcessedSeq, reason);\n    }\n}\n\n// 3. performLaunchActivity()\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    // 基于反射，利用 Instrumentation 对象创建当前 Activity 的实例\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(\n            cl, component.getClassName(), r.intent);\n        StrictMode.incrementExpectedActivityCount(activity.getClass());\n        r.intent.setExtrasClassLoader(cl);\n        r.intent.prepareToEnterProcess();\n        if (r.state != null) {\n            r.state.setClassLoader(cl);\n        }\n    }\n\n    try {\n        if (activity != null) {\n            // attach() 方法做了一系列最基本的初始化\n            activity.attach(appContext, this, getInstrumentation(), r.token,\n                            r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                            r.embeddedID, r.lastNonConfigurationInstances, config,\n                            r.referrer, r.voiceInteractor, window, r.configCallback);\n\n            activity.mCalled = false;\n            // 3.1 依然使用 Instrumentation 对象调用 Activity 的 onCreate() 方法\n            if (r.isPersistable()) {\n                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            } else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            // 强制校验 super 调用\n            if (!activity.mCalled) {\n                throw new SuperNotCalledException(\n                    \"Activity \" + r.intent.getComponent().toShortString() +\n                    \" did not call through to super.onCreate()\");\n            }\n        }\n    }\n    return activity;\n}\n\npublic void callActivityOnCreate(Activity activity, Bundle icicle,PersistableBundle persistentState) {\n    prePerformCreate(activity);\n    // 3.2 调用 Activity 的 performCreate() 方法\n    activity.performCreate(icicle, persistentState);\n    postPerformCreate(activity);\n}\n\n// 3.3 最终得以调用到实际实现的 onCreate()\nfinal void performCreate(Bundle icicle, PersistableBundle persistentState) {\n    restoreHasCurrentPermissionRequest(icicle);\n    onCreate(icicle, persistentState);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n\n// 4 performLaunchActivity() 执行完毕后，根据代码来看，会继续执行 handleResumeActivity()\n// 同样的，这个方法会调用到一个 performResumeActivity()，在该方法内部也会最终执行到 onResume()\n final void handleResumeActivity( ... ... ) {\n     // 最终会执行到 onResume()，不是重点\n     r = performResumeActivity(token, clearHide, reason);\n\n     if (r != null) {\n         final Activity a = r.activity;\n\n         if (r.window == null && !a.mFinished && willBeVisible) {\n             r.window = r.activity.getWindow();\n             View decor = r.window.getDecorView();\n             ViewManager wm = a.getWindowManager();\n             // 5. 执行到 WindowManagerImpl 的 addView()\n             // 然后会跳转到 WindowManagerGlobal 的 addView()\n             if (a.mVisibleFromClient) {\n                 if (!a.mWindowAdded) {\n                     a.mWindowAdded = true;\n                     wm.addView(decor, l);\n                 }\n             }\n         }\n     }\n }\n\npublic void addView( ... ... ) {\n     ViewRootImpl root;\n     synchronized (mLock) {\n         // 初始化一个 ViewRootImpl 的实例\n         root = new ViewRootImpl(view.getContext(), display);\n         try {\n             // 调用 setView，为 root 布局 setView\n             // 其中 view 为传下来的 DecorView 对象\n             // 也就是说，实际上根布局并不是我们认为的 DecorView，而是 ViewRootImpl\n             root.setView(view, wparams, panelParentView);\n         }\n     }\n}\n\n// 6. 将 DecorView 加载到 WindowManager, View 的绘制流程从此刻才开始\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n    // 请求对 View 进行测量和绘制\n    // 与 setContentView() 不同，此处的方法是 ViewRootImpl 的方法\n    requestLayout();\n}\n\n@Override\npublic void requestLayout() {\n    if (!mHandlingLayoutInLayoutRequest) {\n        checkThread();\n        mLayoutRequested = true;\n        // 7. 此方法内部有一个 post 了一个 Runnable 对象\n        // 在其中又调用一个 doTraversal() 方法；\n        // 再之后又会调用到 performTraversals() 方法，然后 View 的测绘流程就从此处开始了\n        scheduleTraversals();\n    }\n}\n\nprivate void performTraversals() {\n\t... ...\n    // Ask host how big it wants to be\n    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n    ... ...\n    performLayout(lp, mWidth, mHeight);\n    ... ...\n    performDraw();\n    ... ...\n}\n```\n\n\n\n问题到这里就差不多得到了解答，View 的测绘流程是在 performTraversals() 才开始的；而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的宽高信息也就很容易理解了。\n\n\n","slug":"can-not-get-height-in-onCreate","published":1,"updated":"2019-03-21T10:50:48.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86dl0018lh1pucv074ej","content":"<p>经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。</p>\n<a id=\"more\"></a>\n<p>具体代码如下：</p>\n<pre><code class=\"java\">public class MainActivity extends AppCompatActivity {\n\n    @BindView(R.id.tv_test)\n    private TextView mTextView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mTv.getHeight(); // 0\n\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        mTv.getHeight(); // 0\n    }\n\n}\n</code></pre>\n<p>要弄清这个问题，首先需要知道代码中涉及到的方法具体做了什么工作，以及具体 View 是在什么时候完成测量的。</p>\n<h3 id=\"setContentView\"><a href=\"#setContentView\" class=\"headerlink\" title=\"setContentView()\"></a>setContentView()</h3><p>很明显，我们在 onCreate() 方法中调用了 setContentView() 方法，而<strong>设置布局</strong>这个动作会给你一种可以获取到宽高的错觉；那么我们从源码的角度来看看，setContentView() 到底干了点什么。</p>\n<pre><code class=\"java\">// 1. AppCompatDelegate 的抽象方法，根据注释，会调用到 Activity 的实现方法中\npublic abstract void setContentView(@LayoutRes int resId);\n\n// 2. Activity 的实现方法\npublic void setContentView(@LayoutRes int layoutResID) {\n    // Window 是一个抽象类，其唯一实现类是 PhoneWindow\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n\n@Override\npublic void setContentView(int layoutResID) {\n    if (mContentParent == null) {\n        // 3. 初始化 DecorView\n        installDecor();\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        mContentParent.removeAllViews();\n    }\n    ... ...\n}\n\nprivate void installDecor() {\n    mForceDecorInstall = false;\n    if (mDecor == null) {\n        // 4. 第一次加载窗口，mDecor 为空时，生成一个 DecorView 对象\n        // generateDecor(-1) : return new DecorView()\n        mDecor = generateDecor(-1);\n        ... ...\n    } else {\n        mDecor.setWindow(this);\n    }\n\n    if (mContentParent == null) {\n        // 5. 初始化父布局\n        mContentParent = generateLayout(mDecor);\n    }\n}\n\n// 继续跟踪到 generateLayout(mDecor) 方法内部\nprotected ViewGroup generateLayout(DecorView decor) {\n    // 此处根据设置的主题进行一些基础设置，没什么决定性作用\n    TypedArray a = getWindowStyle();\n    ... ...\n\n    // 接下来的一大段代码是根据各种主题设置默认布局，篇幅原因，此处有大量源码删减\n    int layoutResource;\n    int features = getLocalFeatures();\n    if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) {\n        layoutResource = R.layout.screen_swipe_dismiss;\n        setCloseOnSwipeEnabled(true);\n    } else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) {\n        if (mIsFloating) {\n            TypedValue res = new TypedValue();\n            getContext().getTheme().resolveAttribute(\n                R.attr.dialogTitleDecorLayout, res, true);\n            layoutResource = res.resourceId;\n        } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) {\n            layoutResource = a.getResourceId(\n                R.styleable.Window_windowActionBarFullscreenDecorLayout,\n                R.layout.screen_action_bar);\n        } else {\n            layoutResource = R.layout.screen_title;\n        }\n    } else {\n        // 默认布局样式\n        layoutResource = R.layout.screen_simple;\n    }\n\n    // 6. 重点来了：将对应的布局加载到 DecorView 中\n    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);\n    return contentParent;\n}\n\nvoid onResourcesLoaded(LayoutInflater inflater, int layoutResource) {\n    // 加载资源文件\n    final View root = inflater.inflate(layoutResource, null);\n    ... ...\n    // 7. 将 View 加载到当前 DecorView 中\n    addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n}\n\npublic void addView(View child, int index, LayoutParams params) {\n    // 页面发生变化的话，请求重新摆放布局以及重新绘制\n    // 注意，此处的 requestLayout 是 View 的方法\n    requestLayout();\n    invalidate(true);\n    addViewInner(child, index, params, false);\n}\n</code></pre>\n<p>说出来你可能不信，但是 setContentView() 到这里就差不多结束了。</p>\n<p>很明显，我们并没有发现任何关于 View 的测量的代码，最后的 requestLayout() 和 invalidate() 也和 View 的 measure() 关系不大，毕竟还没测量，哪里谈得上 layout 和 draw 呢？</p>\n<p>所以， setContentView() 和 View 的测量没啥关系，那么在其之后也就自然获取不到 View 宽高的值了。</p>\n<h3 id=\"测量流程到底是从哪里开始的\"><a href=\"#测量流程到底是从哪里开始的\" class=\"headerlink\" title=\"测量流程到底是从哪里开始的\"></a>测量流程到底是从哪里开始的</h3><p>有了上面的经验，我们已经知道，setContentView() 并不会触发 View 的测量，而只是为 DecorView 指定了布局；那么接下来的问题就是，测量流程到底是从哪里开始的呢？</p>\n<p>我们简单回顾一下 Activity 的启动流程，然后来找到这个答案。</p>\n<pre><code class=\"java\">public void handleMessage(Message msg) {\n    switch (msg.what) {\n        case LAUNCH_ACTIVITY: {\n            // 1. ActivityThread 内部类 H，处理 LAUNCH_ACTIVITY 的消息\n            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);\n        } break;\n }\n\n// 2. 直接从 ActivityThread 的 handleLaunchActivity() 开始了\nprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {\n\n    // 3. 执行 performLaunchActivity() 方法\n    Activity a = performLaunchActivity(r, customIntent);\n\n    if (a != null) {\n        r.createdConfig = new Configuration(mConfiguration);\n        reportSizeConfigurations(r);\n        Bundle oldState = r.state;\n        // 4. 执行 handleResumeActivity() 方法\n        handleResumeActivity(r.token, false, r.isForward,\n                             !r.activity.mFinished &amp;&amp; !r.startsNotResumed,\n                             r.lastProcessedSeq, reason);\n    }\n}\n\n// 3. performLaunchActivity()\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    // 基于反射，利用 Instrumentation 对象创建当前 Activity 的实例\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(\n            cl, component.getClassName(), r.intent);\n        StrictMode.incrementExpectedActivityCount(activity.getClass());\n        r.intent.setExtrasClassLoader(cl);\n        r.intent.prepareToEnterProcess();\n        if (r.state != null) {\n            r.state.setClassLoader(cl);\n        }\n    }\n\n    try {\n        if (activity != null) {\n            // attach() 方法做了一系列最基本的初始化\n            activity.attach(appContext, this, getInstrumentation(), r.token,\n                            r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                            r.embeddedID, r.lastNonConfigurationInstances, config,\n                            r.referrer, r.voiceInteractor, window, r.configCallback);\n\n            activity.mCalled = false;\n            // 3.1 依然使用 Instrumentation 对象调用 Activity 的 onCreate() 方法\n            if (r.isPersistable()) {\n                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            } else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            // 强制校验 super 调用\n            if (!activity.mCalled) {\n                throw new SuperNotCalledException(\n                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +\n                    &quot; did not call through to super.onCreate()&quot;);\n            }\n        }\n    }\n    return activity;\n}\n\npublic void callActivityOnCreate(Activity activity, Bundle icicle,PersistableBundle persistentState) {\n    prePerformCreate(activity);\n    // 3.2 调用 Activity 的 performCreate() 方法\n    activity.performCreate(icicle, persistentState);\n    postPerformCreate(activity);\n}\n\n// 3.3 最终得以调用到实际实现的 onCreate()\nfinal void performCreate(Bundle icicle, PersistableBundle persistentState) {\n    restoreHasCurrentPermissionRequest(icicle);\n    onCreate(icicle, persistentState);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n\n// 4 performLaunchActivity() 执行完毕后，根据代码来看，会继续执行 handleResumeActivity()\n// 同样的，这个方法会调用到一个 performResumeActivity()，在该方法内部也会最终执行到 onResume()\n final void handleResumeActivity( ... ... ) {\n     // 最终会执行到 onResume()，不是重点\n     r = performResumeActivity(token, clearHide, reason);\n\n     if (r != null) {\n         final Activity a = r.activity;\n\n         if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {\n             r.window = r.activity.getWindow();\n             View decor = r.window.getDecorView();\n             ViewManager wm = a.getWindowManager();\n             // 5. 执行到 WindowManagerImpl 的 addView()\n             // 然后会跳转到 WindowManagerGlobal 的 addView()\n             if (a.mVisibleFromClient) {\n                 if (!a.mWindowAdded) {\n                     a.mWindowAdded = true;\n                     wm.addView(decor, l);\n                 }\n             }\n         }\n     }\n }\n\npublic void addView( ... ... ) {\n     ViewRootImpl root;\n     synchronized (mLock) {\n         // 初始化一个 ViewRootImpl 的实例\n         root = new ViewRootImpl(view.getContext(), display);\n         try {\n             // 调用 setView，为 root 布局 setView\n             // 其中 view 为传下来的 DecorView 对象\n             // 也就是说，实际上根布局并不是我们认为的 DecorView，而是 ViewRootImpl\n             root.setView(view, wparams, panelParentView);\n         }\n     }\n}\n\n// 6. 将 DecorView 加载到 WindowManager, View 的绘制流程从此刻才开始\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n    // 请求对 View 进行测量和绘制\n    // 与 setContentView() 不同，此处的方法是 ViewRootImpl 的方法\n    requestLayout();\n}\n\n@Override\npublic void requestLayout() {\n    if (!mHandlingLayoutInLayoutRequest) {\n        checkThread();\n        mLayoutRequested = true;\n        // 7. 此方法内部有一个 post 了一个 Runnable 对象\n        // 在其中又调用一个 doTraversal() 方法；\n        // 再之后又会调用到 performTraversals() 方法，然后 View 的测绘流程就从此处开始了\n        scheduleTraversals();\n    }\n}\n\nprivate void performTraversals() {\n    ... ...\n    // Ask host how big it wants to be\n    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n    ... ...\n    performLayout(lp, mWidth, mHeight);\n    ... ...\n    performDraw();\n    ... ...\n}\n</code></pre>\n<p>问题到这里就差不多得到了解答，View 的测绘流程是在 performTraversals() 才开始的；而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的宽高信息也就很容易理解了。</p>\n","site":{"data":{}},"excerpt":"<p>经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。</p>","more":"<p>具体代码如下：</p>\n<pre><code class=\"java\">public class MainActivity extends AppCompatActivity {\n\n    @BindView(R.id.tv_test)\n    private TextView mTextView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mTv.getHeight(); // 0\n\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        mTv.getHeight(); // 0\n    }\n\n}\n</code></pre>\n<p>要弄清这个问题，首先需要知道代码中涉及到的方法具体做了什么工作，以及具体 View 是在什么时候完成测量的。</p>\n<h3 id=\"setContentView\"><a href=\"#setContentView\" class=\"headerlink\" title=\"setContentView()\"></a>setContentView()</h3><p>很明显，我们在 onCreate() 方法中调用了 setContentView() 方法，而<strong>设置布局</strong>这个动作会给你一种可以获取到宽高的错觉；那么我们从源码的角度来看看，setContentView() 到底干了点什么。</p>\n<pre><code class=\"java\">// 1. AppCompatDelegate 的抽象方法，根据注释，会调用到 Activity 的实现方法中\npublic abstract void setContentView(@LayoutRes int resId);\n\n// 2. Activity 的实现方法\npublic void setContentView(@LayoutRes int layoutResID) {\n    // Window 是一个抽象类，其唯一实现类是 PhoneWindow\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n\n@Override\npublic void setContentView(int layoutResID) {\n    if (mContentParent == null) {\n        // 3. 初始化 DecorView\n        installDecor();\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        mContentParent.removeAllViews();\n    }\n    ... ...\n}\n\nprivate void installDecor() {\n    mForceDecorInstall = false;\n    if (mDecor == null) {\n        // 4. 第一次加载窗口，mDecor 为空时，生成一个 DecorView 对象\n        // generateDecor(-1) : return new DecorView()\n        mDecor = generateDecor(-1);\n        ... ...\n    } else {\n        mDecor.setWindow(this);\n    }\n\n    if (mContentParent == null) {\n        // 5. 初始化父布局\n        mContentParent = generateLayout(mDecor);\n    }\n}\n\n// 继续跟踪到 generateLayout(mDecor) 方法内部\nprotected ViewGroup generateLayout(DecorView decor) {\n    // 此处根据设置的主题进行一些基础设置，没什么决定性作用\n    TypedArray a = getWindowStyle();\n    ... ...\n\n    // 接下来的一大段代码是根据各种主题设置默认布局，篇幅原因，此处有大量源码删减\n    int layoutResource;\n    int features = getLocalFeatures();\n    if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) {\n        layoutResource = R.layout.screen_swipe_dismiss;\n        setCloseOnSwipeEnabled(true);\n    } else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) {\n        if (mIsFloating) {\n            TypedValue res = new TypedValue();\n            getContext().getTheme().resolveAttribute(\n                R.attr.dialogTitleDecorLayout, res, true);\n            layoutResource = res.resourceId;\n        } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) {\n            layoutResource = a.getResourceId(\n                R.styleable.Window_windowActionBarFullscreenDecorLayout,\n                R.layout.screen_action_bar);\n        } else {\n            layoutResource = R.layout.screen_title;\n        }\n    } else {\n        // 默认布局样式\n        layoutResource = R.layout.screen_simple;\n    }\n\n    // 6. 重点来了：将对应的布局加载到 DecorView 中\n    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);\n    return contentParent;\n}\n\nvoid onResourcesLoaded(LayoutInflater inflater, int layoutResource) {\n    // 加载资源文件\n    final View root = inflater.inflate(layoutResource, null);\n    ... ...\n    // 7. 将 View 加载到当前 DecorView 中\n    addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n}\n\npublic void addView(View child, int index, LayoutParams params) {\n    // 页面发生变化的话，请求重新摆放布局以及重新绘制\n    // 注意，此处的 requestLayout 是 View 的方法\n    requestLayout();\n    invalidate(true);\n    addViewInner(child, index, params, false);\n}\n</code></pre>\n<p>说出来你可能不信，但是 setContentView() 到这里就差不多结束了。</p>\n<p>很明显，我们并没有发现任何关于 View 的测量的代码，最后的 requestLayout() 和 invalidate() 也和 View 的 measure() 关系不大，毕竟还没测量，哪里谈得上 layout 和 draw 呢？</p>\n<p>所以， setContentView() 和 View 的测量没啥关系，那么在其之后也就自然获取不到 View 宽高的值了。</p>\n<h3 id=\"测量流程到底是从哪里开始的\"><a href=\"#测量流程到底是从哪里开始的\" class=\"headerlink\" title=\"测量流程到底是从哪里开始的\"></a>测量流程到底是从哪里开始的</h3><p>有了上面的经验，我们已经知道，setContentView() 并不会触发 View 的测量，而只是为 DecorView 指定了布局；那么接下来的问题就是，测量流程到底是从哪里开始的呢？</p>\n<p>我们简单回顾一下 Activity 的启动流程，然后来找到这个答案。</p>\n<pre><code class=\"java\">public void handleMessage(Message msg) {\n    switch (msg.what) {\n        case LAUNCH_ACTIVITY: {\n            // 1. ActivityThread 内部类 H，处理 LAUNCH_ACTIVITY 的消息\n            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);\n        } break;\n }\n\n// 2. 直接从 ActivityThread 的 handleLaunchActivity() 开始了\nprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {\n\n    // 3. 执行 performLaunchActivity() 方法\n    Activity a = performLaunchActivity(r, customIntent);\n\n    if (a != null) {\n        r.createdConfig = new Configuration(mConfiguration);\n        reportSizeConfigurations(r);\n        Bundle oldState = r.state;\n        // 4. 执行 handleResumeActivity() 方法\n        handleResumeActivity(r.token, false, r.isForward,\n                             !r.activity.mFinished &amp;&amp; !r.startsNotResumed,\n                             r.lastProcessedSeq, reason);\n    }\n}\n\n// 3. performLaunchActivity()\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    // 基于反射，利用 Instrumentation 对象创建当前 Activity 的实例\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(\n            cl, component.getClassName(), r.intent);\n        StrictMode.incrementExpectedActivityCount(activity.getClass());\n        r.intent.setExtrasClassLoader(cl);\n        r.intent.prepareToEnterProcess();\n        if (r.state != null) {\n            r.state.setClassLoader(cl);\n        }\n    }\n\n    try {\n        if (activity != null) {\n            // attach() 方法做了一系列最基本的初始化\n            activity.attach(appContext, this, getInstrumentation(), r.token,\n                            r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                            r.embeddedID, r.lastNonConfigurationInstances, config,\n                            r.referrer, r.voiceInteractor, window, r.configCallback);\n\n            activity.mCalled = false;\n            // 3.1 依然使用 Instrumentation 对象调用 Activity 的 onCreate() 方法\n            if (r.isPersistable()) {\n                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            } else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            // 强制校验 super 调用\n            if (!activity.mCalled) {\n                throw new SuperNotCalledException(\n                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +\n                    &quot; did not call through to super.onCreate()&quot;);\n            }\n        }\n    }\n    return activity;\n}\n\npublic void callActivityOnCreate(Activity activity, Bundle icicle,PersistableBundle persistentState) {\n    prePerformCreate(activity);\n    // 3.2 调用 Activity 的 performCreate() 方法\n    activity.performCreate(icicle, persistentState);\n    postPerformCreate(activity);\n}\n\n// 3.3 最终得以调用到实际实现的 onCreate()\nfinal void performCreate(Bundle icicle, PersistableBundle persistentState) {\n    restoreHasCurrentPermissionRequest(icicle);\n    onCreate(icicle, persistentState);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n\n// 4 performLaunchActivity() 执行完毕后，根据代码来看，会继续执行 handleResumeActivity()\n// 同样的，这个方法会调用到一个 performResumeActivity()，在该方法内部也会最终执行到 onResume()\n final void handleResumeActivity( ... ... ) {\n     // 最终会执行到 onResume()，不是重点\n     r = performResumeActivity(token, clearHide, reason);\n\n     if (r != null) {\n         final Activity a = r.activity;\n\n         if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {\n             r.window = r.activity.getWindow();\n             View decor = r.window.getDecorView();\n             ViewManager wm = a.getWindowManager();\n             // 5. 执行到 WindowManagerImpl 的 addView()\n             // 然后会跳转到 WindowManagerGlobal 的 addView()\n             if (a.mVisibleFromClient) {\n                 if (!a.mWindowAdded) {\n                     a.mWindowAdded = true;\n                     wm.addView(decor, l);\n                 }\n             }\n         }\n     }\n }\n\npublic void addView( ... ... ) {\n     ViewRootImpl root;\n     synchronized (mLock) {\n         // 初始化一个 ViewRootImpl 的实例\n         root = new ViewRootImpl(view.getContext(), display);\n         try {\n             // 调用 setView，为 root 布局 setView\n             // 其中 view 为传下来的 DecorView 对象\n             // 也就是说，实际上根布局并不是我们认为的 DecorView，而是 ViewRootImpl\n             root.setView(view, wparams, panelParentView);\n         }\n     }\n}\n\n// 6. 将 DecorView 加载到 WindowManager, View 的绘制流程从此刻才开始\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n    // 请求对 View 进行测量和绘制\n    // 与 setContentView() 不同，此处的方法是 ViewRootImpl 的方法\n    requestLayout();\n}\n\n@Override\npublic void requestLayout() {\n    if (!mHandlingLayoutInLayoutRequest) {\n        checkThread();\n        mLayoutRequested = true;\n        // 7. 此方法内部有一个 post 了一个 Runnable 对象\n        // 在其中又调用一个 doTraversal() 方法；\n        // 再之后又会调用到 performTraversals() 方法，然后 View 的测绘流程就从此处开始了\n        scheduleTraversals();\n    }\n}\n\nprivate void performTraversals() {\n    ... ...\n    // Ask host how big it wants to be\n    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n    ... ...\n    performLayout(lp, mWidth, mHeight);\n    ... ...\n    performDraw();\n    ... ...\n}\n</code></pre>\n<p>问题到这里就差不多得到了解答，View 的测绘流程是在 performTraversals() 才开始的；而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的宽高信息也就很容易理解了。</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329164506.jpg","title":"View.inflate() 的前世今生","date":"2019-03-28T16:00:00.000Z","_content":"\n\n\n误用 LayoutInflater 的 inflate() 方法已经不是什么稀罕事儿了……\n\n<!-- more -->\n\n做 Android 开发做久了，一定会或多或少地对布局的渲染有一些懵逼：\n\n> 1. `View.inflate()` 和 `LayoutInflator.from().inflate()` 有啥区别？\n> 2. 调用 inflate() 方法的时候有时候传 null，有时候传 parent 是为啥？\n> 3. 用 LayoutInflater 有时候还可能传个 attachToRoot ，这又是个啥？\n\n接下来我们就从源码的角度来寻找一下这几个问题的答案，后面再用几个示例来验证我们的猜想。\n\n话不多说，Let's go !\n\n### 基本介绍\n\n先来看一下这个方法具体做了什么：\n\n```java\n/**\n * Inflate a view from an XML resource.  This convenience method wraps the {@link\n * LayoutInflater} class, which provides a full range of options for view inflation.\n */\npublic static View inflate(Context context, int resource, ViewGroup root) {\n    LayoutInflater factory = LayoutInflater.from(context);\n    return factory.inflate(resource, root);\n}\n```\n\n当我们查看源码，就会发现，这个方法的内部实际上就是调用了 `LayoutInflater` 的 inflate 方法。正如此方法的注释所言，这是一个方便开发者调用的 `LayoutInflater` 的包装方法，而 `LayoutInflater` 本身则为 View 的渲染提供了更多的选择。\n\n那么我们现在的问题就变成了， `LayoutInflater` 又做了什么？\n\n继续追踪代码，我们会发现， `LayoutInflator.from().inflate()`  是这个样子的：\n\n```java\n// LayoutInflator#inflate(int, ViewGroup)\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {\n\t\treturn inflate(resource, root, root != null);\n}\n```\n\n啥？重载？\n\n```java\n// LayoutInflator#inflate(int, ViewGroup, boolean)\npublic View inflate(int resource, ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n```\n\n这里我们看到，通过层层调用，最终会调用到 `LayoutInflator#inflate(int, ViewGroup, boolean)` 方法，很明显，这个方法会将我们传入的布局 id 转换为 XmlResourceParser，然后进行另一次，也是最后一次重载。\n\n这个方法就厉害了，这里基本上包括了我们所有问题的答案，我们继续往下看。\n\n### 源码分析\n\n话不多说，上代码。接下来我们来逐段分析下这个 `inflate` 方法：\n\n```java\npublic View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n    \n    // 默认返回结果为传入的根布局\n    View result = root;\n  \n    // 通过 createViewFromTag() 方法找到传入的 layoutId 的根布局，并赋值给 temp\n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    ViewGroup.LayoutParams params = null;\n  \n    // 如果传入的父布局不为空\n    if (root != null) {\n        // 为这个 root 生成一套合适的 LayoutParams\n        params = root.generateLayoutParams(attrs);\n        if (!attachToRoot) {\n            // 如果没有 attachToRoot，那为根布局设置 layoutparams\n            temp.setLayoutParams(params);\n        }\n    }\n\n    // 如果传入的父布局不为空，且想要 attachToRoot\n    if (root != null && attachToRoot) {\n        // 那就将传入的布局以及 layoutparams 通过 addView 方法添加到父布局中 \n        root.addView(temp, params);\n    }\n\n    // 如果传入的根布局为空，或者不想 attachToRoot，则返回要加载的 layoutId\n    if (root == null || !attachToRoot) {\n        result = temp;\n    }\n    return result;\n}\n```\n\n代码也分析完了，我再来总结一下：\n\n* `View#inflate` 只是个简易的包装方法，实际上还是调用的 `LayoutInflater#inflate` ;\n\n* `LayoutInflater#inflate` 由于可以自己选择 root 和 attachToRoot 的搭配（后面有解释），使用起来更加灵活；\n\n* 实际上的区别只是在于 `root` 是否传空，以及 `attachToRoot` 真假与否；\n\n* 当  `root` 传空时，会直接返回要加载的 `layoutId`，返回的 View 没有父布局且没有 LayoutParams；\n\n* 当  `root` 不传空时，又分为 `attachToRoot` 为真或者为假：\n\n  *  `attachToRoot = true` \n\n    会为传入的 `layoutId` 直接设置参数，并将其添加到 `root` 中，然后将传入的 `root` 返回；\n\n  *  `attachToRoot = false` \n\n    会为传入的 `layoutId` 设置参数，但是不会添加到 `root` ，然后返回 `layoutId` 对应的 View；\n\n    > 这里需要注意的是，虽然不马上将 View 添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null；因为子 View 的 LayoutParams 需要由 parent 来确定；否则会在手动 addView 时调用 `generateDefaultLayoutParams()` 为子 View 生成一个宽高都为包裹内容的 LayoutParams，而这并不一定是我们想要的。\n\n\n\n### 测试 & 检验\n\n单说起来可能有些抽象，下面使用代码来进行具体的测试与检验。\n\n#### View.inflate(context, layoutId, null)\n\n如之前所说，这实际上调用的是 `getLayoutInflater().inflate(layoutId, null)` ，结合之前的源码来看：\n\n```java\npublic View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    View result = root;\n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    if (root == null || !attachToRoot) {\n        result = temp;\n    }\n    return result;\n}\n```\n\n很明显，传入的 `root` 为空，则会直接将加载好的 xml 布局返回，而这种情况下返回的这个 View 没有参数，也没有父布局。\n\n```java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.layout_test);\n    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, null);\n    Log.e(\"Test\", \"LayoutParams -> \" + inflateView.getLayoutParams());\n    Log.e(\"Test\", \"Parent -> \" + inflateView.getParent());\n}\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329145224.jpg)\n\n如图所示，正如我们想的，root 传 null 时，参数以及父布局返回结果均为 null。\n\n\n\n#### View.inflate(context, layoutId, mParent)\n\n按之前分析过的，此方法实际调用的是 `getLayoutInflater().inflate(layoutId, root, true)` ，再来看源码：\n\n```java\npublic View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n    View result = root; \n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    ViewGroup.LayoutParams params = null;\n    if (root != null) {\n        params = root.generateLayoutParams(attrs);\n    }\n    if (root != null && attachToRoot) {\n        root.addView(temp, params);\n    }\n    return result;\n}\n```\n\n如源码所示，返回的 result 会在最开始就被赋值为入参的 root，root 不为空，同时 attachToRoot 为 true，就会将加载好的布局直接通过 addView 方法添加到 root 布局中，然后将 root 返回。\n\n```java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    setContentView(R.layout.layout_test);\n\n    LinearLayout mParent = findViewById(R.id.ll_root);\n    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, mParent);\n\n    Log.e(\"Test\", \"LayoutParams -> \" + inflateView.getLayoutParams());\n    Log.e(\"Test\", \"Parent -> \" + inflateView.getParent());\n    Log.e(\"Test\", \"inflateView -> \" + inflateView);\n}\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329153240.jpg)\n\n如图示，返回的 View 正是我们传入的 mParent，对应的 id 是 ll_root，参数也不再为空。\n\n\n\n####getLayoutInflater().inflate(layoutId, root, false) \n\n也许会有人问了，现在要么是 root 传空，返回 layoutId 对应的布局；要么是 root 不传空，返回传入的 root 布局。那我要是想 root 不传空，但是还是返回 layoutId 对应的布局呢？\n\n这就是 `View#inflate` 的局限了，由于它是包装方法，因此 `attachToRoot` 并不能因需定制。这时候我们完全可以自己调用 `getLayoutInflater().inflate(layoutId, root, false)` 方法，手动的将第三个参数传为 false，同时为这个方法传入目标根布局。这样，我们就可以得到一个有 LayoutParams，但是没有 `parentView` 的 `layoutId` 布局了。\n\n```java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.layout_test);\n    LinearLayout mParent = findViewById(R.id.ll_root);\n    View inflateView = getLayoutInflater().inflate(R.layout.main, mParent, false);\n    Log.e(\"Test\", \"LayoutParams -> \" + inflateView.getLayoutParams());\n    Log.e(\"Test\", \"Parent -> \" + inflateView.getParent());\n}\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329155230.jpg)\n\n与我们分析的一致，有参数，但是没有父布局，且返回的就是我们加载的布局 id。我们在之后可以通过 addView 方法手动将这个布局加入父布局中。\n\n**这里还有个要注意的点**，那就是 `params = root.generateLayoutParams(attrs);` 这句代码，我们会发现，为 `layoutId` 设置的 params 参数，实际上是通过 root 来生成的。这也就告诉我们，虽然不马上添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null，因为子 View 的 LayoutParams 需要由 parent 来确定；当然，传入 null 也不会有问题，因为在执行 `addView()` 方法的时候，如果当前 childView 没有参数，会调用 `generateDefaultLayoutParams()` 生成一个宽高都包裹的 LayoutParams 赋值给 childView，而这并不一定是我们想要的。\n\n#### attachToRoot 必须为 false！\n\n代码写多了，大家有时候会发现这个 `attachToRoot` 也不是想怎样就怎样的，有时候它还就必须是 false，不能为 true。下面我们就来看看这些情况。\n\n- RecylerView#onCreateViewHolder()\n\n  在为 RecyclerView 创建 ViewHolder 时，由于 View 复用的问题，是 RecyclerView 来决定什么时候展示它的子View，这个完全不由我们决定，这种情况下，attachToRoot 必须为 false：\n\n  ```java\n  public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  \n  \t\tLayoutInflater inflater = LayoutInflater.from(getActivity());  \n  \t\tView view = inflater.inflate(R.layout.item, parent, false);  \n  \t\treturn new ViewHolder(view);  \n  }\n  ```\n\n- Fragment#onCreateView()\n\n  由于 Fragment 需要依赖于 Activity 展示，一般在 Activity 中也会有容器布局来盛放 Fragment：\n\n  ```java\n  Fragment fragment = new Fragment();\n  getSupportFragmentManager()\n          .beginTransaction()\n          .add(R.id.root_container, fragment)\n          .commit(); \n  ```\n\n  上述代码中的 `R.id.root_container` 便为容器，这个 View 会作为参数传递给 `Fragment#onCreateView()` :\n\n  ```java\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, \n                           Bundle savedInstanceState) {\n      return inflater.inflate(R.layout.fragment_layout, parentViewGroup, false); \n  }\n  ```\n\n  它也是你在 inflate() 方法中传入的 ViewGroup，FragmentManager 会将 Fragment 的 View 添加到 ViewGroup 中，言外之意就是，Fragment 对应的布局展示或者说添加进 ViewGroup 时也不是我们来控制的，而是 FragmentManager 来控制的。\n\n总结一下就是，**当我们不为子 View 的展示负责时，attachToRoot 必须为 false；否则就会出现对应的负责人，比如上面说的 Rv 或者 FragmentManager，已经把布局 id 添加到 ViewGroup 了，我们还继续设置 attachToRoot 为 true，想要手动 addView，那必然会发生 child already has parent 的错误。**\n\n以上。\n\n\n\n#### 参考文章\n\n- [深入理解LayoutInflater.inflate()](<https://juejin.im/entry/5a1513abf265da43052e4473>)\n- [LayoutInflater.inflate和View.inflate](<https://www.jianshu.com/p/cdc9d4c0826e>)\n- [Android API 28 View.java / LayoutInflater.java / ViewGroup.java]()","source":"_posts/View-inflate-analysis.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329164506.jpg\ntitle: View.inflate() 的前世今生\ntags: [Android]\ndate: 2019-03-29\n---\n\n\n\n误用 LayoutInflater 的 inflate() 方法已经不是什么稀罕事儿了……\n\n<!-- more -->\n\n做 Android 开发做久了，一定会或多或少地对布局的渲染有一些懵逼：\n\n> 1. `View.inflate()` 和 `LayoutInflator.from().inflate()` 有啥区别？\n> 2. 调用 inflate() 方法的时候有时候传 null，有时候传 parent 是为啥？\n> 3. 用 LayoutInflater 有时候还可能传个 attachToRoot ，这又是个啥？\n\n接下来我们就从源码的角度来寻找一下这几个问题的答案，后面再用几个示例来验证我们的猜想。\n\n话不多说，Let's go !\n\n### 基本介绍\n\n先来看一下这个方法具体做了什么：\n\n```java\n/**\n * Inflate a view from an XML resource.  This convenience method wraps the {@link\n * LayoutInflater} class, which provides a full range of options for view inflation.\n */\npublic static View inflate(Context context, int resource, ViewGroup root) {\n    LayoutInflater factory = LayoutInflater.from(context);\n    return factory.inflate(resource, root);\n}\n```\n\n当我们查看源码，就会发现，这个方法的内部实际上就是调用了 `LayoutInflater` 的 inflate 方法。正如此方法的注释所言，这是一个方便开发者调用的 `LayoutInflater` 的包装方法，而 `LayoutInflater` 本身则为 View 的渲染提供了更多的选择。\n\n那么我们现在的问题就变成了， `LayoutInflater` 又做了什么？\n\n继续追踪代码，我们会发现， `LayoutInflator.from().inflate()`  是这个样子的：\n\n```java\n// LayoutInflator#inflate(int, ViewGroup)\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {\n\t\treturn inflate(resource, root, root != null);\n}\n```\n\n啥？重载？\n\n```java\n// LayoutInflator#inflate(int, ViewGroup, boolean)\npublic View inflate(int resource, ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n```\n\n这里我们看到，通过层层调用，最终会调用到 `LayoutInflator#inflate(int, ViewGroup, boolean)` 方法，很明显，这个方法会将我们传入的布局 id 转换为 XmlResourceParser，然后进行另一次，也是最后一次重载。\n\n这个方法就厉害了，这里基本上包括了我们所有问题的答案，我们继续往下看。\n\n### 源码分析\n\n话不多说，上代码。接下来我们来逐段分析下这个 `inflate` 方法：\n\n```java\npublic View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n    \n    // 默认返回结果为传入的根布局\n    View result = root;\n  \n    // 通过 createViewFromTag() 方法找到传入的 layoutId 的根布局，并赋值给 temp\n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    ViewGroup.LayoutParams params = null;\n  \n    // 如果传入的父布局不为空\n    if (root != null) {\n        // 为这个 root 生成一套合适的 LayoutParams\n        params = root.generateLayoutParams(attrs);\n        if (!attachToRoot) {\n            // 如果没有 attachToRoot，那为根布局设置 layoutparams\n            temp.setLayoutParams(params);\n        }\n    }\n\n    // 如果传入的父布局不为空，且想要 attachToRoot\n    if (root != null && attachToRoot) {\n        // 那就将传入的布局以及 layoutparams 通过 addView 方法添加到父布局中 \n        root.addView(temp, params);\n    }\n\n    // 如果传入的根布局为空，或者不想 attachToRoot，则返回要加载的 layoutId\n    if (root == null || !attachToRoot) {\n        result = temp;\n    }\n    return result;\n}\n```\n\n代码也分析完了，我再来总结一下：\n\n* `View#inflate` 只是个简易的包装方法，实际上还是调用的 `LayoutInflater#inflate` ;\n\n* `LayoutInflater#inflate` 由于可以自己选择 root 和 attachToRoot 的搭配（后面有解释），使用起来更加灵活；\n\n* 实际上的区别只是在于 `root` 是否传空，以及 `attachToRoot` 真假与否；\n\n* 当  `root` 传空时，会直接返回要加载的 `layoutId`，返回的 View 没有父布局且没有 LayoutParams；\n\n* 当  `root` 不传空时，又分为 `attachToRoot` 为真或者为假：\n\n  *  `attachToRoot = true` \n\n    会为传入的 `layoutId` 直接设置参数，并将其添加到 `root` 中，然后将传入的 `root` 返回；\n\n  *  `attachToRoot = false` \n\n    会为传入的 `layoutId` 设置参数，但是不会添加到 `root` ，然后返回 `layoutId` 对应的 View；\n\n    > 这里需要注意的是，虽然不马上将 View 添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null；因为子 View 的 LayoutParams 需要由 parent 来确定；否则会在手动 addView 时调用 `generateDefaultLayoutParams()` 为子 View 生成一个宽高都为包裹内容的 LayoutParams，而这并不一定是我们想要的。\n\n\n\n### 测试 & 检验\n\n单说起来可能有些抽象，下面使用代码来进行具体的测试与检验。\n\n#### View.inflate(context, layoutId, null)\n\n如之前所说，这实际上调用的是 `getLayoutInflater().inflate(layoutId, null)` ，结合之前的源码来看：\n\n```java\npublic View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    View result = root;\n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    if (root == null || !attachToRoot) {\n        result = temp;\n    }\n    return result;\n}\n```\n\n很明显，传入的 `root` 为空，则会直接将加载好的 xml 布局返回，而这种情况下返回的这个 View 没有参数，也没有父布局。\n\n```java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.layout_test);\n    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, null);\n    Log.e(\"Test\", \"LayoutParams -> \" + inflateView.getLayoutParams());\n    Log.e(\"Test\", \"Parent -> \" + inflateView.getParent());\n}\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329145224.jpg)\n\n如图所示，正如我们想的，root 传 null 时，参数以及父布局返回结果均为 null。\n\n\n\n#### View.inflate(context, layoutId, mParent)\n\n按之前分析过的，此方法实际调用的是 `getLayoutInflater().inflate(layoutId, root, true)` ，再来看源码：\n\n```java\npublic View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n    View result = root; \n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    ViewGroup.LayoutParams params = null;\n    if (root != null) {\n        params = root.generateLayoutParams(attrs);\n    }\n    if (root != null && attachToRoot) {\n        root.addView(temp, params);\n    }\n    return result;\n}\n```\n\n如源码所示，返回的 result 会在最开始就被赋值为入参的 root，root 不为空，同时 attachToRoot 为 true，就会将加载好的布局直接通过 addView 方法添加到 root 布局中，然后将 root 返回。\n\n```java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    setContentView(R.layout.layout_test);\n\n    LinearLayout mParent = findViewById(R.id.ll_root);\n    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, mParent);\n\n    Log.e(\"Test\", \"LayoutParams -> \" + inflateView.getLayoutParams());\n    Log.e(\"Test\", \"Parent -> \" + inflateView.getParent());\n    Log.e(\"Test\", \"inflateView -> \" + inflateView);\n}\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329153240.jpg)\n\n如图示，返回的 View 正是我们传入的 mParent，对应的 id 是 ll_root，参数也不再为空。\n\n\n\n####getLayoutInflater().inflate(layoutId, root, false) \n\n也许会有人问了，现在要么是 root 传空，返回 layoutId 对应的布局；要么是 root 不传空，返回传入的 root 布局。那我要是想 root 不传空，但是还是返回 layoutId 对应的布局呢？\n\n这就是 `View#inflate` 的局限了，由于它是包装方法，因此 `attachToRoot` 并不能因需定制。这时候我们完全可以自己调用 `getLayoutInflater().inflate(layoutId, root, false)` 方法，手动的将第三个参数传为 false，同时为这个方法传入目标根布局。这样，我们就可以得到一个有 LayoutParams，但是没有 `parentView` 的 `layoutId` 布局了。\n\n```java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.layout_test);\n    LinearLayout mParent = findViewById(R.id.ll_root);\n    View inflateView = getLayoutInflater().inflate(R.layout.main, mParent, false);\n    Log.e(\"Test\", \"LayoutParams -> \" + inflateView.getLayoutParams());\n    Log.e(\"Test\", \"Parent -> \" + inflateView.getParent());\n}\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329155230.jpg)\n\n与我们分析的一致，有参数，但是没有父布局，且返回的就是我们加载的布局 id。我们在之后可以通过 addView 方法手动将这个布局加入父布局中。\n\n**这里还有个要注意的点**，那就是 `params = root.generateLayoutParams(attrs);` 这句代码，我们会发现，为 `layoutId` 设置的 params 参数，实际上是通过 root 来生成的。这也就告诉我们，虽然不马上添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null，因为子 View 的 LayoutParams 需要由 parent 来确定；当然，传入 null 也不会有问题，因为在执行 `addView()` 方法的时候，如果当前 childView 没有参数，会调用 `generateDefaultLayoutParams()` 生成一个宽高都包裹的 LayoutParams 赋值给 childView，而这并不一定是我们想要的。\n\n#### attachToRoot 必须为 false！\n\n代码写多了，大家有时候会发现这个 `attachToRoot` 也不是想怎样就怎样的，有时候它还就必须是 false，不能为 true。下面我们就来看看这些情况。\n\n- RecylerView#onCreateViewHolder()\n\n  在为 RecyclerView 创建 ViewHolder 时，由于 View 复用的问题，是 RecyclerView 来决定什么时候展示它的子View，这个完全不由我们决定，这种情况下，attachToRoot 必须为 false：\n\n  ```java\n  public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  \n  \t\tLayoutInflater inflater = LayoutInflater.from(getActivity());  \n  \t\tView view = inflater.inflate(R.layout.item, parent, false);  \n  \t\treturn new ViewHolder(view);  \n  }\n  ```\n\n- Fragment#onCreateView()\n\n  由于 Fragment 需要依赖于 Activity 展示，一般在 Activity 中也会有容器布局来盛放 Fragment：\n\n  ```java\n  Fragment fragment = new Fragment();\n  getSupportFragmentManager()\n          .beginTransaction()\n          .add(R.id.root_container, fragment)\n          .commit(); \n  ```\n\n  上述代码中的 `R.id.root_container` 便为容器，这个 View 会作为参数传递给 `Fragment#onCreateView()` :\n\n  ```java\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, \n                           Bundle savedInstanceState) {\n      return inflater.inflate(R.layout.fragment_layout, parentViewGroup, false); \n  }\n  ```\n\n  它也是你在 inflate() 方法中传入的 ViewGroup，FragmentManager 会将 Fragment 的 View 添加到 ViewGroup 中，言外之意就是，Fragment 对应的布局展示或者说添加进 ViewGroup 时也不是我们来控制的，而是 FragmentManager 来控制的。\n\n总结一下就是，**当我们不为子 View 的展示负责时，attachToRoot 必须为 false；否则就会出现对应的负责人，比如上面说的 Rv 或者 FragmentManager，已经把布局 id 添加到 ViewGroup 了，我们还继续设置 attachToRoot 为 true，想要手动 addView，那必然会发生 child already has parent 的错误。**\n\n以上。\n\n\n\n#### 参考文章\n\n- [深入理解LayoutInflater.inflate()](<https://juejin.im/entry/5a1513abf265da43052e4473>)\n- [LayoutInflater.inflate和View.inflate](<https://www.jianshu.com/p/cdc9d4c0826e>)\n- [Android API 28 View.java / LayoutInflater.java / ViewGroup.java]()","slug":"View-inflate-analysis","published":1,"updated":"2019-03-29T08:47:59.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86dn0019lh1pqqq8oa2h","content":"<p>误用 LayoutInflater 的 inflate() 方法已经不是什么稀罕事儿了……</p>\n<a id=\"more\"></a>\n<p>做 Android 开发做久了，一定会或多或少地对布局的渲染有一些懵逼：</p>\n<blockquote>\n<ol>\n<li><code>View.inflate()</code> 和 <code>LayoutInflator.from().inflate()</code> 有啥区别？</li>\n<li>调用 inflate() 方法的时候有时候传 null，有时候传 parent 是为啥？</li>\n<li>用 LayoutInflater 有时候还可能传个 attachToRoot ，这又是个啥？</li>\n</ol>\n</blockquote>\n<p>接下来我们就从源码的角度来寻找一下这几个问题的答案，后面再用几个示例来验证我们的猜想。</p>\n<p>话不多说，Let’s go !</p>\n<h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>先来看一下这个方法具体做了什么：</p>\n<pre><code class=\"java\">/**\n * Inflate a view from an XML resource.  This convenience method wraps the {@link\n * LayoutInflater} class, which provides a full range of options for view inflation.\n */\npublic static View inflate(Context context, int resource, ViewGroup root) {\n    LayoutInflater factory = LayoutInflater.from(context);\n    return factory.inflate(resource, root);\n}\n</code></pre>\n<p>当我们查看源码，就会发现，这个方法的内部实际上就是调用了 <code>LayoutInflater</code> 的 inflate 方法。正如此方法的注释所言，这是一个方便开发者调用的 <code>LayoutInflater</code> 的包装方法，而 <code>LayoutInflater</code> 本身则为 View 的渲染提供了更多的选择。</p>\n<p>那么我们现在的问题就变成了， <code>LayoutInflater</code> 又做了什么？</p>\n<p>继续追踪代码，我们会发现， <code>LayoutInflator.from().inflate()</code>  是这个样子的：</p>\n<pre><code class=\"java\">// LayoutInflator#inflate(int, ViewGroup)\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {\n        return inflate(resource, root, root != null);\n}\n</code></pre>\n<p>啥？重载？</p>\n<pre><code class=\"java\">// LayoutInflator#inflate(int, ViewGroup, boolean)\npublic View inflate(int resource, ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n</code></pre>\n<p>这里我们看到，通过层层调用，最终会调用到 <code>LayoutInflator#inflate(int, ViewGroup, boolean)</code> 方法，很明显，这个方法会将我们传入的布局 id 转换为 XmlResourceParser，然后进行另一次，也是最后一次重载。</p>\n<p>这个方法就厉害了，这里基本上包括了我们所有问题的答案，我们继续往下看。</p>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>话不多说，上代码。接下来我们来逐段分析下这个 <code>inflate</code> 方法：</p>\n<pre><code class=\"java\">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n\n    // 默认返回结果为传入的根布局\n    View result = root;\n\n    // 通过 createViewFromTag() 方法找到传入的 layoutId 的根布局，并赋值给 temp\n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    ViewGroup.LayoutParams params = null;\n\n    // 如果传入的父布局不为空\n    if (root != null) {\n        // 为这个 root 生成一套合适的 LayoutParams\n        params = root.generateLayoutParams(attrs);\n        if (!attachToRoot) {\n            // 如果没有 attachToRoot，那为根布局设置 layoutparams\n            temp.setLayoutParams(params);\n        }\n    }\n\n    // 如果传入的父布局不为空，且想要 attachToRoot\n    if (root != null &amp;&amp; attachToRoot) {\n        // 那就将传入的布局以及 layoutparams 通过 addView 方法添加到父布局中 \n        root.addView(temp, params);\n    }\n\n    // 如果传入的根布局为空，或者不想 attachToRoot，则返回要加载的 layoutId\n    if (root == null || !attachToRoot) {\n        result = temp;\n    }\n    return result;\n}\n</code></pre>\n<p>代码也分析完了，我再来总结一下：</p>\n<ul>\n<li><p><code>View#inflate</code> 只是个简易的包装方法，实际上还是调用的 <code>LayoutInflater#inflate</code> ;</p>\n</li>\n<li><p><code>LayoutInflater#inflate</code> 由于可以自己选择 root 和 attachToRoot 的搭配（后面有解释），使用起来更加灵活；</p>\n</li>\n<li><p>实际上的区别只是在于 <code>root</code> 是否传空，以及 <code>attachToRoot</code> 真假与否；</p>\n</li>\n<li><p>当  <code>root</code> 传空时，会直接返回要加载的 <code>layoutId</code>，返回的 View 没有父布局且没有 LayoutParams；</p>\n</li>\n<li><p>当  <code>root</code> 不传空时，又分为 <code>attachToRoot</code> 为真或者为假：</p>\n<ul>\n<li><p><code>attachToRoot = true</code> </p>\n<p>会为传入的 <code>layoutId</code> 直接设置参数，并将其添加到 <code>root</code> 中，然后将传入的 <code>root</code> 返回；</p>\n</li>\n<li><p><code>attachToRoot = false</code> </p>\n<p>会为传入的 <code>layoutId</code> 设置参数，但是不会添加到 <code>root</code> ，然后返回 <code>layoutId</code> 对应的 View；</p>\n<blockquote>\n<p>这里需要注意的是，虽然不马上将 View 添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null；因为子 View 的 LayoutParams 需要由 parent 来确定；否则会在手动 addView 时调用 <code>generateDefaultLayoutParams()</code> 为子 View 生成一个宽高都为包裹内容的 LayoutParams，而这并不一定是我们想要的。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"测试-amp-检验\"><a href=\"#测试-amp-检验\" class=\"headerlink\" title=\"测试 &amp; 检验\"></a>测试 &amp; 检验</h3><p>单说起来可能有些抽象，下面使用代码来进行具体的测试与检验。</p>\n<h4 id=\"View-inflate-context-layoutId-null\"><a href=\"#View-inflate-context-layoutId-null\" class=\"headerlink\" title=\"View.inflate(context, layoutId, null)\"></a>View.inflate(context, layoutId, null)</h4><p>如之前所说，这实际上调用的是 <code>getLayoutInflater().inflate(layoutId, null)</code> ，结合之前的源码来看：</p>\n<pre><code class=\"java\">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    View result = root;\n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    if (root == null || !attachToRoot) {\n        result = temp;\n    }\n    return result;\n}\n</code></pre>\n<p>很明显，传入的 <code>root</code> 为空，则会直接将加载好的 xml 布局返回，而这种情况下返回的这个 View 没有参数，也没有父布局。</p>\n<pre><code class=\"java\">protected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.layout_test);\n    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, null);\n    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());\n    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());\n}\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329145224.jpg\" alt=\"\"></p>\n<p>如图所示，正如我们想的，root 传 null 时，参数以及父布局返回结果均为 null。</p>\n<h4 id=\"View-inflate-context-layoutId-mParent\"><a href=\"#View-inflate-context-layoutId-mParent\" class=\"headerlink\" title=\"View.inflate(context, layoutId, mParent)\"></a>View.inflate(context, layoutId, mParent)</h4><p>按之前分析过的，此方法实际调用的是 <code>getLayoutInflater().inflate(layoutId, root, true)</code> ，再来看源码：</p>\n<pre><code class=\"java\">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n    View result = root; \n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    ViewGroup.LayoutParams params = null;\n    if (root != null) {\n        params = root.generateLayoutParams(attrs);\n    }\n    if (root != null &amp;&amp; attachToRoot) {\n        root.addView(temp, params);\n    }\n    return result;\n}\n</code></pre>\n<p>如源码所示，返回的 result 会在最开始就被赋值为入参的 root，root 不为空，同时 attachToRoot 为 true，就会将加载好的布局直接通过 addView 方法添加到 root 布局中，然后将 root 返回。</p>\n<pre><code class=\"java\">protected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    setContentView(R.layout.layout_test);\n\n    LinearLayout mParent = findViewById(R.id.ll_root);\n    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, mParent);\n\n    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());\n    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());\n    Log.e(&quot;Test&quot;, &quot;inflateView -&gt; &quot; + inflateView);\n}\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329153240.jpg\" alt=\"\"></p>\n<p>如图示，返回的 View 正是我们传入的 mParent，对应的 id 是 ll_root，参数也不再为空。</p>\n<p>####getLayoutInflater().inflate(layoutId, root, false) </p>\n<p>也许会有人问了，现在要么是 root 传空，返回 layoutId 对应的布局；要么是 root 不传空，返回传入的 root 布局。那我要是想 root 不传空，但是还是返回 layoutId 对应的布局呢？</p>\n<p>这就是 <code>View#inflate</code> 的局限了，由于它是包装方法，因此 <code>attachToRoot</code> 并不能因需定制。这时候我们完全可以自己调用 <code>getLayoutInflater().inflate(layoutId, root, false)</code> 方法，手动的将第三个参数传为 false，同时为这个方法传入目标根布局。这样，我们就可以得到一个有 LayoutParams，但是没有 <code>parentView</code> 的 <code>layoutId</code> 布局了。</p>\n<pre><code class=\"java\">protected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.layout_test);\n    LinearLayout mParent = findViewById(R.id.ll_root);\n    View inflateView = getLayoutInflater().inflate(R.layout.main, mParent, false);\n    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());\n    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());\n}\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329155230.jpg\" alt=\"\"></p>\n<p>与我们分析的一致，有参数，但是没有父布局，且返回的就是我们加载的布局 id。我们在之后可以通过 addView 方法手动将这个布局加入父布局中。</p>\n<p><strong>这里还有个要注意的点</strong>，那就是 <code>params = root.generateLayoutParams(attrs);</code> 这句代码，我们会发现，为 <code>layoutId</code> 设置的 params 参数，实际上是通过 root 来生成的。这也就告诉我们，虽然不马上添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null，因为子 View 的 LayoutParams 需要由 parent 来确定；当然，传入 null 也不会有问题，因为在执行 <code>addView()</code> 方法的时候，如果当前 childView 没有参数，会调用 <code>generateDefaultLayoutParams()</code> 生成一个宽高都包裹的 LayoutParams 赋值给 childView，而这并不一定是我们想要的。</p>\n<h4 id=\"attachToRoot-必须为-false！\"><a href=\"#attachToRoot-必须为-false！\" class=\"headerlink\" title=\"attachToRoot 必须为 false！\"></a>attachToRoot 必须为 false！</h4><p>代码写多了，大家有时候会发现这个 <code>attachToRoot</code> 也不是想怎样就怎样的，有时候它还就必须是 false，不能为 true。下面我们就来看看这些情况。</p>\n<ul>\n<li><p>RecylerView#onCreateViewHolder()</p>\n<p>在为 RecyclerView 创建 ViewHolder 时，由于 View 复用的问题，是 RecyclerView 来决定什么时候展示它的子View，这个完全不由我们决定，这种情况下，attachToRoot 必须为 false：</p>\n<pre><code class=\"java\">public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  \n        LayoutInflater inflater = LayoutInflater.from(getActivity());  \n        View view = inflater.inflate(R.layout.item, parent, false);  \n        return new ViewHolder(view);  \n}\n</code></pre>\n</li>\n<li><p>Fragment#onCreateView()</p>\n<p>由于 Fragment 需要依赖于 Activity 展示，一般在 Activity 中也会有容器布局来盛放 Fragment：</p>\n<pre><code class=\"java\">Fragment fragment = new Fragment();\ngetSupportFragmentManager()\n        .beginTransaction()\n        .add(R.id.root_container, fragment)\n        .commit(); \n</code></pre>\n<p>上述代码中的 <code>R.id.root_container</code> 便为容器，这个 View 会作为参数传递给 <code>Fragment#onCreateView()</code> :</p>\n<pre><code class=\"java\">public View onCreateView(LayoutInflater inflater, ViewGroup container, \n                         Bundle savedInstanceState) {\n    return inflater.inflate(R.layout.fragment_layout, parentViewGroup, false); \n}\n</code></pre>\n<p>它也是你在 inflate() 方法中传入的 ViewGroup，FragmentManager 会将 Fragment 的 View 添加到 ViewGroup 中，言外之意就是，Fragment 对应的布局展示或者说添加进 ViewGroup 时也不是我们来控制的，而是 FragmentManager 来控制的。</p>\n</li>\n</ul>\n<p>总结一下就是，<strong>当我们不为子 View 的展示负责时，attachToRoot 必须为 false；否则就会出现对应的负责人，比如上面说的 Rv 或者 FragmentManager，已经把布局 id 添加到 ViewGroup 了，我们还继续设置 attachToRoot 为 true，想要手动 addView，那必然会发生 child already has parent 的错误。</strong></p>\n<p>以上。</p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><ul>\n<li><a href=\"https://juejin.im/entry/5a1513abf265da43052e4473\" target=\"_blank\" rel=\"noopener\">深入理解LayoutInflater.inflate()</a></li>\n<li><a href=\"https://www.jianshu.com/p/cdc9d4c0826e\" target=\"_blank\" rel=\"noopener\">LayoutInflater.inflate和View.inflate</a></li>\n<li><a href=\"\">Android API 28 View.java / LayoutInflater.java / ViewGroup.java</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>误用 LayoutInflater 的 inflate() 方法已经不是什么稀罕事儿了……</p>","more":"<p>做 Android 开发做久了，一定会或多或少地对布局的渲染有一些懵逼：</p>\n<blockquote>\n<ol>\n<li><code>View.inflate()</code> 和 <code>LayoutInflator.from().inflate()</code> 有啥区别？</li>\n<li>调用 inflate() 方法的时候有时候传 null，有时候传 parent 是为啥？</li>\n<li>用 LayoutInflater 有时候还可能传个 attachToRoot ，这又是个啥？</li>\n</ol>\n</blockquote>\n<p>接下来我们就从源码的角度来寻找一下这几个问题的答案，后面再用几个示例来验证我们的猜想。</p>\n<p>话不多说，Let’s go !</p>\n<h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>先来看一下这个方法具体做了什么：</p>\n<pre><code class=\"java\">/**\n * Inflate a view from an XML resource.  This convenience method wraps the {@link\n * LayoutInflater} class, which provides a full range of options for view inflation.\n */\npublic static View inflate(Context context, int resource, ViewGroup root) {\n    LayoutInflater factory = LayoutInflater.from(context);\n    return factory.inflate(resource, root);\n}\n</code></pre>\n<p>当我们查看源码，就会发现，这个方法的内部实际上就是调用了 <code>LayoutInflater</code> 的 inflate 方法。正如此方法的注释所言，这是一个方便开发者调用的 <code>LayoutInflater</code> 的包装方法，而 <code>LayoutInflater</code> 本身则为 View 的渲染提供了更多的选择。</p>\n<p>那么我们现在的问题就变成了， <code>LayoutInflater</code> 又做了什么？</p>\n<p>继续追踪代码，我们会发现， <code>LayoutInflator.from().inflate()</code>  是这个样子的：</p>\n<pre><code class=\"java\">// LayoutInflator#inflate(int, ViewGroup)\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {\n        return inflate(resource, root, root != null);\n}\n</code></pre>\n<p>啥？重载？</p>\n<pre><code class=\"java\">// LayoutInflator#inflate(int, ViewGroup, boolean)\npublic View inflate(int resource, ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n</code></pre>\n<p>这里我们看到，通过层层调用，最终会调用到 <code>LayoutInflator#inflate(int, ViewGroup, boolean)</code> 方法，很明显，这个方法会将我们传入的布局 id 转换为 XmlResourceParser，然后进行另一次，也是最后一次重载。</p>\n<p>这个方法就厉害了，这里基本上包括了我们所有问题的答案，我们继续往下看。</p>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>话不多说，上代码。接下来我们来逐段分析下这个 <code>inflate</code> 方法：</p>\n<pre><code class=\"java\">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n\n    // 默认返回结果为传入的根布局\n    View result = root;\n\n    // 通过 createViewFromTag() 方法找到传入的 layoutId 的根布局，并赋值给 temp\n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    ViewGroup.LayoutParams params = null;\n\n    // 如果传入的父布局不为空\n    if (root != null) {\n        // 为这个 root 生成一套合适的 LayoutParams\n        params = root.generateLayoutParams(attrs);\n        if (!attachToRoot) {\n            // 如果没有 attachToRoot，那为根布局设置 layoutparams\n            temp.setLayoutParams(params);\n        }\n    }\n\n    // 如果传入的父布局不为空，且想要 attachToRoot\n    if (root != null &amp;&amp; attachToRoot) {\n        // 那就将传入的布局以及 layoutparams 通过 addView 方法添加到父布局中 \n        root.addView(temp, params);\n    }\n\n    // 如果传入的根布局为空，或者不想 attachToRoot，则返回要加载的 layoutId\n    if (root == null || !attachToRoot) {\n        result = temp;\n    }\n    return result;\n}\n</code></pre>\n<p>代码也分析完了，我再来总结一下：</p>\n<ul>\n<li><p><code>View#inflate</code> 只是个简易的包装方法，实际上还是调用的 <code>LayoutInflater#inflate</code> ;</p>\n</li>\n<li><p><code>LayoutInflater#inflate</code> 由于可以自己选择 root 和 attachToRoot 的搭配（后面有解释），使用起来更加灵活；</p>\n</li>\n<li><p>实际上的区别只是在于 <code>root</code> 是否传空，以及 <code>attachToRoot</code> 真假与否；</p>\n</li>\n<li><p>当  <code>root</code> 传空时，会直接返回要加载的 <code>layoutId</code>，返回的 View 没有父布局且没有 LayoutParams；</p>\n</li>\n<li><p>当  <code>root</code> 不传空时，又分为 <code>attachToRoot</code> 为真或者为假：</p>\n<ul>\n<li><p><code>attachToRoot = true</code> </p>\n<p>会为传入的 <code>layoutId</code> 直接设置参数，并将其添加到 <code>root</code> 中，然后将传入的 <code>root</code> 返回；</p>\n</li>\n<li><p><code>attachToRoot = false</code> </p>\n<p>会为传入的 <code>layoutId</code> 设置参数，但是不会添加到 <code>root</code> ，然后返回 <code>layoutId</code> 对应的 View；</p>\n<blockquote>\n<p>这里需要注意的是，虽然不马上将 View 添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null；因为子 View 的 LayoutParams 需要由 parent 来确定；否则会在手动 addView 时调用 <code>generateDefaultLayoutParams()</code> 为子 View 生成一个宽高都为包裹内容的 LayoutParams，而这并不一定是我们想要的。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"测试-amp-检验\"><a href=\"#测试-amp-检验\" class=\"headerlink\" title=\"测试 &amp; 检验\"></a>测试 &amp; 检验</h3><p>单说起来可能有些抽象，下面使用代码来进行具体的测试与检验。</p>\n<h4 id=\"View-inflate-context-layoutId-null\"><a href=\"#View-inflate-context-layoutId-null\" class=\"headerlink\" title=\"View.inflate(context, layoutId, null)\"></a>View.inflate(context, layoutId, null)</h4><p>如之前所说，这实际上调用的是 <code>getLayoutInflater().inflate(layoutId, null)</code> ，结合之前的源码来看：</p>\n<pre><code class=\"java\">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    View result = root;\n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    if (root == null || !attachToRoot) {\n        result = temp;\n    }\n    return result;\n}\n</code></pre>\n<p>很明显，传入的 <code>root</code> 为空，则会直接将加载好的 xml 布局返回，而这种情况下返回的这个 View 没有参数，也没有父布局。</p>\n<pre><code class=\"java\">protected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.layout_test);\n    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, null);\n    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());\n    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());\n}\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329145224.jpg\" alt=\"\"></p>\n<p>如图所示，正如我们想的，root 传 null 时，参数以及父布局返回结果均为 null。</p>\n<h4 id=\"View-inflate-context-layoutId-mParent\"><a href=\"#View-inflate-context-layoutId-mParent\" class=\"headerlink\" title=\"View.inflate(context, layoutId, mParent)\"></a>View.inflate(context, layoutId, mParent)</h4><p>按之前分析过的，此方法实际调用的是 <code>getLayoutInflater().inflate(layoutId, root, true)</code> ，再来看源码：</p>\n<pre><code class=\"java\">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {\n    final Context inflaterContext = mContext;\n    final AttributeSet attrs = Xml.asAttributeSet(parser);\n    View result = root; \n    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n    ViewGroup.LayoutParams params = null;\n    if (root != null) {\n        params = root.generateLayoutParams(attrs);\n    }\n    if (root != null &amp;&amp; attachToRoot) {\n        root.addView(temp, params);\n    }\n    return result;\n}\n</code></pre>\n<p>如源码所示，返回的 result 会在最开始就被赋值为入参的 root，root 不为空，同时 attachToRoot 为 true，就会将加载好的布局直接通过 addView 方法添加到 root 布局中，然后将 root 返回。</p>\n<pre><code class=\"java\">protected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    setContentView(R.layout.layout_test);\n\n    LinearLayout mParent = findViewById(R.id.ll_root);\n    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, mParent);\n\n    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());\n    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());\n    Log.e(&quot;Test&quot;, &quot;inflateView -&gt; &quot; + inflateView);\n}\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329153240.jpg\" alt=\"\"></p>\n<p>如图示，返回的 View 正是我们传入的 mParent，对应的 id 是 ll_root，参数也不再为空。</p>\n<p>####getLayoutInflater().inflate(layoutId, root, false) </p>\n<p>也许会有人问了，现在要么是 root 传空，返回 layoutId 对应的布局；要么是 root 不传空，返回传入的 root 布局。那我要是想 root 不传空，但是还是返回 layoutId 对应的布局呢？</p>\n<p>这就是 <code>View#inflate</code> 的局限了，由于它是包装方法，因此 <code>attachToRoot</code> 并不能因需定制。这时候我们完全可以自己调用 <code>getLayoutInflater().inflate(layoutId, root, false)</code> 方法，手动的将第三个参数传为 false，同时为这个方法传入目标根布局。这样，我们就可以得到一个有 LayoutParams，但是没有 <code>parentView</code> 的 <code>layoutId</code> 布局了。</p>\n<pre><code class=\"java\">protected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.layout_test);\n    LinearLayout mParent = findViewById(R.id.ll_root);\n    View inflateView = getLayoutInflater().inflate(R.layout.main, mParent, false);\n    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());\n    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());\n}\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329155230.jpg\" alt=\"\"></p>\n<p>与我们分析的一致，有参数，但是没有父布局，且返回的就是我们加载的布局 id。我们在之后可以通过 addView 方法手动将这个布局加入父布局中。</p>\n<p><strong>这里还有个要注意的点</strong>，那就是 <code>params = root.generateLayoutParams(attrs);</code> 这句代码，我们会发现，为 <code>layoutId</code> 设置的 params 参数，实际上是通过 root 来生成的。这也就告诉我们，虽然不马上添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null，因为子 View 的 LayoutParams 需要由 parent 来确定；当然，传入 null 也不会有问题，因为在执行 <code>addView()</code> 方法的时候，如果当前 childView 没有参数，会调用 <code>generateDefaultLayoutParams()</code> 生成一个宽高都包裹的 LayoutParams 赋值给 childView，而这并不一定是我们想要的。</p>\n<h4 id=\"attachToRoot-必须为-false！\"><a href=\"#attachToRoot-必须为-false！\" class=\"headerlink\" title=\"attachToRoot 必须为 false！\"></a>attachToRoot 必须为 false！</h4><p>代码写多了，大家有时候会发现这个 <code>attachToRoot</code> 也不是想怎样就怎样的，有时候它还就必须是 false，不能为 true。下面我们就来看看这些情况。</p>\n<ul>\n<li><p>RecylerView#onCreateViewHolder()</p>\n<p>在为 RecyclerView 创建 ViewHolder 时，由于 View 复用的问题，是 RecyclerView 来决定什么时候展示它的子View，这个完全不由我们决定，这种情况下，attachToRoot 必须为 false：</p>\n<pre><code class=\"java\">public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  \n        LayoutInflater inflater = LayoutInflater.from(getActivity());  \n        View view = inflater.inflate(R.layout.item, parent, false);  \n        return new ViewHolder(view);  \n}\n</code></pre>\n</li>\n<li><p>Fragment#onCreateView()</p>\n<p>由于 Fragment 需要依赖于 Activity 展示，一般在 Activity 中也会有容器布局来盛放 Fragment：</p>\n<pre><code class=\"java\">Fragment fragment = new Fragment();\ngetSupportFragmentManager()\n        .beginTransaction()\n        .add(R.id.root_container, fragment)\n        .commit(); \n</code></pre>\n<p>上述代码中的 <code>R.id.root_container</code> 便为容器，这个 View 会作为参数传递给 <code>Fragment#onCreateView()</code> :</p>\n<pre><code class=\"java\">public View onCreateView(LayoutInflater inflater, ViewGroup container, \n                         Bundle savedInstanceState) {\n    return inflater.inflate(R.layout.fragment_layout, parentViewGroup, false); \n}\n</code></pre>\n<p>它也是你在 inflate() 方法中传入的 ViewGroup，FragmentManager 会将 Fragment 的 View 添加到 ViewGroup 中，言外之意就是，Fragment 对应的布局展示或者说添加进 ViewGroup 时也不是我们来控制的，而是 FragmentManager 来控制的。</p>\n</li>\n</ul>\n<p>总结一下就是，<strong>当我们不为子 View 的展示负责时，attachToRoot 必须为 false；否则就会出现对应的负责人，比如上面说的 Rv 或者 FragmentManager，已经把布局 id 添加到 ViewGroup 了，我们还继续设置 attachToRoot 为 true，想要手动 addView，那必然会发生 child already has parent 的错误。</strong></p>\n<p>以上。</p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><ul>\n<li><a href=\"https://juejin.im/entry/5a1513abf265da43052e4473\" target=\"_blank\" rel=\"noopener\">深入理解LayoutInflater.inflate()</a></li>\n<li><a href=\"https://www.jianshu.com/p/cdc9d4c0826e\" target=\"_blank\" rel=\"noopener\">LayoutInflater.inflate和View.inflate</a></li>\n<li><a href=\"\">Android API 28 View.java / LayoutInflater.java / ViewGroup.java</a></li>\n</ul>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg","title":"一个自定义 View 的小效果","date":"2019-04-14T16:00:00.000Z","_content":"\n\n\n最近简单学了一个自定义 View 的小效果，本身代码并不算多，但是还是有些新东西，本着好记性不如烂笔头的想法，还是要记录下来备忘，说不上什么时候就会用到。\n\n\n\n<!-- more -->\n\n\n\n### 效果展示\n\n整体效果大概如图示：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190414212815.gif)\n\n### 知识点概况\n\n涉及到的知识点其实就那么几个，主要还是思路和编码风格问题；相同的效果用布局摆放，再加上监听 ViewPager 滚动完全可以实现，不过就是扩展性太差，健壮性不太好，也不满足封装的要求，本次实现基本完全使用自定义 View 实现，也是个不错的思路。\n\n需要注意的知识点如下：\n\n1. 最初设计的时候就要考虑到封装，代码耦合性是不是足够低，扩展性是不是足够强；\n2. 自定义 View 的生命周期，因为你需要确定 onMeasure 方法何时执行完毕，从而在合适的位置进行参数的初始化工作，保证测量完成，所以需要的空间都可以取到宽高信息；\n3. 属性动画的基本使用；\n4. Canvas#drawColor 设置背景色\n5. Canvas#drawCircle 要注意圆心的位置是在屏幕的左上顶点，屏幕中心的位置需要自己确定；\n6. 绘制圆环需要正确确定圆环的半径，同时要考虑到与屏幕相切的位置问题；\n7. 如何拦截 View 的创建，并从中去解析自定义属性\n\n下面把整个自定义 View 拆解成几个部分来记录，大概也就是上面的知识点，也没什么好说的，都是熟能生巧的东西，practice makes perfect，没毛病。\n\n\n\n### 旋转效果\n\n先来分析一下这个效果\n\n1. 六个小圆均匀分布在大圆上，每个扇形的角度相同，也就是 60°；\n2. 整体围成一个大圆，不断旋转，大圆位于屏幕正中，直径为屏幕宽度的 1/2；\n3. 六个圆不停的变换位置，但总体位置未发生变化，从而展现出围着大圆旋转的效果；\n\n分析完毕后，我们首先要对诸如画笔颜色，屏幕宽高信息等进行初始化，这个工作只需要执行一次，我们选择在 onLayout 方法中完成，因为需要获取 View 测量后的宽高信息。\n\n```java\nprivate void initParams(Context context) {\n\n    // 获取颜色列表\n    mColorArray = context.getResources().getIntArray(R.array.splash_circle_colors);\n\n    // 获取大圆、小圆的半径\n    mBigCircleRadius = getMeasuredWidth() / 4;\n    mSmallCircleRadius = mBigCircleRadius / 7;\n\n    // 初始化画笔\n    mPaint = new Paint();\n    mPaint.setDither(true);\n    mPaint.setAntiAlias(true);\n\n    // 获取屏幕中心位置的坐标\n    mCenterX = getMeasuredWidth() / 2;\n    mCenterY = getMeasuredHeight() / 2;\n\n}\n```\n\n初始化工作完成后，半径有了，画笔也有了，现在需要确定的是每个小圆圆心的位置：\n\n```java\npublic void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)\n```\n\n大家都学过三角函数，很明显小圆的圆心在大圆圆周上，那么大圆的半径是已知的，每个扇形的角度也是已知的，根据三角函数很容易就能求出来每个小圆圆心向直径做垂线所得到的距离，这个距离又是相对于大圆圆心的距离，大圆圆心坐标已知，很显然就能求得每个小圆的坐标信息。\n\n现在的问题是，怎么让这个小圆转起来？\n\n这里我们的解决办法是，利用一个属性动画，从 0 变化到 2π，也就是整个圆周，在这个过程中，不断地去重绘 View，然后在 onDraw 中更新每个小圆当前的位置，通过重绘来实现不断滚动效果。\n\n废话就不多说了，直接上代码了。\n\n```java\nprivate void setRotateAnimation() {\n    mValueAnimator = ObjectAnimator.ofFloat(0, (float) Math.PI * 2);\n    mValueAnimator.setRepeatCount(-1);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME);\n    mValueAnimator.setInterpolator(new LinearInterpolator());\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mRotatedAngle = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n    // 先绘制整个背景为白色\n    canvas.drawColor(Color.WHITE);\n\n    // 得到每个扇形的弧度\n    double percentAngle = Math.PI * 2 / mColorArray.length;\n\n    for (int i = 0; i < mColorArray.length; i++) {\n\n        mPaint.setColor(mColorArray[i]);\n\n        double currAngle = percentAngle * i + mRotatedAngle;\n\n        // x轴直角边 = 半径 * cos(角度)\n        float cx = mCenterX + (float) (mBigCircleRadius * Math.cos(currAngle));\n\n        // y轴直角边 = 半径 * sin(角度)\n        float cy = mCenterY + (float) (mBigCircleRadius * Math.sin(currAngle));\n\n        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);\n\n    }\n}\n```\n\n整个旋转效果基本上就是这些内容，主要还是一个思路的问题，高中数学的内容，算数过关，代码问题不大。\n\n### 缩放效果\n\n这个效果就更简单了，只是一个很简单的平移动画，怕的是把问题想复杂，比如纠结做出的先放大再缩小是怎么实现的，实际上**那只是属性动画的一个差值器**而已。\n\n本质上这就是每个小圆都从圆周上平移到了圆心处，就是这么简单。只不过在它不是简单的缩放，而是不断的在更改大圆的半径，让整个大圆在慢慢变小。\n\n```java\nprivate void setMergeAnimation() {\n    // 从大圆半径长变化到 0，记录变化的值，并将其作为各个小圆绘制位置的参考值\n    mValueAnimator = ObjectAnimator.ofFloat(mBigCircleRadius, 0);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);\n    mValueAnimator.setInterpolator(new AnticipateInterpolator(5f));\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mCurrBigCircleRadius = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n    canvas.drawColor(Color.WHITE);\n    double percentAngle = Math.PI * 2 / mColorArray.length;\n    for (int i = 0; i < mColorArray.length; i++) {\n        mPaint.setColor(mColorArray[i]);\n        double currAngle = percentAngle * i + mRotatedAngle;\n        // 使用 mCurrBigCircleRadius 代替固定的 大圆半径，从而实现向中心靠拢的效果\n        float cx = mCenterX + (float) (mCurrBigCircleRadius * Math.cos(currAngle));\n        float cy = mCenterY + (float) (mCurrBigCircleRadius * Math.sin(currAngle));\n      \n        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);\n    }\n}\n```\n\n### 水波纹效果\n\n其实水波纹也就是个视觉效果，本质上就是又画了个圆，只不过这个圆有点大，把整个屏幕都包含进去了，也就是说，整个屏幕本质上是这个圆的内切矩形，即屏幕的对角线是这个圆形的直径。\n\n这里需要注意的是，这个画的并不是个普通的圆，而是一个圆环。具体如图。\n\n```java\nprivate void setMergeAnimation() {\n  \t// mExtendRadius = (int) Math.sqrt(Math.pow(mCenterX, 2) + Math.pow(mCenterX, 2));\n    // mExtendRadius 屏幕对角线的一半，即圆的半径\n    mValueAnimator = ObjectAnimator.ofFloat(0, mExtendRadius);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mCurrBigCircleRadius = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n\t\t// mCurrBigCircleRadius 不停变大的半径值\n  \t// mExtendRadius - mCurrBigCircleRadius -> 圆环的宽度\n    float strokeWidth = mExtendRadius - mCurrBigCircleRadius;\n    mPaint.setStrokeWidth(strokeWidth);\n    mPaint.setStyle(Paint.Style.STROKE); // 设置圆环\n    mPaint.setColor(Color.WHITE);\n\t\t// 圆环真正的半径\n    float radius = strokeWidth / 2 + mCurrBigCircleRadius;\n    canvas.drawCircle(mCenterX, mCenterY, radius, mPaint);\n}\n\n```\n\n### ViewPager 滚动视差效果\n\n动画结束，下面来简单介绍一下视差效果。个别控件可以跟随 ViewPager 滚动而变化，本来也可以直接监听 ViewPager 滚动，去遍历需要移动的控件来实现同样的效果，但是由于复用性、扩展性都比较差，这里使用自定义属性的方式来实现。**这种方式的重点在于拦截系统 View 的创建，然后解析自定义的属性，从而实现想要的效果。**\n\n- 拦截View的创建\n\n需要使用 LayoutInflater 的 setFactory 方法，具体就不多做介绍了，不了解的自己去了解一下： [Android 探究 LayoutInflater setFactory](<https://blog.csdn.net/lmj623565791/article/details/51503977>)\n\n需要\n\n- 解析自定义属性\n\n  我们为系统控件扩展了自定义属性，在 attrs 中声明：\n\n  ```xml\n  <resources>\n      <!-- X方向上的位移 -->\n      <attr name=\"translationXIn\" format=\"float\" />\n      <attr name=\"translationXOut\" format=\"float\" />\n      <!-- Y方向上的位移 -->\n      <attr name=\"translationYIn\" format=\"float\" />\n      <attr name=\"translationYOut\" format=\"float\" />\n  </resources>\n  ```\n\n  然后我们拦截到系统的 View 后，尝试从中去解析这些自定义的 View；解析到对应的自定义属性后，通过给 View 设置 tag 的方式，将用户设置的信息进行保存：\n\n  ```xml\n  <resources>\n      <item name=\"parallax_tag\" type=\"id\"/>\n  </resources>\n  ```\n\n  ```java\n   private int[] mParallaxAttrs = new int[]{\n              R.attr.translationXIn, R.attr.translationXOut,\n              R.attr.translationYIn, R.attr.translationYOut\n      };\n  \n  private void analysisAttrs(View view, Context context, AttributeSet attrs) {\n      TypedArray array = context.obtainStyledAttributes(attrs, mParallaxAttrs);\n  \n      // 主动去解析自定义的几个属性，如果能够拿到，就去遍历解析\n      if (array != null && array.getIndexCount() != 0) {\n  \n          ParallaxTag parallaxTag = new ParallaxTag();\n          for (int i = 0; i < array.getIndexCount(); i++) {\n  \n              int arrayIndex = array.getIndex(i);\n  \n              switch (arrayIndex) {\n                  case 0:\n                      parallaxTag.setxIn(array.getFloat(arrayIndex, 0f));\n                      break;\n                  case 1:\n                      parallaxTag.setxOut(array.getFloat(arrayIndex, 0f));\n                      break;\n                  case 2:\n                      parallaxTag.setyIn(array.getFloat(arrayIndex, 0f));\n                      break;\n                  case 3:\n                      parallaxTag.setyOut(array.getFloat(arrayIndex, 0f));\n                      break;\n              }\n  \n              // 要紧的问题是，解析到了以后怎么存 -> 给 View 设置 tag\n              view.setTag(R.id.parallax_tag, parallaxTag);\n  \n              // 将准备操作的 View 放入集合中\n              mParallaxViews.add(view);\n          }\n  \n          array.recycle();\n      }\n  }\n  ```\n  \n\n以上动作在 ViewPager 关联的 Fragment 中实现，这样只需要在 ViewPager 的滑动监听中去取到当前 Fragment 的 View 集合，然后分别为左右两侧的 Fragment 设置进入和划出效果即可。\n\n```java\naddOnPageChangeListener(new OnPageChangeListener() {\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n        // 同时设置左右两侧的 fragment，左边退出，右边进入\n        ParallaxFragment outFragment = mFragments.get(position);\n\n\n        List<View> outFragmentParallaxViews = outFragment.getParallaxViews();\n        for (View view : outFragmentParallaxViews) {\n            ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);\n            view.setTranslationX(( -positionOffsetPixels) * parallaxTag.getxOut());\n            view.setTranslationY(( -positionOffsetPixels) * parallaxTag.getyOut());\n        }\n\n        try {\n            ParallaxFragment inFragment = mFragments.get(position + 1);\n            outFragmentParallaxViews = inFragment.getParallaxViews();\n            for (View view : outFragmentParallaxViews) {\n                ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);\n                view.setTranslationX(\n                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getxIn());\n                view.setTranslationY(\n                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getyIn());\n            }\n        } catch (Exception e) {}\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n});\n```\n\n好啦，说到这里就差不多结束了，完结撒花~\n\n\n\n\n\n\n","source":"_posts/custom-view-parallax.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg\ntitle: 一个自定义 View 的小效果\ntags: [Android]\ndate: 2019-04-15\n---\n\n\n\n最近简单学了一个自定义 View 的小效果，本身代码并不算多，但是还是有些新东西，本着好记性不如烂笔头的想法，还是要记录下来备忘，说不上什么时候就会用到。\n\n\n\n<!-- more -->\n\n\n\n### 效果展示\n\n整体效果大概如图示：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190414212815.gif)\n\n### 知识点概况\n\n涉及到的知识点其实就那么几个，主要还是思路和编码风格问题；相同的效果用布局摆放，再加上监听 ViewPager 滚动完全可以实现，不过就是扩展性太差，健壮性不太好，也不满足封装的要求，本次实现基本完全使用自定义 View 实现，也是个不错的思路。\n\n需要注意的知识点如下：\n\n1. 最初设计的时候就要考虑到封装，代码耦合性是不是足够低，扩展性是不是足够强；\n2. 自定义 View 的生命周期，因为你需要确定 onMeasure 方法何时执行完毕，从而在合适的位置进行参数的初始化工作，保证测量完成，所以需要的空间都可以取到宽高信息；\n3. 属性动画的基本使用；\n4. Canvas#drawColor 设置背景色\n5. Canvas#drawCircle 要注意圆心的位置是在屏幕的左上顶点，屏幕中心的位置需要自己确定；\n6. 绘制圆环需要正确确定圆环的半径，同时要考虑到与屏幕相切的位置问题；\n7. 如何拦截 View 的创建，并从中去解析自定义属性\n\n下面把整个自定义 View 拆解成几个部分来记录，大概也就是上面的知识点，也没什么好说的，都是熟能生巧的东西，practice makes perfect，没毛病。\n\n\n\n### 旋转效果\n\n先来分析一下这个效果\n\n1. 六个小圆均匀分布在大圆上，每个扇形的角度相同，也就是 60°；\n2. 整体围成一个大圆，不断旋转，大圆位于屏幕正中，直径为屏幕宽度的 1/2；\n3. 六个圆不停的变换位置，但总体位置未发生变化，从而展现出围着大圆旋转的效果；\n\n分析完毕后，我们首先要对诸如画笔颜色，屏幕宽高信息等进行初始化，这个工作只需要执行一次，我们选择在 onLayout 方法中完成，因为需要获取 View 测量后的宽高信息。\n\n```java\nprivate void initParams(Context context) {\n\n    // 获取颜色列表\n    mColorArray = context.getResources().getIntArray(R.array.splash_circle_colors);\n\n    // 获取大圆、小圆的半径\n    mBigCircleRadius = getMeasuredWidth() / 4;\n    mSmallCircleRadius = mBigCircleRadius / 7;\n\n    // 初始化画笔\n    mPaint = new Paint();\n    mPaint.setDither(true);\n    mPaint.setAntiAlias(true);\n\n    // 获取屏幕中心位置的坐标\n    mCenterX = getMeasuredWidth() / 2;\n    mCenterY = getMeasuredHeight() / 2;\n\n}\n```\n\n初始化工作完成后，半径有了，画笔也有了，现在需要确定的是每个小圆圆心的位置：\n\n```java\npublic void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)\n```\n\n大家都学过三角函数，很明显小圆的圆心在大圆圆周上，那么大圆的半径是已知的，每个扇形的角度也是已知的，根据三角函数很容易就能求出来每个小圆圆心向直径做垂线所得到的距离，这个距离又是相对于大圆圆心的距离，大圆圆心坐标已知，很显然就能求得每个小圆的坐标信息。\n\n现在的问题是，怎么让这个小圆转起来？\n\n这里我们的解决办法是，利用一个属性动画，从 0 变化到 2π，也就是整个圆周，在这个过程中，不断地去重绘 View，然后在 onDraw 中更新每个小圆当前的位置，通过重绘来实现不断滚动效果。\n\n废话就不多说了，直接上代码了。\n\n```java\nprivate void setRotateAnimation() {\n    mValueAnimator = ObjectAnimator.ofFloat(0, (float) Math.PI * 2);\n    mValueAnimator.setRepeatCount(-1);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME);\n    mValueAnimator.setInterpolator(new LinearInterpolator());\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mRotatedAngle = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n    // 先绘制整个背景为白色\n    canvas.drawColor(Color.WHITE);\n\n    // 得到每个扇形的弧度\n    double percentAngle = Math.PI * 2 / mColorArray.length;\n\n    for (int i = 0; i < mColorArray.length; i++) {\n\n        mPaint.setColor(mColorArray[i]);\n\n        double currAngle = percentAngle * i + mRotatedAngle;\n\n        // x轴直角边 = 半径 * cos(角度)\n        float cx = mCenterX + (float) (mBigCircleRadius * Math.cos(currAngle));\n\n        // y轴直角边 = 半径 * sin(角度)\n        float cy = mCenterY + (float) (mBigCircleRadius * Math.sin(currAngle));\n\n        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);\n\n    }\n}\n```\n\n整个旋转效果基本上就是这些内容，主要还是一个思路的问题，高中数学的内容，算数过关，代码问题不大。\n\n### 缩放效果\n\n这个效果就更简单了，只是一个很简单的平移动画，怕的是把问题想复杂，比如纠结做出的先放大再缩小是怎么实现的，实际上**那只是属性动画的一个差值器**而已。\n\n本质上这就是每个小圆都从圆周上平移到了圆心处，就是这么简单。只不过在它不是简单的缩放，而是不断的在更改大圆的半径，让整个大圆在慢慢变小。\n\n```java\nprivate void setMergeAnimation() {\n    // 从大圆半径长变化到 0，记录变化的值，并将其作为各个小圆绘制位置的参考值\n    mValueAnimator = ObjectAnimator.ofFloat(mBigCircleRadius, 0);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);\n    mValueAnimator.setInterpolator(new AnticipateInterpolator(5f));\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mCurrBigCircleRadius = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n    canvas.drawColor(Color.WHITE);\n    double percentAngle = Math.PI * 2 / mColorArray.length;\n    for (int i = 0; i < mColorArray.length; i++) {\n        mPaint.setColor(mColorArray[i]);\n        double currAngle = percentAngle * i + mRotatedAngle;\n        // 使用 mCurrBigCircleRadius 代替固定的 大圆半径，从而实现向中心靠拢的效果\n        float cx = mCenterX + (float) (mCurrBigCircleRadius * Math.cos(currAngle));\n        float cy = mCenterY + (float) (mCurrBigCircleRadius * Math.sin(currAngle));\n      \n        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);\n    }\n}\n```\n\n### 水波纹效果\n\n其实水波纹也就是个视觉效果，本质上就是又画了个圆，只不过这个圆有点大，把整个屏幕都包含进去了，也就是说，整个屏幕本质上是这个圆的内切矩形，即屏幕的对角线是这个圆形的直径。\n\n这里需要注意的是，这个画的并不是个普通的圆，而是一个圆环。具体如图。\n\n```java\nprivate void setMergeAnimation() {\n  \t// mExtendRadius = (int) Math.sqrt(Math.pow(mCenterX, 2) + Math.pow(mCenterX, 2));\n    // mExtendRadius 屏幕对角线的一半，即圆的半径\n    mValueAnimator = ObjectAnimator.ofFloat(0, mExtendRadius);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mCurrBigCircleRadius = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n\t\t// mCurrBigCircleRadius 不停变大的半径值\n  \t// mExtendRadius - mCurrBigCircleRadius -> 圆环的宽度\n    float strokeWidth = mExtendRadius - mCurrBigCircleRadius;\n    mPaint.setStrokeWidth(strokeWidth);\n    mPaint.setStyle(Paint.Style.STROKE); // 设置圆环\n    mPaint.setColor(Color.WHITE);\n\t\t// 圆环真正的半径\n    float radius = strokeWidth / 2 + mCurrBigCircleRadius;\n    canvas.drawCircle(mCenterX, mCenterY, radius, mPaint);\n}\n\n```\n\n### ViewPager 滚动视差效果\n\n动画结束，下面来简单介绍一下视差效果。个别控件可以跟随 ViewPager 滚动而变化，本来也可以直接监听 ViewPager 滚动，去遍历需要移动的控件来实现同样的效果，但是由于复用性、扩展性都比较差，这里使用自定义属性的方式来实现。**这种方式的重点在于拦截系统 View 的创建，然后解析自定义的属性，从而实现想要的效果。**\n\n- 拦截View的创建\n\n需要使用 LayoutInflater 的 setFactory 方法，具体就不多做介绍了，不了解的自己去了解一下： [Android 探究 LayoutInflater setFactory](<https://blog.csdn.net/lmj623565791/article/details/51503977>)\n\n需要\n\n- 解析自定义属性\n\n  我们为系统控件扩展了自定义属性，在 attrs 中声明：\n\n  ```xml\n  <resources>\n      <!-- X方向上的位移 -->\n      <attr name=\"translationXIn\" format=\"float\" />\n      <attr name=\"translationXOut\" format=\"float\" />\n      <!-- Y方向上的位移 -->\n      <attr name=\"translationYIn\" format=\"float\" />\n      <attr name=\"translationYOut\" format=\"float\" />\n  </resources>\n  ```\n\n  然后我们拦截到系统的 View 后，尝试从中去解析这些自定义的 View；解析到对应的自定义属性后，通过给 View 设置 tag 的方式，将用户设置的信息进行保存：\n\n  ```xml\n  <resources>\n      <item name=\"parallax_tag\" type=\"id\"/>\n  </resources>\n  ```\n\n  ```java\n   private int[] mParallaxAttrs = new int[]{\n              R.attr.translationXIn, R.attr.translationXOut,\n              R.attr.translationYIn, R.attr.translationYOut\n      };\n  \n  private void analysisAttrs(View view, Context context, AttributeSet attrs) {\n      TypedArray array = context.obtainStyledAttributes(attrs, mParallaxAttrs);\n  \n      // 主动去解析自定义的几个属性，如果能够拿到，就去遍历解析\n      if (array != null && array.getIndexCount() != 0) {\n  \n          ParallaxTag parallaxTag = new ParallaxTag();\n          for (int i = 0; i < array.getIndexCount(); i++) {\n  \n              int arrayIndex = array.getIndex(i);\n  \n              switch (arrayIndex) {\n                  case 0:\n                      parallaxTag.setxIn(array.getFloat(arrayIndex, 0f));\n                      break;\n                  case 1:\n                      parallaxTag.setxOut(array.getFloat(arrayIndex, 0f));\n                      break;\n                  case 2:\n                      parallaxTag.setyIn(array.getFloat(arrayIndex, 0f));\n                      break;\n                  case 3:\n                      parallaxTag.setyOut(array.getFloat(arrayIndex, 0f));\n                      break;\n              }\n  \n              // 要紧的问题是，解析到了以后怎么存 -> 给 View 设置 tag\n              view.setTag(R.id.parallax_tag, parallaxTag);\n  \n              // 将准备操作的 View 放入集合中\n              mParallaxViews.add(view);\n          }\n  \n          array.recycle();\n      }\n  }\n  ```\n  \n\n以上动作在 ViewPager 关联的 Fragment 中实现，这样只需要在 ViewPager 的滑动监听中去取到当前 Fragment 的 View 集合，然后分别为左右两侧的 Fragment 设置进入和划出效果即可。\n\n```java\naddOnPageChangeListener(new OnPageChangeListener() {\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n        // 同时设置左右两侧的 fragment，左边退出，右边进入\n        ParallaxFragment outFragment = mFragments.get(position);\n\n\n        List<View> outFragmentParallaxViews = outFragment.getParallaxViews();\n        for (View view : outFragmentParallaxViews) {\n            ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);\n            view.setTranslationX(( -positionOffsetPixels) * parallaxTag.getxOut());\n            view.setTranslationY(( -positionOffsetPixels) * parallaxTag.getyOut());\n        }\n\n        try {\n            ParallaxFragment inFragment = mFragments.get(position + 1);\n            outFragmentParallaxViews = inFragment.getParallaxViews();\n            for (View view : outFragmentParallaxViews) {\n                ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);\n                view.setTranslationX(\n                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getxIn());\n                view.setTranslationY(\n                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getyIn());\n            }\n        } catch (Exception e) {}\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n});\n```\n\n好啦，说到这里就差不多结束了，完结撒花~\n\n\n\n\n\n\n","slug":"custom-view-parallax","published":1,"updated":"2019-04-15T09:24:13.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86dp001clh1pmwrxyvss","content":"<p>最近简单学了一个自定义 View 的小效果，本身代码并不算多，但是还是有些新东西，本着好记性不如烂笔头的想法，还是要记录下来备忘，说不上什么时候就会用到。</p>\n<a id=\"more\"></a>\n<h3 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h3><p>整体效果大概如图示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190414212815.gif\" alt=\"\"></p>\n<h3 id=\"知识点概况\"><a href=\"#知识点概况\" class=\"headerlink\" title=\"知识点概况\"></a>知识点概况</h3><p>涉及到的知识点其实就那么几个，主要还是思路和编码风格问题；相同的效果用布局摆放，再加上监听 ViewPager 滚动完全可以实现，不过就是扩展性太差，健壮性不太好，也不满足封装的要求，本次实现基本完全使用自定义 View 实现，也是个不错的思路。</p>\n<p>需要注意的知识点如下：</p>\n<ol>\n<li>最初设计的时候就要考虑到封装，代码耦合性是不是足够低，扩展性是不是足够强；</li>\n<li>自定义 View 的生命周期，因为你需要确定 onMeasure 方法何时执行完毕，从而在合适的位置进行参数的初始化工作，保证测量完成，所以需要的空间都可以取到宽高信息；</li>\n<li>属性动画的基本使用；</li>\n<li>Canvas#drawColor 设置背景色</li>\n<li>Canvas#drawCircle 要注意圆心的位置是在屏幕的左上顶点，屏幕中心的位置需要自己确定；</li>\n<li>绘制圆环需要正确确定圆环的半径，同时要考虑到与屏幕相切的位置问题；</li>\n<li>如何拦截 View 的创建，并从中去解析自定义属性</li>\n</ol>\n<p>下面把整个自定义 View 拆解成几个部分来记录，大概也就是上面的知识点，也没什么好说的，都是熟能生巧的东西，practice makes perfect，没毛病。</p>\n<h3 id=\"旋转效果\"><a href=\"#旋转效果\" class=\"headerlink\" title=\"旋转效果\"></a>旋转效果</h3><p>先来分析一下这个效果</p>\n<ol>\n<li>六个小圆均匀分布在大圆上，每个扇形的角度相同，也就是 60°；</li>\n<li>整体围成一个大圆，不断旋转，大圆位于屏幕正中，直径为屏幕宽度的 1/2；</li>\n<li>六个圆不停的变换位置，但总体位置未发生变化，从而展现出围着大圆旋转的效果；</li>\n</ol>\n<p>分析完毕后，我们首先要对诸如画笔颜色，屏幕宽高信息等进行初始化，这个工作只需要执行一次，我们选择在 onLayout 方法中完成，因为需要获取 View 测量后的宽高信息。</p>\n<pre><code class=\"java\">private void initParams(Context context) {\n\n    // 获取颜色列表\n    mColorArray = context.getResources().getIntArray(R.array.splash_circle_colors);\n\n    // 获取大圆、小圆的半径\n    mBigCircleRadius = getMeasuredWidth() / 4;\n    mSmallCircleRadius = mBigCircleRadius / 7;\n\n    // 初始化画笔\n    mPaint = new Paint();\n    mPaint.setDither(true);\n    mPaint.setAntiAlias(true);\n\n    // 获取屏幕中心位置的坐标\n    mCenterX = getMeasuredWidth() / 2;\n    mCenterY = getMeasuredHeight() / 2;\n\n}\n</code></pre>\n<p>初始化工作完成后，半径有了，画笔也有了，现在需要确定的是每个小圆圆心的位置：</p>\n<pre><code class=\"java\">public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)\n</code></pre>\n<p>大家都学过三角函数，很明显小圆的圆心在大圆圆周上，那么大圆的半径是已知的，每个扇形的角度也是已知的，根据三角函数很容易就能求出来每个小圆圆心向直径做垂线所得到的距离，这个距离又是相对于大圆圆心的距离，大圆圆心坐标已知，很显然就能求得每个小圆的坐标信息。</p>\n<p>现在的问题是，怎么让这个小圆转起来？</p>\n<p>这里我们的解决办法是，利用一个属性动画，从 0 变化到 2π，也就是整个圆周，在这个过程中，不断地去重绘 View，然后在 onDraw 中更新每个小圆当前的位置，通过重绘来实现不断滚动效果。</p>\n<p>废话就不多说了，直接上代码了。</p>\n<pre><code class=\"java\">private void setRotateAnimation() {\n    mValueAnimator = ObjectAnimator.ofFloat(0, (float) Math.PI * 2);\n    mValueAnimator.setRepeatCount(-1);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME);\n    mValueAnimator.setInterpolator(new LinearInterpolator());\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mRotatedAngle = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n    // 先绘制整个背景为白色\n    canvas.drawColor(Color.WHITE);\n\n    // 得到每个扇形的弧度\n    double percentAngle = Math.PI * 2 / mColorArray.length;\n\n    for (int i = 0; i &lt; mColorArray.length; i++) {\n\n        mPaint.setColor(mColorArray[i]);\n\n        double currAngle = percentAngle * i + mRotatedAngle;\n\n        // x轴直角边 = 半径 * cos(角度)\n        float cx = mCenterX + (float) (mBigCircleRadius * Math.cos(currAngle));\n\n        // y轴直角边 = 半径 * sin(角度)\n        float cy = mCenterY + (float) (mBigCircleRadius * Math.sin(currAngle));\n\n        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);\n\n    }\n}\n</code></pre>\n<p>整个旋转效果基本上就是这些内容，主要还是一个思路的问题，高中数学的内容，算数过关，代码问题不大。</p>\n<h3 id=\"缩放效果\"><a href=\"#缩放效果\" class=\"headerlink\" title=\"缩放效果\"></a>缩放效果</h3><p>这个效果就更简单了，只是一个很简单的平移动画，怕的是把问题想复杂，比如纠结做出的先放大再缩小是怎么实现的，实际上<strong>那只是属性动画的一个差值器</strong>而已。</p>\n<p>本质上这就是每个小圆都从圆周上平移到了圆心处，就是这么简单。只不过在它不是简单的缩放，而是不断的在更改大圆的半径，让整个大圆在慢慢变小。</p>\n<pre><code class=\"java\">private void setMergeAnimation() {\n    // 从大圆半径长变化到 0，记录变化的值，并将其作为各个小圆绘制位置的参考值\n    mValueAnimator = ObjectAnimator.ofFloat(mBigCircleRadius, 0);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);\n    mValueAnimator.setInterpolator(new AnticipateInterpolator(5f));\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mCurrBigCircleRadius = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n    canvas.drawColor(Color.WHITE);\n    double percentAngle = Math.PI * 2 / mColorArray.length;\n    for (int i = 0; i &lt; mColorArray.length; i++) {\n        mPaint.setColor(mColorArray[i]);\n        double currAngle = percentAngle * i + mRotatedAngle;\n        // 使用 mCurrBigCircleRadius 代替固定的 大圆半径，从而实现向中心靠拢的效果\n        float cx = mCenterX + (float) (mCurrBigCircleRadius * Math.cos(currAngle));\n        float cy = mCenterY + (float) (mCurrBigCircleRadius * Math.sin(currAngle));\n\n        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);\n    }\n}\n</code></pre>\n<h3 id=\"水波纹效果\"><a href=\"#水波纹效果\" class=\"headerlink\" title=\"水波纹效果\"></a>水波纹效果</h3><p>其实水波纹也就是个视觉效果，本质上就是又画了个圆，只不过这个圆有点大，把整个屏幕都包含进去了，也就是说，整个屏幕本质上是这个圆的内切矩形，即屏幕的对角线是这个圆形的直径。</p>\n<p>这里需要注意的是，这个画的并不是个普通的圆，而是一个圆环。具体如图。</p>\n<pre><code class=\"java\">private void setMergeAnimation() {\n      // mExtendRadius = (int) Math.sqrt(Math.pow(mCenterX, 2) + Math.pow(mCenterX, 2));\n    // mExtendRadius 屏幕对角线的一半，即圆的半径\n    mValueAnimator = ObjectAnimator.ofFloat(0, mExtendRadius);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mCurrBigCircleRadius = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n        // mCurrBigCircleRadius 不停变大的半径值\n      // mExtendRadius - mCurrBigCircleRadius -&gt; 圆环的宽度\n    float strokeWidth = mExtendRadius - mCurrBigCircleRadius;\n    mPaint.setStrokeWidth(strokeWidth);\n    mPaint.setStyle(Paint.Style.STROKE); // 设置圆环\n    mPaint.setColor(Color.WHITE);\n        // 圆环真正的半径\n    float radius = strokeWidth / 2 + mCurrBigCircleRadius;\n    canvas.drawCircle(mCenterX, mCenterY, radius, mPaint);\n}\n\n</code></pre>\n<h3 id=\"ViewPager-滚动视差效果\"><a href=\"#ViewPager-滚动视差效果\" class=\"headerlink\" title=\"ViewPager 滚动视差效果\"></a>ViewPager 滚动视差效果</h3><p>动画结束，下面来简单介绍一下视差效果。个别控件可以跟随 ViewPager 滚动而变化，本来也可以直接监听 ViewPager 滚动，去遍历需要移动的控件来实现同样的效果，但是由于复用性、扩展性都比较差，这里使用自定义属性的方式来实现。<strong>这种方式的重点在于拦截系统 View 的创建，然后解析自定义的属性，从而实现想要的效果。</strong></p>\n<ul>\n<li>拦截View的创建</li>\n</ul>\n<p>需要使用 LayoutInflater 的 setFactory 方法，具体就不多做介绍了，不了解的自己去了解一下： <a href=\"https://blog.csdn.net/lmj623565791/article/details/51503977\" target=\"_blank\" rel=\"noopener\">Android 探究 LayoutInflater setFactory</a></p>\n<p>需要</p>\n<ul>\n<li><p>解析自定义属性</p>\n<p>我们为系统控件扩展了自定义属性，在 attrs 中声明：</p>\n<pre><code class=\"xml\">&lt;resources&gt;\n    &lt;!-- X方向上的位移 --&gt;\n    &lt;attr name=&quot;translationXIn&quot; format=&quot;float&quot; /&gt;\n    &lt;attr name=&quot;translationXOut&quot; format=&quot;float&quot; /&gt;\n    &lt;!-- Y方向上的位移 --&gt;\n    &lt;attr name=&quot;translationYIn&quot; format=&quot;float&quot; /&gt;\n    &lt;attr name=&quot;translationYOut&quot; format=&quot;float&quot; /&gt;\n&lt;/resources&gt;\n</code></pre>\n<p>然后我们拦截到系统的 View 后，尝试从中去解析这些自定义的 View；解析到对应的自定义属性后，通过给 View 设置 tag 的方式，将用户设置的信息进行保存：</p>\n<pre><code class=\"xml\">&lt;resources&gt;\n    &lt;item name=&quot;parallax_tag&quot; type=&quot;id&quot;/&gt;\n&lt;/resources&gt;\n</code></pre>\n<pre><code class=\"java\"> private int[] mParallaxAttrs = new int[]{\n            R.attr.translationXIn, R.attr.translationXOut,\n            R.attr.translationYIn, R.attr.translationYOut\n    };\n\nprivate void analysisAttrs(View view, Context context, AttributeSet attrs) {\n    TypedArray array = context.obtainStyledAttributes(attrs, mParallaxAttrs);\n\n    // 主动去解析自定义的几个属性，如果能够拿到，就去遍历解析\n    if (array != null &amp;&amp; array.getIndexCount() != 0) {\n\n        ParallaxTag parallaxTag = new ParallaxTag();\n        for (int i = 0; i &lt; array.getIndexCount(); i++) {\n\n            int arrayIndex = array.getIndex(i);\n\n            switch (arrayIndex) {\n                case 0:\n                    parallaxTag.setxIn(array.getFloat(arrayIndex, 0f));\n                    break;\n                case 1:\n                    parallaxTag.setxOut(array.getFloat(arrayIndex, 0f));\n                    break;\n                case 2:\n                    parallaxTag.setyIn(array.getFloat(arrayIndex, 0f));\n                    break;\n                case 3:\n                    parallaxTag.setyOut(array.getFloat(arrayIndex, 0f));\n                    break;\n            }\n\n            // 要紧的问题是，解析到了以后怎么存 -&gt; 给 View 设置 tag\n            view.setTag(R.id.parallax_tag, parallaxTag);\n\n            // 将准备操作的 View 放入集合中\n            mParallaxViews.add(view);\n        }\n\n        array.recycle();\n    }\n}\n</code></pre>\n</li>\n</ul>\n<p>以上动作在 ViewPager 关联的 Fragment 中实现，这样只需要在 ViewPager 的滑动监听中去取到当前 Fragment 的 View 集合，然后分别为左右两侧的 Fragment 设置进入和划出效果即可。</p>\n<pre><code class=\"java\">addOnPageChangeListener(new OnPageChangeListener() {\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n        // 同时设置左右两侧的 fragment，左边退出，右边进入\n        ParallaxFragment outFragment = mFragments.get(position);\n\n\n        List&lt;View&gt; outFragmentParallaxViews = outFragment.getParallaxViews();\n        for (View view : outFragmentParallaxViews) {\n            ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);\n            view.setTranslationX(( -positionOffsetPixels) * parallaxTag.getxOut());\n            view.setTranslationY(( -positionOffsetPixels) * parallaxTag.getyOut());\n        }\n\n        try {\n            ParallaxFragment inFragment = mFragments.get(position + 1);\n            outFragmentParallaxViews = inFragment.getParallaxViews();\n            for (View view : outFragmentParallaxViews) {\n                ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);\n                view.setTranslationX(\n                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getxIn());\n                view.setTranslationY(\n                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getyIn());\n            }\n        } catch (Exception e) {}\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n});\n</code></pre>\n<p>好啦，说到这里就差不多结束了，完结撒花~</p>\n","site":{"data":{}},"excerpt":"<p>最近简单学了一个自定义 View 的小效果，本身代码并不算多，但是还是有些新东西，本着好记性不如烂笔头的想法，还是要记录下来备忘，说不上什么时候就会用到。</p>","more":"<h3 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h3><p>整体效果大概如图示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190414212815.gif\" alt=\"\"></p>\n<h3 id=\"知识点概况\"><a href=\"#知识点概况\" class=\"headerlink\" title=\"知识点概况\"></a>知识点概况</h3><p>涉及到的知识点其实就那么几个，主要还是思路和编码风格问题；相同的效果用布局摆放，再加上监听 ViewPager 滚动完全可以实现，不过就是扩展性太差，健壮性不太好，也不满足封装的要求，本次实现基本完全使用自定义 View 实现，也是个不错的思路。</p>\n<p>需要注意的知识点如下：</p>\n<ol>\n<li>最初设计的时候就要考虑到封装，代码耦合性是不是足够低，扩展性是不是足够强；</li>\n<li>自定义 View 的生命周期，因为你需要确定 onMeasure 方法何时执行完毕，从而在合适的位置进行参数的初始化工作，保证测量完成，所以需要的空间都可以取到宽高信息；</li>\n<li>属性动画的基本使用；</li>\n<li>Canvas#drawColor 设置背景色</li>\n<li>Canvas#drawCircle 要注意圆心的位置是在屏幕的左上顶点，屏幕中心的位置需要自己确定；</li>\n<li>绘制圆环需要正确确定圆环的半径，同时要考虑到与屏幕相切的位置问题；</li>\n<li>如何拦截 View 的创建，并从中去解析自定义属性</li>\n</ol>\n<p>下面把整个自定义 View 拆解成几个部分来记录，大概也就是上面的知识点，也没什么好说的，都是熟能生巧的东西，practice makes perfect，没毛病。</p>\n<h3 id=\"旋转效果\"><a href=\"#旋转效果\" class=\"headerlink\" title=\"旋转效果\"></a>旋转效果</h3><p>先来分析一下这个效果</p>\n<ol>\n<li>六个小圆均匀分布在大圆上，每个扇形的角度相同，也就是 60°；</li>\n<li>整体围成一个大圆，不断旋转，大圆位于屏幕正中，直径为屏幕宽度的 1/2；</li>\n<li>六个圆不停的变换位置，但总体位置未发生变化，从而展现出围着大圆旋转的效果；</li>\n</ol>\n<p>分析完毕后，我们首先要对诸如画笔颜色，屏幕宽高信息等进行初始化，这个工作只需要执行一次，我们选择在 onLayout 方法中完成，因为需要获取 View 测量后的宽高信息。</p>\n<pre><code class=\"java\">private void initParams(Context context) {\n\n    // 获取颜色列表\n    mColorArray = context.getResources().getIntArray(R.array.splash_circle_colors);\n\n    // 获取大圆、小圆的半径\n    mBigCircleRadius = getMeasuredWidth() / 4;\n    mSmallCircleRadius = mBigCircleRadius / 7;\n\n    // 初始化画笔\n    mPaint = new Paint();\n    mPaint.setDither(true);\n    mPaint.setAntiAlias(true);\n\n    // 获取屏幕中心位置的坐标\n    mCenterX = getMeasuredWidth() / 2;\n    mCenterY = getMeasuredHeight() / 2;\n\n}\n</code></pre>\n<p>初始化工作完成后，半径有了，画笔也有了，现在需要确定的是每个小圆圆心的位置：</p>\n<pre><code class=\"java\">public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)\n</code></pre>\n<p>大家都学过三角函数，很明显小圆的圆心在大圆圆周上，那么大圆的半径是已知的，每个扇形的角度也是已知的，根据三角函数很容易就能求出来每个小圆圆心向直径做垂线所得到的距离，这个距离又是相对于大圆圆心的距离，大圆圆心坐标已知，很显然就能求得每个小圆的坐标信息。</p>\n<p>现在的问题是，怎么让这个小圆转起来？</p>\n<p>这里我们的解决办法是，利用一个属性动画，从 0 变化到 2π，也就是整个圆周，在这个过程中，不断地去重绘 View，然后在 onDraw 中更新每个小圆当前的位置，通过重绘来实现不断滚动效果。</p>\n<p>废话就不多说了，直接上代码了。</p>\n<pre><code class=\"java\">private void setRotateAnimation() {\n    mValueAnimator = ObjectAnimator.ofFloat(0, (float) Math.PI * 2);\n    mValueAnimator.setRepeatCount(-1);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME);\n    mValueAnimator.setInterpolator(new LinearInterpolator());\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mRotatedAngle = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n    // 先绘制整个背景为白色\n    canvas.drawColor(Color.WHITE);\n\n    // 得到每个扇形的弧度\n    double percentAngle = Math.PI * 2 / mColorArray.length;\n\n    for (int i = 0; i &lt; mColorArray.length; i++) {\n\n        mPaint.setColor(mColorArray[i]);\n\n        double currAngle = percentAngle * i + mRotatedAngle;\n\n        // x轴直角边 = 半径 * cos(角度)\n        float cx = mCenterX + (float) (mBigCircleRadius * Math.cos(currAngle));\n\n        // y轴直角边 = 半径 * sin(角度)\n        float cy = mCenterY + (float) (mBigCircleRadius * Math.sin(currAngle));\n\n        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);\n\n    }\n}\n</code></pre>\n<p>整个旋转效果基本上就是这些内容，主要还是一个思路的问题，高中数学的内容，算数过关，代码问题不大。</p>\n<h3 id=\"缩放效果\"><a href=\"#缩放效果\" class=\"headerlink\" title=\"缩放效果\"></a>缩放效果</h3><p>这个效果就更简单了，只是一个很简单的平移动画，怕的是把问题想复杂，比如纠结做出的先放大再缩小是怎么实现的，实际上<strong>那只是属性动画的一个差值器</strong>而已。</p>\n<p>本质上这就是每个小圆都从圆周上平移到了圆心处，就是这么简单。只不过在它不是简单的缩放，而是不断的在更改大圆的半径，让整个大圆在慢慢变小。</p>\n<pre><code class=\"java\">private void setMergeAnimation() {\n    // 从大圆半径长变化到 0，记录变化的值，并将其作为各个小圆绘制位置的参考值\n    mValueAnimator = ObjectAnimator.ofFloat(mBigCircleRadius, 0);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);\n    mValueAnimator.setInterpolator(new AnticipateInterpolator(5f));\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mCurrBigCircleRadius = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n    canvas.drawColor(Color.WHITE);\n    double percentAngle = Math.PI * 2 / mColorArray.length;\n    for (int i = 0; i &lt; mColorArray.length; i++) {\n        mPaint.setColor(mColorArray[i]);\n        double currAngle = percentAngle * i + mRotatedAngle;\n        // 使用 mCurrBigCircleRadius 代替固定的 大圆半径，从而实现向中心靠拢的效果\n        float cx = mCenterX + (float) (mCurrBigCircleRadius * Math.cos(currAngle));\n        float cy = mCenterY + (float) (mCurrBigCircleRadius * Math.sin(currAngle));\n\n        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);\n    }\n}\n</code></pre>\n<h3 id=\"水波纹效果\"><a href=\"#水波纹效果\" class=\"headerlink\" title=\"水波纹效果\"></a>水波纹效果</h3><p>其实水波纹也就是个视觉效果，本质上就是又画了个圆，只不过这个圆有点大，把整个屏幕都包含进去了，也就是说，整个屏幕本质上是这个圆的内切矩形，即屏幕的对角线是这个圆形的直径。</p>\n<p>这里需要注意的是，这个画的并不是个普通的圆，而是一个圆环。具体如图。</p>\n<pre><code class=\"java\">private void setMergeAnimation() {\n      // mExtendRadius = (int) Math.sqrt(Math.pow(mCenterX, 2) + Math.pow(mCenterX, 2));\n    // mExtendRadius 屏幕对角线的一半，即圆的半径\n    mValueAnimator = ObjectAnimator.ofFloat(0, mExtendRadius);\n    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);\n    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mCurrBigCircleRadius = (float) animation.getAnimatedValue();\n            invalidate();\n        }\n    });\n    mValueAnimator.start();\n}\n\npublic void draw(Canvas canvas) {\n        // mCurrBigCircleRadius 不停变大的半径值\n      // mExtendRadius - mCurrBigCircleRadius -&gt; 圆环的宽度\n    float strokeWidth = mExtendRadius - mCurrBigCircleRadius;\n    mPaint.setStrokeWidth(strokeWidth);\n    mPaint.setStyle(Paint.Style.STROKE); // 设置圆环\n    mPaint.setColor(Color.WHITE);\n        // 圆环真正的半径\n    float radius = strokeWidth / 2 + mCurrBigCircleRadius;\n    canvas.drawCircle(mCenterX, mCenterY, radius, mPaint);\n}\n\n</code></pre>\n<h3 id=\"ViewPager-滚动视差效果\"><a href=\"#ViewPager-滚动视差效果\" class=\"headerlink\" title=\"ViewPager 滚动视差效果\"></a>ViewPager 滚动视差效果</h3><p>动画结束，下面来简单介绍一下视差效果。个别控件可以跟随 ViewPager 滚动而变化，本来也可以直接监听 ViewPager 滚动，去遍历需要移动的控件来实现同样的效果，但是由于复用性、扩展性都比较差，这里使用自定义属性的方式来实现。<strong>这种方式的重点在于拦截系统 View 的创建，然后解析自定义的属性，从而实现想要的效果。</strong></p>\n<ul>\n<li>拦截View的创建</li>\n</ul>\n<p>需要使用 LayoutInflater 的 setFactory 方法，具体就不多做介绍了，不了解的自己去了解一下： <a href=\"https://blog.csdn.net/lmj623565791/article/details/51503977\" target=\"_blank\" rel=\"noopener\">Android 探究 LayoutInflater setFactory</a></p>\n<p>需要</p>\n<ul>\n<li><p>解析自定义属性</p>\n<p>我们为系统控件扩展了自定义属性，在 attrs 中声明：</p>\n<pre><code class=\"xml\">&lt;resources&gt;\n    &lt;!-- X方向上的位移 --&gt;\n    &lt;attr name=&quot;translationXIn&quot; format=&quot;float&quot; /&gt;\n    &lt;attr name=&quot;translationXOut&quot; format=&quot;float&quot; /&gt;\n    &lt;!-- Y方向上的位移 --&gt;\n    &lt;attr name=&quot;translationYIn&quot; format=&quot;float&quot; /&gt;\n    &lt;attr name=&quot;translationYOut&quot; format=&quot;float&quot; /&gt;\n&lt;/resources&gt;\n</code></pre>\n<p>然后我们拦截到系统的 View 后，尝试从中去解析这些自定义的 View；解析到对应的自定义属性后，通过给 View 设置 tag 的方式，将用户设置的信息进行保存：</p>\n<pre><code class=\"xml\">&lt;resources&gt;\n    &lt;item name=&quot;parallax_tag&quot; type=&quot;id&quot;/&gt;\n&lt;/resources&gt;\n</code></pre>\n<pre><code class=\"java\"> private int[] mParallaxAttrs = new int[]{\n            R.attr.translationXIn, R.attr.translationXOut,\n            R.attr.translationYIn, R.attr.translationYOut\n    };\n\nprivate void analysisAttrs(View view, Context context, AttributeSet attrs) {\n    TypedArray array = context.obtainStyledAttributes(attrs, mParallaxAttrs);\n\n    // 主动去解析自定义的几个属性，如果能够拿到，就去遍历解析\n    if (array != null &amp;&amp; array.getIndexCount() != 0) {\n\n        ParallaxTag parallaxTag = new ParallaxTag();\n        for (int i = 0; i &lt; array.getIndexCount(); i++) {\n\n            int arrayIndex = array.getIndex(i);\n\n            switch (arrayIndex) {\n                case 0:\n                    parallaxTag.setxIn(array.getFloat(arrayIndex, 0f));\n                    break;\n                case 1:\n                    parallaxTag.setxOut(array.getFloat(arrayIndex, 0f));\n                    break;\n                case 2:\n                    parallaxTag.setyIn(array.getFloat(arrayIndex, 0f));\n                    break;\n                case 3:\n                    parallaxTag.setyOut(array.getFloat(arrayIndex, 0f));\n                    break;\n            }\n\n            // 要紧的问题是，解析到了以后怎么存 -&gt; 给 View 设置 tag\n            view.setTag(R.id.parallax_tag, parallaxTag);\n\n            // 将准备操作的 View 放入集合中\n            mParallaxViews.add(view);\n        }\n\n        array.recycle();\n    }\n}\n</code></pre>\n</li>\n</ul>\n<p>以上动作在 ViewPager 关联的 Fragment 中实现，这样只需要在 ViewPager 的滑动监听中去取到当前 Fragment 的 View 集合，然后分别为左右两侧的 Fragment 设置进入和划出效果即可。</p>\n<pre><code class=\"java\">addOnPageChangeListener(new OnPageChangeListener() {\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n        // 同时设置左右两侧的 fragment，左边退出，右边进入\n        ParallaxFragment outFragment = mFragments.get(position);\n\n\n        List&lt;View&gt; outFragmentParallaxViews = outFragment.getParallaxViews();\n        for (View view : outFragmentParallaxViews) {\n            ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);\n            view.setTranslationX(( -positionOffsetPixels) * parallaxTag.getxOut());\n            view.setTranslationY(( -positionOffsetPixels) * parallaxTag.getyOut());\n        }\n\n        try {\n            ParallaxFragment inFragment = mFragments.get(position + 1);\n            outFragmentParallaxViews = inFragment.getParallaxViews();\n            for (View view : outFragmentParallaxViews) {\n                ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);\n                view.setTranslationX(\n                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getxIn());\n                view.setTranslationY(\n                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getyIn());\n            }\n        } catch (Exception e) {}\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n});\n</code></pre>\n<p>好啦，说到这里就差不多结束了，完结撒花~</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg","title":"Java 代理模式简单探讨","date":"2019-08-13T16:00:00.000Z","_content":"\n\n\n动态代理是 Hook 技术的基础技能，下一篇暂定 activity 的启动流程，这篇先来搞一下这个代理设计模式吧。\n\n<!-- more -->\n\n### 定义\n\n先上定义。\n\n> 代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。\n\n说实话我也看不太懂，但是说到代理，基本上往中介方向理解就差不多。\n\n房产中介，就是为租客提供一种服务，以帮助租客租到心仪的房子。一个租客不可能直接接触到租房市场上所有的房源，而中介可以在租客和房子中间起到协调的作用。\n\n哈哈，我可真他娘的是个人才，反正大概就这么个意思吧！\n\n\n\n#### 静态代理\n\n下边正经点儿，代理模式就是客户端不直接操作对象，而是由一个中间者（即代理），来对目标对象进行操作，从而间接地操纵或者增强目标对象。UML 类图我还没学会，直接上代码吧！\n\n```java\n\npublic interface IRentHouse{\n  void rentHouse();\n}\n\npublic class Couple implements IRentHouse{\n  \n  public void rentHouse(){\n    System.out.println(\"新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\");\n  }\n  \n}\n\npublic class RentAgent implements IRentHouse{\n\n  private IRentHouse mClient;\n  \n  public RentAgent(IRentHouse client){\n    mClient = client;\n  }\n  \n  public void rentHouse(){\n    System.out.println(\"联系房东，商谈价格\");\n    if(mClient != null){\n      \tmClient.rentHouse();\n    }\n    System.out.println(\"双周保洁，家电保修\");\n  }\n\n}\n\n```\n\n如上，客户不需要关心租房前后一系列繁琐的事，把这一切都委托给代理去做，自己只管付钱。在这个事例中，`RentAgent` 即为 `Couple` 的代理类，帮助 `Couple` 处理租房事宜，客户端即通过 `RentAgent` 间接操纵了 `Couple` 的动作。\n\n具体调用以及输入结果：\n\n```java\npublic static void main(String[] args) {\n\n  Couple couple = new Couple();\n  RentAgent rentAgent = new RentAgent(couple);\n  rentAgent.rentHouse();\n\n}\n```\n\n```java\n联系房东，商谈价格\n新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\n双周保洁，家电保修\n```\n\n以上就是静态代理。\n\n这种模式很简单，也很清晰，但是缺点也很明显，即代理类和主体类都需要实现接口，而且接口方法一旦发生变动，同时这一动作并非双方都需要的（比如说需要为房产中介提供一个和房东协商价格的方法，这个动作本身和租客并没有关系），那么代码可维护性会变得非常差。\n\n\n\n#### 动态代理\n\n在这种情况下，我们就需要了解一下动态代理。动态代理又称为 JDK 代理或者接口代理，其主要是利用 JDK API，从内存层面在运行时为目标接口动态地创建对象，从而实现对目标对象的代理功能，而不受接口方法变动的影响。\n\n虽然思路大致相同，但是动态代理与静态代理在实现上有本质的区别。静态代理需要显式地写出代理类，委托类，接口等，开发者需要在编译期就手动编码实现代理模式；而动态代理省略了创建代理类的过程，把这个工作交给 JDK 在运行时处理。很明显，这样的设计使得 **JDK 代理要求目标对象必须实现接口，否则无法使用动态代理**。\n\n废话不多说，还是直接看代码。\n\n动态代理的实现主要依靠几个类:\n\n- java.lang.reflect.Proxy\n\n  ```java\n  // Proxy 类静态方法，返回一个指定接口的代理类实例\n  // 方法传入 InvocationHandler 对象，代理类会拦截所有的执行方法，并通过该处理器自行处理\n  Object newProxyInstance(ClassLoader loader,\t\t // 指定当前目标对象使用类加载器\n                          Class<?>[] interfaces, // 目标对象实现的接口的类型\n                          InvocationHandler h\t\t // 自定义方法处理器\n                          ){}\n  ```\n\n- java.lang.reflect.InvocationHandler\n\n  ```java\n  // 代理类会拦截所有的方法，并经由此方法重新调用\n  // 代理类即可以在此进行自己的处理\n  Object invoke(Object proxy, Method method, Object[] args){}\n  ```\n\n下面我们使用动态代理机制，来实现一下我们之前的租房案例。\n\n```java\nclass RentInvocationHandler implements InvocationHandler {\n\n    private Object mClient;\n\n    public RentInvocationHandler(Object client) {\n        this.mClient = client;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        System.out.println(\"联系房东，商谈价格\");\n        Object invoke = method.invoke(mClient, args);\n        System.out.println(\"双周保洁，家电保修\");\n\n        return invoke;\n    }\n}\n```\n\n具体调用：\n\n```java\nCouple couple = new Couple();\n// 使用动态代理，办理租房业务\nIRentHouse rentProxy =(IRentHouse)Proxy.newProxyInstance(\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\tcouple.getClass().getClassLoader(),\n               \t\t\t\t\t\t\t\tcouple.getClass().getInterfaces(), \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\tnew RentInvocationHandler(couple));\nrentProxy.rentHouse(); // 代理执行方法\n```\n\n输入结果：\n\n```java\n联系房东，商谈价格\n新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\n双周保洁，家电保修\n```\n\n具体使用并不复杂，就不再多说，但是关于动态代理生成的代理类本身也有一些特点，下面大概罗列一下：\n\n1. 类修饰符\n\n   该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承\n\n2. 类名\n\n   格式是 “$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是 Proxy 内部对动态代理类做了缓存，如果以前生成过相应的对象，则会直接返回该对象而不是重新创建\n\n3. 继承关系\n\n   $Proxy0 extends Proxy implements InterfaceA, InterfaceB, InterfaceX\n\n动态代理避免了静态代理代码维护的缺点，动态生成代理类，较为灵活，但是缺点也比较明显：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。\n\n\n\n### Cglib 代理\n\n这个东西就很厉害了。前文说了，动态代理的缺点是要求目标对象必须实现接口，否则就无法实现动态代理。Cglib 就是为了解决这个问题出现的，使用cglib代理的对象则无需实现接口，达到代理类无侵入。\n\nCglib 在 Android 使用的不多，后端的同学可能更熟悉一些，Spring 框架就集成了这个库。\n\n使用cglib需要引入[cglib的jar包](https://repo1.maven.org/maven2/cglib/cglib/3.2.5/cglib-3.2.5.jar)，具体使用如下：\n\n```java\npublic class ProxyFactory implements MethodInterceptor{\n\n    private Object target;\t//维护一个目标对象\n    public ProxyFactory(Object target) {\n        this.target = target;\n    }\n    \n    //为目标对象生成代理对象\n    public Object getProxyInstance() {\n        //工具类\n        Enhancer en = new Enhancer();\n        //设置父类\n        en.setSuperclass(target.getClass());\n        //设置回调函数\n        en.setCallback(this);\n        //创建子类对象代理\n        return en.create();\n    }\n\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"开启事务\");\n        // 执行目标对象的方法\n        Object returnValue = method.invoke(target, args);\n        System.out.println(\"关闭事务\");\n        return returnValue;\n    }\n}\n```\n\n具体和动态代理大体相同，就不再赘述了。\n\n\n\n### 代理模式 vs 装饰模式\n\n熟悉装饰者模式的同学可能会有点儿头疼，因为代理模式感觉和装饰者模式一毛一样……反正都是定义个接口，包裹一下委托类，然后操作一下代理类，实际操作了委托类嘛！\n\n二者确实比较相似，从 UML 类图看都没有任何区别，代理类/装饰类与委托类都继承自同一个接口或者抽象类，然后代理类/装饰类包装委托类。\n\n- 装饰模式：能动态的新增或组合对象的行为\n\n  在不改变接口的前提下，动态扩展对象的功能\n\n- 代理模式：为其他对象提供一种代理以控制对这个对象的访问\n\n  在不改变接口的前提下，控制对象的访问\n\n装饰模式是“新增行为”，而代理模式是“控制访问”。关键就是我们如何判断是“新增行为”还是“控制访问”。\n\n具体举例来说，\n\n1. 网上很多封装了带上拉刷新下拉加载的 RecyclerView，实现方式就是装饰模式，一般都是定义一个 Wrapper 来包裹原 adapter 以及原 RecyclerView，在此基础上新增了「下拉刷新」、「上拉加载」的行为；\n\n2. Retrofit 的 create 方法就是动态代理的应用，不对接口做出任何新增行为，只是通过动态代理创建接口对象，控制对接口的访问；\n\n   ```java\n   public <T> T create(final Class<T> service) {\n       return (T) Proxy.newProxyInstance(\n         \t\t\t\t\t\tservice.getClassLoader(), \n         \t\t\t\t\t\tnew Class<?>[] { service }, \n         \t\t\t\t\t\tnew InvocationHandler() {}});\n   }\n   ```\n\n\n\n### 参考文献\n\n- [代理模式及Java实现动态代理](https://www.jianshu.com/p/6f6bb2f0ece9)\n\n- [Java 动态代理机制分析及扩展](https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/)\n\n- [Java代理(jdk静态代理、动态代理和cglib动态代理)](https://www.cnblogs.com/fillPv/p/5939277.html)\n\n- [Java三种代理模式：静态代理、动态代理和cglib代理](https://segmentfault.com/a/1190000011291179)\n\n- [Java的三种代理模式](https://segmentfault.com/a/1190000009235245)\n\n  \n\n","source":"_posts/java-proxy-pattern.md","raw":"---\n\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190415172255.jpg\ntitle: Java 代理模式简单探讨\ntags: [design-pattern]\ndate: 2019-08-14\n\n---\n\n\n\n动态代理是 Hook 技术的基础技能，下一篇暂定 activity 的启动流程，这篇先来搞一下这个代理设计模式吧。\n\n<!-- more -->\n\n### 定义\n\n先上定义。\n\n> 代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。\n\n说实话我也看不太懂，但是说到代理，基本上往中介方向理解就差不多。\n\n房产中介，就是为租客提供一种服务，以帮助租客租到心仪的房子。一个租客不可能直接接触到租房市场上所有的房源，而中介可以在租客和房子中间起到协调的作用。\n\n哈哈，我可真他娘的是个人才，反正大概就这么个意思吧！\n\n\n\n#### 静态代理\n\n下边正经点儿，代理模式就是客户端不直接操作对象，而是由一个中间者（即代理），来对目标对象进行操作，从而间接地操纵或者增强目标对象。UML 类图我还没学会，直接上代码吧！\n\n```java\n\npublic interface IRentHouse{\n  void rentHouse();\n}\n\npublic class Couple implements IRentHouse{\n  \n  public void rentHouse(){\n    System.out.println(\"新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\");\n  }\n  \n}\n\npublic class RentAgent implements IRentHouse{\n\n  private IRentHouse mClient;\n  \n  public RentAgent(IRentHouse client){\n    mClient = client;\n  }\n  \n  public void rentHouse(){\n    System.out.println(\"联系房东，商谈价格\");\n    if(mClient != null){\n      \tmClient.rentHouse();\n    }\n    System.out.println(\"双周保洁，家电保修\");\n  }\n\n}\n\n```\n\n如上，客户不需要关心租房前后一系列繁琐的事，把这一切都委托给代理去做，自己只管付钱。在这个事例中，`RentAgent` 即为 `Couple` 的代理类，帮助 `Couple` 处理租房事宜，客户端即通过 `RentAgent` 间接操纵了 `Couple` 的动作。\n\n具体调用以及输入结果：\n\n```java\npublic static void main(String[] args) {\n\n  Couple couple = new Couple();\n  RentAgent rentAgent = new RentAgent(couple);\n  rentAgent.rentHouse();\n\n}\n```\n\n```java\n联系房东，商谈价格\n新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\n双周保洁，家电保修\n```\n\n以上就是静态代理。\n\n这种模式很简单，也很清晰，但是缺点也很明显，即代理类和主体类都需要实现接口，而且接口方法一旦发生变动，同时这一动作并非双方都需要的（比如说需要为房产中介提供一个和房东协商价格的方法，这个动作本身和租客并没有关系），那么代码可维护性会变得非常差。\n\n\n\n#### 动态代理\n\n在这种情况下，我们就需要了解一下动态代理。动态代理又称为 JDK 代理或者接口代理，其主要是利用 JDK API，从内存层面在运行时为目标接口动态地创建对象，从而实现对目标对象的代理功能，而不受接口方法变动的影响。\n\n虽然思路大致相同，但是动态代理与静态代理在实现上有本质的区别。静态代理需要显式地写出代理类，委托类，接口等，开发者需要在编译期就手动编码实现代理模式；而动态代理省略了创建代理类的过程，把这个工作交给 JDK 在运行时处理。很明显，这样的设计使得 **JDK 代理要求目标对象必须实现接口，否则无法使用动态代理**。\n\n废话不多说，还是直接看代码。\n\n动态代理的实现主要依靠几个类:\n\n- java.lang.reflect.Proxy\n\n  ```java\n  // Proxy 类静态方法，返回一个指定接口的代理类实例\n  // 方法传入 InvocationHandler 对象，代理类会拦截所有的执行方法，并通过该处理器自行处理\n  Object newProxyInstance(ClassLoader loader,\t\t // 指定当前目标对象使用类加载器\n                          Class<?>[] interfaces, // 目标对象实现的接口的类型\n                          InvocationHandler h\t\t // 自定义方法处理器\n                          ){}\n  ```\n\n- java.lang.reflect.InvocationHandler\n\n  ```java\n  // 代理类会拦截所有的方法，并经由此方法重新调用\n  // 代理类即可以在此进行自己的处理\n  Object invoke(Object proxy, Method method, Object[] args){}\n  ```\n\n下面我们使用动态代理机制，来实现一下我们之前的租房案例。\n\n```java\nclass RentInvocationHandler implements InvocationHandler {\n\n    private Object mClient;\n\n    public RentInvocationHandler(Object client) {\n        this.mClient = client;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        System.out.println(\"联系房东，商谈价格\");\n        Object invoke = method.invoke(mClient, args);\n        System.out.println(\"双周保洁，家电保修\");\n\n        return invoke;\n    }\n}\n```\n\n具体调用：\n\n```java\nCouple couple = new Couple();\n// 使用动态代理，办理租房业务\nIRentHouse rentProxy =(IRentHouse)Proxy.newProxyInstance(\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\tcouple.getClass().getClassLoader(),\n               \t\t\t\t\t\t\t\tcouple.getClass().getInterfaces(), \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\tnew RentInvocationHandler(couple));\nrentProxy.rentHouse(); // 代理执行方法\n```\n\n输入结果：\n\n```java\n联系房东，商谈价格\n新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\n双周保洁，家电保修\n```\n\n具体使用并不复杂，就不再多说，但是关于动态代理生成的代理类本身也有一些特点，下面大概罗列一下：\n\n1. 类修饰符\n\n   该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承\n\n2. 类名\n\n   格式是 “$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是 Proxy 内部对动态代理类做了缓存，如果以前生成过相应的对象，则会直接返回该对象而不是重新创建\n\n3. 继承关系\n\n   $Proxy0 extends Proxy implements InterfaceA, InterfaceB, InterfaceX\n\n动态代理避免了静态代理代码维护的缺点，动态生成代理类，较为灵活，但是缺点也比较明显：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。\n\n\n\n### Cglib 代理\n\n这个东西就很厉害了。前文说了，动态代理的缺点是要求目标对象必须实现接口，否则就无法实现动态代理。Cglib 就是为了解决这个问题出现的，使用cglib代理的对象则无需实现接口，达到代理类无侵入。\n\nCglib 在 Android 使用的不多，后端的同学可能更熟悉一些，Spring 框架就集成了这个库。\n\n使用cglib需要引入[cglib的jar包](https://repo1.maven.org/maven2/cglib/cglib/3.2.5/cglib-3.2.5.jar)，具体使用如下：\n\n```java\npublic class ProxyFactory implements MethodInterceptor{\n\n    private Object target;\t//维护一个目标对象\n    public ProxyFactory(Object target) {\n        this.target = target;\n    }\n    \n    //为目标对象生成代理对象\n    public Object getProxyInstance() {\n        //工具类\n        Enhancer en = new Enhancer();\n        //设置父类\n        en.setSuperclass(target.getClass());\n        //设置回调函数\n        en.setCallback(this);\n        //创建子类对象代理\n        return en.create();\n    }\n\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"开启事务\");\n        // 执行目标对象的方法\n        Object returnValue = method.invoke(target, args);\n        System.out.println(\"关闭事务\");\n        return returnValue;\n    }\n}\n```\n\n具体和动态代理大体相同，就不再赘述了。\n\n\n\n### 代理模式 vs 装饰模式\n\n熟悉装饰者模式的同学可能会有点儿头疼，因为代理模式感觉和装饰者模式一毛一样……反正都是定义个接口，包裹一下委托类，然后操作一下代理类，实际操作了委托类嘛！\n\n二者确实比较相似，从 UML 类图看都没有任何区别，代理类/装饰类与委托类都继承自同一个接口或者抽象类，然后代理类/装饰类包装委托类。\n\n- 装饰模式：能动态的新增或组合对象的行为\n\n  在不改变接口的前提下，动态扩展对象的功能\n\n- 代理模式：为其他对象提供一种代理以控制对这个对象的访问\n\n  在不改变接口的前提下，控制对象的访问\n\n装饰模式是“新增行为”，而代理模式是“控制访问”。关键就是我们如何判断是“新增行为”还是“控制访问”。\n\n具体举例来说，\n\n1. 网上很多封装了带上拉刷新下拉加载的 RecyclerView，实现方式就是装饰模式，一般都是定义一个 Wrapper 来包裹原 adapter 以及原 RecyclerView，在此基础上新增了「下拉刷新」、「上拉加载」的行为；\n\n2. Retrofit 的 create 方法就是动态代理的应用，不对接口做出任何新增行为，只是通过动态代理创建接口对象，控制对接口的访问；\n\n   ```java\n   public <T> T create(final Class<T> service) {\n       return (T) Proxy.newProxyInstance(\n         \t\t\t\t\t\tservice.getClassLoader(), \n         \t\t\t\t\t\tnew Class<?>[] { service }, \n         \t\t\t\t\t\tnew InvocationHandler() {}});\n   }\n   ```\n\n\n\n### 参考文献\n\n- [代理模式及Java实现动态代理](https://www.jianshu.com/p/6f6bb2f0ece9)\n\n- [Java 动态代理机制分析及扩展](https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/)\n\n- [Java代理(jdk静态代理、动态代理和cglib动态代理)](https://www.cnblogs.com/fillPv/p/5939277.html)\n\n- [Java三种代理模式：静态代理、动态代理和cglib代理](https://segmentfault.com/a/1190000011291179)\n\n- [Java的三种代理模式](https://segmentfault.com/a/1190000009235245)\n\n  \n\n","slug":"java-proxy-pattern","published":1,"updated":"2019-08-14T09:15:19.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86dr001elh1p2e8klfdt","content":"<p>动态代理是 Hook 技术的基础技能，下一篇暂定 activity 的启动流程，这篇先来搞一下这个代理设计模式吧。</p>\n<a id=\"more\"></a>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>先上定义。</p>\n<blockquote>\n<p>代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>\n</blockquote>\n<p>说实话我也看不太懂，但是说到代理，基本上往中介方向理解就差不多。</p>\n<p>房产中介，就是为租客提供一种服务，以帮助租客租到心仪的房子。一个租客不可能直接接触到租房市场上所有的房源，而中介可以在租客和房子中间起到协调的作用。</p>\n<p>哈哈，我可真他娘的是个人才，反正大概就这么个意思吧！</p>\n<h4 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h4><p>下边正经点儿，代理模式就是客户端不直接操作对象，而是由一个中间者（即代理），来对目标对象进行操作，从而间接地操纵或者增强目标对象。UML 类图我还没学会，直接上代码吧！</p>\n<pre><code class=\"java\">\npublic interface IRentHouse{\n  void rentHouse();\n}\n\npublic class Couple implements IRentHouse{\n\n  public void rentHouse(){\n    System.out.println(&quot;新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！&quot;);\n  }\n\n}\n\npublic class RentAgent implements IRentHouse{\n\n  private IRentHouse mClient;\n\n  public RentAgent(IRentHouse client){\n    mClient = client;\n  }\n\n  public void rentHouse(){\n    System.out.println(&quot;联系房东，商谈价格&quot;);\n    if(mClient != null){\n          mClient.rentHouse();\n    }\n    System.out.println(&quot;双周保洁，家电保修&quot;);\n  }\n\n}\n\n</code></pre>\n<p>如上，客户不需要关心租房前后一系列繁琐的事，把这一切都委托给代理去做，自己只管付钱。在这个事例中，<code>RentAgent</code> 即为 <code>Couple</code> 的代理类，帮助 <code>Couple</code> 处理租房事宜，客户端即通过 <code>RentAgent</code> 间接操纵了 <code>Couple</code> 的动作。</p>\n<p>具体调用以及输入结果：</p>\n<pre><code class=\"java\">public static void main(String[] args) {\n\n  Couple couple = new Couple();\n  RentAgent rentAgent = new RentAgent(couple);\n  rentAgent.rentHouse();\n\n}\n</code></pre>\n<pre><code class=\"java\">联系房东，商谈价格\n新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\n双周保洁，家电保修\n</code></pre>\n<p>以上就是静态代理。</p>\n<p>这种模式很简单，也很清晰，但是缺点也很明显，即代理类和主体类都需要实现接口，而且接口方法一旦发生变动，同时这一动作并非双方都需要的（比如说需要为房产中介提供一个和房东协商价格的方法，这个动作本身和租客并没有关系），那么代码可维护性会变得非常差。</p>\n<h4 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h4><p>在这种情况下，我们就需要了解一下动态代理。动态代理又称为 JDK 代理或者接口代理，其主要是利用 JDK API，从内存层面在运行时为目标接口动态地创建对象，从而实现对目标对象的代理功能，而不受接口方法变动的影响。</p>\n<p>虽然思路大致相同，但是动态代理与静态代理在实现上有本质的区别。静态代理需要显式地写出代理类，委托类，接口等，开发者需要在编译期就手动编码实现代理模式；而动态代理省略了创建代理类的过程，把这个工作交给 JDK 在运行时处理。很明显，这样的设计使得 <strong>JDK 代理要求目标对象必须实现接口，否则无法使用动态代理</strong>。</p>\n<p>废话不多说，还是直接看代码。</p>\n<p>动态代理的实现主要依靠几个类:</p>\n<ul>\n<li><p>java.lang.reflect.Proxy</p>\n<pre><code class=\"java\">// Proxy 类静态方法，返回一个指定接口的代理类实例\n// 方法传入 InvocationHandler 对象，代理类会拦截所有的执行方法，并通过该处理器自行处理\nObject newProxyInstance(ClassLoader loader,         // 指定当前目标对象使用类加载器\n                        Class&lt;?&gt;[] interfaces, // 目标对象实现的接口的类型\n                        InvocationHandler h         // 自定义方法处理器\n                        ){}\n</code></pre>\n</li>\n<li><p>java.lang.reflect.InvocationHandler</p>\n<pre><code class=\"java\">// 代理类会拦截所有的方法，并经由此方法重新调用\n// 代理类即可以在此进行自己的处理\nObject invoke(Object proxy, Method method, Object[] args){}\n</code></pre>\n</li>\n</ul>\n<p>下面我们使用动态代理机制，来实现一下我们之前的租房案例。</p>\n<pre><code class=\"java\">class RentInvocationHandler implements InvocationHandler {\n\n    private Object mClient;\n\n    public RentInvocationHandler(Object client) {\n        this.mClient = client;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        System.out.println(&quot;联系房东，商谈价格&quot;);\n        Object invoke = method.invoke(mClient, args);\n        System.out.println(&quot;双周保洁，家电保修&quot;);\n\n        return invoke;\n    }\n}\n</code></pre>\n<p>具体调用：</p>\n<pre><code class=\"java\">Couple couple = new Couple();\n// 使用动态代理，办理租房业务\nIRentHouse rentProxy =(IRentHouse)Proxy.newProxyInstance(\n                                                          couple.getClass().getClassLoader(),\n                                               couple.getClass().getInterfaces(), \n                                                          new RentInvocationHandler(couple));\nrentProxy.rentHouse(); // 代理执行方法\n</code></pre>\n<p>输入结果：</p>\n<pre><code class=\"java\">联系房东，商谈价格\n新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\n双周保洁，家电保修\n</code></pre>\n<p>具体使用并不复杂，就不再多说，但是关于动态代理生成的代理类本身也有一些特点，下面大概罗列一下：</p>\n<ol>\n<li><p>类修饰符</p>\n<p>该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承</p>\n</li>\n<li><p>类名</p>\n<p>格式是 “$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是 Proxy 内部对动态代理类做了缓存，如果以前生成过相应的对象，则会直接返回该对象而不是重新创建</p>\n</li>\n<li><p>继承关系</p>\n<p>$Proxy0 extends Proxy implements InterfaceA, InterfaceB, InterfaceX</p>\n</li>\n</ol>\n<p>动态代理避免了静态代理代码维护的缺点，动态生成代理类，较为灵活，但是缺点也比较明显：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p>\n<h3 id=\"Cglib-代理\"><a href=\"#Cglib-代理\" class=\"headerlink\" title=\"Cglib 代理\"></a>Cglib 代理</h3><p>这个东西就很厉害了。前文说了，动态代理的缺点是要求目标对象必须实现接口，否则就无法实现动态代理。Cglib 就是为了解决这个问题出现的，使用cglib代理的对象则无需实现接口，达到代理类无侵入。</p>\n<p>Cglib 在 Android 使用的不多，后端的同学可能更熟悉一些，Spring 框架就集成了这个库。</p>\n<p>使用cglib需要引入<a href=\"https://repo1.maven.org/maven2/cglib/cglib/3.2.5/cglib-3.2.5.jar\" target=\"_blank\" rel=\"noopener\">cglib的jar包</a>，具体使用如下：</p>\n<pre><code class=\"java\">public class ProxyFactory implements MethodInterceptor{\n\n    private Object target;    //维护一个目标对象\n    public ProxyFactory(Object target) {\n        this.target = target;\n    }\n\n    //为目标对象生成代理对象\n    public Object getProxyInstance() {\n        //工具类\n        Enhancer en = new Enhancer();\n        //设置父类\n        en.setSuperclass(target.getClass());\n        //设置回调函数\n        en.setCallback(this);\n        //创建子类对象代理\n        return en.create();\n    }\n\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(&quot;开启事务&quot;);\n        // 执行目标对象的方法\n        Object returnValue = method.invoke(target, args);\n        System.out.println(&quot;关闭事务&quot;);\n        return returnValue;\n    }\n}\n</code></pre>\n<p>具体和动态代理大体相同，就不再赘述了。</p>\n<h3 id=\"代理模式-vs-装饰模式\"><a href=\"#代理模式-vs-装饰模式\" class=\"headerlink\" title=\"代理模式 vs 装饰模式\"></a>代理模式 vs 装饰模式</h3><p>熟悉装饰者模式的同学可能会有点儿头疼，因为代理模式感觉和装饰者模式一毛一样……反正都是定义个接口，包裹一下委托类，然后操作一下代理类，实际操作了委托类嘛！</p>\n<p>二者确实比较相似，从 UML 类图看都没有任何区别，代理类/装饰类与委托类都继承自同一个接口或者抽象类，然后代理类/装饰类包装委托类。</p>\n<ul>\n<li><p>装饰模式：能动态的新增或组合对象的行为</p>\n<p>在不改变接口的前提下，动态扩展对象的功能</p>\n</li>\n<li><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问</p>\n<p>在不改变接口的前提下，控制对象的访问</p>\n</li>\n</ul>\n<p>装饰模式是“新增行为”，而代理模式是“控制访问”。关键就是我们如何判断是“新增行为”还是“控制访问”。</p>\n<p>具体举例来说，</p>\n<ol>\n<li><p>网上很多封装了带上拉刷新下拉加载的 RecyclerView，实现方式就是装饰模式，一般都是定义一个 Wrapper 来包裹原 adapter 以及原 RecyclerView，在此基础上新增了「下拉刷新」、「上拉加载」的行为；</p>\n</li>\n<li><p>Retrofit 的 create 方法就是动态代理的应用，不对接口做出任何新增行为，只是通过动态代理创建接口对象，控制对接口的访问；</p>\n<pre><code class=\"java\">public &lt;T&gt; T create(final Class&lt;T&gt; service) {\n    return (T) Proxy.newProxyInstance(\n                              service.getClassLoader(), \n                              new Class&lt;?&gt;[] { service }, \n                              new InvocationHandler() {}});\n}\n</code></pre>\n</li>\n</ol>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><p><a href=\"https://www.jianshu.com/p/6f6bb2f0ece9\" target=\"_blank\" rel=\"noopener\">代理模式及Java实现动态代理</a></p>\n</li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/\" target=\"_blank\" rel=\"noopener\">Java 动态代理机制分析及扩展</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/fillPv/p/5939277.html\" target=\"_blank\" rel=\"noopener\">Java代理(jdk静态代理、动态代理和cglib动态代理)</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000011291179\" target=\"_blank\" rel=\"noopener\">Java三种代理模式：静态代理、动态代理和cglib代理</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009235245\" target=\"_blank\" rel=\"noopener\">Java的三种代理模式</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>动态代理是 Hook 技术的基础技能，下一篇暂定 activity 的启动流程，这篇先来搞一下这个代理设计模式吧。</p>","more":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>先上定义。</p>\n<blockquote>\n<p>代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>\n</blockquote>\n<p>说实话我也看不太懂，但是说到代理，基本上往中介方向理解就差不多。</p>\n<p>房产中介，就是为租客提供一种服务，以帮助租客租到心仪的房子。一个租客不可能直接接触到租房市场上所有的房源，而中介可以在租客和房子中间起到协调的作用。</p>\n<p>哈哈，我可真他娘的是个人才，反正大概就这么个意思吧！</p>\n<h4 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h4><p>下边正经点儿，代理模式就是客户端不直接操作对象，而是由一个中间者（即代理），来对目标对象进行操作，从而间接地操纵或者增强目标对象。UML 类图我还没学会，直接上代码吧！</p>\n<pre><code class=\"java\">\npublic interface IRentHouse{\n  void rentHouse();\n}\n\npublic class Couple implements IRentHouse{\n\n  public void rentHouse(){\n    System.out.println(&quot;新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！&quot;);\n  }\n\n}\n\npublic class RentAgent implements IRentHouse{\n\n  private IRentHouse mClient;\n\n  public RentAgent(IRentHouse client){\n    mClient = client;\n  }\n\n  public void rentHouse(){\n    System.out.println(&quot;联系房东，商谈价格&quot;);\n    if(mClient != null){\n          mClient.rentHouse();\n    }\n    System.out.println(&quot;双周保洁，家电保修&quot;);\n  }\n\n}\n\n</code></pre>\n<p>如上，客户不需要关心租房前后一系列繁琐的事，把这一切都委托给代理去做，自己只管付钱。在这个事例中，<code>RentAgent</code> 即为 <code>Couple</code> 的代理类，帮助 <code>Couple</code> 处理租房事宜，客户端即通过 <code>RentAgent</code> 间接操纵了 <code>Couple</code> 的动作。</p>\n<p>具体调用以及输入结果：</p>\n<pre><code class=\"java\">public static void main(String[] args) {\n\n  Couple couple = new Couple();\n  RentAgent rentAgent = new RentAgent(couple);\n  rentAgent.rentHouse();\n\n}\n</code></pre>\n<pre><code class=\"java\">联系房东，商谈价格\n新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\n双周保洁，家电保修\n</code></pre>\n<p>以上就是静态代理。</p>\n<p>这种模式很简单，也很清晰，但是缺点也很明显，即代理类和主体类都需要实现接口，而且接口方法一旦发生变动，同时这一动作并非双方都需要的（比如说需要为房产中介提供一个和房东协商价格的方法，这个动作本身和租客并没有关系），那么代码可维护性会变得非常差。</p>\n<h4 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h4><p>在这种情况下，我们就需要了解一下动态代理。动态代理又称为 JDK 代理或者接口代理，其主要是利用 JDK API，从内存层面在运行时为目标接口动态地创建对象，从而实现对目标对象的代理功能，而不受接口方法变动的影响。</p>\n<p>虽然思路大致相同，但是动态代理与静态代理在实现上有本质的区别。静态代理需要显式地写出代理类，委托类，接口等，开发者需要在编译期就手动编码实现代理模式；而动态代理省略了创建代理类的过程，把这个工作交给 JDK 在运行时处理。很明显，这样的设计使得 <strong>JDK 代理要求目标对象必须实现接口，否则无法使用动态代理</strong>。</p>\n<p>废话不多说，还是直接看代码。</p>\n<p>动态代理的实现主要依靠几个类:</p>\n<ul>\n<li><p>java.lang.reflect.Proxy</p>\n<pre><code class=\"java\">// Proxy 类静态方法，返回一个指定接口的代理类实例\n// 方法传入 InvocationHandler 对象，代理类会拦截所有的执行方法，并通过该处理器自行处理\nObject newProxyInstance(ClassLoader loader,         // 指定当前目标对象使用类加载器\n                        Class&lt;?&gt;[] interfaces, // 目标对象实现的接口的类型\n                        InvocationHandler h         // 自定义方法处理器\n                        ){}\n</code></pre>\n</li>\n<li><p>java.lang.reflect.InvocationHandler</p>\n<pre><code class=\"java\">// 代理类会拦截所有的方法，并经由此方法重新调用\n// 代理类即可以在此进行自己的处理\nObject invoke(Object proxy, Method method, Object[] args){}\n</code></pre>\n</li>\n</ul>\n<p>下面我们使用动态代理机制，来实现一下我们之前的租房案例。</p>\n<pre><code class=\"java\">class RentInvocationHandler implements InvocationHandler {\n\n    private Object mClient;\n\n    public RentInvocationHandler(Object client) {\n        this.mClient = client;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        System.out.println(&quot;联系房东，商谈价格&quot;);\n        Object invoke = method.invoke(mClient, args);\n        System.out.println(&quot;双周保洁，家电保修&quot;);\n\n        return invoke;\n    }\n}\n</code></pre>\n<p>具体调用：</p>\n<pre><code class=\"java\">Couple couple = new Couple();\n// 使用动态代理，办理租房业务\nIRentHouse rentProxy =(IRentHouse)Proxy.newProxyInstance(\n                                                          couple.getClass().getClassLoader(),\n                                               couple.getClass().getInterfaces(), \n                                                          new RentInvocationHandler(couple));\nrentProxy.rentHouse(); // 代理执行方法\n</code></pre>\n<p>输入结果：</p>\n<pre><code class=\"java\">联系房东，商谈价格\n新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！\n双周保洁，家电保修\n</code></pre>\n<p>具体使用并不复杂，就不再多说，但是关于动态代理生成的代理类本身也有一些特点，下面大概罗列一下：</p>\n<ol>\n<li><p>类修饰符</p>\n<p>该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承</p>\n</li>\n<li><p>类名</p>\n<p>格式是 “$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是 Proxy 内部对动态代理类做了缓存，如果以前生成过相应的对象，则会直接返回该对象而不是重新创建</p>\n</li>\n<li><p>继承关系</p>\n<p>$Proxy0 extends Proxy implements InterfaceA, InterfaceB, InterfaceX</p>\n</li>\n</ol>\n<p>动态代理避免了静态代理代码维护的缺点，动态生成代理类，较为灵活，但是缺点也比较明显：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p>\n<h3 id=\"Cglib-代理\"><a href=\"#Cglib-代理\" class=\"headerlink\" title=\"Cglib 代理\"></a>Cglib 代理</h3><p>这个东西就很厉害了。前文说了，动态代理的缺点是要求目标对象必须实现接口，否则就无法实现动态代理。Cglib 就是为了解决这个问题出现的，使用cglib代理的对象则无需实现接口，达到代理类无侵入。</p>\n<p>Cglib 在 Android 使用的不多，后端的同学可能更熟悉一些，Spring 框架就集成了这个库。</p>\n<p>使用cglib需要引入<a href=\"https://repo1.maven.org/maven2/cglib/cglib/3.2.5/cglib-3.2.5.jar\" target=\"_blank\" rel=\"noopener\">cglib的jar包</a>，具体使用如下：</p>\n<pre><code class=\"java\">public class ProxyFactory implements MethodInterceptor{\n\n    private Object target;    //维护一个目标对象\n    public ProxyFactory(Object target) {\n        this.target = target;\n    }\n\n    //为目标对象生成代理对象\n    public Object getProxyInstance() {\n        //工具类\n        Enhancer en = new Enhancer();\n        //设置父类\n        en.setSuperclass(target.getClass());\n        //设置回调函数\n        en.setCallback(this);\n        //创建子类对象代理\n        return en.create();\n    }\n\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(&quot;开启事务&quot;);\n        // 执行目标对象的方法\n        Object returnValue = method.invoke(target, args);\n        System.out.println(&quot;关闭事务&quot;);\n        return returnValue;\n    }\n}\n</code></pre>\n<p>具体和动态代理大体相同，就不再赘述了。</p>\n<h3 id=\"代理模式-vs-装饰模式\"><a href=\"#代理模式-vs-装饰模式\" class=\"headerlink\" title=\"代理模式 vs 装饰模式\"></a>代理模式 vs 装饰模式</h3><p>熟悉装饰者模式的同学可能会有点儿头疼，因为代理模式感觉和装饰者模式一毛一样……反正都是定义个接口，包裹一下委托类，然后操作一下代理类，实际操作了委托类嘛！</p>\n<p>二者确实比较相似，从 UML 类图看都没有任何区别，代理类/装饰类与委托类都继承自同一个接口或者抽象类，然后代理类/装饰类包装委托类。</p>\n<ul>\n<li><p>装饰模式：能动态的新增或组合对象的行为</p>\n<p>在不改变接口的前提下，动态扩展对象的功能</p>\n</li>\n<li><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问</p>\n<p>在不改变接口的前提下，控制对象的访问</p>\n</li>\n</ul>\n<p>装饰模式是“新增行为”，而代理模式是“控制访问”。关键就是我们如何判断是“新增行为”还是“控制访问”。</p>\n<p>具体举例来说，</p>\n<ol>\n<li><p>网上很多封装了带上拉刷新下拉加载的 RecyclerView，实现方式就是装饰模式，一般都是定义一个 Wrapper 来包裹原 adapter 以及原 RecyclerView，在此基础上新增了「下拉刷新」、「上拉加载」的行为；</p>\n</li>\n<li><p>Retrofit 的 create 方法就是动态代理的应用，不对接口做出任何新增行为，只是通过动态代理创建接口对象，控制对接口的访问；</p>\n<pre><code class=\"java\">public &lt;T&gt; T create(final Class&lt;T&gt; service) {\n    return (T) Proxy.newProxyInstance(\n                              service.getClassLoader(), \n                              new Class&lt;?&gt;[] { service }, \n                              new InvocationHandler() {}});\n}\n</code></pre>\n</li>\n</ol>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><p><a href=\"https://www.jianshu.com/p/6f6bb2f0ece9\" target=\"_blank\" rel=\"noopener\">代理模式及Java实现动态代理</a></p>\n</li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/\" target=\"_blank\" rel=\"noopener\">Java 动态代理机制分析及扩展</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/fillPv/p/5939277.html\" target=\"_blank\" rel=\"noopener\">Java代理(jdk静态代理、动态代理和cglib动态代理)</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000011291179\" target=\"_blank\" rel=\"noopener\">Java三种代理模式：静态代理、动态代理和cglib代理</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009235245\" target=\"_blank\" rel=\"noopener\">Java的三种代理模式</a></p>\n</li>\n</ul>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181407.jpg","title":"Context 到底是什么？","date":"2019-11-13T16:00:00.000Z","_content":"\nContext 是 Android API 中最糟糕的设计之一。\n\n\n\n<!-- more -->\n\n\n\n*本文为笔者整理 + [译文](https://www.freecodecamp.org/news/mastering-android-context-7055c8478a22/)。*\n\n我希望大家通过这篇文章能够对 Android Context 有一个更深的了解。Context 是 Android 开发中属于极为重要的核心概念，但并不是所有的开发者都了解应该怎么使用它。\n\n> 在开始之前，我们必须承认，Context 是 Android API 中最糟糕的设计之一。真正的 **God object** 。\n\n\n\n###写在开始\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20191114182421.png)\n\n在开始之前，我们先来看一下这张图。\n\n从图中我们可以发现，`Activity`、`Service`、`Application` 实际上都是 `Context` 的子类，它甚至可以说是整个 App 的灵魂。\n\n但是你在之前的开发中是否有过这样的疑虑：`getContext()\t`、`this`、`getBaseContext()`、 `getApplicationContext()` 之间有什么不同？如果你的回答是 yes，那这篇文章或许可以帮你理清一些思路。\n\n\n\n### Context 到底是什么？\n\n一个 Android APK 安装包实际上就是一个 Android 组件的集合包。这些组件一般都被开发者声明在 Manifest 文件中，绝大部分由 Activity(UI)，Service(Background)， BroadcastReceiver (Action), ContentProvider (Data), 以及 Resources (images, strings 等) 组成。\n\n开发者可以通过 IntentFilter 将某个组件暴露给系统，比如说发邮件或者分享图片；他们也可以选择只将某些组件暴露给自己应用中的其他组件。 \n\n同样地，Android 操作系统也是基于这个设计，这就使得它同样可以向外暴露自己的组件，较为常见的几个一般是 WifiManager，Vibrator 和 PackageManager。\n\nContext 就是这些组件之间链接的桥梁。你可以使用 Context 在不同组件间进行通信、初始化组件或者是获得某个组件对象。\n\n##### 1. 开发者自定义组件之间的交互\n\n这是比较常用的一个场景。我们使用 Context 实例化我们自己定义的组件，比如 Activity, Content Provider, BroadcastReceiver 等等。除此之外，我们还可以使用 Context 获取资源信息以及对文件系统进行操作等。\n\n##### 2. 自定义组件与系统组件的交互\n\nContext 可以理解成是 Android 系统的入口。一些比较常用的系统级组件都是通过 Context 获取其对象的。比如说，你可以使用 `context.getSystemService(Context.WIFI_SERVICE)`  来获取 WifiManager 对象。\n\n##### 3. 自定义组件与其他 App 的组件的交互\n\n实现这个的重点在于声明组件的时候，利用隐示意图，即 Intent-filter，将该组件尽可能地详尽化。下面是一个简单的发送邮件的隐示意图使用。\n\n```java\nIntent emailIntent = new Intent(android.content.Intent.ACTION_SEND);\nemailIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\nemailIntent.setType(\"vnd.android.cursor.item/email\");\nemailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, new String[]{address});\nemailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\nemailIntent.putExtra(android.content.Intent.EXTRA_TEXT, content);\n```\n\n上面代码的效果就是，手机上所有能够发送邮件的 App 会合并为一个弹窗展示给用户，用户自己可以自由选择。\n\n通过上面的介绍，我们基本可以达成一个共识，即**在 Android 世界中，所有的事物都可以理解成一个组件，而 Context 就是联系各个组件之间的纽带**。Context 可以帮助开发者在不同组件之间进行交互，可以获取系统级别的组件，还可以实例化某个组件。\n\n\n\n### Context 的几种类型\n\n你可以通过很多方式获得你想要的 Context 对象，**这是个极为糟糕的设计**。一般情况下，我们可以通过以下几种方式来获取 Context 对象。\n\n- 在 Activity 中调用 Application 实例对象\n\n- 在 Activity 中使用 this，即当前 Activity 的实例对象\n\n- 在 Activity 中调用 getApplicationContext() \n\n- 在 Activity 中调用 getBaseContext()\n\n- 在 Fragment 或者 View 中调用 getContext()\n\n- Broadcast Receiver 或者 Service 回调中获得的 Context 对象\n\n- 在 Service 中使用 this，即当前 Service 的实例对象\n\n- 在 Service 中调用 getApplicationContext() \n\n- 使用 Context 对象调用 getApplicationContext() \n\n我把所有这些 Context 类型划分为两类：UI Context 和 Non-UI Context。\n\n##### UI Context\n\n实际上，只有 ContextThemeWrapper 是 UI Context，就是 Context + 你的 Theme 主题。\n\n如果你去看看源码，你会发现 Activity 继承自 ContextThemeWrapper，这就是为什么你只是渲染了你的布局文件，但是展示出来的页面却有了你指定的主题。如果你使用一个 Non-UI Context 对布局文件进行渲染，你会发现你的布局没有主题。不信吗？自己去试试看。\n\n在这种情况下，当你使用 Activity 实例作为 Context 使用时，就意味着你使用的是 UI Context；你在 Fragment 里调用 getContext()  方法，你也是在间接地使用 Activity。当然，前提是你的 Fragment 是在 Activity 中，通过 FragmentManager 添加到页面中的。\n\n但是，*View.getContext() 却不能保证总是 UI Context*。\n\n如果你的 View 是通过 LayoutInflator 渲染，并且 LayoutInflator 接收的 Context 也是 UI Context，那你得到的 View 的 Context 就是 UI Context；但是你渲染布局的 Context 不是 UI Context，那你得到的也是 Non-UI Context。\n\n<u>*UI Context*</u>\n\n\n- 在 Activity 中使用 this，即当前 Activity 的实例对象\n- 在 Fragment 调用 getContext()\n- 在*使用 UI Context 渲染*的 View 中调用 getContext()\n\n##### Non-UI Context\n\n所有不是 UI Context 的都是 Non-UI Context。换句话说，只有继承自 ContextThemeWrapper 的才是 UI Context。\n\nNon-UI Context 基本上可以和 UI Context 完全划等号，可以做的事情完全一样，系统对 Non-UI Context 也没有任何限制。**再说一次，糟糕的设计。**但是像我们之前说的，如果你使用 Non-UI Context 去渲染布局，那你会丢失掉你的主题。\n\n<u>*Non-UI Context*</u>\n\n- 在 Activity 中调用 Application 实例对象\n- Broadcast Receiver 或者 Service 回调中获得的 Context 对象\n- 在 Service 中使用 this，即当前 Service 的实例对象\n- 在 Service 中调用 getApplicationContext() \n- 在 Activity 中调用 getApplicationContext() \n- 使用 Context 对象调用 getApplicationContext() \n\n通过上面的分析，我们已经把所有的 Context 分为了两类。概况来说，UI Context 就是 Context + Theme，只要 ContextThemeWrapper 的子类都属于这个集合；其他的 Context 全部都是 Non-UI Context。\n\n<u>需要注意的是，所有的 Context 都是在内存中短期存活的，只有 Application context 除外，也就是你通过 Application 实例充当的，或者通过调用 getApplicationContext() 方法拿到的 Context 对象。</u>\n\n\n\n### 应用场景\n\n##### 场景 1\n\n假设你使用一个 Non-UI Context 渲染了一个布局文件，会发生什么呢？答案是什么都不会发生，除了你的布局没有主题之外。好像还不错是吧？这种程度的错误可以容忍。\n\n##### 场景 2\n\n你不小心使用了 UI Context 去获取资源文件，或者去读取了一个文件，会出现什么问题？还是什么都不会发生。记住这点，UI Context = Contex + Theme。在这种场景下，Non-UI Context 会和 UI Context 不会带给你什么不同。\n\n##### 场景 3\n\n和场景 2 差不多，你使用 UI Context 去下载一个文件。很明显，这是个耗时操作，会发生什么问题呢？恭喜你，内存泄漏。\n\n假设你很幸运，下载速度很快，对象被正确回收，什么都没发生。太阳当空照，花儿对我笑。这也是大部分开发者常会犯的错误，他们把本应该短期存在的 UI Context 对象引用传递到某个会长期存活的任务重，但是最后也不会造成什么影响。\n\n但是事情不总是这么幸运。有时候 Android 系统会检查你某个组件的内存占用情况或者为其他需要更多内存的应用分配内存，然后等待你的就是内存溢出导致的应用崩溃。\n\n**再说一次，Context 的设计实在是太糟糕了。**\n\n这就是错误使用 Context 对象可能导致的最严重的情况。遇到困难跌倒并不可耻，可耻的是每次都在同一个地方跌倒。如果你每次写代码都会内存泄漏，但是每次都是不同原因，那么恭喜你，你在成长。\n\n使用 Context 的正确姿势：\n\n1. 如果你需要处理 UI 相关的业务，比如渲染布局或者展示一个弹窗，使用 UI Context；否则，使用 Non-UI Context；\n2. 涉及到耗时任务时，只使用 Application Context\n\n\n\n### 不同 Context 之间的区别是什么\n\n那么，this，getApplicationContext() 和 getBaseContext() 的区别是什么？\n\n我们知道在手机运行的过程中，很多因素都一直在变化。比如说一些配置项就是始终变化，不能确定的。所有的这些变化都会使得 App 需要不停地重建，从而确保当前展示给用户的是正确的配置，横竖屏、切换语言、切换主题等等。你的 App 需要获取到最匹配的资源文件来展示给用户他们想要的效果，这就是 Context 的工作。\n\n试着回答这个问题：\n\n用户将本地语言设置为英文，但是你要给用户展示德文，你怎么实现？\n\n下面是 Context 的一些 magic method：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20191114182356.png)\n\n我们可以看到 createConfigurationContext() 方法，来看看怎么使用：\n\n```java\npublic Context createConfigurationContext(Configuration overrideConfiguration){\n \tConfiguration configuration = getResources().getConfiguration();\n\tconfiguration.setLocale(your_custom_locale);\n\tcontext = createConfigurationContext(configuration);\n  return context;\n}\n```\n\n没错，通过这个方法，你可以获取任意自己想要的 Context 对象。当你使用这个新的 Context 对象时，你就能够拿到你配置的对应的资源信息。\n\n现在我们回到之前的问题，**this，getApplicationContext() 和 getBaseContext() 的区别是什么？**\n\n这是你在 Activity 中获取 Context 对象的几种方式。\n\n1. this 指代的是当前 Activity 自身，UI Context，*在内存中短期存活*的 context；\n\n2. baseContext 是最基本的 Context 对象，创建于 Application 创建时。之前我们介绍了 createConfigurationContext() 方法，你可以自定义自己的 Context 对象，然后通过 attachBaseContext() 方法，将原有的 Context 对象进行重置。\n\n   一旦重置 baseContext，之后 Activity 的 Context 引用都会指向新的 Context；如果你不是在 Activity 中重置的，那你还可以通过 getBaseContext() 来获取 Activity 对象；\n\n我们可以说，Context 就是 Android App 的灵魂，甚至说，你的 App 就是你的 Context。在 Android 开发中，没有 Context 你就什么都做不了；如果没有 Context，那你的 App 就只是一堆 Java 代码罢了。\n\n\n\n### Android = Context + Java code\n\n虽然我们吐槽了一次又一次 Context 的设计，但是系统设计如此，我们能做的也只是尽可能地去更好地使用它。\n\n通过文章的第一部分，我们知道了我们主要使用 Context 来进行不同组件间的交互，获取系统级组件。\n\n紧接着，我们知道了 Context 分为 UI Context 和 Non-UI Context，以及在内存中短期存活的和长期存活的 Context。\n\n在之后，我们学习到要谨慎选择使用 Context，否则轻则有 UI 显示问题，重则有内存泄漏甚至内存溢出的问题。\n\n最后，我们知道 Context 主要负责为 App 加载正确、合适的资源文件，也知道了怎么对 Context 进行自定义；还了解到了 this，applicationContext 和 baseContext 的区别。\n\n很多人可能会建议你一直使用 Application Context，一劳永逸；\n\n但我不这么想：不要因为害怕内存泄漏而始终使用 Application Context，你应该知道根本的原因，然后使用正确的 Context。","source":"_posts/what's the fuck is Context.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181407.jpg\ntitle: Context 到底是什么？\ntags: [Android]\ndate: 2019-11-14\n---\n\nContext 是 Android API 中最糟糕的设计之一。\n\n\n\n<!-- more -->\n\n\n\n*本文为笔者整理 + [译文](https://www.freecodecamp.org/news/mastering-android-context-7055c8478a22/)。*\n\n我希望大家通过这篇文章能够对 Android Context 有一个更深的了解。Context 是 Android 开发中属于极为重要的核心概念，但并不是所有的开发者都了解应该怎么使用它。\n\n> 在开始之前，我们必须承认，Context 是 Android API 中最糟糕的设计之一。真正的 **God object** 。\n\n\n\n###写在开始\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20191114182421.png)\n\n在开始之前，我们先来看一下这张图。\n\n从图中我们可以发现，`Activity`、`Service`、`Application` 实际上都是 `Context` 的子类，它甚至可以说是整个 App 的灵魂。\n\n但是你在之前的开发中是否有过这样的疑虑：`getContext()\t`、`this`、`getBaseContext()`、 `getApplicationContext()` 之间有什么不同？如果你的回答是 yes，那这篇文章或许可以帮你理清一些思路。\n\n\n\n### Context 到底是什么？\n\n一个 Android APK 安装包实际上就是一个 Android 组件的集合包。这些组件一般都被开发者声明在 Manifest 文件中，绝大部分由 Activity(UI)，Service(Background)， BroadcastReceiver (Action), ContentProvider (Data), 以及 Resources (images, strings 等) 组成。\n\n开发者可以通过 IntentFilter 将某个组件暴露给系统，比如说发邮件或者分享图片；他们也可以选择只将某些组件暴露给自己应用中的其他组件。 \n\n同样地，Android 操作系统也是基于这个设计，这就使得它同样可以向外暴露自己的组件，较为常见的几个一般是 WifiManager，Vibrator 和 PackageManager。\n\nContext 就是这些组件之间链接的桥梁。你可以使用 Context 在不同组件间进行通信、初始化组件或者是获得某个组件对象。\n\n##### 1. 开发者自定义组件之间的交互\n\n这是比较常用的一个场景。我们使用 Context 实例化我们自己定义的组件，比如 Activity, Content Provider, BroadcastReceiver 等等。除此之外，我们还可以使用 Context 获取资源信息以及对文件系统进行操作等。\n\n##### 2. 自定义组件与系统组件的交互\n\nContext 可以理解成是 Android 系统的入口。一些比较常用的系统级组件都是通过 Context 获取其对象的。比如说，你可以使用 `context.getSystemService(Context.WIFI_SERVICE)`  来获取 WifiManager 对象。\n\n##### 3. 自定义组件与其他 App 的组件的交互\n\n实现这个的重点在于声明组件的时候，利用隐示意图，即 Intent-filter，将该组件尽可能地详尽化。下面是一个简单的发送邮件的隐示意图使用。\n\n```java\nIntent emailIntent = new Intent(android.content.Intent.ACTION_SEND);\nemailIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\nemailIntent.setType(\"vnd.android.cursor.item/email\");\nemailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, new String[]{address});\nemailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\nemailIntent.putExtra(android.content.Intent.EXTRA_TEXT, content);\n```\n\n上面代码的效果就是，手机上所有能够发送邮件的 App 会合并为一个弹窗展示给用户，用户自己可以自由选择。\n\n通过上面的介绍，我们基本可以达成一个共识，即**在 Android 世界中，所有的事物都可以理解成一个组件，而 Context 就是联系各个组件之间的纽带**。Context 可以帮助开发者在不同组件之间进行交互，可以获取系统级别的组件，还可以实例化某个组件。\n\n\n\n### Context 的几种类型\n\n你可以通过很多方式获得你想要的 Context 对象，**这是个极为糟糕的设计**。一般情况下，我们可以通过以下几种方式来获取 Context 对象。\n\n- 在 Activity 中调用 Application 实例对象\n\n- 在 Activity 中使用 this，即当前 Activity 的实例对象\n\n- 在 Activity 中调用 getApplicationContext() \n\n- 在 Activity 中调用 getBaseContext()\n\n- 在 Fragment 或者 View 中调用 getContext()\n\n- Broadcast Receiver 或者 Service 回调中获得的 Context 对象\n\n- 在 Service 中使用 this，即当前 Service 的实例对象\n\n- 在 Service 中调用 getApplicationContext() \n\n- 使用 Context 对象调用 getApplicationContext() \n\n我把所有这些 Context 类型划分为两类：UI Context 和 Non-UI Context。\n\n##### UI Context\n\n实际上，只有 ContextThemeWrapper 是 UI Context，就是 Context + 你的 Theme 主题。\n\n如果你去看看源码，你会发现 Activity 继承自 ContextThemeWrapper，这就是为什么你只是渲染了你的布局文件，但是展示出来的页面却有了你指定的主题。如果你使用一个 Non-UI Context 对布局文件进行渲染，你会发现你的布局没有主题。不信吗？自己去试试看。\n\n在这种情况下，当你使用 Activity 实例作为 Context 使用时，就意味着你使用的是 UI Context；你在 Fragment 里调用 getContext()  方法，你也是在间接地使用 Activity。当然，前提是你的 Fragment 是在 Activity 中，通过 FragmentManager 添加到页面中的。\n\n但是，*View.getContext() 却不能保证总是 UI Context*。\n\n如果你的 View 是通过 LayoutInflator 渲染，并且 LayoutInflator 接收的 Context 也是 UI Context，那你得到的 View 的 Context 就是 UI Context；但是你渲染布局的 Context 不是 UI Context，那你得到的也是 Non-UI Context。\n\n<u>*UI Context*</u>\n\n\n- 在 Activity 中使用 this，即当前 Activity 的实例对象\n- 在 Fragment 调用 getContext()\n- 在*使用 UI Context 渲染*的 View 中调用 getContext()\n\n##### Non-UI Context\n\n所有不是 UI Context 的都是 Non-UI Context。换句话说，只有继承自 ContextThemeWrapper 的才是 UI Context。\n\nNon-UI Context 基本上可以和 UI Context 完全划等号，可以做的事情完全一样，系统对 Non-UI Context 也没有任何限制。**再说一次，糟糕的设计。**但是像我们之前说的，如果你使用 Non-UI Context 去渲染布局，那你会丢失掉你的主题。\n\n<u>*Non-UI Context*</u>\n\n- 在 Activity 中调用 Application 实例对象\n- Broadcast Receiver 或者 Service 回调中获得的 Context 对象\n- 在 Service 中使用 this，即当前 Service 的实例对象\n- 在 Service 中调用 getApplicationContext() \n- 在 Activity 中调用 getApplicationContext() \n- 使用 Context 对象调用 getApplicationContext() \n\n通过上面的分析，我们已经把所有的 Context 分为了两类。概况来说，UI Context 就是 Context + Theme，只要 ContextThemeWrapper 的子类都属于这个集合；其他的 Context 全部都是 Non-UI Context。\n\n<u>需要注意的是，所有的 Context 都是在内存中短期存活的，只有 Application context 除外，也就是你通过 Application 实例充当的，或者通过调用 getApplicationContext() 方法拿到的 Context 对象。</u>\n\n\n\n### 应用场景\n\n##### 场景 1\n\n假设你使用一个 Non-UI Context 渲染了一个布局文件，会发生什么呢？答案是什么都不会发生，除了你的布局没有主题之外。好像还不错是吧？这种程度的错误可以容忍。\n\n##### 场景 2\n\n你不小心使用了 UI Context 去获取资源文件，或者去读取了一个文件，会出现什么问题？还是什么都不会发生。记住这点，UI Context = Contex + Theme。在这种场景下，Non-UI Context 会和 UI Context 不会带给你什么不同。\n\n##### 场景 3\n\n和场景 2 差不多，你使用 UI Context 去下载一个文件。很明显，这是个耗时操作，会发生什么问题呢？恭喜你，内存泄漏。\n\n假设你很幸运，下载速度很快，对象被正确回收，什么都没发生。太阳当空照，花儿对我笑。这也是大部分开发者常会犯的错误，他们把本应该短期存在的 UI Context 对象引用传递到某个会长期存活的任务重，但是最后也不会造成什么影响。\n\n但是事情不总是这么幸运。有时候 Android 系统会检查你某个组件的内存占用情况或者为其他需要更多内存的应用分配内存，然后等待你的就是内存溢出导致的应用崩溃。\n\n**再说一次，Context 的设计实在是太糟糕了。**\n\n这就是错误使用 Context 对象可能导致的最严重的情况。遇到困难跌倒并不可耻，可耻的是每次都在同一个地方跌倒。如果你每次写代码都会内存泄漏，但是每次都是不同原因，那么恭喜你，你在成长。\n\n使用 Context 的正确姿势：\n\n1. 如果你需要处理 UI 相关的业务，比如渲染布局或者展示一个弹窗，使用 UI Context；否则，使用 Non-UI Context；\n2. 涉及到耗时任务时，只使用 Application Context\n\n\n\n### 不同 Context 之间的区别是什么\n\n那么，this，getApplicationContext() 和 getBaseContext() 的区别是什么？\n\n我们知道在手机运行的过程中，很多因素都一直在变化。比如说一些配置项就是始终变化，不能确定的。所有的这些变化都会使得 App 需要不停地重建，从而确保当前展示给用户的是正确的配置，横竖屏、切换语言、切换主题等等。你的 App 需要获取到最匹配的资源文件来展示给用户他们想要的效果，这就是 Context 的工作。\n\n试着回答这个问题：\n\n用户将本地语言设置为英文，但是你要给用户展示德文，你怎么实现？\n\n下面是 Context 的一些 magic method：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20191114182356.png)\n\n我们可以看到 createConfigurationContext() 方法，来看看怎么使用：\n\n```java\npublic Context createConfigurationContext(Configuration overrideConfiguration){\n \tConfiguration configuration = getResources().getConfiguration();\n\tconfiguration.setLocale(your_custom_locale);\n\tcontext = createConfigurationContext(configuration);\n  return context;\n}\n```\n\n没错，通过这个方法，你可以获取任意自己想要的 Context 对象。当你使用这个新的 Context 对象时，你就能够拿到你配置的对应的资源信息。\n\n现在我们回到之前的问题，**this，getApplicationContext() 和 getBaseContext() 的区别是什么？**\n\n这是你在 Activity 中获取 Context 对象的几种方式。\n\n1. this 指代的是当前 Activity 自身，UI Context，*在内存中短期存活*的 context；\n\n2. baseContext 是最基本的 Context 对象，创建于 Application 创建时。之前我们介绍了 createConfigurationContext() 方法，你可以自定义自己的 Context 对象，然后通过 attachBaseContext() 方法，将原有的 Context 对象进行重置。\n\n   一旦重置 baseContext，之后 Activity 的 Context 引用都会指向新的 Context；如果你不是在 Activity 中重置的，那你还可以通过 getBaseContext() 来获取 Activity 对象；\n\n我们可以说，Context 就是 Android App 的灵魂，甚至说，你的 App 就是你的 Context。在 Android 开发中，没有 Context 你就什么都做不了；如果没有 Context，那你的 App 就只是一堆 Java 代码罢了。\n\n\n\n### Android = Context + Java code\n\n虽然我们吐槽了一次又一次 Context 的设计，但是系统设计如此，我们能做的也只是尽可能地去更好地使用它。\n\n通过文章的第一部分，我们知道了我们主要使用 Context 来进行不同组件间的交互，获取系统级组件。\n\n紧接着，我们知道了 Context 分为 UI Context 和 Non-UI Context，以及在内存中短期存活的和长期存活的 Context。\n\n在之后，我们学习到要谨慎选择使用 Context，否则轻则有 UI 显示问题，重则有内存泄漏甚至内存溢出的问题。\n\n最后，我们知道 Context 主要负责为 App 加载正确、合适的资源文件，也知道了怎么对 Context 进行自定义；还了解到了 this，applicationContext 和 baseContext 的区别。\n\n很多人可能会建议你一直使用 Application Context，一劳永逸；\n\n但我不这么想：不要因为害怕内存泄漏而始终使用 Application Context，你应该知道根本的原因，然后使用正确的 Context。","slug":"what's the fuck is Context","published":1,"updated":"2019-11-14T10:44:32.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86dt001hlh1p7ddmr0qu","content":"<p>Context 是 Android API 中最糟糕的设计之一。</p>\n<a id=\"more\"></a>\n<p><em>本文为笔者整理 + <a href=\"https://www.freecodecamp.org/news/mastering-android-context-7055c8478a22/\" target=\"_blank\" rel=\"noopener\">译文</a>。</em></p>\n<p>我希望大家通过这篇文章能够对 Android Context 有一个更深的了解。Context 是 Android 开发中属于极为重要的核心概念，但并不是所有的开发者都了解应该怎么使用它。</p>\n<blockquote>\n<p>在开始之前，我们必须承认，Context 是 Android API 中最糟糕的设计之一。真正的 <strong>God object</strong> 。</p>\n</blockquote>\n<p>###写在开始</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20191114182421.png\" alt=\"\"></p>\n<p>在开始之前，我们先来看一下这张图。</p>\n<p>从图中我们可以发现，<code>Activity</code>、<code>Service</code>、<code>Application</code> 实际上都是 <code>Context</code> 的子类，它甚至可以说是整个 App 的灵魂。</p>\n<p>但是你在之前的开发中是否有过这样的疑虑：<code>getContext()</code>、<code>this</code>、<code>getBaseContext()</code>、 <code>getApplicationContext()</code> 之间有什么不同？如果你的回答是 yes，那这篇文章或许可以帮你理清一些思路。</p>\n<h3 id=\"Context-到底是什么？\"><a href=\"#Context-到底是什么？\" class=\"headerlink\" title=\"Context 到底是什么？\"></a>Context 到底是什么？</h3><p>一个 Android APK 安装包实际上就是一个 Android 组件的集合包。这些组件一般都被开发者声明在 Manifest 文件中，绝大部分由 Activity(UI)，Service(Background)， BroadcastReceiver (Action), ContentProvider (Data), 以及 Resources (images, strings 等) 组成。</p>\n<p>开发者可以通过 IntentFilter 将某个组件暴露给系统，比如说发邮件或者分享图片；他们也可以选择只将某些组件暴露给自己应用中的其他组件。 </p>\n<p>同样地，Android 操作系统也是基于这个设计，这就使得它同样可以向外暴露自己的组件，较为常见的几个一般是 WifiManager，Vibrator 和 PackageManager。</p>\n<p>Context 就是这些组件之间链接的桥梁。你可以使用 Context 在不同组件间进行通信、初始化组件或者是获得某个组件对象。</p>\n<h5 id=\"1-开发者自定义组件之间的交互\"><a href=\"#1-开发者自定义组件之间的交互\" class=\"headerlink\" title=\"1. 开发者自定义组件之间的交互\"></a>1. 开发者自定义组件之间的交互</h5><p>这是比较常用的一个场景。我们使用 Context 实例化我们自己定义的组件，比如 Activity, Content Provider, BroadcastReceiver 等等。除此之外，我们还可以使用 Context 获取资源信息以及对文件系统进行操作等。</p>\n<h5 id=\"2-自定义组件与系统组件的交互\"><a href=\"#2-自定义组件与系统组件的交互\" class=\"headerlink\" title=\"2. 自定义组件与系统组件的交互\"></a>2. 自定义组件与系统组件的交互</h5><p>Context 可以理解成是 Android 系统的入口。一些比较常用的系统级组件都是通过 Context 获取其对象的。比如说，你可以使用 <code>context.getSystemService(Context.WIFI_SERVICE)</code>  来获取 WifiManager 对象。</p>\n<h5 id=\"3-自定义组件与其他-App-的组件的交互\"><a href=\"#3-自定义组件与其他-App-的组件的交互\" class=\"headerlink\" title=\"3. 自定义组件与其他 App 的组件的交互\"></a>3. 自定义组件与其他 App 的组件的交互</h5><p>实现这个的重点在于声明组件的时候，利用隐示意图，即 Intent-filter，将该组件尽可能地详尽化。下面是一个简单的发送邮件的隐示意图使用。</p>\n<pre><code class=\"java\">Intent emailIntent = new Intent(android.content.Intent.ACTION_SEND);\nemailIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\nemailIntent.setType(&quot;vnd.android.cursor.item/email&quot;);\nemailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, new String[]{address});\nemailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\nemailIntent.putExtra(android.content.Intent.EXTRA_TEXT, content);\n</code></pre>\n<p>上面代码的效果就是，手机上所有能够发送邮件的 App 会合并为一个弹窗展示给用户，用户自己可以自由选择。</p>\n<p>通过上面的介绍，我们基本可以达成一个共识，即<strong>在 Android 世界中，所有的事物都可以理解成一个组件，而 Context 就是联系各个组件之间的纽带</strong>。Context 可以帮助开发者在不同组件之间进行交互，可以获取系统级别的组件，还可以实例化某个组件。</p>\n<h3 id=\"Context-的几种类型\"><a href=\"#Context-的几种类型\" class=\"headerlink\" title=\"Context 的几种类型\"></a>Context 的几种类型</h3><p>你可以通过很多方式获得你想要的 Context 对象，<strong>这是个极为糟糕的设计</strong>。一般情况下，我们可以通过以下几种方式来获取 Context 对象。</p>\n<ul>\n<li><p>在 Activity 中调用 Application 实例对象</p>\n</li>\n<li><p>在 Activity 中使用 this，即当前 Activity 的实例对象</p>\n</li>\n<li><p>在 Activity 中调用 getApplicationContext() </p>\n</li>\n<li><p>在 Activity 中调用 getBaseContext()</p>\n</li>\n<li><p>在 Fragment 或者 View 中调用 getContext()</p>\n</li>\n<li><p>Broadcast Receiver 或者 Service 回调中获得的 Context 对象</p>\n</li>\n<li><p>在 Service 中使用 this，即当前 Service 的实例对象</p>\n</li>\n<li><p>在 Service 中调用 getApplicationContext() </p>\n</li>\n<li><p>使用 Context 对象调用 getApplicationContext() </p>\n</li>\n</ul>\n<p>我把所有这些 Context 类型划分为两类：UI Context 和 Non-UI Context。</p>\n<h5 id=\"UI-Context\"><a href=\"#UI-Context\" class=\"headerlink\" title=\"UI Context\"></a>UI Context</h5><p>实际上，只有 ContextThemeWrapper 是 UI Context，就是 Context + 你的 Theme 主题。</p>\n<p>如果你去看看源码，你会发现 Activity 继承自 ContextThemeWrapper，这就是为什么你只是渲染了你的布局文件，但是展示出来的页面却有了你指定的主题。如果你使用一个 Non-UI Context 对布局文件进行渲染，你会发现你的布局没有主题。不信吗？自己去试试看。</p>\n<p>在这种情况下，当你使用 Activity 实例作为 Context 使用时，就意味着你使用的是 UI Context；你在 Fragment 里调用 getContext()  方法，你也是在间接地使用 Activity。当然，前提是你的 Fragment 是在 Activity 中，通过 FragmentManager 添加到页面中的。</p>\n<p>但是，<em>View.getContext() 却不能保证总是 UI Context</em>。</p>\n<p>如果你的 View 是通过 LayoutInflator 渲染，并且 LayoutInflator 接收的 Context 也是 UI Context，那你得到的 View 的 Context 就是 UI Context；但是你渲染布局的 Context 不是 UI Context，那你得到的也是 Non-UI Context。</p>\n<p><u><em>UI Context</em></u></p>\n<ul>\n<li>在 Activity 中使用 this，即当前 Activity 的实例对象</li>\n<li>在 Fragment 调用 getContext()</li>\n<li>在<em>使用 UI Context 渲染</em>的 View 中调用 getContext()</li>\n</ul>\n<h5 id=\"Non-UI-Context\"><a href=\"#Non-UI-Context\" class=\"headerlink\" title=\"Non-UI Context\"></a>Non-UI Context</h5><p>所有不是 UI Context 的都是 Non-UI Context。换句话说，只有继承自 ContextThemeWrapper 的才是 UI Context。</p>\n<p>Non-UI Context 基本上可以和 UI Context 完全划等号，可以做的事情完全一样，系统对 Non-UI Context 也没有任何限制。<strong>再说一次，糟糕的设计。</strong>但是像我们之前说的，如果你使用 Non-UI Context 去渲染布局，那你会丢失掉你的主题。</p>\n<p><u><em>Non-UI Context</em></u></p>\n<ul>\n<li>在 Activity 中调用 Application 实例对象</li>\n<li>Broadcast Receiver 或者 Service 回调中获得的 Context 对象</li>\n<li>在 Service 中使用 this，即当前 Service 的实例对象</li>\n<li>在 Service 中调用 getApplicationContext() </li>\n<li>在 Activity 中调用 getApplicationContext() </li>\n<li>使用 Context 对象调用 getApplicationContext() </li>\n</ul>\n<p>通过上面的分析，我们已经把所有的 Context 分为了两类。概况来说，UI Context 就是 Context + Theme，只要 ContextThemeWrapper 的子类都属于这个集合；其他的 Context 全部都是 Non-UI Context。</p>\n<p><u>需要注意的是，所有的 Context 都是在内存中短期存活的，只有 Application context 除外，也就是你通过 Application 实例充当的，或者通过调用 getApplicationContext() 方法拿到的 Context 对象。</u></p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h5 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景 1\"></a>场景 1</h5><p>假设你使用一个 Non-UI Context 渲染了一个布局文件，会发生什么呢？答案是什么都不会发生，除了你的布局没有主题之外。好像还不错是吧？这种程度的错误可以容忍。</p>\n<h5 id=\"场景-2\"><a href=\"#场景-2\" class=\"headerlink\" title=\"场景 2\"></a>场景 2</h5><p>你不小心使用了 UI Context 去获取资源文件，或者去读取了一个文件，会出现什么问题？还是什么都不会发生。记住这点，UI Context = Contex + Theme。在这种场景下，Non-UI Context 会和 UI Context 不会带给你什么不同。</p>\n<h5 id=\"场景-3\"><a href=\"#场景-3\" class=\"headerlink\" title=\"场景 3\"></a>场景 3</h5><p>和场景 2 差不多，你使用 UI Context 去下载一个文件。很明显，这是个耗时操作，会发生什么问题呢？恭喜你，内存泄漏。</p>\n<p>假设你很幸运，下载速度很快，对象被正确回收，什么都没发生。太阳当空照，花儿对我笑。这也是大部分开发者常会犯的错误，他们把本应该短期存在的 UI Context 对象引用传递到某个会长期存活的任务重，但是最后也不会造成什么影响。</p>\n<p>但是事情不总是这么幸运。有时候 Android 系统会检查你某个组件的内存占用情况或者为其他需要更多内存的应用分配内存，然后等待你的就是内存溢出导致的应用崩溃。</p>\n<p><strong>再说一次，Context 的设计实在是太糟糕了。</strong></p>\n<p>这就是错误使用 Context 对象可能导致的最严重的情况。遇到困难跌倒并不可耻，可耻的是每次都在同一个地方跌倒。如果你每次写代码都会内存泄漏，但是每次都是不同原因，那么恭喜你，你在成长。</p>\n<p>使用 Context 的正确姿势：</p>\n<ol>\n<li>如果你需要处理 UI 相关的业务，比如渲染布局或者展示一个弹窗，使用 UI Context；否则，使用 Non-UI Context；</li>\n<li>涉及到耗时任务时，只使用 Application Context</li>\n</ol>\n<h3 id=\"不同-Context-之间的区别是什么\"><a href=\"#不同-Context-之间的区别是什么\" class=\"headerlink\" title=\"不同 Context 之间的区别是什么\"></a>不同 Context 之间的区别是什么</h3><p>那么，this，getApplicationContext() 和 getBaseContext() 的区别是什么？</p>\n<p>我们知道在手机运行的过程中，很多因素都一直在变化。比如说一些配置项就是始终变化，不能确定的。所有的这些变化都会使得 App 需要不停地重建，从而确保当前展示给用户的是正确的配置，横竖屏、切换语言、切换主题等等。你的 App 需要获取到最匹配的资源文件来展示给用户他们想要的效果，这就是 Context 的工作。</p>\n<p>试着回答这个问题：</p>\n<p>用户将本地语言设置为英文，但是你要给用户展示德文，你怎么实现？</p>\n<p>下面是 Context 的一些 magic method：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20191114182356.png\" alt=\"\"></p>\n<p>我们可以看到 createConfigurationContext() 方法，来看看怎么使用：</p>\n<pre><code class=\"java\">public Context createConfigurationContext(Configuration overrideConfiguration){\n     Configuration configuration = getResources().getConfiguration();\n    configuration.setLocale(your_custom_locale);\n    context = createConfigurationContext(configuration);\n  return context;\n}\n</code></pre>\n<p>没错，通过这个方法，你可以获取任意自己想要的 Context 对象。当你使用这个新的 Context 对象时，你就能够拿到你配置的对应的资源信息。</p>\n<p>现在我们回到之前的问题，<strong>this，getApplicationContext() 和 getBaseContext() 的区别是什么？</strong></p>\n<p>这是你在 Activity 中获取 Context 对象的几种方式。</p>\n<ol>\n<li><p>this 指代的是当前 Activity 自身，UI Context，<em>在内存中短期存活</em>的 context；</p>\n</li>\n<li><p>baseContext 是最基本的 Context 对象，创建于 Application 创建时。之前我们介绍了 createConfigurationContext() 方法，你可以自定义自己的 Context 对象，然后通过 attachBaseContext() 方法，将原有的 Context 对象进行重置。</p>\n<p>一旦重置 baseContext，之后 Activity 的 Context 引用都会指向新的 Context；如果你不是在 Activity 中重置的，那你还可以通过 getBaseContext() 来获取 Activity 对象；</p>\n</li>\n</ol>\n<p>我们可以说，Context 就是 Android App 的灵魂，甚至说，你的 App 就是你的 Context。在 Android 开发中，没有 Context 你就什么都做不了；如果没有 Context，那你的 App 就只是一堆 Java 代码罢了。</p>\n<h3 id=\"Android-Context-Java-code\"><a href=\"#Android-Context-Java-code\" class=\"headerlink\" title=\"Android = Context + Java code\"></a>Android = Context + Java code</h3><p>虽然我们吐槽了一次又一次 Context 的设计，但是系统设计如此，我们能做的也只是尽可能地去更好地使用它。</p>\n<p>通过文章的第一部分，我们知道了我们主要使用 Context 来进行不同组件间的交互，获取系统级组件。</p>\n<p>紧接着，我们知道了 Context 分为 UI Context 和 Non-UI Context，以及在内存中短期存活的和长期存活的 Context。</p>\n<p>在之后，我们学习到要谨慎选择使用 Context，否则轻则有 UI 显示问题，重则有内存泄漏甚至内存溢出的问题。</p>\n<p>最后，我们知道 Context 主要负责为 App 加载正确、合适的资源文件，也知道了怎么对 Context 进行自定义；还了解到了 this，applicationContext 和 baseContext 的区别。</p>\n<p>很多人可能会建议你一直使用 Application Context，一劳永逸；</p>\n<p>但我不这么想：不要因为害怕内存泄漏而始终使用 Application Context，你应该知道根本的原因，然后使用正确的 Context。</p>\n","site":{"data":{}},"excerpt":"<p>Context 是 Android API 中最糟糕的设计之一。</p>","more":"<p><em>本文为笔者整理 + <a href=\"https://www.freecodecamp.org/news/mastering-android-context-7055c8478a22/\" target=\"_blank\" rel=\"noopener\">译文</a>。</em></p>\n<p>我希望大家通过这篇文章能够对 Android Context 有一个更深的了解。Context 是 Android 开发中属于极为重要的核心概念，但并不是所有的开发者都了解应该怎么使用它。</p>\n<blockquote>\n<p>在开始之前，我们必须承认，Context 是 Android API 中最糟糕的设计之一。真正的 <strong>God object</strong> 。</p>\n</blockquote>\n<p>###写在开始</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20191114182421.png\" alt=\"\"></p>\n<p>在开始之前，我们先来看一下这张图。</p>\n<p>从图中我们可以发现，<code>Activity</code>、<code>Service</code>、<code>Application</code> 实际上都是 <code>Context</code> 的子类，它甚至可以说是整个 App 的灵魂。</p>\n<p>但是你在之前的开发中是否有过这样的疑虑：<code>getContext()</code>、<code>this</code>、<code>getBaseContext()</code>、 <code>getApplicationContext()</code> 之间有什么不同？如果你的回答是 yes，那这篇文章或许可以帮你理清一些思路。</p>\n<h3 id=\"Context-到底是什么？\"><a href=\"#Context-到底是什么？\" class=\"headerlink\" title=\"Context 到底是什么？\"></a>Context 到底是什么？</h3><p>一个 Android APK 安装包实际上就是一个 Android 组件的集合包。这些组件一般都被开发者声明在 Manifest 文件中，绝大部分由 Activity(UI)，Service(Background)， BroadcastReceiver (Action), ContentProvider (Data), 以及 Resources (images, strings 等) 组成。</p>\n<p>开发者可以通过 IntentFilter 将某个组件暴露给系统，比如说发邮件或者分享图片；他们也可以选择只将某些组件暴露给自己应用中的其他组件。 </p>\n<p>同样地，Android 操作系统也是基于这个设计，这就使得它同样可以向外暴露自己的组件，较为常见的几个一般是 WifiManager，Vibrator 和 PackageManager。</p>\n<p>Context 就是这些组件之间链接的桥梁。你可以使用 Context 在不同组件间进行通信、初始化组件或者是获得某个组件对象。</p>\n<h5 id=\"1-开发者自定义组件之间的交互\"><a href=\"#1-开发者自定义组件之间的交互\" class=\"headerlink\" title=\"1. 开发者自定义组件之间的交互\"></a>1. 开发者自定义组件之间的交互</h5><p>这是比较常用的一个场景。我们使用 Context 实例化我们自己定义的组件，比如 Activity, Content Provider, BroadcastReceiver 等等。除此之外，我们还可以使用 Context 获取资源信息以及对文件系统进行操作等。</p>\n<h5 id=\"2-自定义组件与系统组件的交互\"><a href=\"#2-自定义组件与系统组件的交互\" class=\"headerlink\" title=\"2. 自定义组件与系统组件的交互\"></a>2. 自定义组件与系统组件的交互</h5><p>Context 可以理解成是 Android 系统的入口。一些比较常用的系统级组件都是通过 Context 获取其对象的。比如说，你可以使用 <code>context.getSystemService(Context.WIFI_SERVICE)</code>  来获取 WifiManager 对象。</p>\n<h5 id=\"3-自定义组件与其他-App-的组件的交互\"><a href=\"#3-自定义组件与其他-App-的组件的交互\" class=\"headerlink\" title=\"3. 自定义组件与其他 App 的组件的交互\"></a>3. 自定义组件与其他 App 的组件的交互</h5><p>实现这个的重点在于声明组件的时候，利用隐示意图，即 Intent-filter，将该组件尽可能地详尽化。下面是一个简单的发送邮件的隐示意图使用。</p>\n<pre><code class=\"java\">Intent emailIntent = new Intent(android.content.Intent.ACTION_SEND);\nemailIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\nemailIntent.setType(&quot;vnd.android.cursor.item/email&quot;);\nemailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, new String[]{address});\nemailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\nemailIntent.putExtra(android.content.Intent.EXTRA_TEXT, content);\n</code></pre>\n<p>上面代码的效果就是，手机上所有能够发送邮件的 App 会合并为一个弹窗展示给用户，用户自己可以自由选择。</p>\n<p>通过上面的介绍，我们基本可以达成一个共识，即<strong>在 Android 世界中，所有的事物都可以理解成一个组件，而 Context 就是联系各个组件之间的纽带</strong>。Context 可以帮助开发者在不同组件之间进行交互，可以获取系统级别的组件，还可以实例化某个组件。</p>\n<h3 id=\"Context-的几种类型\"><a href=\"#Context-的几种类型\" class=\"headerlink\" title=\"Context 的几种类型\"></a>Context 的几种类型</h3><p>你可以通过很多方式获得你想要的 Context 对象，<strong>这是个极为糟糕的设计</strong>。一般情况下，我们可以通过以下几种方式来获取 Context 对象。</p>\n<ul>\n<li><p>在 Activity 中调用 Application 实例对象</p>\n</li>\n<li><p>在 Activity 中使用 this，即当前 Activity 的实例对象</p>\n</li>\n<li><p>在 Activity 中调用 getApplicationContext() </p>\n</li>\n<li><p>在 Activity 中调用 getBaseContext()</p>\n</li>\n<li><p>在 Fragment 或者 View 中调用 getContext()</p>\n</li>\n<li><p>Broadcast Receiver 或者 Service 回调中获得的 Context 对象</p>\n</li>\n<li><p>在 Service 中使用 this，即当前 Service 的实例对象</p>\n</li>\n<li><p>在 Service 中调用 getApplicationContext() </p>\n</li>\n<li><p>使用 Context 对象调用 getApplicationContext() </p>\n</li>\n</ul>\n<p>我把所有这些 Context 类型划分为两类：UI Context 和 Non-UI Context。</p>\n<h5 id=\"UI-Context\"><a href=\"#UI-Context\" class=\"headerlink\" title=\"UI Context\"></a>UI Context</h5><p>实际上，只有 ContextThemeWrapper 是 UI Context，就是 Context + 你的 Theme 主题。</p>\n<p>如果你去看看源码，你会发现 Activity 继承自 ContextThemeWrapper，这就是为什么你只是渲染了你的布局文件，但是展示出来的页面却有了你指定的主题。如果你使用一个 Non-UI Context 对布局文件进行渲染，你会发现你的布局没有主题。不信吗？自己去试试看。</p>\n<p>在这种情况下，当你使用 Activity 实例作为 Context 使用时，就意味着你使用的是 UI Context；你在 Fragment 里调用 getContext()  方法，你也是在间接地使用 Activity。当然，前提是你的 Fragment 是在 Activity 中，通过 FragmentManager 添加到页面中的。</p>\n<p>但是，<em>View.getContext() 却不能保证总是 UI Context</em>。</p>\n<p>如果你的 View 是通过 LayoutInflator 渲染，并且 LayoutInflator 接收的 Context 也是 UI Context，那你得到的 View 的 Context 就是 UI Context；但是你渲染布局的 Context 不是 UI Context，那你得到的也是 Non-UI Context。</p>\n<p><u><em>UI Context</em></u></p>\n<ul>\n<li>在 Activity 中使用 this，即当前 Activity 的实例对象</li>\n<li>在 Fragment 调用 getContext()</li>\n<li>在<em>使用 UI Context 渲染</em>的 View 中调用 getContext()</li>\n</ul>\n<h5 id=\"Non-UI-Context\"><a href=\"#Non-UI-Context\" class=\"headerlink\" title=\"Non-UI Context\"></a>Non-UI Context</h5><p>所有不是 UI Context 的都是 Non-UI Context。换句话说，只有继承自 ContextThemeWrapper 的才是 UI Context。</p>\n<p>Non-UI Context 基本上可以和 UI Context 完全划等号，可以做的事情完全一样，系统对 Non-UI Context 也没有任何限制。<strong>再说一次，糟糕的设计。</strong>但是像我们之前说的，如果你使用 Non-UI Context 去渲染布局，那你会丢失掉你的主题。</p>\n<p><u><em>Non-UI Context</em></u></p>\n<ul>\n<li>在 Activity 中调用 Application 实例对象</li>\n<li>Broadcast Receiver 或者 Service 回调中获得的 Context 对象</li>\n<li>在 Service 中使用 this，即当前 Service 的实例对象</li>\n<li>在 Service 中调用 getApplicationContext() </li>\n<li>在 Activity 中调用 getApplicationContext() </li>\n<li>使用 Context 对象调用 getApplicationContext() </li>\n</ul>\n<p>通过上面的分析，我们已经把所有的 Context 分为了两类。概况来说，UI Context 就是 Context + Theme，只要 ContextThemeWrapper 的子类都属于这个集合；其他的 Context 全部都是 Non-UI Context。</p>\n<p><u>需要注意的是，所有的 Context 都是在内存中短期存活的，只有 Application context 除外，也就是你通过 Application 实例充当的，或者通过调用 getApplicationContext() 方法拿到的 Context 对象。</u></p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h5 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景 1\"></a>场景 1</h5><p>假设你使用一个 Non-UI Context 渲染了一个布局文件，会发生什么呢？答案是什么都不会发生，除了你的布局没有主题之外。好像还不错是吧？这种程度的错误可以容忍。</p>\n<h5 id=\"场景-2\"><a href=\"#场景-2\" class=\"headerlink\" title=\"场景 2\"></a>场景 2</h5><p>你不小心使用了 UI Context 去获取资源文件，或者去读取了一个文件，会出现什么问题？还是什么都不会发生。记住这点，UI Context = Contex + Theme。在这种场景下，Non-UI Context 会和 UI Context 不会带给你什么不同。</p>\n<h5 id=\"场景-3\"><a href=\"#场景-3\" class=\"headerlink\" title=\"场景 3\"></a>场景 3</h5><p>和场景 2 差不多，你使用 UI Context 去下载一个文件。很明显，这是个耗时操作，会发生什么问题呢？恭喜你，内存泄漏。</p>\n<p>假设你很幸运，下载速度很快，对象被正确回收，什么都没发生。太阳当空照，花儿对我笑。这也是大部分开发者常会犯的错误，他们把本应该短期存在的 UI Context 对象引用传递到某个会长期存活的任务重，但是最后也不会造成什么影响。</p>\n<p>但是事情不总是这么幸运。有时候 Android 系统会检查你某个组件的内存占用情况或者为其他需要更多内存的应用分配内存，然后等待你的就是内存溢出导致的应用崩溃。</p>\n<p><strong>再说一次，Context 的设计实在是太糟糕了。</strong></p>\n<p>这就是错误使用 Context 对象可能导致的最严重的情况。遇到困难跌倒并不可耻，可耻的是每次都在同一个地方跌倒。如果你每次写代码都会内存泄漏，但是每次都是不同原因，那么恭喜你，你在成长。</p>\n<p>使用 Context 的正确姿势：</p>\n<ol>\n<li>如果你需要处理 UI 相关的业务，比如渲染布局或者展示一个弹窗，使用 UI Context；否则，使用 Non-UI Context；</li>\n<li>涉及到耗时任务时，只使用 Application Context</li>\n</ol>\n<h3 id=\"不同-Context-之间的区别是什么\"><a href=\"#不同-Context-之间的区别是什么\" class=\"headerlink\" title=\"不同 Context 之间的区别是什么\"></a>不同 Context 之间的区别是什么</h3><p>那么，this，getApplicationContext() 和 getBaseContext() 的区别是什么？</p>\n<p>我们知道在手机运行的过程中，很多因素都一直在变化。比如说一些配置项就是始终变化，不能确定的。所有的这些变化都会使得 App 需要不停地重建，从而确保当前展示给用户的是正确的配置，横竖屏、切换语言、切换主题等等。你的 App 需要获取到最匹配的资源文件来展示给用户他们想要的效果，这就是 Context 的工作。</p>\n<p>试着回答这个问题：</p>\n<p>用户将本地语言设置为英文，但是你要给用户展示德文，你怎么实现？</p>\n<p>下面是 Context 的一些 magic method：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20191114182356.png\" alt=\"\"></p>\n<p>我们可以看到 createConfigurationContext() 方法，来看看怎么使用：</p>\n<pre><code class=\"java\">public Context createConfigurationContext(Configuration overrideConfiguration){\n     Configuration configuration = getResources().getConfiguration();\n    configuration.setLocale(your_custom_locale);\n    context = createConfigurationContext(configuration);\n  return context;\n}\n</code></pre>\n<p>没错，通过这个方法，你可以获取任意自己想要的 Context 对象。当你使用这个新的 Context 对象时，你就能够拿到你配置的对应的资源信息。</p>\n<p>现在我们回到之前的问题，<strong>this，getApplicationContext() 和 getBaseContext() 的区别是什么？</strong></p>\n<p>这是你在 Activity 中获取 Context 对象的几种方式。</p>\n<ol>\n<li><p>this 指代的是当前 Activity 自身，UI Context，<em>在内存中短期存活</em>的 context；</p>\n</li>\n<li><p>baseContext 是最基本的 Context 对象，创建于 Application 创建时。之前我们介绍了 createConfigurationContext() 方法，你可以自定义自己的 Context 对象，然后通过 attachBaseContext() 方法，将原有的 Context 对象进行重置。</p>\n<p>一旦重置 baseContext，之后 Activity 的 Context 引用都会指向新的 Context；如果你不是在 Activity 中重置的，那你还可以通过 getBaseContext() 来获取 Activity 对象；</p>\n</li>\n</ol>\n<p>我们可以说，Context 就是 Android App 的灵魂，甚至说，你的 App 就是你的 Context。在 Android 开发中，没有 Context 你就什么都做不了；如果没有 Context，那你的 App 就只是一堆 Java 代码罢了。</p>\n<h3 id=\"Android-Context-Java-code\"><a href=\"#Android-Context-Java-code\" class=\"headerlink\" title=\"Android = Context + Java code\"></a>Android = Context + Java code</h3><p>虽然我们吐槽了一次又一次 Context 的设计，但是系统设计如此，我们能做的也只是尽可能地去更好地使用它。</p>\n<p>通过文章的第一部分，我们知道了我们主要使用 Context 来进行不同组件间的交互，获取系统级组件。</p>\n<p>紧接着，我们知道了 Context 分为 UI Context 和 Non-UI Context，以及在内存中短期存活的和长期存活的 Context。</p>\n<p>在之后，我们学习到要谨慎选择使用 Context，否则轻则有 UI 显示问题，重则有内存泄漏甚至内存溢出的问题。</p>\n<p>最后，我们知道 Context 主要负责为 App 加载正确、合适的资源文件，也知道了怎么对 Context 进行自定义；还了解到了 this，applicationContext 和 baseContext 的区别。</p>\n<p>很多人可能会建议你一直使用 Application Context，一劳永逸；</p>\n<p>但我不这么想：不要因为害怕内存泄漏而始终使用 Application Context，你应该知道根本的原因，然后使用正确的 Context。</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322185113.png","title":"ConstraintLayout 介绍","date":"2019-03-21T16:00:00.000Z","_content":"\n不知道从什么时候开始，Android 死丢丢已经默认使用约束布局 ConstraintLayout 作为默认布局了，但是懒癌发作一直不想学习，每次都换成 LinearLayout，这次也忘记了为啥开始学习这个东西，学完发现还挺爽……写个笔记记录一下，哈哈\n\n\n\n<!-- more -->\n\n\n\n正文开始~\n\n#### 相对布局\n\n##### 属性集合\n\n类似 RelativeLayout ，使用相对位置的属性来互相约束位置。具体的属性以及使用方式也类似 RelativeLayout，默认像 FrameLayout 一样堆叠在一起，使用属性讲层级关系区分开：\n\n```xml\nlayout_constraintLeft_toLeftOf   当前控件的左侧与某个控件的左侧对齐\nlayout_constraintLeft_toRightOf  当前控件的左侧与某个控件的右侧对齐\nlayout_constraintRight_toLeftOf  当前控件的右侧与某个控件的左侧对齐\nlayout_constraintRight_toRightOf 当前控件的右侧与某个控件的右侧对齐\n\nlayout_constraintStart_toEndOf   同上\nlayout_constraintStart_toStartOf\nlayout_constraintEnd_toStartOf\nlayout_constraintEnd_toEndOf\n\nlayout_constraintTop_toTopOf       当前控件与某个控件顶端对齐\nlayout_constraintTop_toBottomOf    即当前控件某个控件的下面\nlayout_constraintBottom_toTopOf    即当前控件在某个控件的上面\nlayout_constraintBottom_toBottomOf 当前控件与某个控件底部对齐\n\nlayout_constraintBaseline_toBaselineOf 文本基线对齐\n```\n\n##### 具体示例\n\n```xml\n<!-- 居中对齐实现方式 -->\n\n<!-- 上下左右全部受 parent 约束，最后的效果就是「居中对齐」 -->\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"居中对齐\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"\n    app:layout_constraintLeft_toLeftOf=\"parent\"\n    app:layout_constraintRight_toRightOf=\"parent\"/>\n\n<!-- 同理，左右受 parent 约束，效果就是「水平居中对齐」-->\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"水平居中对齐\"\n    app:layout_constraintLeft_toLeftOf=\"parent\"\n    app:layout_constraintRight_toRightOf=\"parent\"/>\n\n<!-- 同理，上下受 parent 约束，效果就是「垂直居中对齐」-->\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"垂直居中对齐\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"/>\n```\n\n居中对齐很好理解，下边我们来写一个正常的 item 布局看看：\n\n![ConstraintLayout 实现的 item 布局](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322142136.png)\n\n```xml\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:padding=\"5dp\">\n\n    <ImageView\n        android:id=\"@+id/iv_logo\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@mipmap/ic_launcher\" />\n\n    <!-- 设置标题名称 View 的左侧边缘位于 logo 的右侧 -->\n    <TextView\n        android:id=\"@+id/tv_title\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginLeft=\"10dp\"\n        android:text=\"虾吃虾涮（华贸店）\"\n        app:layout_constraintLeft_toRightOf=\"@+id/iv_logo\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <!-- 设置价格 View 的底部靠近父布局，且顶部参考 titleView，同时左侧与 titleView 对齐 -->\n    <TextView\n        android:id=\"@+id/tv_price\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"￥64/人\"\n        android:textSize=\"13sp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"@id/tv_title\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_title\" />\n\n    <!-- 设置 distanceView 紧贴屏幕右侧，且顶部与 priceView 对齐-->\n    <TextView\n        android:id=\"@+id/tv_distance\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"1.1km\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"@id/tv_price\" />\n\n    <!-- 设置 areaView 顶部与左侧都参考 priceView，底部位置参考 ivLogo-->\n    <TextView\n        android:id=\"@+id/tv_area\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"朝阳区 大望路\"\n        android:textSize=\"13sp\"\n        app:layout_constraintBottom_toBottomOf=\"@id/iv_logo\"\n        app:layout_constraintLeft_toLeftOf=\"@id/tv_price\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_price\" />\n\n    <!-- 设置 hotView 紧贴屏幕右侧，且顶部与 areaView 顶部对齐-->\n    <TextView\n        android:id=\"@+id/tv_curr_hot\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"当前人气89\"\n        android:textSize=\"13sp\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"@id/tv_area\" />\n\n    <!-- dividerView 位于整个布局的最底部，且始终位于 ivLogo 底部，并保持一定距离 -->\n    <View\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"1px\"\n        android:layout_marginTop=\"7dp\"\n        android:background=\"@android:color/darker_gray\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@id/iv_logo\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n可以发现使用约束布局实现比普通的 RL 实现还要简单，界面完全实现扁平化，没有任何嵌套。如果使用 LL 或者 RL 来实现同样的效果，代码要复杂多少想必不用我多说。\n\n\n\n#### Bias 偏向\n\n以上的内容就是基本使用了，把上下左右各种参考、依赖关系搞明白，本身没有多么复杂，使用起来也和 RL 差不多，下面来介绍一些新花样。\n\n`bias` 很好理解，正如其英文本意一样，它表达的是**偏移**。当某一布局同时受两个相反方向的约束力时，该布局就会处于约束它的那两个力量的正中央。而 `layout_constraintHorizontal_bias` 与 `layout_constraintVertical_bias` 就是用在这种时候，用来将某一方向的约束力减弱。来自两侧的约束力可以为 parent，也可以是普通 View。\n\n文字描述可能有点抽象，具体布局文件还是更好理解一些：\n\n```xml\n<android.support.constraint.ConstraintLayout \n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView\n        android:id=\"@+id/tv1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"this is a text\"\n        app:layout_constraintLeft_toLeftOf=\"parent\" />\n\n    <TextView\n        android:id=\"@+id/tv2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"this is a text\"\n        app:layout_constraintHorizontal_bias=\"0.3\"\n        app:layout_constraintLeft_toRightOf=\"@id/tv1\"\n        app:layout_constraintRight_toLeftOf=\"@id/tv3\" />\n\n    <TextView\n        android:id=\"@+id/tv3\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"this is a text\"\n        app:layout_constraintRight_toRightOf=\"parent\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n布局很简单，三个 TextView 并排显示，左右两个分别紧贴父布局，中间一个受左右两侧布局约束，本来应该是位于两个 TextView 正中央，但是由于设置了 `layout_constraintHorizontal_bias` 小于 0.5，所以最后效果中间的 TextView 整体偏向左侧，展示如下图：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322145701.jpg)\n\n\n\n#### Circle 布局\n\n这个看上去很厉害的！可以令 B 布局以 A 布局为圆心，然后用角度和半径距离来约束两个布局的位置。废话不多说，上图：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322153304.jpg)这个也很好理解，主要有三个属性：\n\n```\nlayout_constraintCircle ：      当前布局以哪个布局为圆心\nlayout_constraintCircleRadius ：半径\nlayout_constraintCircleAngle ： 摆放角度\n```\n\n我反正是给谷歌跪了……\n\n```xml\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <TextView\n        android:id=\"@+id/tv_center\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        android:text=\"Circle Center\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n    \n    <!-- 「测试布局」以 tv_center 为圆心，位于其 135° 方向的 100dp 处 -->\n    <TextView\n        android:text=\"测试布局\"\n        app:layout_constraintCircle=\"@id/tv_center\"\n        app:layout_constraintCircleAngle=\"135\"\n        app:layout_constraintCircleRadius=\"100dp\"\n        android:textColor=\"@android:color/black\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n\n\n#### 替代 MATCH_PARENT 的 MATCH_CONSTRAINT\n\n在约束布局中，由于布局受各方约束控制，也就没有所谓的「match_parent」了。随之而来的需求则是，左边有个布局约束我，右边还有个布局约束我，然后我就想充满剩余的全部位置，「match_constraint」也就应运而生了。\n\n说起来复杂，其实只需要把对应的 View 宽高设置为 0dp 即可，该 View 就会占据上剩余的所有可用空间。在这种情况下，谷歌给我们提供了几个额外的属性：\n\n```\nlayout_constraintWidth_min   宽度最小值\nlayout_constraintHeight_min  高度最小值\n\nlayout_constraintWidth_max   宽度最大值\nlayout_constraintHeight_max  高度最大值\n\nlayout_constraintWidth_percent   宽度占剩余位置的百分比\nlayout_constraintHeight_percent  高度占剩余位置的百分比\n```\n\n具体示例如下：\n\n```xml\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/btn1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Test Button\"\n        app:layout_constraintLeft_toLeftOf=\"parent\" />\n\n    <Button\n        android:id=\"@+id/btn2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button\"\n        app:layout_constraintRight_toRightOf=\"parent\" />\n\n    <Button\n        android:id=\"@+id/btn3\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constrainedWidth=\"true\"\n        android:text=\"Button\"\n        app:layout_constraintWidth_min=\"wrap\"\n        app:layout_constraintWidth_max=\"wrap\"\n        app:layout_constraintWidth_percent=\"0.3\"\n        app:layout_constraintLeft_toRightOf=\"@id/btn1\"\n        app:layout_constraintRight_toLeftOf=\"@id/btn2\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322163826.jpg)\n\n\n\n#### Chains 链\n\n如果几个不同的 View 两两发生关联，如下图，则这几个 View 构成了一个 Chains(链)。\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322170158.jpg)\n\n具体布局代码如下：\n\n```xml\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/btn1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toLeftOf=\"@id/btn2\" />\n\n    <Button\n        android:id=\"@+id/btn2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button\"\n        app:layout_constraintLeft_toRightOf=\"@id/btn1\"\n        app:layout_constraintRight_toLeftOf=\"@id/btn3\" />\n\n    <Button\n        android:id=\"@+id/btn3\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button\"\n        app:layout_constraintLeft_toRightOf=\"@id/btn2\"\n        app:layout_constraintRight_toRightOf=\"parent\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n这样这三个 Button 就形成了一个横向的 Chain，在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果：\n\n该属性为：\n\n```\nlayout_constraintHorizontal_chainStyle\nlayout_constraintVertical_chainStyle\n```\n\n其取值可以为：spread、spread_inside、packed。\n\n具体样式展示如下：\n\n1. spread，基本上就是按照权重等分\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171443.jpg)\n\n2. spread_inside，也是等分展示，但是两侧吸附\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171444.jpg)\n\n3. packed，整条链挤在一起，居中展示\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171442.jpg)\n\n官网有一个图来展示不同样式的 Chains，可以参考一下，也很形象：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322172439.jpg)\n\n\n\n#### 虚拟辅助视图\n\n与以往的 ViewGroup 不同，ConstraintLayout 还提供了几种辅助页面绘制的布局，这种布局一般表现为引导线之类，不会在页面上绘制，但是可以通过占位的方式，成为不同布局的约束条件。\n\n##### GuideLine\n\n顾名思义，GuideLine 可以创建基于父布局 ConstraintLayout 的水平或者垂直准线，从而帮助开发者进行布局定位。\n\n这个布局有四个基本属性，依次为：\n\n```xml\norientation 如上所述，用来表示是垂直方向还是竖直方向\nlayout_constraintGuide_begin 距离父亲的起始位置\nlayout_constraintGuide_end 距离父亲的结束位置\nlayout_constraintGuide_percent 距离父亲的位置，用百分比表示\n\n经过试验，percent 优先级最高，其次是 begin，最后是 end，一般来讲使用 percent 就足够了\n```\n\nxml 以及对应的页面效果如下：\n\n```xml\n<android.support.constraint.ConstraintLayout        \t\t\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <!-- 假设说现在需要将 ImageView 摆放到右下角的位置，就可以使用 GL 辅助实现-->\n    <android.support.constraint.Guideline\n        android:id=\"@+id/gl_vertical\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n        app:layout_constraintGuide_percent=\"0.8\"/>\n\n    <android.support.constraint.Guideline\n        android:id=\"@+id/gl_horizontal\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"0dp\"\n        android:orientation=\"horizontal\"\n        app:layout_constraintGuide_percent=\"0.8\" />\n\n    <ImageView\n        android:src=\"@mipmap/ic_launcher\"\n        app:layout_constraintLeft_toRightOf=\"@id/gl_vertical\"\n        app:layout_constraintTop_toBottomOf=\"@id/gl_horizontal\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322174954.jpg)\n\n\n\n##### Barrier\n\n与 GuideLine 差不多，但是比它更灵活，可以用来约束多个布局，且自动匹配最大最小值进行约束。\n\nBarrier 有两个基本属性：\n\n- barrierDirection\n\n  >  取值可为 top, bottom, left, right, start, end\n\n  用于约定栅栏拦截的 View 方向，假设说要拦截的 View 在右侧，这个属性就应该为 right 或者 end\n\n- constraint_referenced_ids\n\n  被栅栏保护，屏蔽起来的 View 集合，直接输入 viewId，用逗号分隔即可；barrier 会根据宽度或者高度最大的那个 View 来设置栅栏的边界\n\n可能会有些抽象，我们在开发时可能会遇到一种比较蛋疼的需求：\n\n> 姓名、性别、出生日期、手机号等字段从上到下一字排开，但是每个字段对应的值要保证彼此左侧对齐\n\n讲道理以前这种布局我一直不知道怎么画，但是现在有了 `barrier` 以后这问题就迎刃而解了。我们可以用 barrier 将左侧的那些字段与右侧的值拦截开，barrier 会自动识别最宽的那个字段，并将之作为 barrier 的宽度，之后每个值都用 barrier 来制造约束就可以了。\n\n```XML\n<android.support.constraint.ConstraintLayout \n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:padding=\"10dp\">\n\n    <TextView\n        android:id=\"@+id/tv_name\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"姓名:\"/>\n\n    <TextView\n        android:id=\"@+id/tv_gender\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_name\"\n        android:text=\"性别:\"/>\n\n    <TextView\n        android:id=\"@+id/tv_phone\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_gender\"\n        android:text=\"手机号:\"/>\n\n    <TextView\n        android:id=\"@+id/tv_birthday\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_phone\"\n        android:text=\"出生日期:\"/>\n\n    <android.support.constraint.Barrier\n        android:id=\"@+id/barrier\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:barrierDirection=\"end\"\n        app:constraint_referenced_ids=\"tv_name,tv_phone,tv_gender,tv_birthday\"/>\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintLeft_toRightOf=\"@id/barrier\"\n        android:text=\"易烊千玺\"/>\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_name\"\n        app:layout_constraintLeft_toRightOf=\"@id/barrier\"\n        android:text=\"男\"/>\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintLeft_toRightOf=\"@id/barrier\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_gender\"\n        android:text=\"13800138000\"/>\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintLeft_toRightOf=\"@id/barrier\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_phone\"\n        android:text=\"2000年1月1日\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n显示效果如图，很完美有没有？\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322182306.jpg)\n\n\n\n##### Group\n\nGroup 是一个组，用来批量控制 View 的显示与隐藏；但是注意这不是个 ViewGroup，它只是一个不执行绘制的 View，和 barrier 一样，它有一个 constraint_referenced_ids 的属性，可以将需要隐藏的 ViewId 丢进去，在需要的时候将其批量隐藏即可。\n\n还通过上面的例子，假设现在要把性别一栏隐藏掉：\n\n```xml\n<android.support.constraint.Group\n    app:constraint_referenced_ids=\"tv_gender,tv_sex_value\"\n    android:visibility=\"gone\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\" />\n```\n\n通过将性别的 key 和 value 的 id 都放进去，将其设置为 gone，则可以将该组实现隐藏：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322183030.jpg)\n\n但是，使用 Group 控制可见性是有坑的：\n\n> 1. 和以前用的ViewGroup有一点不同，以前用ViewGroup约束View的时候，外层ViewGroup设置成可见，里层View设置成不可见是可以生效的，但是用Group就不能。Group约束的元素的可见性始终一致。\n>\n> 2. 调用Group的setVisibility方法不会立即对它约束对子View生效，而是要等到Group所在的ConstrainLayout调用preLayout方法时才会生效。preLayout只有在第一次layout和布局发生变化时才会调用。\n\n\n\n#### Optimizer优化\n\n可以通过将标签app：layout_optimizationLevel元素添加到 ConstraintLayout 来决定应用哪些优化\n\n```xml\n<android.support.constraint.ConstraintLayout \n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    app:layout_optimizationLevel=\"standard|dimensions|chains\"/>\n```\n\n- none： 不执行优化\n- standard： 默认，仅优化直接和障碍约束\n- direct： 优化直接约束\n- barrier： 优化障碍约束\n- chain：优化链条约束\n- dimensions：优化维度测量，减少匹配约束元素的度量数量\n\n\n\n#### 参考文章\n\n- [ConstraintLayout 全解析](https://juejin.im/post/5c0bd6b05188257c3045dc50#heading-7)\n- [拒绝拖拽 使用ConstraintLayout优化你的布局吧](<https://mp.weixin.qq.com/s/vI-fPaNoJ7ZBlZcMkEGdLQ>)","source":"_posts/ConstraintLayout-learning.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322185113.png\ntitle: ConstraintLayout 介绍\ntags: [Android]\ndate: 2019-03-22\n---\n\n不知道从什么时候开始，Android 死丢丢已经默认使用约束布局 ConstraintLayout 作为默认布局了，但是懒癌发作一直不想学习，每次都换成 LinearLayout，这次也忘记了为啥开始学习这个东西，学完发现还挺爽……写个笔记记录一下，哈哈\n\n\n\n<!-- more -->\n\n\n\n正文开始~\n\n#### 相对布局\n\n##### 属性集合\n\n类似 RelativeLayout ，使用相对位置的属性来互相约束位置。具体的属性以及使用方式也类似 RelativeLayout，默认像 FrameLayout 一样堆叠在一起，使用属性讲层级关系区分开：\n\n```xml\nlayout_constraintLeft_toLeftOf   当前控件的左侧与某个控件的左侧对齐\nlayout_constraintLeft_toRightOf  当前控件的左侧与某个控件的右侧对齐\nlayout_constraintRight_toLeftOf  当前控件的右侧与某个控件的左侧对齐\nlayout_constraintRight_toRightOf 当前控件的右侧与某个控件的右侧对齐\n\nlayout_constraintStart_toEndOf   同上\nlayout_constraintStart_toStartOf\nlayout_constraintEnd_toStartOf\nlayout_constraintEnd_toEndOf\n\nlayout_constraintTop_toTopOf       当前控件与某个控件顶端对齐\nlayout_constraintTop_toBottomOf    即当前控件某个控件的下面\nlayout_constraintBottom_toTopOf    即当前控件在某个控件的上面\nlayout_constraintBottom_toBottomOf 当前控件与某个控件底部对齐\n\nlayout_constraintBaseline_toBaselineOf 文本基线对齐\n```\n\n##### 具体示例\n\n```xml\n<!-- 居中对齐实现方式 -->\n\n<!-- 上下左右全部受 parent 约束，最后的效果就是「居中对齐」 -->\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"居中对齐\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"\n    app:layout_constraintLeft_toLeftOf=\"parent\"\n    app:layout_constraintRight_toRightOf=\"parent\"/>\n\n<!-- 同理，左右受 parent 约束，效果就是「水平居中对齐」-->\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"水平居中对齐\"\n    app:layout_constraintLeft_toLeftOf=\"parent\"\n    app:layout_constraintRight_toRightOf=\"parent\"/>\n\n<!-- 同理，上下受 parent 约束，效果就是「垂直居中对齐」-->\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"垂直居中对齐\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"/>\n```\n\n居中对齐很好理解，下边我们来写一个正常的 item 布局看看：\n\n![ConstraintLayout 实现的 item 布局](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322142136.png)\n\n```xml\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:padding=\"5dp\">\n\n    <ImageView\n        android:id=\"@+id/iv_logo\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@mipmap/ic_launcher\" />\n\n    <!-- 设置标题名称 View 的左侧边缘位于 logo 的右侧 -->\n    <TextView\n        android:id=\"@+id/tv_title\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginLeft=\"10dp\"\n        android:text=\"虾吃虾涮（华贸店）\"\n        app:layout_constraintLeft_toRightOf=\"@+id/iv_logo\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <!-- 设置价格 View 的底部靠近父布局，且顶部参考 titleView，同时左侧与 titleView 对齐 -->\n    <TextView\n        android:id=\"@+id/tv_price\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"￥64/人\"\n        android:textSize=\"13sp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"@id/tv_title\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_title\" />\n\n    <!-- 设置 distanceView 紧贴屏幕右侧，且顶部与 priceView 对齐-->\n    <TextView\n        android:id=\"@+id/tv_distance\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"1.1km\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"@id/tv_price\" />\n\n    <!-- 设置 areaView 顶部与左侧都参考 priceView，底部位置参考 ivLogo-->\n    <TextView\n        android:id=\"@+id/tv_area\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"朝阳区 大望路\"\n        android:textSize=\"13sp\"\n        app:layout_constraintBottom_toBottomOf=\"@id/iv_logo\"\n        app:layout_constraintLeft_toLeftOf=\"@id/tv_price\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_price\" />\n\n    <!-- 设置 hotView 紧贴屏幕右侧，且顶部与 areaView 顶部对齐-->\n    <TextView\n        android:id=\"@+id/tv_curr_hot\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"当前人气89\"\n        android:textSize=\"13sp\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"@id/tv_area\" />\n\n    <!-- dividerView 位于整个布局的最底部，且始终位于 ivLogo 底部，并保持一定距离 -->\n    <View\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"1px\"\n        android:layout_marginTop=\"7dp\"\n        android:background=\"@android:color/darker_gray\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@id/iv_logo\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n可以发现使用约束布局实现比普通的 RL 实现还要简单，界面完全实现扁平化，没有任何嵌套。如果使用 LL 或者 RL 来实现同样的效果，代码要复杂多少想必不用我多说。\n\n\n\n#### Bias 偏向\n\n以上的内容就是基本使用了，把上下左右各种参考、依赖关系搞明白，本身没有多么复杂，使用起来也和 RL 差不多，下面来介绍一些新花样。\n\n`bias` 很好理解，正如其英文本意一样，它表达的是**偏移**。当某一布局同时受两个相反方向的约束力时，该布局就会处于约束它的那两个力量的正中央。而 `layout_constraintHorizontal_bias` 与 `layout_constraintVertical_bias` 就是用在这种时候，用来将某一方向的约束力减弱。来自两侧的约束力可以为 parent，也可以是普通 View。\n\n文字描述可能有点抽象，具体布局文件还是更好理解一些：\n\n```xml\n<android.support.constraint.ConstraintLayout \n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView\n        android:id=\"@+id/tv1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"this is a text\"\n        app:layout_constraintLeft_toLeftOf=\"parent\" />\n\n    <TextView\n        android:id=\"@+id/tv2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"this is a text\"\n        app:layout_constraintHorizontal_bias=\"0.3\"\n        app:layout_constraintLeft_toRightOf=\"@id/tv1\"\n        app:layout_constraintRight_toLeftOf=\"@id/tv3\" />\n\n    <TextView\n        android:id=\"@+id/tv3\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"this is a text\"\n        app:layout_constraintRight_toRightOf=\"parent\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n布局很简单，三个 TextView 并排显示，左右两个分别紧贴父布局，中间一个受左右两侧布局约束，本来应该是位于两个 TextView 正中央，但是由于设置了 `layout_constraintHorizontal_bias` 小于 0.5，所以最后效果中间的 TextView 整体偏向左侧，展示如下图：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322145701.jpg)\n\n\n\n#### Circle 布局\n\n这个看上去很厉害的！可以令 B 布局以 A 布局为圆心，然后用角度和半径距离来约束两个布局的位置。废话不多说，上图：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322153304.jpg)这个也很好理解，主要有三个属性：\n\n```\nlayout_constraintCircle ：      当前布局以哪个布局为圆心\nlayout_constraintCircleRadius ：半径\nlayout_constraintCircleAngle ： 摆放角度\n```\n\n我反正是给谷歌跪了……\n\n```xml\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <TextView\n        android:id=\"@+id/tv_center\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        android:text=\"Circle Center\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n    \n    <!-- 「测试布局」以 tv_center 为圆心，位于其 135° 方向的 100dp 处 -->\n    <TextView\n        android:text=\"测试布局\"\n        app:layout_constraintCircle=\"@id/tv_center\"\n        app:layout_constraintCircleAngle=\"135\"\n        app:layout_constraintCircleRadius=\"100dp\"\n        android:textColor=\"@android:color/black\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n\n\n#### 替代 MATCH_PARENT 的 MATCH_CONSTRAINT\n\n在约束布局中，由于布局受各方约束控制，也就没有所谓的「match_parent」了。随之而来的需求则是，左边有个布局约束我，右边还有个布局约束我，然后我就想充满剩余的全部位置，「match_constraint」也就应运而生了。\n\n说起来复杂，其实只需要把对应的 View 宽高设置为 0dp 即可，该 View 就会占据上剩余的所有可用空间。在这种情况下，谷歌给我们提供了几个额外的属性：\n\n```\nlayout_constraintWidth_min   宽度最小值\nlayout_constraintHeight_min  高度最小值\n\nlayout_constraintWidth_max   宽度最大值\nlayout_constraintHeight_max  高度最大值\n\nlayout_constraintWidth_percent   宽度占剩余位置的百分比\nlayout_constraintHeight_percent  高度占剩余位置的百分比\n```\n\n具体示例如下：\n\n```xml\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/btn1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Test Button\"\n        app:layout_constraintLeft_toLeftOf=\"parent\" />\n\n    <Button\n        android:id=\"@+id/btn2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button\"\n        app:layout_constraintRight_toRightOf=\"parent\" />\n\n    <Button\n        android:id=\"@+id/btn3\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constrainedWidth=\"true\"\n        android:text=\"Button\"\n        app:layout_constraintWidth_min=\"wrap\"\n        app:layout_constraintWidth_max=\"wrap\"\n        app:layout_constraintWidth_percent=\"0.3\"\n        app:layout_constraintLeft_toRightOf=\"@id/btn1\"\n        app:layout_constraintRight_toLeftOf=\"@id/btn2\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322163826.jpg)\n\n\n\n#### Chains 链\n\n如果几个不同的 View 两两发生关联，如下图，则这几个 View 构成了一个 Chains(链)。\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322170158.jpg)\n\n具体布局代码如下：\n\n```xml\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/btn1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toLeftOf=\"@id/btn2\" />\n\n    <Button\n        android:id=\"@+id/btn2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button\"\n        app:layout_constraintLeft_toRightOf=\"@id/btn1\"\n        app:layout_constraintRight_toLeftOf=\"@id/btn3\" />\n\n    <Button\n        android:id=\"@+id/btn3\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button\"\n        app:layout_constraintLeft_toRightOf=\"@id/btn2\"\n        app:layout_constraintRight_toRightOf=\"parent\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n这样这三个 Button 就形成了一个横向的 Chain，在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果：\n\n该属性为：\n\n```\nlayout_constraintHorizontal_chainStyle\nlayout_constraintVertical_chainStyle\n```\n\n其取值可以为：spread、spread_inside、packed。\n\n具体样式展示如下：\n\n1. spread，基本上就是按照权重等分\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171443.jpg)\n\n2. spread_inside，也是等分展示，但是两侧吸附\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171444.jpg)\n\n3. packed，整条链挤在一起，居中展示\n\n   ![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171442.jpg)\n\n官网有一个图来展示不同样式的 Chains，可以参考一下，也很形象：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322172439.jpg)\n\n\n\n#### 虚拟辅助视图\n\n与以往的 ViewGroup 不同，ConstraintLayout 还提供了几种辅助页面绘制的布局，这种布局一般表现为引导线之类，不会在页面上绘制，但是可以通过占位的方式，成为不同布局的约束条件。\n\n##### GuideLine\n\n顾名思义，GuideLine 可以创建基于父布局 ConstraintLayout 的水平或者垂直准线，从而帮助开发者进行布局定位。\n\n这个布局有四个基本属性，依次为：\n\n```xml\norientation 如上所述，用来表示是垂直方向还是竖直方向\nlayout_constraintGuide_begin 距离父亲的起始位置\nlayout_constraintGuide_end 距离父亲的结束位置\nlayout_constraintGuide_percent 距离父亲的位置，用百分比表示\n\n经过试验，percent 优先级最高，其次是 begin，最后是 end，一般来讲使用 percent 就足够了\n```\n\nxml 以及对应的页面效果如下：\n\n```xml\n<android.support.constraint.ConstraintLayout        \t\t\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <!-- 假设说现在需要将 ImageView 摆放到右下角的位置，就可以使用 GL 辅助实现-->\n    <android.support.constraint.Guideline\n        android:id=\"@+id/gl_vertical\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n        app:layout_constraintGuide_percent=\"0.8\"/>\n\n    <android.support.constraint.Guideline\n        android:id=\"@+id/gl_horizontal\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"0dp\"\n        android:orientation=\"horizontal\"\n        app:layout_constraintGuide_percent=\"0.8\" />\n\n    <ImageView\n        android:src=\"@mipmap/ic_launcher\"\n        app:layout_constraintLeft_toRightOf=\"@id/gl_vertical\"\n        app:layout_constraintTop_toBottomOf=\"@id/gl_horizontal\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322174954.jpg)\n\n\n\n##### Barrier\n\n与 GuideLine 差不多，但是比它更灵活，可以用来约束多个布局，且自动匹配最大最小值进行约束。\n\nBarrier 有两个基本属性：\n\n- barrierDirection\n\n  >  取值可为 top, bottom, left, right, start, end\n\n  用于约定栅栏拦截的 View 方向，假设说要拦截的 View 在右侧，这个属性就应该为 right 或者 end\n\n- constraint_referenced_ids\n\n  被栅栏保护，屏蔽起来的 View 集合，直接输入 viewId，用逗号分隔即可；barrier 会根据宽度或者高度最大的那个 View 来设置栅栏的边界\n\n可能会有些抽象，我们在开发时可能会遇到一种比较蛋疼的需求：\n\n> 姓名、性别、出生日期、手机号等字段从上到下一字排开，但是每个字段对应的值要保证彼此左侧对齐\n\n讲道理以前这种布局我一直不知道怎么画，但是现在有了 `barrier` 以后这问题就迎刃而解了。我们可以用 barrier 将左侧的那些字段与右侧的值拦截开，barrier 会自动识别最宽的那个字段，并将之作为 barrier 的宽度，之后每个值都用 barrier 来制造约束就可以了。\n\n```XML\n<android.support.constraint.ConstraintLayout \n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:padding=\"10dp\">\n\n    <TextView\n        android:id=\"@+id/tv_name\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"姓名:\"/>\n\n    <TextView\n        android:id=\"@+id/tv_gender\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_name\"\n        android:text=\"性别:\"/>\n\n    <TextView\n        android:id=\"@+id/tv_phone\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_gender\"\n        android:text=\"手机号:\"/>\n\n    <TextView\n        android:id=\"@+id/tv_birthday\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_phone\"\n        android:text=\"出生日期:\"/>\n\n    <android.support.constraint.Barrier\n        android:id=\"@+id/barrier\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:barrierDirection=\"end\"\n        app:constraint_referenced_ids=\"tv_name,tv_phone,tv_gender,tv_birthday\"/>\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintLeft_toRightOf=\"@id/barrier\"\n        android:text=\"易烊千玺\"/>\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_name\"\n        app:layout_constraintLeft_toRightOf=\"@id/barrier\"\n        android:text=\"男\"/>\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintLeft_toRightOf=\"@id/barrier\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_gender\"\n        android:text=\"13800138000\"/>\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintLeft_toRightOf=\"@id/barrier\"\n        app:layout_constraintTop_toBottomOf=\"@id/tv_phone\"\n        android:text=\"2000年1月1日\" />\n\n</android.support.constraint.ConstraintLayout>\n```\n\n显示效果如图，很完美有没有？\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322182306.jpg)\n\n\n\n##### Group\n\nGroup 是一个组，用来批量控制 View 的显示与隐藏；但是注意这不是个 ViewGroup，它只是一个不执行绘制的 View，和 barrier 一样，它有一个 constraint_referenced_ids 的属性，可以将需要隐藏的 ViewId 丢进去，在需要的时候将其批量隐藏即可。\n\n还通过上面的例子，假设现在要把性别一栏隐藏掉：\n\n```xml\n<android.support.constraint.Group\n    app:constraint_referenced_ids=\"tv_gender,tv_sex_value\"\n    android:visibility=\"gone\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\" />\n```\n\n通过将性别的 key 和 value 的 id 都放进去，将其设置为 gone，则可以将该组实现隐藏：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322183030.jpg)\n\n但是，使用 Group 控制可见性是有坑的：\n\n> 1. 和以前用的ViewGroup有一点不同，以前用ViewGroup约束View的时候，外层ViewGroup设置成可见，里层View设置成不可见是可以生效的，但是用Group就不能。Group约束的元素的可见性始终一致。\n>\n> 2. 调用Group的setVisibility方法不会立即对它约束对子View生效，而是要等到Group所在的ConstrainLayout调用preLayout方法时才会生效。preLayout只有在第一次layout和布局发生变化时才会调用。\n\n\n\n#### Optimizer优化\n\n可以通过将标签app：layout_optimizationLevel元素添加到 ConstraintLayout 来决定应用哪些优化\n\n```xml\n<android.support.constraint.ConstraintLayout \n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    app:layout_optimizationLevel=\"standard|dimensions|chains\"/>\n```\n\n- none： 不执行优化\n- standard： 默认，仅优化直接和障碍约束\n- direct： 优化直接约束\n- barrier： 优化障碍约束\n- chain：优化链条约束\n- dimensions：优化维度测量，减少匹配约束元素的度量数量\n\n\n\n#### 参考文章\n\n- [ConstraintLayout 全解析](https://juejin.im/post/5c0bd6b05188257c3045dc50#heading-7)\n- [拒绝拖拽 使用ConstraintLayout优化你的布局吧](<https://mp.weixin.qq.com/s/vI-fPaNoJ7ZBlZcMkEGdLQ>)","slug":"ConstraintLayout-learning","published":1,"updated":"2019-03-22T10:51:31.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86ep001tlh1pxdspgpfw","content":"<p>不知道从什么时候开始，Android 死丢丢已经默认使用约束布局 ConstraintLayout 作为默认布局了，但是懒癌发作一直不想学习，每次都换成 LinearLayout，这次也忘记了为啥开始学习这个东西，学完发现还挺爽……写个笔记记录一下，哈哈</p>\n<a id=\"more\"></a>\n<p>正文开始~</p>\n<h4 id=\"相对布局\"><a href=\"#相对布局\" class=\"headerlink\" title=\"相对布局\"></a>相对布局</h4><h5 id=\"属性集合\"><a href=\"#属性集合\" class=\"headerlink\" title=\"属性集合\"></a>属性集合</h5><p>类似 RelativeLayout ，使用相对位置的属性来互相约束位置。具体的属性以及使用方式也类似 RelativeLayout，默认像 FrameLayout 一样堆叠在一起，使用属性讲层级关系区分开：</p>\n<pre><code class=\"xml\">layout_constraintLeft_toLeftOf   当前控件的左侧与某个控件的左侧对齐\nlayout_constraintLeft_toRightOf  当前控件的左侧与某个控件的右侧对齐\nlayout_constraintRight_toLeftOf  当前控件的右侧与某个控件的左侧对齐\nlayout_constraintRight_toRightOf 当前控件的右侧与某个控件的右侧对齐\n\nlayout_constraintStart_toEndOf   同上\nlayout_constraintStart_toStartOf\nlayout_constraintEnd_toStartOf\nlayout_constraintEnd_toEndOf\n\nlayout_constraintTop_toTopOf       当前控件与某个控件顶端对齐\nlayout_constraintTop_toBottomOf    即当前控件某个控件的下面\nlayout_constraintBottom_toTopOf    即当前控件在某个控件的上面\nlayout_constraintBottom_toBottomOf 当前控件与某个控件底部对齐\n\nlayout_constraintBaseline_toBaselineOf 文本基线对齐\n</code></pre>\n<h5 id=\"具体示例\"><a href=\"#具体示例\" class=\"headerlink\" title=\"具体示例\"></a>具体示例</h5><pre><code class=\"xml\">&lt;!-- 居中对齐实现方式 --&gt;\n\n&lt;!-- 上下左右全部受 parent 约束，最后的效果就是「居中对齐」 --&gt;\n&lt;TextView\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;居中对齐&quot;\n    app:layout_constraintTop_toTopOf=&quot;parent&quot;\n    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n    app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;\n\n&lt;!-- 同理，左右受 parent 约束，效果就是「水平居中对齐」--&gt;\n&lt;TextView\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;水平居中对齐&quot;\n    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n    app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;\n\n&lt;!-- 同理，上下受 parent 约束，效果就是「垂直居中对齐」--&gt;\n&lt;TextView\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;垂直居中对齐&quot;\n    app:layout_constraintTop_toTopOf=&quot;parent&quot;\n    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&gt;\n</code></pre>\n<p>居中对齐很好理解，下边我们来写一个正常的 item 布局看看：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322142136.png\" alt=\"ConstraintLayout 实现的 item 布局\"></p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:padding=&quot;5dp&quot;&gt;\n\n    &lt;ImageView\n        android:id=&quot;@+id/iv_logo&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:background=&quot;@mipmap/ic_launcher&quot; /&gt;\n\n    &lt;!-- 设置标题名称 View 的左侧边缘位于 logo 的右侧 --&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_title&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_marginLeft=&quot;10dp&quot;\n        android:text=&quot;虾吃虾涮（华贸店）&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@+id/iv_logo&quot;\n        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;\n\n    &lt;!-- 设置价格 View 的底部靠近父布局，且顶部参考 titleView，同时左侧与 titleView 对齐 --&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_price&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;￥64/人&quot;\n        android:textSize=&quot;13sp&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;@id/tv_title&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_title&quot; /&gt;\n\n    &lt;!-- 设置 distanceView 紧贴屏幕右侧，且顶部与 priceView 对齐--&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_distance&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;1.1km&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toTopOf=&quot;@id/tv_price&quot; /&gt;\n\n    &lt;!-- 设置 areaView 顶部与左侧都参考 priceView，底部位置参考 ivLogo--&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_area&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;朝阳区 大望路&quot;\n        android:textSize=&quot;13sp&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;@id/iv_logo&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;@id/tv_price&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_price&quot; /&gt;\n\n    &lt;!-- 设置 hotView 紧贴屏幕右侧，且顶部与 areaView 顶部对齐--&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_curr_hot&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;当前人气89&quot;\n        android:textSize=&quot;13sp&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toTopOf=&quot;@id/tv_area&quot; /&gt;\n\n    &lt;!-- dividerView 位于整个布局的最底部，且始终位于 ivLogo 底部，并保持一定距离 --&gt;\n    &lt;View\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;1px&quot;\n        android:layout_marginTop=&quot;7dp&quot;\n        android:background=&quot;@android:color/darker_gray&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/iv_logo&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p>可以发现使用约束布局实现比普通的 RL 实现还要简单，界面完全实现扁平化，没有任何嵌套。如果使用 LL 或者 RL 来实现同样的效果，代码要复杂多少想必不用我多说。</p>\n<h4 id=\"Bias-偏向\"><a href=\"#Bias-偏向\" class=\"headerlink\" title=\"Bias 偏向\"></a>Bias 偏向</h4><p>以上的内容就是基本使用了，把上下左右各种参考、依赖关系搞明白，本身没有多么复杂，使用起来也和 RL 差不多，下面来介绍一些新花样。</p>\n<p><code>bias</code> 很好理解，正如其英文本意一样，它表达的是<strong>偏移</strong>。当某一布局同时受两个相反方向的约束力时，该布局就会处于约束它的那两个力量的正中央。而 <code>layout_constraintHorizontal_bias</code> 与 <code>layout_constraintVertical_bias</code> 就是用在这种时候，用来将某一方向的约束力减弱。来自两侧的约束力可以为 parent，也可以是普通 View。</p>\n<p>文字描述可能有点抽象，具体布局文件还是更好理解一些：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv1&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;this is a text&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv2&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;this is a text&quot;\n        app:layout_constraintHorizontal_bias=&quot;0.3&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/tv1&quot;\n        app:layout_constraintRight_toLeftOf=&quot;@id/tv3&quot; /&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv3&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;this is a text&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p>布局很简单，三个 TextView 并排显示，左右两个分别紧贴父布局，中间一个受左右两侧布局约束，本来应该是位于两个 TextView 正中央，但是由于设置了 <code>layout_constraintHorizontal_bias</code> 小于 0.5，所以最后效果中间的 TextView 整体偏向左侧，展示如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322145701.jpg\" alt=\"\"></p>\n<h4 id=\"Circle-布局\"><a href=\"#Circle-布局\" class=\"headerlink\" title=\"Circle 布局\"></a>Circle 布局</h4><p>这个看上去很厉害的！可以令 B 布局以 A 布局为圆心，然后用角度和半径距离来约束两个布局的位置。废话不多说，上图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322153304.jpg\" alt=\"\">这个也很好理解，主要有三个属性：</p>\n<pre><code>layout_constraintCircle ：      当前布局以哪个布局为圆心\nlayout_constraintCircleRadius ：半径\nlayout_constraintCircleAngle ： 摆放角度\n</code></pre><p>我反正是给谷歌跪了……</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_center&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toTopOf=&quot;parent&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n        android:text=&quot;Circle Center&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n    &lt;!-- 「测试布局」以 tv_center 为圆心，位于其 135° 方向的 100dp 处 --&gt;\n    &lt;TextView\n        android:text=&quot;测试布局&quot;\n        app:layout_constraintCircle=&quot;@id/tv_center&quot;\n        app:layout_constraintCircleAngle=&quot;135&quot;\n        app:layout_constraintCircleRadius=&quot;100dp&quot;\n        android:textColor=&quot;@android:color/black&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<h4 id=\"替代-MATCH-PARENT-的-MATCH-CONSTRAINT\"><a href=\"#替代-MATCH-PARENT-的-MATCH-CONSTRAINT\" class=\"headerlink\" title=\"替代 MATCH_PARENT 的 MATCH_CONSTRAINT\"></a>替代 MATCH_PARENT 的 MATCH_CONSTRAINT</h4><p>在约束布局中，由于布局受各方约束控制，也就没有所谓的「match_parent」了。随之而来的需求则是，左边有个布局约束我，右边还有个布局约束我，然后我就想充满剩余的全部位置，「match_constraint」也就应运而生了。</p>\n<p>说起来复杂，其实只需要把对应的 View 宽高设置为 0dp 即可，该 View 就会占据上剩余的所有可用空间。在这种情况下，谷歌给我们提供了几个额外的属性：</p>\n<pre><code>layout_constraintWidth_min   宽度最小值\nlayout_constraintHeight_min  高度最小值\n\nlayout_constraintWidth_max   宽度最大值\nlayout_constraintHeight_max  高度最大值\n\nlayout_constraintWidth_percent   宽度占剩余位置的百分比\nlayout_constraintHeight_percent  高度占剩余位置的百分比\n</code></pre><p>具体示例如下：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn1&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Test Button&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn2&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn3&quot;\n        android:layout_width=&quot;0dp&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constrainedWidth=&quot;true&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintWidth_min=&quot;wrap&quot;\n        app:layout_constraintWidth_max=&quot;wrap&quot;\n        app:layout_constraintWidth_percent=&quot;0.3&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/btn1&quot;\n        app:layout_constraintRight_toLeftOf=&quot;@id/btn2&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322163826.jpg\" alt=\"\"></p>\n<h4 id=\"Chains-链\"><a href=\"#Chains-链\" class=\"headerlink\" title=\"Chains 链\"></a>Chains 链</h4><p>如果几个不同的 View 两两发生关联，如下图，则这几个 View 构成了一个 Chains(链)。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322170158.jpg\" alt=\"\"></p>\n<p>具体布局代码如下：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn1&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n        app:layout_constraintRight_toLeftOf=&quot;@id/btn2&quot; /&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn2&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/btn1&quot;\n        app:layout_constraintRight_toLeftOf=&quot;@id/btn3&quot; /&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn3&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/btn2&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p>这样这三个 Button 就形成了一个横向的 Chain，在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果：</p>\n<p>该属性为：</p>\n<pre><code>layout_constraintHorizontal_chainStyle\nlayout_constraintVertical_chainStyle\n</code></pre><p>其取值可以为：spread、spread_inside、packed。</p>\n<p>具体样式展示如下：</p>\n<ol>\n<li>spread，基本上就是按照权重等分</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171443.jpg\" alt=\"\"></p>\n<ol>\n<li><p>spread_inside，也是等分展示，但是两侧吸附</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171444.jpg\" alt=\"\"></p>\n</li>\n<li><p>packed，整条链挤在一起，居中展示</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171442.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<p>官网有一个图来展示不同样式的 Chains，可以参考一下，也很形象：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322172439.jpg\" alt=\"\"></p>\n<h4 id=\"虚拟辅助视图\"><a href=\"#虚拟辅助视图\" class=\"headerlink\" title=\"虚拟辅助视图\"></a>虚拟辅助视图</h4><p>与以往的 ViewGroup 不同，ConstraintLayout 还提供了几种辅助页面绘制的布局，这种布局一般表现为引导线之类，不会在页面上绘制，但是可以通过占位的方式，成为不同布局的约束条件。</p>\n<h5 id=\"GuideLine\"><a href=\"#GuideLine\" class=\"headerlink\" title=\"GuideLine\"></a>GuideLine</h5><p>顾名思义，GuideLine 可以创建基于父布局 ConstraintLayout 的水平或者垂直准线，从而帮助开发者进行布局定位。</p>\n<p>这个布局有四个基本属性，依次为：</p>\n<pre><code class=\"xml\">orientation 如上所述，用来表示是垂直方向还是竖直方向\nlayout_constraintGuide_begin 距离父亲的起始位置\nlayout_constraintGuide_end 距离父亲的结束位置\nlayout_constraintGuide_percent 距离父亲的位置，用百分比表示\n\n经过试验，percent 优先级最高，其次是 begin，最后是 end，一般来讲使用 percent 就足够了\n</code></pre>\n<p>xml 以及对应的页面效果如下：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout                \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;!-- 假设说现在需要将 ImageView 摆放到右下角的位置，就可以使用 GL 辅助实现--&gt;\n    &lt;android.support.constraint.Guideline\n        android:id=&quot;@+id/gl_vertical&quot;\n        android:layout_width=&quot;0dp&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;\n        app:layout_constraintGuide_percent=&quot;0.8&quot;/&gt;\n\n    &lt;android.support.constraint.Guideline\n        android:id=&quot;@+id/gl_horizontal&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;0dp&quot;\n        android:orientation=&quot;horizontal&quot;\n        app:layout_constraintGuide_percent=&quot;0.8&quot; /&gt;\n\n    &lt;ImageView\n        android:src=&quot;@mipmap/ic_launcher&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/gl_vertical&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/gl_horizontal&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322174954.jpg\" alt=\"\"></p>\n<h5 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h5><p>与 GuideLine 差不多，但是比它更灵活，可以用来约束多个布局，且自动匹配最大最小值进行约束。</p>\n<p>Barrier 有两个基本属性：</p>\n<ul>\n<li><p>barrierDirection</p>\n<blockquote>\n<p> 取值可为 top, bottom, left, right, start, end</p>\n</blockquote>\n<p>用于约定栅栏拦截的 View 方向，假设说要拦截的 View 在右侧，这个属性就应该为 right 或者 end</p>\n</li>\n<li><p>constraint_referenced_ids</p>\n<p>被栅栏保护，屏蔽起来的 View 集合，直接输入 viewId，用逗号分隔即可；barrier 会根据宽度或者高度最大的那个 View 来设置栅栏的边界</p>\n</li>\n</ul>\n<p>可能会有些抽象，我们在开发时可能会遇到一种比较蛋疼的需求：</p>\n<blockquote>\n<p>姓名、性别、出生日期、手机号等字段从上到下一字排开，但是每个字段对应的值要保证彼此左侧对齐</p>\n</blockquote>\n<p>讲道理以前这种布局我一直不知道怎么画，但是现在有了 <code>barrier</code> 以后这问题就迎刃而解了。我们可以用 barrier 将左侧的那些字段与右侧的值拦截开，barrier 会自动识别最宽的那个字段，并将之作为 barrier 的宽度，之后每个值都用 barrier 来制造约束就可以了。</p>\n<pre><code class=\"XML\">&lt;android.support.constraint.ConstraintLayout \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:padding=&quot;10dp&quot;&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_name&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;姓名:&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_gender&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_name&quot;\n        android:text=&quot;性别:&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_phone&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_gender&quot;\n        android:text=&quot;手机号:&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_birthday&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_phone&quot;\n        android:text=&quot;出生日期:&quot;/&gt;\n\n    &lt;android.support.constraint.Barrier\n        android:id=&quot;@+id/barrier&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:barrierDirection=&quot;end&quot;\n        app:constraint_referenced_ids=&quot;tv_name,tv_phone,tv_gender,tv_birthday&quot;/&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;\n        android:text=&quot;易烊千玺&quot;/&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_name&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;\n        android:text=&quot;男&quot;/&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_gender&quot;\n        android:text=&quot;13800138000&quot;/&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_phone&quot;\n        android:text=&quot;2000年1月1日&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p>显示效果如图，很完美有没有？</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322182306.jpg\" alt=\"\"></p>\n<h5 id=\"Group\"><a href=\"#Group\" class=\"headerlink\" title=\"Group\"></a>Group</h5><p>Group 是一个组，用来批量控制 View 的显示与隐藏；但是注意这不是个 ViewGroup，它只是一个不执行绘制的 View，和 barrier 一样，它有一个 constraint_referenced_ids 的属性，可以将需要隐藏的 ViewId 丢进去，在需要的时候将其批量隐藏即可。</p>\n<p>还通过上面的例子，假设现在要把性别一栏隐藏掉：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.Group\n    app:constraint_referenced_ids=&quot;tv_gender,tv_sex_value&quot;\n    android:visibility=&quot;gone&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot; /&gt;\n</code></pre>\n<p>通过将性别的 key 和 value 的 id 都放进去，将其设置为 gone，则可以将该组实现隐藏：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322183030.jpg\" alt=\"\"></p>\n<p>但是，使用 Group 控制可见性是有坑的：</p>\n<blockquote>\n<ol>\n<li><p>和以前用的ViewGroup有一点不同，以前用ViewGroup约束View的时候，外层ViewGroup设置成可见，里层View设置成不可见是可以生效的，但是用Group就不能。Group约束的元素的可见性始终一致。</p>\n</li>\n<li><p>调用Group的setVisibility方法不会立即对它约束对子View生效，而是要等到Group所在的ConstrainLayout调用preLayout方法时才会生效。preLayout只有在第一次layout和布局发生变化时才会调用。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"Optimizer优化\"><a href=\"#Optimizer优化\" class=\"headerlink\" title=\"Optimizer优化\"></a>Optimizer优化</h4><p>可以通过将标签app：layout_optimizationLevel元素添加到 ConstraintLayout 来决定应用哪些优化</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    app:layout_optimizationLevel=&quot;standard|dimensions|chains&quot;/&gt;\n</code></pre>\n<ul>\n<li>none： 不执行优化</li>\n<li>standard： 默认，仅优化直接和障碍约束</li>\n<li>direct： 优化直接约束</li>\n<li>barrier： 优化障碍约束</li>\n<li>chain：优化链条约束</li>\n<li>dimensions：优化维度测量，减少匹配约束元素的度量数量</li>\n</ul>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><ul>\n<li><a href=\"https://juejin.im/post/5c0bd6b05188257c3045dc50#heading-7\" target=\"_blank\" rel=\"noopener\">ConstraintLayout 全解析</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/vI-fPaNoJ7ZBlZcMkEGdLQ\" target=\"_blank\" rel=\"noopener\">拒绝拖拽 使用ConstraintLayout优化你的布局吧</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>不知道从什么时候开始，Android 死丢丢已经默认使用约束布局 ConstraintLayout 作为默认布局了，但是懒癌发作一直不想学习，每次都换成 LinearLayout，这次也忘记了为啥开始学习这个东西，学完发现还挺爽……写个笔记记录一下，哈哈</p>","more":"<p>正文开始~</p>\n<h4 id=\"相对布局\"><a href=\"#相对布局\" class=\"headerlink\" title=\"相对布局\"></a>相对布局</h4><h5 id=\"属性集合\"><a href=\"#属性集合\" class=\"headerlink\" title=\"属性集合\"></a>属性集合</h5><p>类似 RelativeLayout ，使用相对位置的属性来互相约束位置。具体的属性以及使用方式也类似 RelativeLayout，默认像 FrameLayout 一样堆叠在一起，使用属性讲层级关系区分开：</p>\n<pre><code class=\"xml\">layout_constraintLeft_toLeftOf   当前控件的左侧与某个控件的左侧对齐\nlayout_constraintLeft_toRightOf  当前控件的左侧与某个控件的右侧对齐\nlayout_constraintRight_toLeftOf  当前控件的右侧与某个控件的左侧对齐\nlayout_constraintRight_toRightOf 当前控件的右侧与某个控件的右侧对齐\n\nlayout_constraintStart_toEndOf   同上\nlayout_constraintStart_toStartOf\nlayout_constraintEnd_toStartOf\nlayout_constraintEnd_toEndOf\n\nlayout_constraintTop_toTopOf       当前控件与某个控件顶端对齐\nlayout_constraintTop_toBottomOf    即当前控件某个控件的下面\nlayout_constraintBottom_toTopOf    即当前控件在某个控件的上面\nlayout_constraintBottom_toBottomOf 当前控件与某个控件底部对齐\n\nlayout_constraintBaseline_toBaselineOf 文本基线对齐\n</code></pre>\n<h5 id=\"具体示例\"><a href=\"#具体示例\" class=\"headerlink\" title=\"具体示例\"></a>具体示例</h5><pre><code class=\"xml\">&lt;!-- 居中对齐实现方式 --&gt;\n\n&lt;!-- 上下左右全部受 parent 约束，最后的效果就是「居中对齐」 --&gt;\n&lt;TextView\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;居中对齐&quot;\n    app:layout_constraintTop_toTopOf=&quot;parent&quot;\n    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n    app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;\n\n&lt;!-- 同理，左右受 parent 约束，效果就是「水平居中对齐」--&gt;\n&lt;TextView\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;水平居中对齐&quot;\n    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n    app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;\n\n&lt;!-- 同理，上下受 parent 约束，效果就是「垂直居中对齐」--&gt;\n&lt;TextView\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;垂直居中对齐&quot;\n    app:layout_constraintTop_toTopOf=&quot;parent&quot;\n    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&gt;\n</code></pre>\n<p>居中对齐很好理解，下边我们来写一个正常的 item 布局看看：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322142136.png\" alt=\"ConstraintLayout 实现的 item 布局\"></p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:padding=&quot;5dp&quot;&gt;\n\n    &lt;ImageView\n        android:id=&quot;@+id/iv_logo&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:background=&quot;@mipmap/ic_launcher&quot; /&gt;\n\n    &lt;!-- 设置标题名称 View 的左侧边缘位于 logo 的右侧 --&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_title&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_marginLeft=&quot;10dp&quot;\n        android:text=&quot;虾吃虾涮（华贸店）&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@+id/iv_logo&quot;\n        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;\n\n    &lt;!-- 设置价格 View 的底部靠近父布局，且顶部参考 titleView，同时左侧与 titleView 对齐 --&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_price&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;￥64/人&quot;\n        android:textSize=&quot;13sp&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;@id/tv_title&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_title&quot; /&gt;\n\n    &lt;!-- 设置 distanceView 紧贴屏幕右侧，且顶部与 priceView 对齐--&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_distance&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;1.1km&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toTopOf=&quot;@id/tv_price&quot; /&gt;\n\n    &lt;!-- 设置 areaView 顶部与左侧都参考 priceView，底部位置参考 ivLogo--&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_area&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;朝阳区 大望路&quot;\n        android:textSize=&quot;13sp&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;@id/iv_logo&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;@id/tv_price&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_price&quot; /&gt;\n\n    &lt;!-- 设置 hotView 紧贴屏幕右侧，且顶部与 areaView 顶部对齐--&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tv_curr_hot&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;当前人气89&quot;\n        android:textSize=&quot;13sp&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toTopOf=&quot;@id/tv_area&quot; /&gt;\n\n    &lt;!-- dividerView 位于整个布局的最底部，且始终位于 ivLogo 底部，并保持一定距离 --&gt;\n    &lt;View\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;1px&quot;\n        android:layout_marginTop=&quot;7dp&quot;\n        android:background=&quot;@android:color/darker_gray&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/iv_logo&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p>可以发现使用约束布局实现比普通的 RL 实现还要简单，界面完全实现扁平化，没有任何嵌套。如果使用 LL 或者 RL 来实现同样的效果，代码要复杂多少想必不用我多说。</p>\n<h4 id=\"Bias-偏向\"><a href=\"#Bias-偏向\" class=\"headerlink\" title=\"Bias 偏向\"></a>Bias 偏向</h4><p>以上的内容就是基本使用了，把上下左右各种参考、依赖关系搞明白，本身没有多么复杂，使用起来也和 RL 差不多，下面来介绍一些新花样。</p>\n<p><code>bias</code> 很好理解，正如其英文本意一样，它表达的是<strong>偏移</strong>。当某一布局同时受两个相反方向的约束力时，该布局就会处于约束它的那两个力量的正中央。而 <code>layout_constraintHorizontal_bias</code> 与 <code>layout_constraintVertical_bias</code> 就是用在这种时候，用来将某一方向的约束力减弱。来自两侧的约束力可以为 parent，也可以是普通 View。</p>\n<p>文字描述可能有点抽象，具体布局文件还是更好理解一些：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv1&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;this is a text&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv2&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;this is a text&quot;\n        app:layout_constraintHorizontal_bias=&quot;0.3&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/tv1&quot;\n        app:layout_constraintRight_toLeftOf=&quot;@id/tv3&quot; /&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv3&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;this is a text&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p>布局很简单，三个 TextView 并排显示，左右两个分别紧贴父布局，中间一个受左右两侧布局约束，本来应该是位于两个 TextView 正中央，但是由于设置了 <code>layout_constraintHorizontal_bias</code> 小于 0.5，所以最后效果中间的 TextView 整体偏向左侧，展示如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322145701.jpg\" alt=\"\"></p>\n<h4 id=\"Circle-布局\"><a href=\"#Circle-布局\" class=\"headerlink\" title=\"Circle 布局\"></a>Circle 布局</h4><p>这个看上去很厉害的！可以令 B 布局以 A 布局为圆心，然后用角度和半径距离来约束两个布局的位置。废话不多说，上图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322153304.jpg\" alt=\"\">这个也很好理解，主要有三个属性：</p>\n<pre><code>layout_constraintCircle ：      当前布局以哪个布局为圆心\nlayout_constraintCircleRadius ：半径\nlayout_constraintCircleAngle ： 摆放角度\n</code></pre><p>我反正是给谷歌跪了……</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_center&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toTopOf=&quot;parent&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n        android:text=&quot;Circle Center&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n    &lt;!-- 「测试布局」以 tv_center 为圆心，位于其 135° 方向的 100dp 处 --&gt;\n    &lt;TextView\n        android:text=&quot;测试布局&quot;\n        app:layout_constraintCircle=&quot;@id/tv_center&quot;\n        app:layout_constraintCircleAngle=&quot;135&quot;\n        app:layout_constraintCircleRadius=&quot;100dp&quot;\n        android:textColor=&quot;@android:color/black&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<h4 id=\"替代-MATCH-PARENT-的-MATCH-CONSTRAINT\"><a href=\"#替代-MATCH-PARENT-的-MATCH-CONSTRAINT\" class=\"headerlink\" title=\"替代 MATCH_PARENT 的 MATCH_CONSTRAINT\"></a>替代 MATCH_PARENT 的 MATCH_CONSTRAINT</h4><p>在约束布局中，由于布局受各方约束控制，也就没有所谓的「match_parent」了。随之而来的需求则是，左边有个布局约束我，右边还有个布局约束我，然后我就想充满剩余的全部位置，「match_constraint」也就应运而生了。</p>\n<p>说起来复杂，其实只需要把对应的 View 宽高设置为 0dp 即可，该 View 就会占据上剩余的所有可用空间。在这种情况下，谷歌给我们提供了几个额外的属性：</p>\n<pre><code>layout_constraintWidth_min   宽度最小值\nlayout_constraintHeight_min  高度最小值\n\nlayout_constraintWidth_max   宽度最大值\nlayout_constraintHeight_max  高度最大值\n\nlayout_constraintWidth_percent   宽度占剩余位置的百分比\nlayout_constraintHeight_percent  高度占剩余位置的百分比\n</code></pre><p>具体示例如下：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn1&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Test Button&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn2&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn3&quot;\n        android:layout_width=&quot;0dp&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constrainedWidth=&quot;true&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintWidth_min=&quot;wrap&quot;\n        app:layout_constraintWidth_max=&quot;wrap&quot;\n        app:layout_constraintWidth_percent=&quot;0.3&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/btn1&quot;\n        app:layout_constraintRight_toLeftOf=&quot;@id/btn2&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322163826.jpg\" alt=\"\"></p>\n<h4 id=\"Chains-链\"><a href=\"#Chains-链\" class=\"headerlink\" title=\"Chains 链\"></a>Chains 链</h4><p>如果几个不同的 View 两两发生关联，如下图，则这几个 View 构成了一个 Chains(链)。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322170158.jpg\" alt=\"\"></p>\n<p>具体布局代码如下：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn1&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;\n        app:layout_constraintRight_toLeftOf=&quot;@id/btn2&quot; /&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn2&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/btn1&quot;\n        app:layout_constraintRight_toLeftOf=&quot;@id/btn3&quot; /&gt;\n\n    &lt;Button\n        android:id=&quot;@+id/btn3&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;Button&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/btn2&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p>这样这三个 Button 就形成了一个横向的 Chain，在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果：</p>\n<p>该属性为：</p>\n<pre><code>layout_constraintHorizontal_chainStyle\nlayout_constraintVertical_chainStyle\n</code></pre><p>其取值可以为：spread、spread_inside、packed。</p>\n<p>具体样式展示如下：</p>\n<ol>\n<li>spread，基本上就是按照权重等分</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171443.jpg\" alt=\"\"></p>\n<ol>\n<li><p>spread_inside，也是等分展示，但是两侧吸附</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171444.jpg\" alt=\"\"></p>\n</li>\n<li><p>packed，整条链挤在一起，居中展示</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171442.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<p>官网有一个图来展示不同样式的 Chains，可以参考一下，也很形象：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322172439.jpg\" alt=\"\"></p>\n<h4 id=\"虚拟辅助视图\"><a href=\"#虚拟辅助视图\" class=\"headerlink\" title=\"虚拟辅助视图\"></a>虚拟辅助视图</h4><p>与以往的 ViewGroup 不同，ConstraintLayout 还提供了几种辅助页面绘制的布局，这种布局一般表现为引导线之类，不会在页面上绘制，但是可以通过占位的方式，成为不同布局的约束条件。</p>\n<h5 id=\"GuideLine\"><a href=\"#GuideLine\" class=\"headerlink\" title=\"GuideLine\"></a>GuideLine</h5><p>顾名思义，GuideLine 可以创建基于父布局 ConstraintLayout 的水平或者垂直准线，从而帮助开发者进行布局定位。</p>\n<p>这个布局有四个基本属性，依次为：</p>\n<pre><code class=\"xml\">orientation 如上所述，用来表示是垂直方向还是竖直方向\nlayout_constraintGuide_begin 距离父亲的起始位置\nlayout_constraintGuide_end 距离父亲的结束位置\nlayout_constraintGuide_percent 距离父亲的位置，用百分比表示\n\n经过试验，percent 优先级最高，其次是 begin，最后是 end，一般来讲使用 percent 就足够了\n</code></pre>\n<p>xml 以及对应的页面效果如下：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout                \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;!-- 假设说现在需要将 ImageView 摆放到右下角的位置，就可以使用 GL 辅助实现--&gt;\n    &lt;android.support.constraint.Guideline\n        android:id=&quot;@+id/gl_vertical&quot;\n        android:layout_width=&quot;0dp&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;\n        app:layout_constraintGuide_percent=&quot;0.8&quot;/&gt;\n\n    &lt;android.support.constraint.Guideline\n        android:id=&quot;@+id/gl_horizontal&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;0dp&quot;\n        android:orientation=&quot;horizontal&quot;\n        app:layout_constraintGuide_percent=&quot;0.8&quot; /&gt;\n\n    &lt;ImageView\n        android:src=&quot;@mipmap/ic_launcher&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/gl_vertical&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/gl_horizontal&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322174954.jpg\" alt=\"\"></p>\n<h5 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h5><p>与 GuideLine 差不多，但是比它更灵活，可以用来约束多个布局，且自动匹配最大最小值进行约束。</p>\n<p>Barrier 有两个基本属性：</p>\n<ul>\n<li><p>barrierDirection</p>\n<blockquote>\n<p> 取值可为 top, bottom, left, right, start, end</p>\n</blockquote>\n<p>用于约定栅栏拦截的 View 方向，假设说要拦截的 View 在右侧，这个属性就应该为 right 或者 end</p>\n</li>\n<li><p>constraint_referenced_ids</p>\n<p>被栅栏保护，屏蔽起来的 View 集合，直接输入 viewId，用逗号分隔即可；barrier 会根据宽度或者高度最大的那个 View 来设置栅栏的边界</p>\n</li>\n</ul>\n<p>可能会有些抽象，我们在开发时可能会遇到一种比较蛋疼的需求：</p>\n<blockquote>\n<p>姓名、性别、出生日期、手机号等字段从上到下一字排开，但是每个字段对应的值要保证彼此左侧对齐</p>\n</blockquote>\n<p>讲道理以前这种布局我一直不知道怎么画，但是现在有了 <code>barrier</code> 以后这问题就迎刃而解了。我们可以用 barrier 将左侧的那些字段与右侧的值拦截开，barrier 会自动识别最宽的那个字段，并将之作为 barrier 的宽度，之后每个值都用 barrier 来制造约束就可以了。</p>\n<pre><code class=\"XML\">&lt;android.support.constraint.ConstraintLayout \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:padding=&quot;10dp&quot;&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_name&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;姓名:&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_gender&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_name&quot;\n        android:text=&quot;性别:&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_phone&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_gender&quot;\n        android:text=&quot;手机号:&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/tv_birthday&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_phone&quot;\n        android:text=&quot;出生日期:&quot;/&gt;\n\n    &lt;android.support.constraint.Barrier\n        android:id=&quot;@+id/barrier&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:barrierDirection=&quot;end&quot;\n        app:constraint_referenced_ids=&quot;tv_name,tv_phone,tv_gender,tv_birthday&quot;/&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;\n        android:text=&quot;易烊千玺&quot;/&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_name&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;\n        android:text=&quot;男&quot;/&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_gender&quot;\n        android:text=&quot;13800138000&quot;/&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;\n        app:layout_constraintTop_toBottomOf=&quot;@id/tv_phone&quot;\n        android:text=&quot;2000年1月1日&quot; /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p>显示效果如图，很完美有没有？</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322182306.jpg\" alt=\"\"></p>\n<h5 id=\"Group\"><a href=\"#Group\" class=\"headerlink\" title=\"Group\"></a>Group</h5><p>Group 是一个组，用来批量控制 View 的显示与隐藏；但是注意这不是个 ViewGroup，它只是一个不执行绘制的 View，和 barrier 一样，它有一个 constraint_referenced_ids 的属性，可以将需要隐藏的 ViewId 丢进去，在需要的时候将其批量隐藏即可。</p>\n<p>还通过上面的例子，假设现在要把性别一栏隐藏掉：</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.Group\n    app:constraint_referenced_ids=&quot;tv_gender,tv_sex_value&quot;\n    android:visibility=&quot;gone&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot; /&gt;\n</code></pre>\n<p>通过将性别的 key 和 value 的 id 都放进去，将其设置为 gone，则可以将该组实现隐藏：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322183030.jpg\" alt=\"\"></p>\n<p>但是，使用 Group 控制可见性是有坑的：</p>\n<blockquote>\n<ol>\n<li><p>和以前用的ViewGroup有一点不同，以前用ViewGroup约束View的时候，外层ViewGroup设置成可见，里层View设置成不可见是可以生效的，但是用Group就不能。Group约束的元素的可见性始终一致。</p>\n</li>\n<li><p>调用Group的setVisibility方法不会立即对它约束对子View生效，而是要等到Group所在的ConstrainLayout调用preLayout方法时才会生效。preLayout只有在第一次layout和布局发生变化时才会调用。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"Optimizer优化\"><a href=\"#Optimizer优化\" class=\"headerlink\" title=\"Optimizer优化\"></a>Optimizer优化</h4><p>可以通过将标签app：layout_optimizationLevel元素添加到 ConstraintLayout 来决定应用哪些优化</p>\n<pre><code class=\"xml\">&lt;android.support.constraint.ConstraintLayout \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    app:layout_optimizationLevel=&quot;standard|dimensions|chains&quot;/&gt;\n</code></pre>\n<ul>\n<li>none： 不执行优化</li>\n<li>standard： 默认，仅优化直接和障碍约束</li>\n<li>direct： 优化直接约束</li>\n<li>barrier： 优化障碍约束</li>\n<li>chain：优化链条约束</li>\n<li>dimensions：优化维度测量，减少匹配约束元素的度量数量</li>\n</ul>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><ul>\n<li><a href=\"https://juejin.im/post/5c0bd6b05188257c3045dc50#heading-7\" target=\"_blank\" rel=\"noopener\">ConstraintLayout 全解析</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/vI-fPaNoJ7ZBlZcMkEGdLQ\" target=\"_blank\" rel=\"noopener\">拒绝拖拽 使用ConstraintLayout优化你的布局吧</a></li>\n</ul>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181407.jpg","title":"Android View.post 浅析","date":"2018-08-13T16:00:00.000Z","_content":"\n> 研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……\n\n<!-- more -->\n\n### 序\n\n之前的文章里写到过，我们在 onCreate() 和 onResume() 方法中无法获取 View 的宽高信息，但在平时开发中，我们经常会用到 View#post 来进行 View 宽高信息的获取。\n\n那么问题就来了，为什么 View#post 就可以获取到宽高信息？里边那个 run() 是在什么时候执行的？具体实现原理又是什么？\n\n带着这些疑问，我最近研究了一下 View#post 的源码。本来以为挺简单的一个东西，但是没想到坑越挖越深，最过分的是，不同的版本源码还不相同，实现原理也有细微的差别。集中攻克了一个周末以后，感觉大概理解了，索性写下篇博客进行记录备忘。\n\n文章大概分为以下几个方面：\n\n- View#post 基本使用\n- post() 执行过程以及源码分析\n- post() 中 Runnable#run 执行的时机\n- View#post 整体流程的简单总结\n- Android 7.0 里 View#post 的变动以及原因\n- 致谢\n\n### View#post 基本使用\n\n具体代码如下：\n\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    View view = findViewById(R.id.test);\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            // 可以正常获取到 View 的宽高信息\n            Log.e(\"Test\", \"view.post ---- > \" + view.getHeight());\n        }\n    });\n}\n```\n\n这里我们以 API 26 为例，来尝试解答一下这个问题。\n\n实际上，Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别，具体的改动以及原因在后文会一一给出分析。\n\n\n\n### post() 执行过程以及源码分析\n\n#### 1. View#post 入口\n先来看 View#post 源码，重点注意注释：\n\n```java\n/**\n * Causes the Runnable to be added to the message queue.\n * The runnable will be run on the user interface thread.\n * 将 Runnable 添加到执行队列中，其最终会在 UI 线程中执行\n */\npublic boolean post(Runnable action) {\n    // AttachInfo 是 View 的内部类，用来存储一些基本信息\n    // 此处可以暂时认为 mAttachInfo 为 null\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        // attachInfo 不为空时，转而使用其内部的 Handler 对象操作\n        return attachInfo.mHandler.post(action);\n    }\n\n    // Postpone the runnable until we know on which thread it needs to run.\n    // Assume that the runnable will be successfully placed after attach.\n    // 在我们确定当前 Runnable 的目标运行线程之前，先将其推迟执行\n    // 假设在 attach 完成之后，此 Runnable 对象会被成功的「placed」（暂且翻译成「放置」）\n    // 好好理解一下这个注释，我们继续往下走\n    getRunQueue().post(action);\n    return true;\n}\n```\n\n首先，明确一点：**Runnable 会在 UI 线程中执行**；\n\n然后，我们来看一下这个看上去很重要的 **mAttachInfo** 是在哪里赋值的：\n\n```java\nvoid dispatchAttachedToWindow(AttachInfo info, int visibility) {\n    mAttachInfo = info;\n    // Transfer all pending runnables. 转移所有待办任务\n    if (mRunQueue != null) {\n        mRunQueue.executeActions(info.mHandler);\n        mRunQueue = null;\n    }\n    // 回调方法\n    onAttachedToWindow();\n}\n```\n\n先不在意除了赋值以外的其他操作，我们继续追踪 dispatchAttachedToWindow 方法，发现其最初调用是在 ViewRootImpl#performTraversals 方法。好了，记住这个结论，我们先把它放在一旁。\n\n接下来，我们来看一看这个 **getRunQueue().post()** 又做了什么：\n\n```java\n/**\n * 获取一个 RunQueue 对象，用来进行 post 操作\n * Returns the queue of runnable for this view.\n * 注释是：为当前 View 对象返回一个执行队列，记住这个「当前 View 对象」\n */\nprivate HandlerActionQueue getRunQueue() {\n    if (mRunQueue == null) {\n        mRunQueue = new HandlerActionQueue();\n    }\n    return mRunQueue;\n}\n```\n\n\n\n#### 2. HandlerActionQueue 又是个啥\n\n很明显，执行 post 方法的是 HandlerActionQueue 对象，那这又是个什么东西：\n\n```java\n/**\n * Class used to enqueue pending work from Views when no Handler is attached.\n * 此类用于在当前 View 没有 Handler 依附的时候，将其待完成的任务入队\n */\npublic class HandlerActionQueue {\n    private HandlerAction[] mActions;\n    private int mCount;\n\n    // 这个就是我们在外边调用的 post 方法，最终会调用到 postDelayed 方法\n    public void post(Runnable action) {\n        postDelayed(action, 0);\n    }\n\n    // 将传入的 Runnable 对象存入数组中，等待调用\n    public void postDelayed(Runnable action, long delayMillis) {\n        final HandlerAction handlerAction = new HandlerAction(action, delayMillis);\n\n        synchronized (this) {\n            if (mActions == null) {\n                mActions = new HandlerAction[4];\n            }\n            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);\n            mCount++;\n        }\n    }\n\n    // 这里才是真的执行方法\n    public void executeActions(Handler handler) {\n        synchronized (this) {\n            final HandlerAction[] actions = mActions;\n            for (int i = 0, count = mCount; i < count; i++) {\n                final HandlerAction handlerAction = actions[i];\n                handler.postDelayed(handlerAction.action, handlerAction.delay);\n            }\n\n            mActions = null;\n            mCount = 0;\n        }\n    }\n}\n```\n\n通过查看 HandlerActionQueue 的源码，我们发现了一个问题：不同于在 onCreate() 直接获取 View 的宽高，我们调用 post 方法，其中的 run 方法并没有被马上执行。\n\n这样就不难解释为什么用这种方式可以获取到宽高了。那我们可以猜测一下，这种情况下，一定是 View 完成测量后才执行了这个方法，所以我们才可以拿到宽高信息。\n\n事实上也正是这样的，那么这个方法到底是在什么时候执行的呢？很明显，HandlerActionQueue#executeActions 才是真正完成调用的方法，那这个方法又做了些什么工作呢？\n\n**根据代码可知，该方法接收一个 Handler，然后使用这个 Handler 对当前队列中的所有 Runnable 进行处理，即 post 到该 Handler 的线程中，按照优先级对这些 Runnable 依次进行处理。**\n\n**简单来说，就是传入的 Handler 决定着这些 Runnable 的执行线程。**\n\n接下来，我们来追踪这个方法的调用情况。\n\n![executeActions() 的调用情况](http://upload-images.jianshu.io/upload_images/5419805-e0cf86fbea081bc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们注意到，对于该方法出现了两次调用，一次在 View#dispatchAttachToWindow（就是我们最开始找到的那个方法），另一次是在 ViewRootImpl#performTraversals。\n\n#### 3. 万恶之源 performTraversals()\n\n很明显，所有的证据都指向了 performTraversals ，那么下面我们就来重点分析一下这个方法。\n\n如果你了解过 View 的测绘流程，那你对这个方法一定不会陌生，因为这个方法就是 View 绘制流程的起点。\n\n```java\nprivate void performTraversals() {\n    \n    // 此处的 host 是根布局 DecorView，用递归的方式一层一层的调用 dispatchAttachedToWindow\n    // mAttachInfo 是不是很眼熟，就是最开始 View#post 的第一层判断\n    // 这个 mAttachInfo 在 ViewRootImpl 的构造器中初始化的，其持有 ViewRootImpl 的 Handler 对象\n    host.dispatchAttachedToWindow(mAttachInfo, 0);\n    getRunQueue().executeActions(mAttachInfo.mHandler);\n    \n    // 绘制流程就从这里开始\n    performMeasure();\n    performLayout();\n    performDraw();\n}\n```\n\n我们先从 dispatchAttachedToWindow 开始，我们之前已经看过这个方法的源码了：\n\n```java\nvoid dispatchAttachedToWindow(AttachInfo info, int visibility) {\n    mAttachInfo = info;\n    // Transfer all pending runnables. 转移所有待办任务\n    if (mRunQueue != null) {\n        mRunQueue.executeActions(info.mHandler);\n        mRunQueue = null;\n    }\n    // 回调方法\n    onAttachedToWindow();\n}\n```\n**现在来进行分析：**\n\n1. 我们已经知道了此方法是从根视图开始递归向下调用的，那么递归到最深处，就会轮到最开始我们调用 post 方法的 View 对象来执行该方法，也就是该方法内的所有属性，都是我们 findViewById 获得的那个 View 对象的属性；\n2. 而且我们也知道，第一个参数 AttachInfo 就是 ViewRootImpl 中初始化的 AttachInfo，它持有当前 ViewRootImpl 的 Handler 对象引用，并将该引用传给了 executeActions()。此时，我们再来回顾一下 **executeActions()** 方法的作用，**传入的 Handler 决定着队列里这些 Runnable 的执行线程**。\n\n\n很明显，此处的 mRunQueue 就是我们最开始调用 post() 时，调用 View#getRunQueue 返回的那个对象，这个对象中有准备获取View高度的 Runnable 对象，也就是说 **mRunQueue 通过调用 executeActions() 将当前 View 的所有 Runnable ，都会转由 ViewRootImpl 的 Handler 来处理！**而在完成这个工作之后，当前 View 也显示地将 mRunQueue 置空，因为所有的待办任务都已经交给 ViewRootImpl 去处理了。\n\n现在再回过头看代码的注释，就差不多可以理解了：\n\n```java\n// Postpone the runnable until we know on which thread it needs to run.\n// Assume that the runnable will be successfully placed after attach.\n// 所有的 Runnable 都会在 attach 之后被正确的放到其应该运行的线程上去\ngetRunQueue().post(action);\n\n// Transfer all pending runnables.\n// 转移所有待办任务(到 ViewRootImpl 中进行处理)\nif (mRunQueue != null) {\n    mRunQueue.executeActions(info.mHandler);\n    mRunQueue = null;\n}\n```\n\ndispatch 方法执行完了，我们继续回来走 performTraversals() ，接下来一句是：\n\n```java\n// 有之前的经验，我们知道这句话的意思是\n// 使用 mAttachInfo.mHandler 来处理 getRunQueue() 中的 Runnable 任务\ngetRunQueue().executeActions(mAttachInfo.mHandler);\n```\n\n要明确的一点是，此时我们处在 ViewRootImpl 类中，此处的 getRunQueue() 方法有别于 View#post：\n\n```java\n// ViewRootImpl#getRunQueue\n// 使用 ThreadLocal 来存储每个线程自身的执行队列 HandlerActionQueue\nstatic HandlerActionQueue getRunQueue() {\n    // sRunQueues 是 ThreadLocal<HandlerActionQueue> 对象\n    HandlerActionQueue rq = sRunQueues.get();\n    if (rq != null) {\n        return rq;\n    }\n    rq = new HandlerActionQueue();\n    sRunQueues.set(rq);\n    return rq;\n}\n\n// View#post\n// 为当前 View 返回一个执行队列，但是在 dispatchAttachToWindow 时转到 UI 线程去\nprivate HandlerActionQueue getRunQueue() {\n    if (mRunQueue == null) {\n        mRunQueue = new HandlerActionQueue();\n    }\n    return mRunQueue;\n}\n```\n\n说回 performTraversals() ，很明显 getRunQueue() 是 UI 线程执行队列的第一次初始化，也就是说当前这个任务队列里并没有待执行任务！\n\n但是需要注意的是，**当前没有执行任务（**HandlerActionQueue**），不代表 Handler 消息队列中没有消息**，这是两个概念，需要注意区分开。\n\n总结一下：\n\n1. View#post 方法调用时，会为当前 View 对象初始化一个 HandlerActionQueue ，并将 Runnable 入队存储；\n2. 等在 ViewRootImpl#performTraversals 中递归调用到 View#dispatchAttachedToWindow 时，会将 ViewRootImpl 的 Handler 对象传下来，然后通过这个 Handler 将最初的 Runnable 发送到 UI 线程（消息队列中）等待执行，并将 View 的 HandlerActionQueue 对象置空，方便回收；\n3. ViewRootImpl#performTraversals 继续执行，才会为 UI 线程首次初始化 HandlerActionQueue 对象，并通过 ThreadLocal 进行存储，方便之后的复用，但需要注意的是，此处初始化的队列中是没有任何 Runnable 对象的；\n4. 然后 ViewRootImpl#performTraversals 继续执行，开始 View 的测量流程。\n\n\n\n### View#post 中 Runnable#run 执行的时机\n\n但现在的问题是，无论怎么说，**HandlerActionQueue#executeActions 都是先于 View 测绘流程的**，为什么在还没有完成测量的时候，就可以拿到宽高信息？\n\n我们都知道，Android 系统是基于消息机制运行的，所有的事件、行为，都是基于 Handler 消息机制在运行的。所以，当 ViewRootImpl#performTraversals 在执行的时候，也一定是基于某个消息的。而且，HandlerActionQueue#executeActions 执行的时候，也只是通过 Handler 将 Runnable post 到了 UI 线程等待执行（还记得 View#post 的注释吗？）。\n\n不出意外的话，此时 UI 线程正忙着执行 ViewRootImpl#performTraversal ，等该方法执行完毕，View 已经完成了测量流程，此时再去执行 Runnable#run ，也就自然可以获取到 View 的宽高信息了。\n\n下面用具体的实例佐证一下我们的猜想。\n\n```JAVA\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    final ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();\n\n    // 等待 Add 到父布局中\n    view = new View(this) {\n        @Override\n        protected void onLayout( ... ... ) {\n            super.onLayout(changed, left, top, right, bottom);\n            Log.e(\"Test\", \"执行了onLayout()\");\n        }\n    };\n\n    // 自己声明的 Handler \n    mHandler.post(new Runnable() {\n        @Override\n        public void run() {\n            Log.e(\"Test\", \"mHandler.post ---- > \" + view.getHeight());\n        }\n    });\n\n    // onCreate() 中 mAttachInfo 还未被赋值，这里会交给 ViewRootImpl 的 Handler 来处理\n    // 即加入消息队列，等待执行\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            Log.e(\"Test\", \"view.post ---- > \" + view.getHeight());\n        }\n    });\n\n    viewGroup.addView(view);\n}\n```\n\n最终打印日志如下：\n\n![image](http://upload-images.jianshu.io/upload_images/5419805-ec13fe6929791de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n也就是说：\n\n1. Handler#post 首先执行，其 post 的时间点在 onCreate() 方法内，在消息队列中的位置一定比 performTraversals() 靠前；\n2. ViewRootImpl#performTraversal 执行，过程中执行了 View#dispatchAttachedToWindow 方法，将最初的 Runnable 入队后进行测量流程，完成了 layout 过程；\n3. 之后才执行了最初的 View#post 方法，也就说明了，在 View#dispatchAttachedToWindow 中使用 ViewRootImpl 的 Handler postDelay 的 Runnable 对象，在主线程消息队列中，确实是排在 ViewRootImpl#performTraversal 之后的\n\n### View#post 整体流程的简单总结\n\n最后大概总结一下：\n\n当我们使用 View#post 时，会有两种情况：\n\n1. 在当前 View attach 到 Window 之前，会自己先维护一个 HandlerActionQueue 对象，用来存储当前的 Runnable 对象，然后等到 Attach 到 Window 的时候 (也就是 ViewRootImpl 执行到 performTraversal 方法时) ，会统一将 Runnable 转交给 ViewRootImpl 处理；\n2. 而在 View#dispatchAttachedToWindow 时，也会为当前 View 初始化一个 AttachInfo 对象，该对象持有 ViewRootImpl 的引用，当 View 有此对象后，后续的所有 Runnable 都将直接交给 ViewRootImpl 处理；\n3. 而 ViewRootImpl 也会在执行 performTraversal 方法，也会调用 ViewRootImpl#getRunQueue ，利用 ThreadLocal 来为主线程维护一个 HandlerActionQueue 对象，至此，ViewRootImpl 内部都将使用该队列来进行 Runnable 任务的短期维护；\n4. 但需要注意的是，各个 View 调用的 post 方法，仍然是由各自的 HandlerActionQueue 对象来入队任务的，然后在 View#dispatchAttachedToWindow 的时候转移给 ViewRootImpl 去处理。\n\n\n\n### Android 7.0 里 View#post 的变动以及原因\n\nView#post 说到这里大概就差不多了，文章开篇的时候说到：\n\n> Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别\n\n下面来简单对比一下具体的差别，顺便分析一下具体为什么要这样改动。\n\n实际上这个方法的改动主要是为了解决一个 bug，这个 bug 就是：**在 View 被 attach 到 window 之前，从子线程调用的 View#post ，永远无法得到执行。**\n\n具体原因，我们来看一下 API23 版本的 View#post，就大概都明白了：\n\n```java\n// Android API23 View#post\npublic boolean post(Runnable action) {\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        return attachInfo.mHandler.post(action);\n    }\n    // Assume that post will succeed later\n    // 注意此处，不同于我们之前介绍的，这里是直接使用 ViewRootImpl#getRunQueue 来入队任务的\n    ViewRootImpl.getRunQueue().post(action);\n    return true;\n}\n```\n\n我们可以看到，不同于我们之前介绍的，API23 版本中，View#post 在没有 attach 到 window 之前，也就是 mAttachInfo 是 null 的时候，不是自己维护任务队列，而是直接使用 ViewRootImpl#getRunQueue 来入队任务的。\n\n再来看一下 ViewRootImpl#getRunQueue 方法，我们就会发现问题出在哪里了：\n\n```java\nstatic final ThreadLocal<RunQueue> sRunQueues = new ThreadLocal<RunQueue>();\nstatic RunQueue getRunQueue() {\n    RunQueue rq = sRunQueues.get();\n    if (rq != null) {\n        return rq;\n    }\n    rq = new RunQueue();\n    sRunQueues.set(rq);\n    return rq;\n}\n```\n\n没错，这个队列的保存与获取，是通过以线程为 key 值来存取对象 ThreadLocal 来维护的。而在这个版本的源码中，executeActions() 方法的执行，只有一次调用，那就是 ViewRootImpl#performTraversal 中（感兴趣的可以去 23 版本的源码中查看，这里就不贴图了），与此同时，该方法肯定是执行在主线程中的。\n\n现在的问题就变成了：**我在子线程中 post 了一个 runnable，并且系统以该子线程为 key 将队列存了起来等待执行；但是在具体执行的时候，系统却是去主线程中寻找待执行的 Runnable，那么当然是永远都得不到执行的了。**\n\n而在**具体 attach 到 window 之后**，View 的 mAttachInfo 持有 ViewRootImpl 引用，会直接将所有的 Runnable 转交给 ViewRootImpl 的 Handler 处理，也**就都能得到妥善处理，就与线程无关了。**\n\n除此以外，ViewRootImpl 使用 ThreadLocal 来存储队列信息，在某些情境下，还会导致内存泄漏。详细信息可以参考：https://blog.csdn.net/a740169405/article/details/69668957\n\n所以，**Google 工程师为了解决这两个问题（内存泄漏的问题更严重一些），就在 View#post 方法中使用 View 对象来进行队列的存储，然后在 attach 到 window 的时候，通过持有 ViewRootImpl 引用的 AttachInfo 对象直接将 View 对象的 Runnable 处理掉，就完美解决了这些问题。**\n\n\n\n### 致谢\n\n下边是自己研究的时候具体参考过的文章，给各位前辈加个鸡腿：\n\n##### https://blog.csdn.net/a740169405/article/details/69668957\n\n##### https://blog.csdn.net/scnuxisan225/article/details/49815269\n\n##### https://www.cnblogs.com/plokmju/p/7481727.html\n\n","source":"_posts/android-view-post.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181407.jpg\ntitle: Android View.post 浅析\ntags: [Android]\ndate: 2018-08-14\n---\n\n> 研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……\n\n<!-- more -->\n\n### 序\n\n之前的文章里写到过，我们在 onCreate() 和 onResume() 方法中无法获取 View 的宽高信息，但在平时开发中，我们经常会用到 View#post 来进行 View 宽高信息的获取。\n\n那么问题就来了，为什么 View#post 就可以获取到宽高信息？里边那个 run() 是在什么时候执行的？具体实现原理又是什么？\n\n带着这些疑问，我最近研究了一下 View#post 的源码。本来以为挺简单的一个东西，但是没想到坑越挖越深，最过分的是，不同的版本源码还不相同，实现原理也有细微的差别。集中攻克了一个周末以后，感觉大概理解了，索性写下篇博客进行记录备忘。\n\n文章大概分为以下几个方面：\n\n- View#post 基本使用\n- post() 执行过程以及源码分析\n- post() 中 Runnable#run 执行的时机\n- View#post 整体流程的简单总结\n- Android 7.0 里 View#post 的变动以及原因\n- 致谢\n\n### View#post 基本使用\n\n具体代码如下：\n\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    View view = findViewById(R.id.test);\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            // 可以正常获取到 View 的宽高信息\n            Log.e(\"Test\", \"view.post ---- > \" + view.getHeight());\n        }\n    });\n}\n```\n\n这里我们以 API 26 为例，来尝试解答一下这个问题。\n\n实际上，Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别，具体的改动以及原因在后文会一一给出分析。\n\n\n\n### post() 执行过程以及源码分析\n\n#### 1. View#post 入口\n先来看 View#post 源码，重点注意注释：\n\n```java\n/**\n * Causes the Runnable to be added to the message queue.\n * The runnable will be run on the user interface thread.\n * 将 Runnable 添加到执行队列中，其最终会在 UI 线程中执行\n */\npublic boolean post(Runnable action) {\n    // AttachInfo 是 View 的内部类，用来存储一些基本信息\n    // 此处可以暂时认为 mAttachInfo 为 null\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        // attachInfo 不为空时，转而使用其内部的 Handler 对象操作\n        return attachInfo.mHandler.post(action);\n    }\n\n    // Postpone the runnable until we know on which thread it needs to run.\n    // Assume that the runnable will be successfully placed after attach.\n    // 在我们确定当前 Runnable 的目标运行线程之前，先将其推迟执行\n    // 假设在 attach 完成之后，此 Runnable 对象会被成功的「placed」（暂且翻译成「放置」）\n    // 好好理解一下这个注释，我们继续往下走\n    getRunQueue().post(action);\n    return true;\n}\n```\n\n首先，明确一点：**Runnable 会在 UI 线程中执行**；\n\n然后，我们来看一下这个看上去很重要的 **mAttachInfo** 是在哪里赋值的：\n\n```java\nvoid dispatchAttachedToWindow(AttachInfo info, int visibility) {\n    mAttachInfo = info;\n    // Transfer all pending runnables. 转移所有待办任务\n    if (mRunQueue != null) {\n        mRunQueue.executeActions(info.mHandler);\n        mRunQueue = null;\n    }\n    // 回调方法\n    onAttachedToWindow();\n}\n```\n\n先不在意除了赋值以外的其他操作，我们继续追踪 dispatchAttachedToWindow 方法，发现其最初调用是在 ViewRootImpl#performTraversals 方法。好了，记住这个结论，我们先把它放在一旁。\n\n接下来，我们来看一看这个 **getRunQueue().post()** 又做了什么：\n\n```java\n/**\n * 获取一个 RunQueue 对象，用来进行 post 操作\n * Returns the queue of runnable for this view.\n * 注释是：为当前 View 对象返回一个执行队列，记住这个「当前 View 对象」\n */\nprivate HandlerActionQueue getRunQueue() {\n    if (mRunQueue == null) {\n        mRunQueue = new HandlerActionQueue();\n    }\n    return mRunQueue;\n}\n```\n\n\n\n#### 2. HandlerActionQueue 又是个啥\n\n很明显，执行 post 方法的是 HandlerActionQueue 对象，那这又是个什么东西：\n\n```java\n/**\n * Class used to enqueue pending work from Views when no Handler is attached.\n * 此类用于在当前 View 没有 Handler 依附的时候，将其待完成的任务入队\n */\npublic class HandlerActionQueue {\n    private HandlerAction[] mActions;\n    private int mCount;\n\n    // 这个就是我们在外边调用的 post 方法，最终会调用到 postDelayed 方法\n    public void post(Runnable action) {\n        postDelayed(action, 0);\n    }\n\n    // 将传入的 Runnable 对象存入数组中，等待调用\n    public void postDelayed(Runnable action, long delayMillis) {\n        final HandlerAction handlerAction = new HandlerAction(action, delayMillis);\n\n        synchronized (this) {\n            if (mActions == null) {\n                mActions = new HandlerAction[4];\n            }\n            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);\n            mCount++;\n        }\n    }\n\n    // 这里才是真的执行方法\n    public void executeActions(Handler handler) {\n        synchronized (this) {\n            final HandlerAction[] actions = mActions;\n            for (int i = 0, count = mCount; i < count; i++) {\n                final HandlerAction handlerAction = actions[i];\n                handler.postDelayed(handlerAction.action, handlerAction.delay);\n            }\n\n            mActions = null;\n            mCount = 0;\n        }\n    }\n}\n```\n\n通过查看 HandlerActionQueue 的源码，我们发现了一个问题：不同于在 onCreate() 直接获取 View 的宽高，我们调用 post 方法，其中的 run 方法并没有被马上执行。\n\n这样就不难解释为什么用这种方式可以获取到宽高了。那我们可以猜测一下，这种情况下，一定是 View 完成测量后才执行了这个方法，所以我们才可以拿到宽高信息。\n\n事实上也正是这样的，那么这个方法到底是在什么时候执行的呢？很明显，HandlerActionQueue#executeActions 才是真正完成调用的方法，那这个方法又做了些什么工作呢？\n\n**根据代码可知，该方法接收一个 Handler，然后使用这个 Handler 对当前队列中的所有 Runnable 进行处理，即 post 到该 Handler 的线程中，按照优先级对这些 Runnable 依次进行处理。**\n\n**简单来说，就是传入的 Handler 决定着这些 Runnable 的执行线程。**\n\n接下来，我们来追踪这个方法的调用情况。\n\n![executeActions() 的调用情况](http://upload-images.jianshu.io/upload_images/5419805-e0cf86fbea081bc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们注意到，对于该方法出现了两次调用，一次在 View#dispatchAttachToWindow（就是我们最开始找到的那个方法），另一次是在 ViewRootImpl#performTraversals。\n\n#### 3. 万恶之源 performTraversals()\n\n很明显，所有的证据都指向了 performTraversals ，那么下面我们就来重点分析一下这个方法。\n\n如果你了解过 View 的测绘流程，那你对这个方法一定不会陌生，因为这个方法就是 View 绘制流程的起点。\n\n```java\nprivate void performTraversals() {\n    \n    // 此处的 host 是根布局 DecorView，用递归的方式一层一层的调用 dispatchAttachedToWindow\n    // mAttachInfo 是不是很眼熟，就是最开始 View#post 的第一层判断\n    // 这个 mAttachInfo 在 ViewRootImpl 的构造器中初始化的，其持有 ViewRootImpl 的 Handler 对象\n    host.dispatchAttachedToWindow(mAttachInfo, 0);\n    getRunQueue().executeActions(mAttachInfo.mHandler);\n    \n    // 绘制流程就从这里开始\n    performMeasure();\n    performLayout();\n    performDraw();\n}\n```\n\n我们先从 dispatchAttachedToWindow 开始，我们之前已经看过这个方法的源码了：\n\n```java\nvoid dispatchAttachedToWindow(AttachInfo info, int visibility) {\n    mAttachInfo = info;\n    // Transfer all pending runnables. 转移所有待办任务\n    if (mRunQueue != null) {\n        mRunQueue.executeActions(info.mHandler);\n        mRunQueue = null;\n    }\n    // 回调方法\n    onAttachedToWindow();\n}\n```\n**现在来进行分析：**\n\n1. 我们已经知道了此方法是从根视图开始递归向下调用的，那么递归到最深处，就会轮到最开始我们调用 post 方法的 View 对象来执行该方法，也就是该方法内的所有属性，都是我们 findViewById 获得的那个 View 对象的属性；\n2. 而且我们也知道，第一个参数 AttachInfo 就是 ViewRootImpl 中初始化的 AttachInfo，它持有当前 ViewRootImpl 的 Handler 对象引用，并将该引用传给了 executeActions()。此时，我们再来回顾一下 **executeActions()** 方法的作用，**传入的 Handler 决定着队列里这些 Runnable 的执行线程**。\n\n\n很明显，此处的 mRunQueue 就是我们最开始调用 post() 时，调用 View#getRunQueue 返回的那个对象，这个对象中有准备获取View高度的 Runnable 对象，也就是说 **mRunQueue 通过调用 executeActions() 将当前 View 的所有 Runnable ，都会转由 ViewRootImpl 的 Handler 来处理！**而在完成这个工作之后，当前 View 也显示地将 mRunQueue 置空，因为所有的待办任务都已经交给 ViewRootImpl 去处理了。\n\n现在再回过头看代码的注释，就差不多可以理解了：\n\n```java\n// Postpone the runnable until we know on which thread it needs to run.\n// Assume that the runnable will be successfully placed after attach.\n// 所有的 Runnable 都会在 attach 之后被正确的放到其应该运行的线程上去\ngetRunQueue().post(action);\n\n// Transfer all pending runnables.\n// 转移所有待办任务(到 ViewRootImpl 中进行处理)\nif (mRunQueue != null) {\n    mRunQueue.executeActions(info.mHandler);\n    mRunQueue = null;\n}\n```\n\ndispatch 方法执行完了，我们继续回来走 performTraversals() ，接下来一句是：\n\n```java\n// 有之前的经验，我们知道这句话的意思是\n// 使用 mAttachInfo.mHandler 来处理 getRunQueue() 中的 Runnable 任务\ngetRunQueue().executeActions(mAttachInfo.mHandler);\n```\n\n要明确的一点是，此时我们处在 ViewRootImpl 类中，此处的 getRunQueue() 方法有别于 View#post：\n\n```java\n// ViewRootImpl#getRunQueue\n// 使用 ThreadLocal 来存储每个线程自身的执行队列 HandlerActionQueue\nstatic HandlerActionQueue getRunQueue() {\n    // sRunQueues 是 ThreadLocal<HandlerActionQueue> 对象\n    HandlerActionQueue rq = sRunQueues.get();\n    if (rq != null) {\n        return rq;\n    }\n    rq = new HandlerActionQueue();\n    sRunQueues.set(rq);\n    return rq;\n}\n\n// View#post\n// 为当前 View 返回一个执行队列，但是在 dispatchAttachToWindow 时转到 UI 线程去\nprivate HandlerActionQueue getRunQueue() {\n    if (mRunQueue == null) {\n        mRunQueue = new HandlerActionQueue();\n    }\n    return mRunQueue;\n}\n```\n\n说回 performTraversals() ，很明显 getRunQueue() 是 UI 线程执行队列的第一次初始化，也就是说当前这个任务队列里并没有待执行任务！\n\n但是需要注意的是，**当前没有执行任务（**HandlerActionQueue**），不代表 Handler 消息队列中没有消息**，这是两个概念，需要注意区分开。\n\n总结一下：\n\n1. View#post 方法调用时，会为当前 View 对象初始化一个 HandlerActionQueue ，并将 Runnable 入队存储；\n2. 等在 ViewRootImpl#performTraversals 中递归调用到 View#dispatchAttachedToWindow 时，会将 ViewRootImpl 的 Handler 对象传下来，然后通过这个 Handler 将最初的 Runnable 发送到 UI 线程（消息队列中）等待执行，并将 View 的 HandlerActionQueue 对象置空，方便回收；\n3. ViewRootImpl#performTraversals 继续执行，才会为 UI 线程首次初始化 HandlerActionQueue 对象，并通过 ThreadLocal 进行存储，方便之后的复用，但需要注意的是，此处初始化的队列中是没有任何 Runnable 对象的；\n4. 然后 ViewRootImpl#performTraversals 继续执行，开始 View 的测量流程。\n\n\n\n### View#post 中 Runnable#run 执行的时机\n\n但现在的问题是，无论怎么说，**HandlerActionQueue#executeActions 都是先于 View 测绘流程的**，为什么在还没有完成测量的时候，就可以拿到宽高信息？\n\n我们都知道，Android 系统是基于消息机制运行的，所有的事件、行为，都是基于 Handler 消息机制在运行的。所以，当 ViewRootImpl#performTraversals 在执行的时候，也一定是基于某个消息的。而且，HandlerActionQueue#executeActions 执行的时候，也只是通过 Handler 将 Runnable post 到了 UI 线程等待执行（还记得 View#post 的注释吗？）。\n\n不出意外的话，此时 UI 线程正忙着执行 ViewRootImpl#performTraversal ，等该方法执行完毕，View 已经完成了测量流程，此时再去执行 Runnable#run ，也就自然可以获取到 View 的宽高信息了。\n\n下面用具体的实例佐证一下我们的猜想。\n\n```JAVA\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    final ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();\n\n    // 等待 Add 到父布局中\n    view = new View(this) {\n        @Override\n        protected void onLayout( ... ... ) {\n            super.onLayout(changed, left, top, right, bottom);\n            Log.e(\"Test\", \"执行了onLayout()\");\n        }\n    };\n\n    // 自己声明的 Handler \n    mHandler.post(new Runnable() {\n        @Override\n        public void run() {\n            Log.e(\"Test\", \"mHandler.post ---- > \" + view.getHeight());\n        }\n    });\n\n    // onCreate() 中 mAttachInfo 还未被赋值，这里会交给 ViewRootImpl 的 Handler 来处理\n    // 即加入消息队列，等待执行\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            Log.e(\"Test\", \"view.post ---- > \" + view.getHeight());\n        }\n    });\n\n    viewGroup.addView(view);\n}\n```\n\n最终打印日志如下：\n\n![image](http://upload-images.jianshu.io/upload_images/5419805-ec13fe6929791de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n也就是说：\n\n1. Handler#post 首先执行，其 post 的时间点在 onCreate() 方法内，在消息队列中的位置一定比 performTraversals() 靠前；\n2. ViewRootImpl#performTraversal 执行，过程中执行了 View#dispatchAttachedToWindow 方法，将最初的 Runnable 入队后进行测量流程，完成了 layout 过程；\n3. 之后才执行了最初的 View#post 方法，也就说明了，在 View#dispatchAttachedToWindow 中使用 ViewRootImpl 的 Handler postDelay 的 Runnable 对象，在主线程消息队列中，确实是排在 ViewRootImpl#performTraversal 之后的\n\n### View#post 整体流程的简单总结\n\n最后大概总结一下：\n\n当我们使用 View#post 时，会有两种情况：\n\n1. 在当前 View attach 到 Window 之前，会自己先维护一个 HandlerActionQueue 对象，用来存储当前的 Runnable 对象，然后等到 Attach 到 Window 的时候 (也就是 ViewRootImpl 执行到 performTraversal 方法时) ，会统一将 Runnable 转交给 ViewRootImpl 处理；\n2. 而在 View#dispatchAttachedToWindow 时，也会为当前 View 初始化一个 AttachInfo 对象，该对象持有 ViewRootImpl 的引用，当 View 有此对象后，后续的所有 Runnable 都将直接交给 ViewRootImpl 处理；\n3. 而 ViewRootImpl 也会在执行 performTraversal 方法，也会调用 ViewRootImpl#getRunQueue ，利用 ThreadLocal 来为主线程维护一个 HandlerActionQueue 对象，至此，ViewRootImpl 内部都将使用该队列来进行 Runnable 任务的短期维护；\n4. 但需要注意的是，各个 View 调用的 post 方法，仍然是由各自的 HandlerActionQueue 对象来入队任务的，然后在 View#dispatchAttachedToWindow 的时候转移给 ViewRootImpl 去处理。\n\n\n\n### Android 7.0 里 View#post 的变动以及原因\n\nView#post 说到这里大概就差不多了，文章开篇的时候说到：\n\n> Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别\n\n下面来简单对比一下具体的差别，顺便分析一下具体为什么要这样改动。\n\n实际上这个方法的改动主要是为了解决一个 bug，这个 bug 就是：**在 View 被 attach 到 window 之前，从子线程调用的 View#post ，永远无法得到执行。**\n\n具体原因，我们来看一下 API23 版本的 View#post，就大概都明白了：\n\n```java\n// Android API23 View#post\npublic boolean post(Runnable action) {\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        return attachInfo.mHandler.post(action);\n    }\n    // Assume that post will succeed later\n    // 注意此处，不同于我们之前介绍的，这里是直接使用 ViewRootImpl#getRunQueue 来入队任务的\n    ViewRootImpl.getRunQueue().post(action);\n    return true;\n}\n```\n\n我们可以看到，不同于我们之前介绍的，API23 版本中，View#post 在没有 attach 到 window 之前，也就是 mAttachInfo 是 null 的时候，不是自己维护任务队列，而是直接使用 ViewRootImpl#getRunQueue 来入队任务的。\n\n再来看一下 ViewRootImpl#getRunQueue 方法，我们就会发现问题出在哪里了：\n\n```java\nstatic final ThreadLocal<RunQueue> sRunQueues = new ThreadLocal<RunQueue>();\nstatic RunQueue getRunQueue() {\n    RunQueue rq = sRunQueues.get();\n    if (rq != null) {\n        return rq;\n    }\n    rq = new RunQueue();\n    sRunQueues.set(rq);\n    return rq;\n}\n```\n\n没错，这个队列的保存与获取，是通过以线程为 key 值来存取对象 ThreadLocal 来维护的。而在这个版本的源码中，executeActions() 方法的执行，只有一次调用，那就是 ViewRootImpl#performTraversal 中（感兴趣的可以去 23 版本的源码中查看，这里就不贴图了），与此同时，该方法肯定是执行在主线程中的。\n\n现在的问题就变成了：**我在子线程中 post 了一个 runnable，并且系统以该子线程为 key 将队列存了起来等待执行；但是在具体执行的时候，系统却是去主线程中寻找待执行的 Runnable，那么当然是永远都得不到执行的了。**\n\n而在**具体 attach 到 window 之后**，View 的 mAttachInfo 持有 ViewRootImpl 引用，会直接将所有的 Runnable 转交给 ViewRootImpl 的 Handler 处理，也**就都能得到妥善处理，就与线程无关了。**\n\n除此以外，ViewRootImpl 使用 ThreadLocal 来存储队列信息，在某些情境下，还会导致内存泄漏。详细信息可以参考：https://blog.csdn.net/a740169405/article/details/69668957\n\n所以，**Google 工程师为了解决这两个问题（内存泄漏的问题更严重一些），就在 View#post 方法中使用 View 对象来进行队列的存储，然后在 attach 到 window 的时候，通过持有 ViewRootImpl 引用的 AttachInfo 对象直接将 View 对象的 Runnable 处理掉，就完美解决了这些问题。**\n\n\n\n### 致谢\n\n下边是自己研究的时候具体参考过的文章，给各位前辈加个鸡腿：\n\n##### https://blog.csdn.net/a740169405/article/details/69668957\n\n##### https://blog.csdn.net/scnuxisan225/article/details/49815269\n\n##### https://www.cnblogs.com/plokmju/p/7481727.html\n\n","slug":"android-view-post","published":1,"updated":"2019-03-21T10:15:31.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86ep001ulh1p5atkwl16","content":"<blockquote>\n<p>研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h3><p>之前的文章里写到过，我们在 onCreate() 和 onResume() 方法中无法获取 View 的宽高信息，但在平时开发中，我们经常会用到 View#post 来进行 View 宽高信息的获取。</p>\n<p>那么问题就来了，为什么 View#post 就可以获取到宽高信息？里边那个 run() 是在什么时候执行的？具体实现原理又是什么？</p>\n<p>带着这些疑问，我最近研究了一下 View#post 的源码。本来以为挺简单的一个东西，但是没想到坑越挖越深，最过分的是，不同的版本源码还不相同，实现原理也有细微的差别。集中攻克了一个周末以后，感觉大概理解了，索性写下篇博客进行记录备忘。</p>\n<p>文章大概分为以下几个方面：</p>\n<ul>\n<li>View#post 基本使用</li>\n<li>post() 执行过程以及源码分析</li>\n<li>post() 中 Runnable#run 执行的时机</li>\n<li>View#post 整体流程的简单总结</li>\n<li>Android 7.0 里 View#post 的变动以及原因</li>\n<li>致谢</li>\n</ul>\n<h3 id=\"View-post-基本使用\"><a href=\"#View-post-基本使用\" class=\"headerlink\" title=\"View#post 基本使用\"></a>View#post 基本使用</h3><p>具体代码如下：</p>\n<pre><code class=\"java\">@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    View view = findViewById(R.id.test);\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            // 可以正常获取到 View 的宽高信息\n            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());\n        }\n    });\n}\n</code></pre>\n<p>这里我们以 API 26 为例，来尝试解答一下这个问题。</p>\n<p>实际上，Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别，具体的改动以及原因在后文会一一给出分析。</p>\n<h3 id=\"post-执行过程以及源码分析\"><a href=\"#post-执行过程以及源码分析\" class=\"headerlink\" title=\"post() 执行过程以及源码分析\"></a>post() 执行过程以及源码分析</h3><h4 id=\"1-View-post-入口\"><a href=\"#1-View-post-入口\" class=\"headerlink\" title=\"1. View#post 入口\"></a>1. View#post 入口</h4><p>先来看 View#post 源码，重点注意注释：</p>\n<pre><code class=\"java\">/**\n * Causes the Runnable to be added to the message queue.\n * The runnable will be run on the user interface thread.\n * 将 Runnable 添加到执行队列中，其最终会在 UI 线程中执行\n */\npublic boolean post(Runnable action) {\n    // AttachInfo 是 View 的内部类，用来存储一些基本信息\n    // 此处可以暂时认为 mAttachInfo 为 null\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        // attachInfo 不为空时，转而使用其内部的 Handler 对象操作\n        return attachInfo.mHandler.post(action);\n    }\n\n    // Postpone the runnable until we know on which thread it needs to run.\n    // Assume that the runnable will be successfully placed after attach.\n    // 在我们确定当前 Runnable 的目标运行线程之前，先将其推迟执行\n    // 假设在 attach 完成之后，此 Runnable 对象会被成功的「placed」（暂且翻译成「放置」）\n    // 好好理解一下这个注释，我们继续往下走\n    getRunQueue().post(action);\n    return true;\n}\n</code></pre>\n<p>首先，明确一点：<strong>Runnable 会在 UI 线程中执行</strong>；</p>\n<p>然后，我们来看一下这个看上去很重要的 <strong>mAttachInfo</strong> 是在哪里赋值的：</p>\n<pre><code class=\"java\">void dispatchAttachedToWindow(AttachInfo info, int visibility) {\n    mAttachInfo = info;\n    // Transfer all pending runnables. 转移所有待办任务\n    if (mRunQueue != null) {\n        mRunQueue.executeActions(info.mHandler);\n        mRunQueue = null;\n    }\n    // 回调方法\n    onAttachedToWindow();\n}\n</code></pre>\n<p>先不在意除了赋值以外的其他操作，我们继续追踪 dispatchAttachedToWindow 方法，发现其最初调用是在 ViewRootImpl#performTraversals 方法。好了，记住这个结论，我们先把它放在一旁。</p>\n<p>接下来，我们来看一看这个 <strong>getRunQueue().post()</strong> 又做了什么：</p>\n<pre><code class=\"java\">/**\n * 获取一个 RunQueue 对象，用来进行 post 操作\n * Returns the queue of runnable for this view.\n * 注释是：为当前 View 对象返回一个执行队列，记住这个「当前 View 对象」\n */\nprivate HandlerActionQueue getRunQueue() {\n    if (mRunQueue == null) {\n        mRunQueue = new HandlerActionQueue();\n    }\n    return mRunQueue;\n}\n</code></pre>\n<h4 id=\"2-HandlerActionQueue-又是个啥\"><a href=\"#2-HandlerActionQueue-又是个啥\" class=\"headerlink\" title=\"2. HandlerActionQueue 又是个啥\"></a>2. HandlerActionQueue 又是个啥</h4><p>很明显，执行 post 方法的是 HandlerActionQueue 对象，那这又是个什么东西：</p>\n<pre><code class=\"java\">/**\n * Class used to enqueue pending work from Views when no Handler is attached.\n * 此类用于在当前 View 没有 Handler 依附的时候，将其待完成的任务入队\n */\npublic class HandlerActionQueue {\n    private HandlerAction[] mActions;\n    private int mCount;\n\n    // 这个就是我们在外边调用的 post 方法，最终会调用到 postDelayed 方法\n    public void post(Runnable action) {\n        postDelayed(action, 0);\n    }\n\n    // 将传入的 Runnable 对象存入数组中，等待调用\n    public void postDelayed(Runnable action, long delayMillis) {\n        final HandlerAction handlerAction = new HandlerAction(action, delayMillis);\n\n        synchronized (this) {\n            if (mActions == null) {\n                mActions = new HandlerAction[4];\n            }\n            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);\n            mCount++;\n        }\n    }\n\n    // 这里才是真的执行方法\n    public void executeActions(Handler handler) {\n        synchronized (this) {\n            final HandlerAction[] actions = mActions;\n            for (int i = 0, count = mCount; i &lt; count; i++) {\n                final HandlerAction handlerAction = actions[i];\n                handler.postDelayed(handlerAction.action, handlerAction.delay);\n            }\n\n            mActions = null;\n            mCount = 0;\n        }\n    }\n}\n</code></pre>\n<p>通过查看 HandlerActionQueue 的源码，我们发现了一个问题：不同于在 onCreate() 直接获取 View 的宽高，我们调用 post 方法，其中的 run 方法并没有被马上执行。</p>\n<p>这样就不难解释为什么用这种方式可以获取到宽高了。那我们可以猜测一下，这种情况下，一定是 View 完成测量后才执行了这个方法，所以我们才可以拿到宽高信息。</p>\n<p>事实上也正是这样的，那么这个方法到底是在什么时候执行的呢？很明显，HandlerActionQueue#executeActions 才是真正完成调用的方法，那这个方法又做了些什么工作呢？</p>\n<p><strong>根据代码可知，该方法接收一个 Handler，然后使用这个 Handler 对当前队列中的所有 Runnable 进行处理，即 post 到该 Handler 的线程中，按照优先级对这些 Runnable 依次进行处理。</strong></p>\n<p><strong>简单来说，就是传入的 Handler 决定着这些 Runnable 的执行线程。</strong></p>\n<p>接下来，我们来追踪这个方法的调用情况。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5419805-e0cf86fbea081bc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"executeActions() 的调用情况\"></p>\n<p>我们注意到，对于该方法出现了两次调用，一次在 View#dispatchAttachToWindow（就是我们最开始找到的那个方法），另一次是在 ViewRootImpl#performTraversals。</p>\n<h4 id=\"3-万恶之源-performTraversals\"><a href=\"#3-万恶之源-performTraversals\" class=\"headerlink\" title=\"3. 万恶之源 performTraversals()\"></a>3. 万恶之源 performTraversals()</h4><p>很明显，所有的证据都指向了 performTraversals ，那么下面我们就来重点分析一下这个方法。</p>\n<p>如果你了解过 View 的测绘流程，那你对这个方法一定不会陌生，因为这个方法就是 View 绘制流程的起点。</p>\n<pre><code class=\"java\">private void performTraversals() {\n\n    // 此处的 host 是根布局 DecorView，用递归的方式一层一层的调用 dispatchAttachedToWindow\n    // mAttachInfo 是不是很眼熟，就是最开始 View#post 的第一层判断\n    // 这个 mAttachInfo 在 ViewRootImpl 的构造器中初始化的，其持有 ViewRootImpl 的 Handler 对象\n    host.dispatchAttachedToWindow(mAttachInfo, 0);\n    getRunQueue().executeActions(mAttachInfo.mHandler);\n\n    // 绘制流程就从这里开始\n    performMeasure();\n    performLayout();\n    performDraw();\n}\n</code></pre>\n<p>我们先从 dispatchAttachedToWindow 开始，我们之前已经看过这个方法的源码了：</p>\n<pre><code class=\"java\">void dispatchAttachedToWindow(AttachInfo info, int visibility) {\n    mAttachInfo = info;\n    // Transfer all pending runnables. 转移所有待办任务\n    if (mRunQueue != null) {\n        mRunQueue.executeActions(info.mHandler);\n        mRunQueue = null;\n    }\n    // 回调方法\n    onAttachedToWindow();\n}\n</code></pre>\n<p><strong>现在来进行分析：</strong></p>\n<ol>\n<li>我们已经知道了此方法是从根视图开始递归向下调用的，那么递归到最深处，就会轮到最开始我们调用 post 方法的 View 对象来执行该方法，也就是该方法内的所有属性，都是我们 findViewById 获得的那个 View 对象的属性；</li>\n<li>而且我们也知道，第一个参数 AttachInfo 就是 ViewRootImpl 中初始化的 AttachInfo，它持有当前 ViewRootImpl 的 Handler 对象引用，并将该引用传给了 executeActions()。此时，我们再来回顾一下 <strong>executeActions()</strong> 方法的作用，<strong>传入的 Handler 决定着队列里这些 Runnable 的执行线程</strong>。</li>\n</ol>\n<p>很明显，此处的 mRunQueue 就是我们最开始调用 post() 时，调用 View#getRunQueue 返回的那个对象，这个对象中有准备获取View高度的 Runnable 对象，也就是说 <strong>mRunQueue 通过调用 executeActions() 将当前 View 的所有 Runnable ，都会转由 ViewRootImpl 的 Handler 来处理！</strong>而在完成这个工作之后，当前 View 也显示地将 mRunQueue 置空，因为所有的待办任务都已经交给 ViewRootImpl 去处理了。</p>\n<p>现在再回过头看代码的注释，就差不多可以理解了：</p>\n<pre><code class=\"java\">// Postpone the runnable until we know on which thread it needs to run.\n// Assume that the runnable will be successfully placed after attach.\n// 所有的 Runnable 都会在 attach 之后被正确的放到其应该运行的线程上去\ngetRunQueue().post(action);\n\n// Transfer all pending runnables.\n// 转移所有待办任务(到 ViewRootImpl 中进行处理)\nif (mRunQueue != null) {\n    mRunQueue.executeActions(info.mHandler);\n    mRunQueue = null;\n}\n</code></pre>\n<p>dispatch 方法执行完了，我们继续回来走 performTraversals() ，接下来一句是：</p>\n<pre><code class=\"java\">// 有之前的经验，我们知道这句话的意思是\n// 使用 mAttachInfo.mHandler 来处理 getRunQueue() 中的 Runnable 任务\ngetRunQueue().executeActions(mAttachInfo.mHandler);\n</code></pre>\n<p>要明确的一点是，此时我们处在 ViewRootImpl 类中，此处的 getRunQueue() 方法有别于 View#post：</p>\n<pre><code class=\"java\">// ViewRootImpl#getRunQueue\n// 使用 ThreadLocal 来存储每个线程自身的执行队列 HandlerActionQueue\nstatic HandlerActionQueue getRunQueue() {\n    // sRunQueues 是 ThreadLocal&lt;HandlerActionQueue&gt; 对象\n    HandlerActionQueue rq = sRunQueues.get();\n    if (rq != null) {\n        return rq;\n    }\n    rq = new HandlerActionQueue();\n    sRunQueues.set(rq);\n    return rq;\n}\n\n// View#post\n// 为当前 View 返回一个执行队列，但是在 dispatchAttachToWindow 时转到 UI 线程去\nprivate HandlerActionQueue getRunQueue() {\n    if (mRunQueue == null) {\n        mRunQueue = new HandlerActionQueue();\n    }\n    return mRunQueue;\n}\n</code></pre>\n<p>说回 performTraversals() ，很明显 getRunQueue() 是 UI 线程执行队列的第一次初始化，也就是说当前这个任务队列里并没有待执行任务！</p>\n<p>但是需要注意的是，<strong>当前没有执行任务（</strong>HandlerActionQueue<strong>），不代表 Handler 消息队列中没有消息</strong>，这是两个概念，需要注意区分开。</p>\n<p>总结一下：</p>\n<ol>\n<li>View#post 方法调用时，会为当前 View 对象初始化一个 HandlerActionQueue ，并将 Runnable 入队存储；</li>\n<li>等在 ViewRootImpl#performTraversals 中递归调用到 View#dispatchAttachedToWindow 时，会将 ViewRootImpl 的 Handler 对象传下来，然后通过这个 Handler 将最初的 Runnable 发送到 UI 线程（消息队列中）等待执行，并将 View 的 HandlerActionQueue 对象置空，方便回收；</li>\n<li>ViewRootImpl#performTraversals 继续执行，才会为 UI 线程首次初始化 HandlerActionQueue 对象，并通过 ThreadLocal 进行存储，方便之后的复用，但需要注意的是，此处初始化的队列中是没有任何 Runnable 对象的；</li>\n<li>然后 ViewRootImpl#performTraversals 继续执行，开始 View 的测量流程。</li>\n</ol>\n<h3 id=\"View-post-中-Runnable-run-执行的时机\"><a href=\"#View-post-中-Runnable-run-执行的时机\" class=\"headerlink\" title=\"View#post 中 Runnable#run 执行的时机\"></a>View#post 中 Runnable#run 执行的时机</h3><p>但现在的问题是，无论怎么说，<strong>HandlerActionQueue#executeActions 都是先于 View 测绘流程的</strong>，为什么在还没有完成测量的时候，就可以拿到宽高信息？</p>\n<p>我们都知道，Android 系统是基于消息机制运行的，所有的事件、行为，都是基于 Handler 消息机制在运行的。所以，当 ViewRootImpl#performTraversals 在执行的时候，也一定是基于某个消息的。而且，HandlerActionQueue#executeActions 执行的时候，也只是通过 Handler 将 Runnable post 到了 UI 线程等待执行（还记得 View#post 的注释吗？）。</p>\n<p>不出意外的话，此时 UI 线程正忙着执行 ViewRootImpl#performTraversal ，等该方法执行完毕，View 已经完成了测量流程，此时再去执行 Runnable#run ，也就自然可以获取到 View 的宽高信息了。</p>\n<p>下面用具体的实例佐证一下我们的猜想。</p>\n<pre><code class=\"JAVA\">@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    final ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();\n\n    // 等待 Add 到父布局中\n    view = new View(this) {\n        @Override\n        protected void onLayout( ... ... ) {\n            super.onLayout(changed, left, top, right, bottom);\n            Log.e(&quot;Test&quot;, &quot;执行了onLayout()&quot;);\n        }\n    };\n\n    // 自己声明的 Handler \n    mHandler.post(new Runnable() {\n        @Override\n        public void run() {\n            Log.e(&quot;Test&quot;, &quot;mHandler.post ---- &gt; &quot; + view.getHeight());\n        }\n    });\n\n    // onCreate() 中 mAttachInfo 还未被赋值，这里会交给 ViewRootImpl 的 Handler 来处理\n    // 即加入消息队列，等待执行\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());\n        }\n    });\n\n    viewGroup.addView(view);\n}\n</code></pre>\n<p>最终打印日志如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5419805-ec13fe6929791de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>也就是说：</p>\n<ol>\n<li>Handler#post 首先执行，其 post 的时间点在 onCreate() 方法内，在消息队列中的位置一定比 performTraversals() 靠前；</li>\n<li>ViewRootImpl#performTraversal 执行，过程中执行了 View#dispatchAttachedToWindow 方法，将最初的 Runnable 入队后进行测量流程，完成了 layout 过程；</li>\n<li>之后才执行了最初的 View#post 方法，也就说明了，在 View#dispatchAttachedToWindow 中使用 ViewRootImpl 的 Handler postDelay 的 Runnable 对象，在主线程消息队列中，确实是排在 ViewRootImpl#performTraversal 之后的</li>\n</ol>\n<h3 id=\"View-post-整体流程的简单总结\"><a href=\"#View-post-整体流程的简单总结\" class=\"headerlink\" title=\"View#post 整体流程的简单总结\"></a>View#post 整体流程的简单总结</h3><p>最后大概总结一下：</p>\n<p>当我们使用 View#post 时，会有两种情况：</p>\n<ol>\n<li>在当前 View attach 到 Window 之前，会自己先维护一个 HandlerActionQueue 对象，用来存储当前的 Runnable 对象，然后等到 Attach 到 Window 的时候 (也就是 ViewRootImpl 执行到 performTraversal 方法时) ，会统一将 Runnable 转交给 ViewRootImpl 处理；</li>\n<li>而在 View#dispatchAttachedToWindow 时，也会为当前 View 初始化一个 AttachInfo 对象，该对象持有 ViewRootImpl 的引用，当 View 有此对象后，后续的所有 Runnable 都将直接交给 ViewRootImpl 处理；</li>\n<li>而 ViewRootImpl 也会在执行 performTraversal 方法，也会调用 ViewRootImpl#getRunQueue ，利用 ThreadLocal 来为主线程维护一个 HandlerActionQueue 对象，至此，ViewRootImpl 内部都将使用该队列来进行 Runnable 任务的短期维护；</li>\n<li>但需要注意的是，各个 View 调用的 post 方法，仍然是由各自的 HandlerActionQueue 对象来入队任务的，然后在 View#dispatchAttachedToWindow 的时候转移给 ViewRootImpl 去处理。</li>\n</ol>\n<h3 id=\"Android-7-0-里-View-post-的变动以及原因\"><a href=\"#Android-7-0-里-View-post-的变动以及原因\" class=\"headerlink\" title=\"Android 7.0 里 View#post 的变动以及原因\"></a>Android 7.0 里 View#post 的变动以及原因</h3><p>View#post 说到这里大概就差不多了，文章开篇的时候说到：</p>\n<blockquote>\n<p>Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别</p>\n</blockquote>\n<p>下面来简单对比一下具体的差别，顺便分析一下具体为什么要这样改动。</p>\n<p>实际上这个方法的改动主要是为了解决一个 bug，这个 bug 就是：<strong>在 View 被 attach 到 window 之前，从子线程调用的 View#post ，永远无法得到执行。</strong></p>\n<p>具体原因，我们来看一下 API23 版本的 View#post，就大概都明白了：</p>\n<pre><code class=\"java\">// Android API23 View#post\npublic boolean post(Runnable action) {\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        return attachInfo.mHandler.post(action);\n    }\n    // Assume that post will succeed later\n    // 注意此处，不同于我们之前介绍的，这里是直接使用 ViewRootImpl#getRunQueue 来入队任务的\n    ViewRootImpl.getRunQueue().post(action);\n    return true;\n}\n</code></pre>\n<p>我们可以看到，不同于我们之前介绍的，API23 版本中，View#post 在没有 attach 到 window 之前，也就是 mAttachInfo 是 null 的时候，不是自己维护任务队列，而是直接使用 ViewRootImpl#getRunQueue 来入队任务的。</p>\n<p>再来看一下 ViewRootImpl#getRunQueue 方法，我们就会发现问题出在哪里了：</p>\n<pre><code class=\"java\">static final ThreadLocal&lt;RunQueue&gt; sRunQueues = new ThreadLocal&lt;RunQueue&gt;();\nstatic RunQueue getRunQueue() {\n    RunQueue rq = sRunQueues.get();\n    if (rq != null) {\n        return rq;\n    }\n    rq = new RunQueue();\n    sRunQueues.set(rq);\n    return rq;\n}\n</code></pre>\n<p>没错，这个队列的保存与获取，是通过以线程为 key 值来存取对象 ThreadLocal 来维护的。而在这个版本的源码中，executeActions() 方法的执行，只有一次调用，那就是 ViewRootImpl#performTraversal 中（感兴趣的可以去 23 版本的源码中查看，这里就不贴图了），与此同时，该方法肯定是执行在主线程中的。</p>\n<p>现在的问题就变成了：<strong>我在子线程中 post 了一个 runnable，并且系统以该子线程为 key 将队列存了起来等待执行；但是在具体执行的时候，系统却是去主线程中寻找待执行的 Runnable，那么当然是永远都得不到执行的了。</strong></p>\n<p>而在<strong>具体 attach 到 window 之后</strong>，View 的 mAttachInfo 持有 ViewRootImpl 引用，会直接将所有的 Runnable 转交给 ViewRootImpl 的 Handler 处理，也<strong>就都能得到妥善处理，就与线程无关了。</strong></p>\n<p>除此以外，ViewRootImpl 使用 ThreadLocal 来存储队列信息，在某些情境下，还会导致内存泄漏。详细信息可以参考：<a href=\"https://blog.csdn.net/a740169405/article/details/69668957\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/a740169405/article/details/69668957</a></p>\n<p>所以，<strong>Google 工程师为了解决这两个问题（内存泄漏的问题更严重一些），就在 View#post 方法中使用 View 对象来进行队列的存储，然后在 attach 到 window 的时候，通过持有 ViewRootImpl 引用的 AttachInfo 对象直接将 View 对象的 Runnable 处理掉，就完美解决了这些问题。</strong></p>\n<h3 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h3><p>下边是自己研究的时候具体参考过的文章，给各位前辈加个鸡腿：</p>\n<h5 id=\"https-blog-csdn-net-a740169405-article-details-69668957\"><a href=\"#https-blog-csdn-net-a740169405-article-details-69668957\" class=\"headerlink\" title=\"https://blog.csdn.net/a740169405/article/details/69668957\"></a><a href=\"https://blog.csdn.net/a740169405/article/details/69668957\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/a740169405/article/details/69668957</a></h5><h5 id=\"https-blog-csdn-net-scnuxisan225-article-details-49815269\"><a href=\"#https-blog-csdn-net-scnuxisan225-article-details-49815269\" class=\"headerlink\" title=\"https://blog.csdn.net/scnuxisan225/article/details/49815269\"></a><a href=\"https://blog.csdn.net/scnuxisan225/article/details/49815269\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/scnuxisan225/article/details/49815269</a></h5><h5 id=\"https-www-cnblogs-com-plokmju-p-7481727-html\"><a href=\"#https-www-cnblogs-com-plokmju-p-7481727-html\" class=\"headerlink\" title=\"https://www.cnblogs.com/plokmju/p/7481727.html\"></a><a href=\"https://www.cnblogs.com/plokmju/p/7481727.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/plokmju/p/7481727.html</a></h5>","site":{"data":{}},"excerpt":"<blockquote>\n<p>研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……</p>\n</blockquote>","more":"<h3 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h3><p>之前的文章里写到过，我们在 onCreate() 和 onResume() 方法中无法获取 View 的宽高信息，但在平时开发中，我们经常会用到 View#post 来进行 View 宽高信息的获取。</p>\n<p>那么问题就来了，为什么 View#post 就可以获取到宽高信息？里边那个 run() 是在什么时候执行的？具体实现原理又是什么？</p>\n<p>带着这些疑问，我最近研究了一下 View#post 的源码。本来以为挺简单的一个东西，但是没想到坑越挖越深，最过分的是，不同的版本源码还不相同，实现原理也有细微的差别。集中攻克了一个周末以后，感觉大概理解了，索性写下篇博客进行记录备忘。</p>\n<p>文章大概分为以下几个方面：</p>\n<ul>\n<li>View#post 基本使用</li>\n<li>post() 执行过程以及源码分析</li>\n<li>post() 中 Runnable#run 执行的时机</li>\n<li>View#post 整体流程的简单总结</li>\n<li>Android 7.0 里 View#post 的变动以及原因</li>\n<li>致谢</li>\n</ul>\n<h3 id=\"View-post-基本使用\"><a href=\"#View-post-基本使用\" class=\"headerlink\" title=\"View#post 基本使用\"></a>View#post 基本使用</h3><p>具体代码如下：</p>\n<pre><code class=\"java\">@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    View view = findViewById(R.id.test);\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            // 可以正常获取到 View 的宽高信息\n            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());\n        }\n    });\n}\n</code></pre>\n<p>这里我们以 API 26 为例，来尝试解答一下这个问题。</p>\n<p>实际上，Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别，具体的改动以及原因在后文会一一给出分析。</p>\n<h3 id=\"post-执行过程以及源码分析\"><a href=\"#post-执行过程以及源码分析\" class=\"headerlink\" title=\"post() 执行过程以及源码分析\"></a>post() 执行过程以及源码分析</h3><h4 id=\"1-View-post-入口\"><a href=\"#1-View-post-入口\" class=\"headerlink\" title=\"1. View#post 入口\"></a>1. View#post 入口</h4><p>先来看 View#post 源码，重点注意注释：</p>\n<pre><code class=\"java\">/**\n * Causes the Runnable to be added to the message queue.\n * The runnable will be run on the user interface thread.\n * 将 Runnable 添加到执行队列中，其最终会在 UI 线程中执行\n */\npublic boolean post(Runnable action) {\n    // AttachInfo 是 View 的内部类，用来存储一些基本信息\n    // 此处可以暂时认为 mAttachInfo 为 null\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        // attachInfo 不为空时，转而使用其内部的 Handler 对象操作\n        return attachInfo.mHandler.post(action);\n    }\n\n    // Postpone the runnable until we know on which thread it needs to run.\n    // Assume that the runnable will be successfully placed after attach.\n    // 在我们确定当前 Runnable 的目标运行线程之前，先将其推迟执行\n    // 假设在 attach 完成之后，此 Runnable 对象会被成功的「placed」（暂且翻译成「放置」）\n    // 好好理解一下这个注释，我们继续往下走\n    getRunQueue().post(action);\n    return true;\n}\n</code></pre>\n<p>首先，明确一点：<strong>Runnable 会在 UI 线程中执行</strong>；</p>\n<p>然后，我们来看一下这个看上去很重要的 <strong>mAttachInfo</strong> 是在哪里赋值的：</p>\n<pre><code class=\"java\">void dispatchAttachedToWindow(AttachInfo info, int visibility) {\n    mAttachInfo = info;\n    // Transfer all pending runnables. 转移所有待办任务\n    if (mRunQueue != null) {\n        mRunQueue.executeActions(info.mHandler);\n        mRunQueue = null;\n    }\n    // 回调方法\n    onAttachedToWindow();\n}\n</code></pre>\n<p>先不在意除了赋值以外的其他操作，我们继续追踪 dispatchAttachedToWindow 方法，发现其最初调用是在 ViewRootImpl#performTraversals 方法。好了，记住这个结论，我们先把它放在一旁。</p>\n<p>接下来，我们来看一看这个 <strong>getRunQueue().post()</strong> 又做了什么：</p>\n<pre><code class=\"java\">/**\n * 获取一个 RunQueue 对象，用来进行 post 操作\n * Returns the queue of runnable for this view.\n * 注释是：为当前 View 对象返回一个执行队列，记住这个「当前 View 对象」\n */\nprivate HandlerActionQueue getRunQueue() {\n    if (mRunQueue == null) {\n        mRunQueue = new HandlerActionQueue();\n    }\n    return mRunQueue;\n}\n</code></pre>\n<h4 id=\"2-HandlerActionQueue-又是个啥\"><a href=\"#2-HandlerActionQueue-又是个啥\" class=\"headerlink\" title=\"2. HandlerActionQueue 又是个啥\"></a>2. HandlerActionQueue 又是个啥</h4><p>很明显，执行 post 方法的是 HandlerActionQueue 对象，那这又是个什么东西：</p>\n<pre><code class=\"java\">/**\n * Class used to enqueue pending work from Views when no Handler is attached.\n * 此类用于在当前 View 没有 Handler 依附的时候，将其待完成的任务入队\n */\npublic class HandlerActionQueue {\n    private HandlerAction[] mActions;\n    private int mCount;\n\n    // 这个就是我们在外边调用的 post 方法，最终会调用到 postDelayed 方法\n    public void post(Runnable action) {\n        postDelayed(action, 0);\n    }\n\n    // 将传入的 Runnable 对象存入数组中，等待调用\n    public void postDelayed(Runnable action, long delayMillis) {\n        final HandlerAction handlerAction = new HandlerAction(action, delayMillis);\n\n        synchronized (this) {\n            if (mActions == null) {\n                mActions = new HandlerAction[4];\n            }\n            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);\n            mCount++;\n        }\n    }\n\n    // 这里才是真的执行方法\n    public void executeActions(Handler handler) {\n        synchronized (this) {\n            final HandlerAction[] actions = mActions;\n            for (int i = 0, count = mCount; i &lt; count; i++) {\n                final HandlerAction handlerAction = actions[i];\n                handler.postDelayed(handlerAction.action, handlerAction.delay);\n            }\n\n            mActions = null;\n            mCount = 0;\n        }\n    }\n}\n</code></pre>\n<p>通过查看 HandlerActionQueue 的源码，我们发现了一个问题：不同于在 onCreate() 直接获取 View 的宽高，我们调用 post 方法，其中的 run 方法并没有被马上执行。</p>\n<p>这样就不难解释为什么用这种方式可以获取到宽高了。那我们可以猜测一下，这种情况下，一定是 View 完成测量后才执行了这个方法，所以我们才可以拿到宽高信息。</p>\n<p>事实上也正是这样的，那么这个方法到底是在什么时候执行的呢？很明显，HandlerActionQueue#executeActions 才是真正完成调用的方法，那这个方法又做了些什么工作呢？</p>\n<p><strong>根据代码可知，该方法接收一个 Handler，然后使用这个 Handler 对当前队列中的所有 Runnable 进行处理，即 post 到该 Handler 的线程中，按照优先级对这些 Runnable 依次进行处理。</strong></p>\n<p><strong>简单来说，就是传入的 Handler 决定着这些 Runnable 的执行线程。</strong></p>\n<p>接下来，我们来追踪这个方法的调用情况。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5419805-e0cf86fbea081bc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"executeActions() 的调用情况\"></p>\n<p>我们注意到，对于该方法出现了两次调用，一次在 View#dispatchAttachToWindow（就是我们最开始找到的那个方法），另一次是在 ViewRootImpl#performTraversals。</p>\n<h4 id=\"3-万恶之源-performTraversals\"><a href=\"#3-万恶之源-performTraversals\" class=\"headerlink\" title=\"3. 万恶之源 performTraversals()\"></a>3. 万恶之源 performTraversals()</h4><p>很明显，所有的证据都指向了 performTraversals ，那么下面我们就来重点分析一下这个方法。</p>\n<p>如果你了解过 View 的测绘流程，那你对这个方法一定不会陌生，因为这个方法就是 View 绘制流程的起点。</p>\n<pre><code class=\"java\">private void performTraversals() {\n\n    // 此处的 host 是根布局 DecorView，用递归的方式一层一层的调用 dispatchAttachedToWindow\n    // mAttachInfo 是不是很眼熟，就是最开始 View#post 的第一层判断\n    // 这个 mAttachInfo 在 ViewRootImpl 的构造器中初始化的，其持有 ViewRootImpl 的 Handler 对象\n    host.dispatchAttachedToWindow(mAttachInfo, 0);\n    getRunQueue().executeActions(mAttachInfo.mHandler);\n\n    // 绘制流程就从这里开始\n    performMeasure();\n    performLayout();\n    performDraw();\n}\n</code></pre>\n<p>我们先从 dispatchAttachedToWindow 开始，我们之前已经看过这个方法的源码了：</p>\n<pre><code class=\"java\">void dispatchAttachedToWindow(AttachInfo info, int visibility) {\n    mAttachInfo = info;\n    // Transfer all pending runnables. 转移所有待办任务\n    if (mRunQueue != null) {\n        mRunQueue.executeActions(info.mHandler);\n        mRunQueue = null;\n    }\n    // 回调方法\n    onAttachedToWindow();\n}\n</code></pre>\n<p><strong>现在来进行分析：</strong></p>\n<ol>\n<li>我们已经知道了此方法是从根视图开始递归向下调用的，那么递归到最深处，就会轮到最开始我们调用 post 方法的 View 对象来执行该方法，也就是该方法内的所有属性，都是我们 findViewById 获得的那个 View 对象的属性；</li>\n<li>而且我们也知道，第一个参数 AttachInfo 就是 ViewRootImpl 中初始化的 AttachInfo，它持有当前 ViewRootImpl 的 Handler 对象引用，并将该引用传给了 executeActions()。此时，我们再来回顾一下 <strong>executeActions()</strong> 方法的作用，<strong>传入的 Handler 决定着队列里这些 Runnable 的执行线程</strong>。</li>\n</ol>\n<p>很明显，此处的 mRunQueue 就是我们最开始调用 post() 时，调用 View#getRunQueue 返回的那个对象，这个对象中有准备获取View高度的 Runnable 对象，也就是说 <strong>mRunQueue 通过调用 executeActions() 将当前 View 的所有 Runnable ，都会转由 ViewRootImpl 的 Handler 来处理！</strong>而在完成这个工作之后，当前 View 也显示地将 mRunQueue 置空，因为所有的待办任务都已经交给 ViewRootImpl 去处理了。</p>\n<p>现在再回过头看代码的注释，就差不多可以理解了：</p>\n<pre><code class=\"java\">// Postpone the runnable until we know on which thread it needs to run.\n// Assume that the runnable will be successfully placed after attach.\n// 所有的 Runnable 都会在 attach 之后被正确的放到其应该运行的线程上去\ngetRunQueue().post(action);\n\n// Transfer all pending runnables.\n// 转移所有待办任务(到 ViewRootImpl 中进行处理)\nif (mRunQueue != null) {\n    mRunQueue.executeActions(info.mHandler);\n    mRunQueue = null;\n}\n</code></pre>\n<p>dispatch 方法执行完了，我们继续回来走 performTraversals() ，接下来一句是：</p>\n<pre><code class=\"java\">// 有之前的经验，我们知道这句话的意思是\n// 使用 mAttachInfo.mHandler 来处理 getRunQueue() 中的 Runnable 任务\ngetRunQueue().executeActions(mAttachInfo.mHandler);\n</code></pre>\n<p>要明确的一点是，此时我们处在 ViewRootImpl 类中，此处的 getRunQueue() 方法有别于 View#post：</p>\n<pre><code class=\"java\">// ViewRootImpl#getRunQueue\n// 使用 ThreadLocal 来存储每个线程自身的执行队列 HandlerActionQueue\nstatic HandlerActionQueue getRunQueue() {\n    // sRunQueues 是 ThreadLocal&lt;HandlerActionQueue&gt; 对象\n    HandlerActionQueue rq = sRunQueues.get();\n    if (rq != null) {\n        return rq;\n    }\n    rq = new HandlerActionQueue();\n    sRunQueues.set(rq);\n    return rq;\n}\n\n// View#post\n// 为当前 View 返回一个执行队列，但是在 dispatchAttachToWindow 时转到 UI 线程去\nprivate HandlerActionQueue getRunQueue() {\n    if (mRunQueue == null) {\n        mRunQueue = new HandlerActionQueue();\n    }\n    return mRunQueue;\n}\n</code></pre>\n<p>说回 performTraversals() ，很明显 getRunQueue() 是 UI 线程执行队列的第一次初始化，也就是说当前这个任务队列里并没有待执行任务！</p>\n<p>但是需要注意的是，<strong>当前没有执行任务（</strong>HandlerActionQueue<strong>），不代表 Handler 消息队列中没有消息</strong>，这是两个概念，需要注意区分开。</p>\n<p>总结一下：</p>\n<ol>\n<li>View#post 方法调用时，会为当前 View 对象初始化一个 HandlerActionQueue ，并将 Runnable 入队存储；</li>\n<li>等在 ViewRootImpl#performTraversals 中递归调用到 View#dispatchAttachedToWindow 时，会将 ViewRootImpl 的 Handler 对象传下来，然后通过这个 Handler 将最初的 Runnable 发送到 UI 线程（消息队列中）等待执行，并将 View 的 HandlerActionQueue 对象置空，方便回收；</li>\n<li>ViewRootImpl#performTraversals 继续执行，才会为 UI 线程首次初始化 HandlerActionQueue 对象，并通过 ThreadLocal 进行存储，方便之后的复用，但需要注意的是，此处初始化的队列中是没有任何 Runnable 对象的；</li>\n<li>然后 ViewRootImpl#performTraversals 继续执行，开始 View 的测量流程。</li>\n</ol>\n<h3 id=\"View-post-中-Runnable-run-执行的时机\"><a href=\"#View-post-中-Runnable-run-执行的时机\" class=\"headerlink\" title=\"View#post 中 Runnable#run 执行的时机\"></a>View#post 中 Runnable#run 执行的时机</h3><p>但现在的问题是，无论怎么说，<strong>HandlerActionQueue#executeActions 都是先于 View 测绘流程的</strong>，为什么在还没有完成测量的时候，就可以拿到宽高信息？</p>\n<p>我们都知道，Android 系统是基于消息机制运行的，所有的事件、行为，都是基于 Handler 消息机制在运行的。所以，当 ViewRootImpl#performTraversals 在执行的时候，也一定是基于某个消息的。而且，HandlerActionQueue#executeActions 执行的时候，也只是通过 Handler 将 Runnable post 到了 UI 线程等待执行（还记得 View#post 的注释吗？）。</p>\n<p>不出意外的话，此时 UI 线程正忙着执行 ViewRootImpl#performTraversal ，等该方法执行完毕，View 已经完成了测量流程，此时再去执行 Runnable#run ，也就自然可以获取到 View 的宽高信息了。</p>\n<p>下面用具体的实例佐证一下我们的猜想。</p>\n<pre><code class=\"JAVA\">@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    final ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();\n\n    // 等待 Add 到父布局中\n    view = new View(this) {\n        @Override\n        protected void onLayout( ... ... ) {\n            super.onLayout(changed, left, top, right, bottom);\n            Log.e(&quot;Test&quot;, &quot;执行了onLayout()&quot;);\n        }\n    };\n\n    // 自己声明的 Handler \n    mHandler.post(new Runnable() {\n        @Override\n        public void run() {\n            Log.e(&quot;Test&quot;, &quot;mHandler.post ---- &gt; &quot; + view.getHeight());\n        }\n    });\n\n    // onCreate() 中 mAttachInfo 还未被赋值，这里会交给 ViewRootImpl 的 Handler 来处理\n    // 即加入消息队列，等待执行\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());\n        }\n    });\n\n    viewGroup.addView(view);\n}\n</code></pre>\n<p>最终打印日志如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5419805-ec13fe6929791de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>也就是说：</p>\n<ol>\n<li>Handler#post 首先执行，其 post 的时间点在 onCreate() 方法内，在消息队列中的位置一定比 performTraversals() 靠前；</li>\n<li>ViewRootImpl#performTraversal 执行，过程中执行了 View#dispatchAttachedToWindow 方法，将最初的 Runnable 入队后进行测量流程，完成了 layout 过程；</li>\n<li>之后才执行了最初的 View#post 方法，也就说明了，在 View#dispatchAttachedToWindow 中使用 ViewRootImpl 的 Handler postDelay 的 Runnable 对象，在主线程消息队列中，确实是排在 ViewRootImpl#performTraversal 之后的</li>\n</ol>\n<h3 id=\"View-post-整体流程的简单总结\"><a href=\"#View-post-整体流程的简单总结\" class=\"headerlink\" title=\"View#post 整体流程的简单总结\"></a>View#post 整体流程的简单总结</h3><p>最后大概总结一下：</p>\n<p>当我们使用 View#post 时，会有两种情况：</p>\n<ol>\n<li>在当前 View attach 到 Window 之前，会自己先维护一个 HandlerActionQueue 对象，用来存储当前的 Runnable 对象，然后等到 Attach 到 Window 的时候 (也就是 ViewRootImpl 执行到 performTraversal 方法时) ，会统一将 Runnable 转交给 ViewRootImpl 处理；</li>\n<li>而在 View#dispatchAttachedToWindow 时，也会为当前 View 初始化一个 AttachInfo 对象，该对象持有 ViewRootImpl 的引用，当 View 有此对象后，后续的所有 Runnable 都将直接交给 ViewRootImpl 处理；</li>\n<li>而 ViewRootImpl 也会在执行 performTraversal 方法，也会调用 ViewRootImpl#getRunQueue ，利用 ThreadLocal 来为主线程维护一个 HandlerActionQueue 对象，至此，ViewRootImpl 内部都将使用该队列来进行 Runnable 任务的短期维护；</li>\n<li>但需要注意的是，各个 View 调用的 post 方法，仍然是由各自的 HandlerActionQueue 对象来入队任务的，然后在 View#dispatchAttachedToWindow 的时候转移给 ViewRootImpl 去处理。</li>\n</ol>\n<h3 id=\"Android-7-0-里-View-post-的变动以及原因\"><a href=\"#Android-7-0-里-View-post-的变动以及原因\" class=\"headerlink\" title=\"Android 7.0 里 View#post 的变动以及原因\"></a>Android 7.0 里 View#post 的变动以及原因</h3><p>View#post 说到这里大概就差不多了，文章开篇的时候说到：</p>\n<blockquote>\n<p>Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别</p>\n</blockquote>\n<p>下面来简单对比一下具体的差别，顺便分析一下具体为什么要这样改动。</p>\n<p>实际上这个方法的改动主要是为了解决一个 bug，这个 bug 就是：<strong>在 View 被 attach 到 window 之前，从子线程调用的 View#post ，永远无法得到执行。</strong></p>\n<p>具体原因，我们来看一下 API23 版本的 View#post，就大概都明白了：</p>\n<pre><code class=\"java\">// Android API23 View#post\npublic boolean post(Runnable action) {\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        return attachInfo.mHandler.post(action);\n    }\n    // Assume that post will succeed later\n    // 注意此处，不同于我们之前介绍的，这里是直接使用 ViewRootImpl#getRunQueue 来入队任务的\n    ViewRootImpl.getRunQueue().post(action);\n    return true;\n}\n</code></pre>\n<p>我们可以看到，不同于我们之前介绍的，API23 版本中，View#post 在没有 attach 到 window 之前，也就是 mAttachInfo 是 null 的时候，不是自己维护任务队列，而是直接使用 ViewRootImpl#getRunQueue 来入队任务的。</p>\n<p>再来看一下 ViewRootImpl#getRunQueue 方法，我们就会发现问题出在哪里了：</p>\n<pre><code class=\"java\">static final ThreadLocal&lt;RunQueue&gt; sRunQueues = new ThreadLocal&lt;RunQueue&gt;();\nstatic RunQueue getRunQueue() {\n    RunQueue rq = sRunQueues.get();\n    if (rq != null) {\n        return rq;\n    }\n    rq = new RunQueue();\n    sRunQueues.set(rq);\n    return rq;\n}\n</code></pre>\n<p>没错，这个队列的保存与获取，是通过以线程为 key 值来存取对象 ThreadLocal 来维护的。而在这个版本的源码中，executeActions() 方法的执行，只有一次调用，那就是 ViewRootImpl#performTraversal 中（感兴趣的可以去 23 版本的源码中查看，这里就不贴图了），与此同时，该方法肯定是执行在主线程中的。</p>\n<p>现在的问题就变成了：<strong>我在子线程中 post 了一个 runnable，并且系统以该子线程为 key 将队列存了起来等待执行；但是在具体执行的时候，系统却是去主线程中寻找待执行的 Runnable，那么当然是永远都得不到执行的了。</strong></p>\n<p>而在<strong>具体 attach 到 window 之后</strong>，View 的 mAttachInfo 持有 ViewRootImpl 引用，会直接将所有的 Runnable 转交给 ViewRootImpl 的 Handler 处理，也<strong>就都能得到妥善处理，就与线程无关了。</strong></p>\n<p>除此以外，ViewRootImpl 使用 ThreadLocal 来存储队列信息，在某些情境下，还会导致内存泄漏。详细信息可以参考：<a href=\"https://blog.csdn.net/a740169405/article/details/69668957\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/a740169405/article/details/69668957</a></p>\n<p>所以，<strong>Google 工程师为了解决这两个问题（内存泄漏的问题更严重一些），就在 View#post 方法中使用 View 对象来进行队列的存储，然后在 attach 到 window 的时候，通过持有 ViewRootImpl 引用的 AttachInfo 对象直接将 View 对象的 Runnable 处理掉，就完美解决了这些问题。</strong></p>\n<h3 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h3><p>下边是自己研究的时候具体参考过的文章，给各位前辈加个鸡腿：</p>\n<h5 id=\"https-blog-csdn-net-a740169405-article-details-69668957\"><a href=\"#https-blog-csdn-net-a740169405-article-details-69668957\" class=\"headerlink\" title=\"https://blog.csdn.net/a740169405/article/details/69668957\"></a><a href=\"https://blog.csdn.net/a740169405/article/details/69668957\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/a740169405/article/details/69668957</a></h5><h5 id=\"https-blog-csdn-net-scnuxisan225-article-details-49815269\"><a href=\"#https-blog-csdn-net-scnuxisan225-article-details-49815269\" class=\"headerlink\" title=\"https://blog.csdn.net/scnuxisan225/article/details/49815269\"></a><a href=\"https://blog.csdn.net/scnuxisan225/article/details/49815269\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/scnuxisan225/article/details/49815269</a></h5><h5 id=\"https-www-cnblogs-com-plokmju-p-7481727-html\"><a href=\"#https-www-cnblogs-com-plokmju-p-7481727-html\" class=\"headerlink\" title=\"https://www.cnblogs.com/plokmju/p/7481727.html\"></a><a href=\"https://www.cnblogs.com/plokmju/p/7481727.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/plokmju/p/7481727.html</a></h5>"},{"thumbnail":"//raw.githubusercontent.com/Joeljt/BlogImage/master/20190410195304.jpg","title":"Activity 启动流程","date":"2019-08-29T16:00:00.000Z","_content":"\n\n\n当我们调用 startActivity() 的时候，实际上发生了什么？\n\n\n\n<!-- more --> \n\n\n\n## 前言\n\n这篇来介绍一下 Activity 启动流程。\n\n这几乎是向高级工程师进阶时无法跳过的一步，整个过程涉及到的知识点也纷繁复杂，加之系统源码在 API23 之后又做过大幅修改，所以大家可能会发现点开不同的文章，贴的源码都不一样，也不知道谁是对的，其实他们都是对的。在这种情况下，在这篇文章中，我们也不打算一堆一堆地贴源码，只能是通过文章梳理出思路，理清脉络，初探系统源码，帮助我们更好地进行应用层的开发。\n\n要理解 Activity 的启动流程，有几个基本的门槛需要了解，虽说不用全部精通吧，但是起码要混个脸熟：\n\n1. Binder 机制\n2. Handler 机制 \n3. Instrumentation\n4. ActivityThread\n5. ApplicationThread\n6. ActivityManagerService\n\n乍一看这么多没见过的东西，可能都有点慌，我们来一个个的解释一下。\n\n\n\n\n## 门槛简介\n\n### 对 Binder 机制的理解\n\n其实我也不是很懂 Binder 机制，只能差不多说个大概。我们都知道 Android 是基于 Linux 内核的，每个 App 都是一个单独的进程，一些系统服务需要在开机时就初始化好，这些系统应用也是运行在某个进程中的。那我们在 Android 系统中进行的所有操作，都是需要通过这些系统服务来实现的。但是不同的进程间要进行通信，就需要借助特殊的方式。\n\n常见的进程间通信的方式一般包括管道、socket、共享内存等，但是 Android 系统有其特殊性，Binder 机制就是 Android 系统中特有的进程间通信机制，整体设计思想也是面向对象的。Binder 的英文释义为**粘合剂**，这与 Binder 机制的工作原理十分契合。诸如 ActivityManagerService 这种的系统级服务，在系统进程中初始化完成后，通过 Binder 机制配合代理模式，将服务的引用散落在系统的各个 App 进程中，各个 App 的代理引用就用过 Binder 机制与系统进程的实际对象进行了映射和绑定，就实现了**粘合**，也就是面向对象思想的体现。\n\n掉书袋的解释就是，**Binder 本质上就是一种底层的通信机制，与具体的服务没有关系。Binder 机制采用代理设计模式，定义一个抽象接口，Client 和 Server 都实现该接口，Server 端是真正的功能实现，Client 端只是对这些函数远程调用请求的包装，C/S 两端通过 binder 驱动来进行具体的细节交互。**\n\n就好比说，\n\n我其实是个菜鸡，但是满世界给人吹牛说自己技术有多好，等真有复杂的需求了，我其实是把要做的事情打包给认识的大佬，大佬做好之后直接给我，我再直接把成果给人家需求方。\n\n在这个例子中，我就是 Client，大佬就是 Server，我打包资料给他这个动作就是 binder 驱动做的工作，在 binder 机制中，这个过程是通过面向接口的方式完成的。\n\n这么说大家应该对 binder 机制有个大概的认识了，实际上 binder 机制还很复杂，有兴趣的可以拜读一下[这篇文章](https://blog.csdn.net/universus/article/details/6211589)，8 年过去了，还是没人能够超越作者当年的水平……\n\n\n\n### Instrumentation\n\n翻译为仪器。每一个应用程序，或者说每一个进程，只有一个 Instrumentation 对象，优先于 application 创建。当前 App 中，每个 activity 内都有对 Instrumentation 对象的引用。Instrumentation 可以理解成应用进程的大管家，Activity 的所有动作，从创建到销毁，实际上都是用 Instrumentation 来操作的。\n\n\n\n### ActivityThread\n\n这里就是每个 App 的入口。写太久 Android，大家可能忘记了 Java 程序的入口是 main() 方法，Android 程序的 main() 方法就在 ActivityThread 这个类中。这里就是 App 真正的入口。当开启 App 时，会初始化一个 Looper 对象，调用 attach() 方法，进行 App 的初始化工作，之后就会开启消息循环队列，与 AMS 配合，一起完成 App 的交互管理工作。\n\nActivityThread 实际上并不是 Thread，它只是运行在主线程，也就是我们常说的 UI 线程中，可以理解成 ActivityThread 是 UI 线程的表现形式。\n\n\n\n### ApplicationThread\n\nApplicationThread 是 ActivityThread 的内部类，实现了 IApplicationThread，通过 ApplicationThreadProxy 代理类来与 ActivityManagerService 进行 binder 通信。简单来说，ActivityManagerService 通过 ApplicationThreadProxy 来与 ApplicationThread 进行 binder 通信，从而执行对 application 以及 activity 的各项操作。\n\n\n\n### ActivityManagerService\n\n服务端对象，简称 AMS。AMS 是 Android 中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在 Android 中非常重要。AMS 主要通过 binder 机制与应用层进行通信，在之前的例子中，AMS 就是在背后处理工作的大佬。\n\n\n\n## Activity 启动的大体流程\n\n正如之前所说，系统源码在不同的版本中不完全相同，就我实际翻找来看，目前至少有三个版本的系统源码，所以我们暂时不打算详细了解这部分差异内容，有机会的话，等下次再写篇文章对比。\n\n但是不管怎么说，万变不离其宗，大体的启动流程还是没有发生变化的，今天我们的重点就是这部分内容。\n\n在开始之前，请先允许我高水平地用一句话概括一下 Activity 的启动流程。\n\n**当 startActivity 方法被调用时，首先经由 Instrumentation 类中转，然后在过程中对任务栈等信息进行处理（不同版本源码的区别都在这一步），最终在 AMS 中通过 binder 通信的方式，将启动命令回调到 ApplicationThread 类中进行处理，该类通过 Handler 消息机制发送 LAUNCH_ACTIVITY 的消息并接收处理，最终将启动命令交回给 Instrumentation 处理，利用反射机制初始化待启动 Activity 的实例。**\n\n好了，下面我要开始贴源码了。\n\n1. Activity#startActivity -> Activity#startActivityForResult \n\n   ```java\n   @Override\n   public void startActivity(Intent intent) {\n     this.startActivity(intent, null);\n   }\n   \n   @Override\n   public void startActivity(Intent intent, @Nullable Bundle options) {\n     if (options != null) {\n       startActivityForResult(intent, -1, options);\n     } else {\n       // Note we want to go through this call for compatibility with\n       // applications that may have overridden the method.\n       startActivityForResult(intent, -1);\n     }\n   }\n   \n   public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {\n       startActivityForResult(intent, requestCode, null);\n   }\n   \n   public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n               @Nullable Bundle options) {\n       if (mParent == null) {\n         Instrumentation.ActivityResult ar =\n           mInstrumentation.execStartActivity(\n           this, mMainThread.getApplicationThread(), mToken, this,\n           intent, requestCode, options);\n       } else {\n         if (options != null) {\n           mParent.startActivityFromChild(this, intent, requestCode, options);\n         } else {\n           mParent.startActivityFromChild(this, intent, requestCode);\n         }\n       }\n   }\n   ```\n\n   我们看源码会发现，当 startActivity 被调用时，实际上在源码层面都是调用了 startActivityForResult，requestCode 传入的值为 -1，这也给我们提了个醒，就是真正调用 startActivityForResult 时，不可以在 requestCode 传入 -1，否则一定拿不到回调。\n\n   我们继续向下看会发现，经过一层层的方法重载，最终在一个 startActivityForResult 方法中，会调用 Instrumentation#execStartActivity，然后正式开启 IPC 之旅。\n\n2. Instrumentation#execStartActivity\n\n   ```java\n   public ActivityResult execStartActivity(\n     Context who, IBinder contextThread, IBinder token, Activity target,\n     Intent intent, int requestCode, Bundle options) {\n   \n     \t// 从上边的调用可以看到，contextThread 传入的值为 mMainThread.getApplicationThread()\n     \t// 继续探究源码会发现，实际传入的为 ActivityThread 内部类 ApplicationThread 的实例对象\n       IApplicationThread whoThread = (IApplicationThread) contextThread;\n   \n     \t// 重点就在这里\n       int result = ActivityManager.getService()\n         .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolveTypeIfNeeded(who.getContentResolver()),\n                        token, target != null ? target.mEmbeddedID : null,\n                        requestCode, 0, null, options);\n   \n       checkStartActivityResult(result, intent);\n   \n       return null;\n   }\n   \n   ```\n\n   binder 通信就从这个方法开始：\n\n   ```java\n   public static IActivityManager getService() {\n     \treturn IActivityManagerSingleton.get();\n   }\n   \n   private static final Singleton<IActivityManager> IActivityManagerSingleton =\n       new Singleton<IActivityManager>() {\n           @Override\n           protected IActivityManager create() {\n               final IBinder b =ServiceManager.getService(Context.ACTIVITY_SERVICE);\n               final IActivityManager am = IActivityManager.Stub.asInterface(b);\n               return am;\n           }\n   };\n   ```\n\n   接触过 AIDL 的朋友可能会对这部分代码相对熟悉，简单来说，就是 ActivityManager.getService() 返回了一个 IActivityManager 的实例对象。可以理解成面向接口编程，接口无法被实例化，所以 getService() 返回的一定是 IActivityManager 的实现类对象。\n\n   这里我们不需要关心 binder 机制是如何实现的，只需要知道这个方法通过 binder 驱动，利用 IActivityManager 与系统进程的 ActivityManagerService 建立了连接，并为我们返回了它的引用即可。也就是说，getService() 方法的返回值就是 AMS 的实例。\n\n   我们再看之前的代码：\n\n   ```java\n   int result = ActivityManager.getService().startActivity()\n   ```\n\n   很明显，我们的下一站，就是 AMS 的 startActivity() 方法\n\n3. ActivityManagerService#startActivity\n\n   ```java\n   @Override\n   public final int startActivity( ... ... ) {\n     \treturn startActivityAsUser(... ...);\n   }\n   ```\n\n   从这一步开始，AMS 就会利用几个管理类来对待启动的 activity 进行一些任务栈、启动模式等的处理。如我们之前所说，不同版本的系统源码正是在这个位置有所区别：\n\n   - API 23 之前，利用 ActivityStackSupervisor、ActivityStack等对任务栈、启动模式等进行处理，启动过程中将当前所在的 Activity 先暂停，判断目标 activity 是否有实例，有则复用，没有就新建，在流程的最后，调用 ActivityStackSupervisor#realStartActivityLocked 方法，回到客户端层，即 ApplicationThread，处理启动逻辑\n   - API 28 之前，引入 ActivityStarter 类，它是 AMS 管理 Activity 启动过程的一个管理类，并在 ActivityStackSupervisor 中新增了一些诸如 resolveIntent、resolveActivity 等方法，用来解析待启动的 activity 信息等，在 AMS 旅途的终点同样是 ActivityStackSupervisor#realStartActivityLocked 方法\n   - API 28 再次对源码做了修改，Android 9.0 首次引入了事务机制来启动Activity，而以前都是通过主线程，直接 app.thread.scheduleLaunchActivity 调度执行，这是最大的差别\n\n4. ActivityStackSupervisor#realStartActivityLocked\n\n   ```java\n   final boolean realStartActivityLocked(... ...) {\n     \tapp.thread.scheduleLaunchActivity(... ...);\n   \t\treturn true;\n   }\n   ```\n\n   上面的方法我删减了大量代码，只留下了最关键的一行调用。点进去看，我们会发现 app.thread 是 IApplicationThread 对象，而 IApplicationThread 在 Client 端的实现正是 ApplicationThread，也就是说我们要看 ApplicationThread 的 scheduleLaunchActivity。\n\n5. ApplicationThread#scheduleLaunchActivity\n\n   ```java\n   @Override\n   public final void scheduleLaunchActivity( ... ...) {\n       ActivityClientRecord r = new ActivityClientRecord();\n       sendMessage(H.LAUNCH_ACTIVITY, r);\n   }\n   \n   public void handleMessage(Message msg) {\n       switch (msg.what) {\n           case LAUNCH_ACTIVITY: \n               final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n               handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n               break;\n       }\n   }\n    \n   private void handleLaunchActivity(... ...) {\n   \t\tActivity a = performLaunchActivity(... ...);\n   }\n   \n   private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n     \t Activity activity = null;\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n     \t return activity;\n   }\n   ```\n\n   顺着代码看下来，就会发现，代码经过 IApplicationThread 回调回到 Client 端 ActivityThread 后，发送了 LAUNCH_ACTIVITY 的消息，然后在 Handler 的回调中，调用了 handleLaunchActivity 方法，最后进入了 performLaunchActivity() 方法中。\n\n   在这个方法中，我们会发现目标 activity 的初始化就是在这里完成的，由之前我们提到的 Instrumentation 对象，通过反射的方式进行的初始化。\n\n\n\n好了，Activity 启动流程大概就是这样了。\n\n\n\n## UI 进程是怎么和服务进程发生绑定的？\n\n如果大家认真走过整个流程，会发现在 Activity 启动的流程中，binder 机制都是单向的。在流程开始时，通过 ActivityManager.getService() 拿到的是 IActivityManager 接口的实现，也就是 Server 端的 AMS 对象；而在流程快要结束，AMS 的工作处理完成后，是通过 IApplicationThread 接口将操作逻辑还给 Client 端的，也就是 ApplicationThread 对象。\n\n那细心的朋友可能就会问，这两个对象又是怎么发生绑定的？我在 Server 端，也就是 AMS 中是怎么知道我对应的 Client 端是谁，我处理完业务后怎么把结果回传给 Client 呢？下面我们就来为大家解答一下这个疑问。\n\n故事的重点就在于 App 的入口，ActivityThread#main()  中。\n\n我们之前说过，在这个 main() 方法中，程序会初始化一个 mainLooper，然后做一些初始化操作，之后就会开启循环队列，等待系统消息的分发处理。但是在这之前，还有一个重要的 attach() 方法，这个方法中就有我们要找的答案。\n\nActivityThread#main() & ActivityThread#attach()   \n\n```java\npublic static void main(String[] args) {\n  \t// 初始化主线程 MainLooper\n    Looper.prepareMainLooper();\n\t\t\n  \t// 初始化 ActivityThread 实例，调用 attach 方法，入参 false\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false);\n\t\t\n  \t// 开启 Looper 循环\n    Looper.loop();\n  \n  \t// 主线程 Looper 不可以停止，一旦停止就会抛异常\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n\nprivate void attach(boolean system) {\n    sCurrentActivityThread = this;\n    mSystemThread = system;\n  \t// \n    if (!system) {\n      \tIActivityManager mgr = ActivityManager.getService();\n      \tmgr.attachApplication(mAppThread);\n    } else {\n      \t// 如果是系统进程，那初始化一个 Instrumentation 对象，创建 Context、Application 对象\n      \t// 调用 application 的 onCreate 方法\n        mInstrumentation = new Instrumentation();\n        ContextImpl context = ContextImpl.createAppContext(\n          this, getSystemContext().mPackageInfo);\n        mInitialApplication = context.mPackageInfo.makeApplication(true, null);\n        mInitialApplication.onCreate();\n    }\n}\n```\n\n如上所示，在 attach() 方法中，会判断一下当前是否为系统进程，而在 ActivityThread 中调用此方法时，传入的值一律为 false，而在 SystemServer 初始化时才会传入 true。\n\nActivityThread#systemMain，在 SystemServer#createSystemContext() 中调用：\n\n```java\npublic static ActivityThread systemMain() {\n    ActivityThread thread = new ActivityThread();\n    thread.attach(true);\n    return thread;\n}\n```\n\n如果不是系统进程，则会根据 binder 机制，通过 IActivityManager 与 AMS 建立连接，调用  attachApplication 方法，并将 IApplicationThread 实例对象传入 AMS，这样一来，IActivityManager 和 IApplicationThread 就建立了绑定关系。\n\n\n\n## Application 又是什么时候初始化的\n\n接下来我们看一下 application 绑定的过程。\n\n```java\n// ActivityManagerService#attachApplication\npublic final void attachApplication(IApplicationThread thread) {\n    synchronized (this) {\n      int callingPid = Binder.getCallingPid();\n      final long origId = Binder.clearCallingIdentity();\n      attachApplicationLocked(thread, callingPid);\n      Binder.restoreCallingIdentity(origId);\n    }\n}\n\n// ActivityManagerService#attachApplicationLocked\nprivate boolean attachApplicationLocked(IApplicationThread thread, int pid) {\n\n    if (app.instr != null) {\n      thread.bindApplication(processName, appInfo, providers,\n                             app.instr.mClass,\n                             profilerInfo, app.instr.mArguments,\n                             app.instr.mWatcher,\n                             app.instr.mUiAutomationConnection, testMode,\n                             mBinderTransactionTrackingEnabled, enableTrackAllocation,\n                             isRestrictedBackupMode || !normalMode, app.persistent,\n                             new Configuration(getGlobalConfiguration()), app.compat,\n                             getCommonServicesLocked(app.isolated),\n                             mCoreSettingsObserver.getCoreSettingsLocked(),\n                             buildSerial);\n    } else {\n      thread.bindApplication(processName, appInfo, providers, null, profilerInfo,\n                             null, null, null, testMode,\n                             mBinderTransactionTrackingEnabled, enableTrackAllocation,\n                             isRestrictedBackupMode || !normalMode, app.persistent,\n                             new Configuration(getGlobalConfiguration()), app.compat,\n                             getCommonServicesLocked(app.isolated),\n                             mCoreSettingsObserver.getCoreSettingsLocked(),\n                             buildSerial);\n    }\n\n  \treturn true;\n}\n\n// 很明显，通过 IApplicationThread 又将代码回调到了 Client 端\n// ApplicationThread#bindApplication\npublic final void bindApplication(... ...) {\n  \tsendMessage(H.BIND_APPLICATION, data);\n}\n\n// 根据消息机制，我们在 ActivityThread#H 中寻找消息处理\npublic void handleMessage(Message msg) {\n    case BIND_APPLICATION:\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n        AppBindData data = (AppBindData)msg.obj;\n        handleBindApplication(data);\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    break;\n}\n\n// ActivityThread#handleBindApplication\nprivate void handleBindApplication(AppBindData data) {\n\n    final InstrumentationInfo ii;\n    if (data.instrumentationName != null) {\n        ii = new ApplicationPackageManager(null, getPackageManager())\n          .getInstrumentationInfo(data.instrumentationName, 0);\n    } else {\n      \tii = null;\n    }\n\n    // 根据上层调用传入的参数，决定初始化 mInstrumentation 实例的方式\n  \t// 1. 使用 ClassLoader 初始化；2. 直接 new 对象\n    if (ii != null) {\n        final ApplicationInfo instrApp = new ApplicationInfo();\n        ii.copyTo(instrApp);\n        instrApp.initForUser(UserHandle.myUserId());\n        final LoadedApk pi = getPackageInfo(......);\n        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);\n\n        try {\n          final ClassLoader cl = instrContext.getClassLoader();\n          mInstrumentation = (Instrumentation)\n            cl.loadClass(data.instrumentationName.getClassName()).newInstance();\n        } \n\n        final ComponentName component = new ComponentName(ii.packageName, ii.name);\n        mInstrumentation.init(... ...);\n    } else {\n      \tmInstrumentation = new Instrumentation();\n    }\n\n    try {\n      \t// 调用 makeApplication 创建当前 App 的 Application 对象\n        Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n        mInitialApplication = app; \n      \t\n      \t// 初始化 application 对象后，通过 mInstrumentation 调用 application 的 onCreate 方法\n        mInstrumentation.onCreate(data.instrumentationArgs);\n        mInstrumentation.callApplicationOnCreate(app);\n    }\n}\n\n// LoadedApk#makeApplication\npublic Application makeApplication(boolean forceDefaultAppClass,\n                                   Instrumentation instrumentation) {\n    if (mApplication != null) {\n      return mApplication;\n    }\n\n    java.lang.ClassLoader cl = getClassLoader();\n    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n    // 入参的 instrumentation 为 null，使用 ActivityThread 的 mInstrumentation\n    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);\n    appContext.setOuterContext(app);\n\n    // 调用时传入的值为 null，所以不会进 if\n    if (instrumentation != null) {\n      instrumentation.callApplicationOnCreate(app);   \n    }\n\n    return app;\n}\n\n```\n\n经过层层调用，我们最终发现，Application 的初始化也是通过 Instrumentation 来处理的，现在大家能理解为什么管它叫应用程序的大管家了吧，因为事无巨细，全是它来做的呀！\n\n```java\npublic Application newApplication(ClassLoader cl, String className, Context context) {\n  \treturn newApplication(cl.loadClass(className), context);\n}\n\nstatic public Application newApplication(Class<?> clazz, Context context){\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n```\n\n我们可以发现，application 实例的创建也是通过反射的方式实现的。\n\n流程走到这里，Application 实例是怎么创建的，C/S 是怎么发生绑定的，整个 App 是怎么被 Instumentation 支配的，大概都已经介绍清楚了。\n\n完结，撒花！！\n\n   \n\n   \n\n   \n\n   ","source":"_posts/start-activity-procedure.md","raw":"---\nthumbnail: //raw.githubusercontent.com/Joeljt/BlogImage/master/20190410195304.jpg\ntitle: Activity 启动流程\ntags: [Android]\ndate: 2019-08-30\n---\n\n\n\n当我们调用 startActivity() 的时候，实际上发生了什么？\n\n\n\n<!-- more --> \n\n\n\n## 前言\n\n这篇来介绍一下 Activity 启动流程。\n\n这几乎是向高级工程师进阶时无法跳过的一步，整个过程涉及到的知识点也纷繁复杂，加之系统源码在 API23 之后又做过大幅修改，所以大家可能会发现点开不同的文章，贴的源码都不一样，也不知道谁是对的，其实他们都是对的。在这种情况下，在这篇文章中，我们也不打算一堆一堆地贴源码，只能是通过文章梳理出思路，理清脉络，初探系统源码，帮助我们更好地进行应用层的开发。\n\n要理解 Activity 的启动流程，有几个基本的门槛需要了解，虽说不用全部精通吧，但是起码要混个脸熟：\n\n1. Binder 机制\n2. Handler 机制 \n3. Instrumentation\n4. ActivityThread\n5. ApplicationThread\n6. ActivityManagerService\n\n乍一看这么多没见过的东西，可能都有点慌，我们来一个个的解释一下。\n\n\n\n\n## 门槛简介\n\n### 对 Binder 机制的理解\n\n其实我也不是很懂 Binder 机制，只能差不多说个大概。我们都知道 Android 是基于 Linux 内核的，每个 App 都是一个单独的进程，一些系统服务需要在开机时就初始化好，这些系统应用也是运行在某个进程中的。那我们在 Android 系统中进行的所有操作，都是需要通过这些系统服务来实现的。但是不同的进程间要进行通信，就需要借助特殊的方式。\n\n常见的进程间通信的方式一般包括管道、socket、共享内存等，但是 Android 系统有其特殊性，Binder 机制就是 Android 系统中特有的进程间通信机制，整体设计思想也是面向对象的。Binder 的英文释义为**粘合剂**，这与 Binder 机制的工作原理十分契合。诸如 ActivityManagerService 这种的系统级服务，在系统进程中初始化完成后，通过 Binder 机制配合代理模式，将服务的引用散落在系统的各个 App 进程中，各个 App 的代理引用就用过 Binder 机制与系统进程的实际对象进行了映射和绑定，就实现了**粘合**，也就是面向对象思想的体现。\n\n掉书袋的解释就是，**Binder 本质上就是一种底层的通信机制，与具体的服务没有关系。Binder 机制采用代理设计模式，定义一个抽象接口，Client 和 Server 都实现该接口，Server 端是真正的功能实现，Client 端只是对这些函数远程调用请求的包装，C/S 两端通过 binder 驱动来进行具体的细节交互。**\n\n就好比说，\n\n我其实是个菜鸡，但是满世界给人吹牛说自己技术有多好，等真有复杂的需求了，我其实是把要做的事情打包给认识的大佬，大佬做好之后直接给我，我再直接把成果给人家需求方。\n\n在这个例子中，我就是 Client，大佬就是 Server，我打包资料给他这个动作就是 binder 驱动做的工作，在 binder 机制中，这个过程是通过面向接口的方式完成的。\n\n这么说大家应该对 binder 机制有个大概的认识了，实际上 binder 机制还很复杂，有兴趣的可以拜读一下[这篇文章](https://blog.csdn.net/universus/article/details/6211589)，8 年过去了，还是没人能够超越作者当年的水平……\n\n\n\n### Instrumentation\n\n翻译为仪器。每一个应用程序，或者说每一个进程，只有一个 Instrumentation 对象，优先于 application 创建。当前 App 中，每个 activity 内都有对 Instrumentation 对象的引用。Instrumentation 可以理解成应用进程的大管家，Activity 的所有动作，从创建到销毁，实际上都是用 Instrumentation 来操作的。\n\n\n\n### ActivityThread\n\n这里就是每个 App 的入口。写太久 Android，大家可能忘记了 Java 程序的入口是 main() 方法，Android 程序的 main() 方法就在 ActivityThread 这个类中。这里就是 App 真正的入口。当开启 App 时，会初始化一个 Looper 对象，调用 attach() 方法，进行 App 的初始化工作，之后就会开启消息循环队列，与 AMS 配合，一起完成 App 的交互管理工作。\n\nActivityThread 实际上并不是 Thread，它只是运行在主线程，也就是我们常说的 UI 线程中，可以理解成 ActivityThread 是 UI 线程的表现形式。\n\n\n\n### ApplicationThread\n\nApplicationThread 是 ActivityThread 的内部类，实现了 IApplicationThread，通过 ApplicationThreadProxy 代理类来与 ActivityManagerService 进行 binder 通信。简单来说，ActivityManagerService 通过 ApplicationThreadProxy 来与 ApplicationThread 进行 binder 通信，从而执行对 application 以及 activity 的各项操作。\n\n\n\n### ActivityManagerService\n\n服务端对象，简称 AMS。AMS 是 Android 中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在 Android 中非常重要。AMS 主要通过 binder 机制与应用层进行通信，在之前的例子中，AMS 就是在背后处理工作的大佬。\n\n\n\n## Activity 启动的大体流程\n\n正如之前所说，系统源码在不同的版本中不完全相同，就我实际翻找来看，目前至少有三个版本的系统源码，所以我们暂时不打算详细了解这部分差异内容，有机会的话，等下次再写篇文章对比。\n\n但是不管怎么说，万变不离其宗，大体的启动流程还是没有发生变化的，今天我们的重点就是这部分内容。\n\n在开始之前，请先允许我高水平地用一句话概括一下 Activity 的启动流程。\n\n**当 startActivity 方法被调用时，首先经由 Instrumentation 类中转，然后在过程中对任务栈等信息进行处理（不同版本源码的区别都在这一步），最终在 AMS 中通过 binder 通信的方式，将启动命令回调到 ApplicationThread 类中进行处理，该类通过 Handler 消息机制发送 LAUNCH_ACTIVITY 的消息并接收处理，最终将启动命令交回给 Instrumentation 处理，利用反射机制初始化待启动 Activity 的实例。**\n\n好了，下面我要开始贴源码了。\n\n1. Activity#startActivity -> Activity#startActivityForResult \n\n   ```java\n   @Override\n   public void startActivity(Intent intent) {\n     this.startActivity(intent, null);\n   }\n   \n   @Override\n   public void startActivity(Intent intent, @Nullable Bundle options) {\n     if (options != null) {\n       startActivityForResult(intent, -1, options);\n     } else {\n       // Note we want to go through this call for compatibility with\n       // applications that may have overridden the method.\n       startActivityForResult(intent, -1);\n     }\n   }\n   \n   public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {\n       startActivityForResult(intent, requestCode, null);\n   }\n   \n   public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n               @Nullable Bundle options) {\n       if (mParent == null) {\n         Instrumentation.ActivityResult ar =\n           mInstrumentation.execStartActivity(\n           this, mMainThread.getApplicationThread(), mToken, this,\n           intent, requestCode, options);\n       } else {\n         if (options != null) {\n           mParent.startActivityFromChild(this, intent, requestCode, options);\n         } else {\n           mParent.startActivityFromChild(this, intent, requestCode);\n         }\n       }\n   }\n   ```\n\n   我们看源码会发现，当 startActivity 被调用时，实际上在源码层面都是调用了 startActivityForResult，requestCode 传入的值为 -1，这也给我们提了个醒，就是真正调用 startActivityForResult 时，不可以在 requestCode 传入 -1，否则一定拿不到回调。\n\n   我们继续向下看会发现，经过一层层的方法重载，最终在一个 startActivityForResult 方法中，会调用 Instrumentation#execStartActivity，然后正式开启 IPC 之旅。\n\n2. Instrumentation#execStartActivity\n\n   ```java\n   public ActivityResult execStartActivity(\n     Context who, IBinder contextThread, IBinder token, Activity target,\n     Intent intent, int requestCode, Bundle options) {\n   \n     \t// 从上边的调用可以看到，contextThread 传入的值为 mMainThread.getApplicationThread()\n     \t// 继续探究源码会发现，实际传入的为 ActivityThread 内部类 ApplicationThread 的实例对象\n       IApplicationThread whoThread = (IApplicationThread) contextThread;\n   \n     \t// 重点就在这里\n       int result = ActivityManager.getService()\n         .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolveTypeIfNeeded(who.getContentResolver()),\n                        token, target != null ? target.mEmbeddedID : null,\n                        requestCode, 0, null, options);\n   \n       checkStartActivityResult(result, intent);\n   \n       return null;\n   }\n   \n   ```\n\n   binder 通信就从这个方法开始：\n\n   ```java\n   public static IActivityManager getService() {\n     \treturn IActivityManagerSingleton.get();\n   }\n   \n   private static final Singleton<IActivityManager> IActivityManagerSingleton =\n       new Singleton<IActivityManager>() {\n           @Override\n           protected IActivityManager create() {\n               final IBinder b =ServiceManager.getService(Context.ACTIVITY_SERVICE);\n               final IActivityManager am = IActivityManager.Stub.asInterface(b);\n               return am;\n           }\n   };\n   ```\n\n   接触过 AIDL 的朋友可能会对这部分代码相对熟悉，简单来说，就是 ActivityManager.getService() 返回了一个 IActivityManager 的实例对象。可以理解成面向接口编程，接口无法被实例化，所以 getService() 返回的一定是 IActivityManager 的实现类对象。\n\n   这里我们不需要关心 binder 机制是如何实现的，只需要知道这个方法通过 binder 驱动，利用 IActivityManager 与系统进程的 ActivityManagerService 建立了连接，并为我们返回了它的引用即可。也就是说，getService() 方法的返回值就是 AMS 的实例。\n\n   我们再看之前的代码：\n\n   ```java\n   int result = ActivityManager.getService().startActivity()\n   ```\n\n   很明显，我们的下一站，就是 AMS 的 startActivity() 方法\n\n3. ActivityManagerService#startActivity\n\n   ```java\n   @Override\n   public final int startActivity( ... ... ) {\n     \treturn startActivityAsUser(... ...);\n   }\n   ```\n\n   从这一步开始，AMS 就会利用几个管理类来对待启动的 activity 进行一些任务栈、启动模式等的处理。如我们之前所说，不同版本的系统源码正是在这个位置有所区别：\n\n   - API 23 之前，利用 ActivityStackSupervisor、ActivityStack等对任务栈、启动模式等进行处理，启动过程中将当前所在的 Activity 先暂停，判断目标 activity 是否有实例，有则复用，没有就新建，在流程的最后，调用 ActivityStackSupervisor#realStartActivityLocked 方法，回到客户端层，即 ApplicationThread，处理启动逻辑\n   - API 28 之前，引入 ActivityStarter 类，它是 AMS 管理 Activity 启动过程的一个管理类，并在 ActivityStackSupervisor 中新增了一些诸如 resolveIntent、resolveActivity 等方法，用来解析待启动的 activity 信息等，在 AMS 旅途的终点同样是 ActivityStackSupervisor#realStartActivityLocked 方法\n   - API 28 再次对源码做了修改，Android 9.0 首次引入了事务机制来启动Activity，而以前都是通过主线程，直接 app.thread.scheduleLaunchActivity 调度执行，这是最大的差别\n\n4. ActivityStackSupervisor#realStartActivityLocked\n\n   ```java\n   final boolean realStartActivityLocked(... ...) {\n     \tapp.thread.scheduleLaunchActivity(... ...);\n   \t\treturn true;\n   }\n   ```\n\n   上面的方法我删减了大量代码，只留下了最关键的一行调用。点进去看，我们会发现 app.thread 是 IApplicationThread 对象，而 IApplicationThread 在 Client 端的实现正是 ApplicationThread，也就是说我们要看 ApplicationThread 的 scheduleLaunchActivity。\n\n5. ApplicationThread#scheduleLaunchActivity\n\n   ```java\n   @Override\n   public final void scheduleLaunchActivity( ... ...) {\n       ActivityClientRecord r = new ActivityClientRecord();\n       sendMessage(H.LAUNCH_ACTIVITY, r);\n   }\n   \n   public void handleMessage(Message msg) {\n       switch (msg.what) {\n           case LAUNCH_ACTIVITY: \n               final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n               handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n               break;\n       }\n   }\n    \n   private void handleLaunchActivity(... ...) {\n   \t\tActivity a = performLaunchActivity(... ...);\n   }\n   \n   private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n     \t Activity activity = null;\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n     \t return activity;\n   }\n   ```\n\n   顺着代码看下来，就会发现，代码经过 IApplicationThread 回调回到 Client 端 ActivityThread 后，发送了 LAUNCH_ACTIVITY 的消息，然后在 Handler 的回调中，调用了 handleLaunchActivity 方法，最后进入了 performLaunchActivity() 方法中。\n\n   在这个方法中，我们会发现目标 activity 的初始化就是在这里完成的，由之前我们提到的 Instrumentation 对象，通过反射的方式进行的初始化。\n\n\n\n好了，Activity 启动流程大概就是这样了。\n\n\n\n## UI 进程是怎么和服务进程发生绑定的？\n\n如果大家认真走过整个流程，会发现在 Activity 启动的流程中，binder 机制都是单向的。在流程开始时，通过 ActivityManager.getService() 拿到的是 IActivityManager 接口的实现，也就是 Server 端的 AMS 对象；而在流程快要结束，AMS 的工作处理完成后，是通过 IApplicationThread 接口将操作逻辑还给 Client 端的，也就是 ApplicationThread 对象。\n\n那细心的朋友可能就会问，这两个对象又是怎么发生绑定的？我在 Server 端，也就是 AMS 中是怎么知道我对应的 Client 端是谁，我处理完业务后怎么把结果回传给 Client 呢？下面我们就来为大家解答一下这个疑问。\n\n故事的重点就在于 App 的入口，ActivityThread#main()  中。\n\n我们之前说过，在这个 main() 方法中，程序会初始化一个 mainLooper，然后做一些初始化操作，之后就会开启循环队列，等待系统消息的分发处理。但是在这之前，还有一个重要的 attach() 方法，这个方法中就有我们要找的答案。\n\nActivityThread#main() & ActivityThread#attach()   \n\n```java\npublic static void main(String[] args) {\n  \t// 初始化主线程 MainLooper\n    Looper.prepareMainLooper();\n\t\t\n  \t// 初始化 ActivityThread 实例，调用 attach 方法，入参 false\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false);\n\t\t\n  \t// 开启 Looper 循环\n    Looper.loop();\n  \n  \t// 主线程 Looper 不可以停止，一旦停止就会抛异常\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n\nprivate void attach(boolean system) {\n    sCurrentActivityThread = this;\n    mSystemThread = system;\n  \t// \n    if (!system) {\n      \tIActivityManager mgr = ActivityManager.getService();\n      \tmgr.attachApplication(mAppThread);\n    } else {\n      \t// 如果是系统进程，那初始化一个 Instrumentation 对象，创建 Context、Application 对象\n      \t// 调用 application 的 onCreate 方法\n        mInstrumentation = new Instrumentation();\n        ContextImpl context = ContextImpl.createAppContext(\n          this, getSystemContext().mPackageInfo);\n        mInitialApplication = context.mPackageInfo.makeApplication(true, null);\n        mInitialApplication.onCreate();\n    }\n}\n```\n\n如上所示，在 attach() 方法中，会判断一下当前是否为系统进程，而在 ActivityThread 中调用此方法时，传入的值一律为 false，而在 SystemServer 初始化时才会传入 true。\n\nActivityThread#systemMain，在 SystemServer#createSystemContext() 中调用：\n\n```java\npublic static ActivityThread systemMain() {\n    ActivityThread thread = new ActivityThread();\n    thread.attach(true);\n    return thread;\n}\n```\n\n如果不是系统进程，则会根据 binder 机制，通过 IActivityManager 与 AMS 建立连接，调用  attachApplication 方法，并将 IApplicationThread 实例对象传入 AMS，这样一来，IActivityManager 和 IApplicationThread 就建立了绑定关系。\n\n\n\n## Application 又是什么时候初始化的\n\n接下来我们看一下 application 绑定的过程。\n\n```java\n// ActivityManagerService#attachApplication\npublic final void attachApplication(IApplicationThread thread) {\n    synchronized (this) {\n      int callingPid = Binder.getCallingPid();\n      final long origId = Binder.clearCallingIdentity();\n      attachApplicationLocked(thread, callingPid);\n      Binder.restoreCallingIdentity(origId);\n    }\n}\n\n// ActivityManagerService#attachApplicationLocked\nprivate boolean attachApplicationLocked(IApplicationThread thread, int pid) {\n\n    if (app.instr != null) {\n      thread.bindApplication(processName, appInfo, providers,\n                             app.instr.mClass,\n                             profilerInfo, app.instr.mArguments,\n                             app.instr.mWatcher,\n                             app.instr.mUiAutomationConnection, testMode,\n                             mBinderTransactionTrackingEnabled, enableTrackAllocation,\n                             isRestrictedBackupMode || !normalMode, app.persistent,\n                             new Configuration(getGlobalConfiguration()), app.compat,\n                             getCommonServicesLocked(app.isolated),\n                             mCoreSettingsObserver.getCoreSettingsLocked(),\n                             buildSerial);\n    } else {\n      thread.bindApplication(processName, appInfo, providers, null, profilerInfo,\n                             null, null, null, testMode,\n                             mBinderTransactionTrackingEnabled, enableTrackAllocation,\n                             isRestrictedBackupMode || !normalMode, app.persistent,\n                             new Configuration(getGlobalConfiguration()), app.compat,\n                             getCommonServicesLocked(app.isolated),\n                             mCoreSettingsObserver.getCoreSettingsLocked(),\n                             buildSerial);\n    }\n\n  \treturn true;\n}\n\n// 很明显，通过 IApplicationThread 又将代码回调到了 Client 端\n// ApplicationThread#bindApplication\npublic final void bindApplication(... ...) {\n  \tsendMessage(H.BIND_APPLICATION, data);\n}\n\n// 根据消息机制，我们在 ActivityThread#H 中寻找消息处理\npublic void handleMessage(Message msg) {\n    case BIND_APPLICATION:\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n        AppBindData data = (AppBindData)msg.obj;\n        handleBindApplication(data);\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    break;\n}\n\n// ActivityThread#handleBindApplication\nprivate void handleBindApplication(AppBindData data) {\n\n    final InstrumentationInfo ii;\n    if (data.instrumentationName != null) {\n        ii = new ApplicationPackageManager(null, getPackageManager())\n          .getInstrumentationInfo(data.instrumentationName, 0);\n    } else {\n      \tii = null;\n    }\n\n    // 根据上层调用传入的参数，决定初始化 mInstrumentation 实例的方式\n  \t// 1. 使用 ClassLoader 初始化；2. 直接 new 对象\n    if (ii != null) {\n        final ApplicationInfo instrApp = new ApplicationInfo();\n        ii.copyTo(instrApp);\n        instrApp.initForUser(UserHandle.myUserId());\n        final LoadedApk pi = getPackageInfo(......);\n        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);\n\n        try {\n          final ClassLoader cl = instrContext.getClassLoader();\n          mInstrumentation = (Instrumentation)\n            cl.loadClass(data.instrumentationName.getClassName()).newInstance();\n        } \n\n        final ComponentName component = new ComponentName(ii.packageName, ii.name);\n        mInstrumentation.init(... ...);\n    } else {\n      \tmInstrumentation = new Instrumentation();\n    }\n\n    try {\n      \t// 调用 makeApplication 创建当前 App 的 Application 对象\n        Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n        mInitialApplication = app; \n      \t\n      \t// 初始化 application 对象后，通过 mInstrumentation 调用 application 的 onCreate 方法\n        mInstrumentation.onCreate(data.instrumentationArgs);\n        mInstrumentation.callApplicationOnCreate(app);\n    }\n}\n\n// LoadedApk#makeApplication\npublic Application makeApplication(boolean forceDefaultAppClass,\n                                   Instrumentation instrumentation) {\n    if (mApplication != null) {\n      return mApplication;\n    }\n\n    java.lang.ClassLoader cl = getClassLoader();\n    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n    // 入参的 instrumentation 为 null，使用 ActivityThread 的 mInstrumentation\n    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);\n    appContext.setOuterContext(app);\n\n    // 调用时传入的值为 null，所以不会进 if\n    if (instrumentation != null) {\n      instrumentation.callApplicationOnCreate(app);   \n    }\n\n    return app;\n}\n\n```\n\n经过层层调用，我们最终发现，Application 的初始化也是通过 Instrumentation 来处理的，现在大家能理解为什么管它叫应用程序的大管家了吧，因为事无巨细，全是它来做的呀！\n\n```java\npublic Application newApplication(ClassLoader cl, String className, Context context) {\n  \treturn newApplication(cl.loadClass(className), context);\n}\n\nstatic public Application newApplication(Class<?> clazz, Context context){\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n```\n\n我们可以发现，application 实例的创建也是通过反射的方式实现的。\n\n流程走到这里，Application 实例是怎么创建的，C/S 是怎么发生绑定的，整个 App 是怎么被 Instumentation 支配的，大概都已经介绍清楚了。\n\n完结，撒花！！\n\n   \n\n   \n\n   \n\n   ","slug":"start-activity-procedure","published":1,"updated":"2019-08-30T08:48:14.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86eq001wlh1pzl6ybvq9","content":"<p>当我们调用 startActivity() 的时候，实际上发生了什么？</p>\n<a id=\"more\"></a> \n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇来介绍一下 Activity 启动流程。</p>\n<p>这几乎是向高级工程师进阶时无法跳过的一步，整个过程涉及到的知识点也纷繁复杂，加之系统源码在 API23 之后又做过大幅修改，所以大家可能会发现点开不同的文章，贴的源码都不一样，也不知道谁是对的，其实他们都是对的。在这种情况下，在这篇文章中，我们也不打算一堆一堆地贴源码，只能是通过文章梳理出思路，理清脉络，初探系统源码，帮助我们更好地进行应用层的开发。</p>\n<p>要理解 Activity 的启动流程，有几个基本的门槛需要了解，虽说不用全部精通吧，但是起码要混个脸熟：</p>\n<ol>\n<li>Binder 机制</li>\n<li>Handler 机制 </li>\n<li>Instrumentation</li>\n<li>ActivityThread</li>\n<li>ApplicationThread</li>\n<li>ActivityManagerService</li>\n</ol>\n<p>乍一看这么多没见过的东西，可能都有点慌，我们来一个个的解释一下。</p>\n<h2 id=\"门槛简介\"><a href=\"#门槛简介\" class=\"headerlink\" title=\"门槛简介\"></a>门槛简介</h2><h3 id=\"对-Binder-机制的理解\"><a href=\"#对-Binder-机制的理解\" class=\"headerlink\" title=\"对 Binder 机制的理解\"></a>对 Binder 机制的理解</h3><p>其实我也不是很懂 Binder 机制，只能差不多说个大概。我们都知道 Android 是基于 Linux 内核的，每个 App 都是一个单独的进程，一些系统服务需要在开机时就初始化好，这些系统应用也是运行在某个进程中的。那我们在 Android 系统中进行的所有操作，都是需要通过这些系统服务来实现的。但是不同的进程间要进行通信，就需要借助特殊的方式。</p>\n<p>常见的进程间通信的方式一般包括管道、socket、共享内存等，但是 Android 系统有其特殊性，Binder 机制就是 Android 系统中特有的进程间通信机制，整体设计思想也是面向对象的。Binder 的英文释义为<strong>粘合剂</strong>，这与 Binder 机制的工作原理十分契合。诸如 ActivityManagerService 这种的系统级服务，在系统进程中初始化完成后，通过 Binder 机制配合代理模式，将服务的引用散落在系统的各个 App 进程中，各个 App 的代理引用就用过 Binder 机制与系统进程的实际对象进行了映射和绑定，就实现了<strong>粘合</strong>，也就是面向对象思想的体现。</p>\n<p>掉书袋的解释就是，<strong>Binder 本质上就是一种底层的通信机制，与具体的服务没有关系。Binder 机制采用代理设计模式，定义一个抽象接口，Client 和 Server 都实现该接口，Server 端是真正的功能实现，Client 端只是对这些函数远程调用请求的包装，C/S 两端通过 binder 驱动来进行具体的细节交互。</strong></p>\n<p>就好比说，</p>\n<p>我其实是个菜鸡，但是满世界给人吹牛说自己技术有多好，等真有复杂的需求了，我其实是把要做的事情打包给认识的大佬，大佬做好之后直接给我，我再直接把成果给人家需求方。</p>\n<p>在这个例子中，我就是 Client，大佬就是 Server，我打包资料给他这个动作就是 binder 驱动做的工作，在 binder 机制中，这个过程是通过面向接口的方式完成的。</p>\n<p>这么说大家应该对 binder 机制有个大概的认识了，实际上 binder 机制还很复杂，有兴趣的可以拜读一下<a href=\"https://blog.csdn.net/universus/article/details/6211589\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，8 年过去了，还是没人能够超越作者当年的水平……</p>\n<h3 id=\"Instrumentation\"><a href=\"#Instrumentation\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><p>翻译为仪器。每一个应用程序，或者说每一个进程，只有一个 Instrumentation 对象，优先于 application 创建。当前 App 中，每个 activity 内都有对 Instrumentation 对象的引用。Instrumentation 可以理解成应用进程的大管家，Activity 的所有动作，从创建到销毁，实际上都是用 Instrumentation 来操作的。</p>\n<h3 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h3><p>这里就是每个 App 的入口。写太久 Android，大家可能忘记了 Java 程序的入口是 main() 方法，Android 程序的 main() 方法就在 ActivityThread 这个类中。这里就是 App 真正的入口。当开启 App 时，会初始化一个 Looper 对象，调用 attach() 方法，进行 App 的初始化工作，之后就会开启消息循环队列，与 AMS 配合，一起完成 App 的交互管理工作。</p>\n<p>ActivityThread 实际上并不是 Thread，它只是运行在主线程，也就是我们常说的 UI 线程中，可以理解成 ActivityThread 是 UI 线程的表现形式。</p>\n<h3 id=\"ApplicationThread\"><a href=\"#ApplicationThread\" class=\"headerlink\" title=\"ApplicationThread\"></a>ApplicationThread</h3><p>ApplicationThread 是 ActivityThread 的内部类，实现了 IApplicationThread，通过 ApplicationThreadProxy 代理类来与 ActivityManagerService 进行 binder 通信。简单来说，ActivityManagerService 通过 ApplicationThreadProxy 来与 ApplicationThread 进行 binder 通信，从而执行对 application 以及 activity 的各项操作。</p>\n<h3 id=\"ActivityManagerService\"><a href=\"#ActivityManagerService\" class=\"headerlink\" title=\"ActivityManagerService\"></a>ActivityManagerService</h3><p>服务端对象，简称 AMS。AMS 是 Android 中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在 Android 中非常重要。AMS 主要通过 binder 机制与应用层进行通信，在之前的例子中，AMS 就是在背后处理工作的大佬。</p>\n<h2 id=\"Activity-启动的大体流程\"><a href=\"#Activity-启动的大体流程\" class=\"headerlink\" title=\"Activity 启动的大体流程\"></a>Activity 启动的大体流程</h2><p>正如之前所说，系统源码在不同的版本中不完全相同，就我实际翻找来看，目前至少有三个版本的系统源码，所以我们暂时不打算详细了解这部分差异内容，有机会的话，等下次再写篇文章对比。</p>\n<p>但是不管怎么说，万变不离其宗，大体的启动流程还是没有发生变化的，今天我们的重点就是这部分内容。</p>\n<p>在开始之前，请先允许我高水平地用一句话概括一下 Activity 的启动流程。</p>\n<p><strong>当 startActivity 方法被调用时，首先经由 Instrumentation 类中转，然后在过程中对任务栈等信息进行处理（不同版本源码的区别都在这一步），最终在 AMS 中通过 binder 通信的方式，将启动命令回调到 ApplicationThread 类中进行处理，该类通过 Handler 消息机制发送 LAUNCH_ACTIVITY 的消息并接收处理，最终将启动命令交回给 Instrumentation 处理，利用反射机制初始化待启动 Activity 的实例。</strong></p>\n<p>好了，下面我要开始贴源码了。</p>\n<ol>\n<li><p>Activity#startActivity -&gt; Activity#startActivityForResult </p>\n<pre><code class=\"java\">@Override\npublic void startActivity(Intent intent) {\n  this.startActivity(intent, null);\n}\n\n@Override\npublic void startActivity(Intent intent, @Nullable Bundle options) {\n  if (options != null) {\n    startActivityForResult(intent, -1, options);\n  } else {\n    // Note we want to go through this call for compatibility with\n    // applications that may have overridden the method.\n    startActivityForResult(intent, -1);\n  }\n}\n\npublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {\n    startActivityForResult(intent, requestCode, null);\n}\n\npublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n            @Nullable Bundle options) {\n    if (mParent == null) {\n      Instrumentation.ActivityResult ar =\n        mInstrumentation.execStartActivity(\n        this, mMainThread.getApplicationThread(), mToken, this,\n        intent, requestCode, options);\n    } else {\n      if (options != null) {\n        mParent.startActivityFromChild(this, intent, requestCode, options);\n      } else {\n        mParent.startActivityFromChild(this, intent, requestCode);\n      }\n    }\n}\n</code></pre>\n<p>我们看源码会发现，当 startActivity 被调用时，实际上在源码层面都是调用了 startActivityForResult，requestCode 传入的值为 -1，这也给我们提了个醒，就是真正调用 startActivityForResult 时，不可以在 requestCode 传入 -1，否则一定拿不到回调。</p>\n<p>我们继续向下看会发现，经过一层层的方法重载，最终在一个 startActivityForResult 方法中，会调用 Instrumentation#execStartActivity，然后正式开启 IPC 之旅。</p>\n</li>\n<li><p>Instrumentation#execStartActivity</p>\n<pre><code class=\"java\">public ActivityResult execStartActivity(\n  Context who, IBinder contextThread, IBinder token, Activity target,\n  Intent intent, int requestCode, Bundle options) {\n\n      // 从上边的调用可以看到，contextThread 传入的值为 mMainThread.getApplicationThread()\n      // 继续探究源码会发现，实际传入的为 ActivityThread 内部类 ApplicationThread 的实例对象\n    IApplicationThread whoThread = (IApplicationThread) contextThread;\n\n      // 重点就在这里\n    int result = ActivityManager.getService()\n      .startActivity(whoThread, who.getBasePackageName(), intent,\n                     intent.resolveTypeIfNeeded(who.getContentResolver()),\n                     token, target != null ? target.mEmbeddedID : null,\n                     requestCode, 0, null, options);\n\n    checkStartActivityResult(result, intent);\n\n    return null;\n}\n\n</code></pre>\n<p>binder 通信就从这个方法开始：</p>\n<pre><code class=\"java\">public static IActivityManager getService() {\n      return IActivityManagerSingleton.get();\n}\n\nprivate static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =\n    new Singleton&lt;IActivityManager&gt;() {\n        @Override\n        protected IActivityManager create() {\n            final IBinder b =ServiceManager.getService(Context.ACTIVITY_SERVICE);\n            final IActivityManager am = IActivityManager.Stub.asInterface(b);\n            return am;\n        }\n};\n</code></pre>\n<p>接触过 AIDL 的朋友可能会对这部分代码相对熟悉，简单来说，就是 ActivityManager.getService() 返回了一个 IActivityManager 的实例对象。可以理解成面向接口编程，接口无法被实例化，所以 getService() 返回的一定是 IActivityManager 的实现类对象。</p>\n<p>这里我们不需要关心 binder 机制是如何实现的，只需要知道这个方法通过 binder 驱动，利用 IActivityManager 与系统进程的 ActivityManagerService 建立了连接，并为我们返回了它的引用即可。也就是说，getService() 方法的返回值就是 AMS 的实例。</p>\n<p>我们再看之前的代码：</p>\n<pre><code class=\"java\">int result = ActivityManager.getService().startActivity()\n</code></pre>\n<p>很明显，我们的下一站，就是 AMS 的 startActivity() 方法</p>\n</li>\n<li><p>ActivityManagerService#startActivity</p>\n<pre><code class=\"java\">@Override\npublic final int startActivity( ... ... ) {\n      return startActivityAsUser(... ...);\n}\n</code></pre>\n<p>从这一步开始，AMS 就会利用几个管理类来对待启动的 activity 进行一些任务栈、启动模式等的处理。如我们之前所说，不同版本的系统源码正是在这个位置有所区别：</p>\n<ul>\n<li>API 23 之前，利用 ActivityStackSupervisor、ActivityStack等对任务栈、启动模式等进行处理，启动过程中将当前所在的 Activity 先暂停，判断目标 activity 是否有实例，有则复用，没有就新建，在流程的最后，调用 ActivityStackSupervisor#realStartActivityLocked 方法，回到客户端层，即 ApplicationThread，处理启动逻辑</li>\n<li>API 28 之前，引入 ActivityStarter 类，它是 AMS 管理 Activity 启动过程的一个管理类，并在 ActivityStackSupervisor 中新增了一些诸如 resolveIntent、resolveActivity 等方法，用来解析待启动的 activity 信息等，在 AMS 旅途的终点同样是 ActivityStackSupervisor#realStartActivityLocked 方法</li>\n<li>API 28 再次对源码做了修改，Android 9.0 首次引入了事务机制来启动Activity，而以前都是通过主线程，直接 app.thread.scheduleLaunchActivity 调度执行，这是最大的差别</li>\n</ul>\n</li>\n<li><p>ActivityStackSupervisor#realStartActivityLocked</p>\n<pre><code class=\"java\">final boolean realStartActivityLocked(... ...) {\n      app.thread.scheduleLaunchActivity(... ...);\n        return true;\n}\n</code></pre>\n<p>上面的方法我删减了大量代码，只留下了最关键的一行调用。点进去看，我们会发现 app.thread 是 IApplicationThread 对象，而 IApplicationThread 在 Client 端的实现正是 ApplicationThread，也就是说我们要看 ApplicationThread 的 scheduleLaunchActivity。</p>\n</li>\n<li><p>ApplicationThread#scheduleLaunchActivity</p>\n<pre><code class=\"java\">@Override\npublic final void scheduleLaunchActivity( ... ...) {\n    ActivityClientRecord r = new ActivityClientRecord();\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n}\n\npublic void handleMessage(Message msg) {\n    switch (msg.what) {\n        case LAUNCH_ACTIVITY: \n            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);\n            break;\n    }\n}\n\nprivate void handleLaunchActivity(... ...) {\n        Activity a = performLaunchActivity(... ...);\n}\n\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n       Activity activity = null;\n     java.lang.ClassLoader cl = appContext.getClassLoader();\n     activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n       return activity;\n}\n</code></pre>\n<p>顺着代码看下来，就会发现，代码经过 IApplicationThread 回调回到 Client 端 ActivityThread 后，发送了 LAUNCH_ACTIVITY 的消息，然后在 Handler 的回调中，调用了 handleLaunchActivity 方法，最后进入了 performLaunchActivity() 方法中。</p>\n<p>在这个方法中，我们会发现目标 activity 的初始化就是在这里完成的，由之前我们提到的 Instrumentation 对象，通过反射的方式进行的初始化。</p>\n</li>\n</ol>\n<p>好了，Activity 启动流程大概就是这样了。</p>\n<h2 id=\"UI-进程是怎么和服务进程发生绑定的？\"><a href=\"#UI-进程是怎么和服务进程发生绑定的？\" class=\"headerlink\" title=\"UI 进程是怎么和服务进程发生绑定的？\"></a>UI 进程是怎么和服务进程发生绑定的？</h2><p>如果大家认真走过整个流程，会发现在 Activity 启动的流程中，binder 机制都是单向的。在流程开始时，通过 ActivityManager.getService() 拿到的是 IActivityManager 接口的实现，也就是 Server 端的 AMS 对象；而在流程快要结束，AMS 的工作处理完成后，是通过 IApplicationThread 接口将操作逻辑还给 Client 端的，也就是 ApplicationThread 对象。</p>\n<p>那细心的朋友可能就会问，这两个对象又是怎么发生绑定的？我在 Server 端，也就是 AMS 中是怎么知道我对应的 Client 端是谁，我处理完业务后怎么把结果回传给 Client 呢？下面我们就来为大家解答一下这个疑问。</p>\n<p>故事的重点就在于 App 的入口，ActivityThread#main()  中。</p>\n<p>我们之前说过，在这个 main() 方法中，程序会初始化一个 mainLooper，然后做一些初始化操作，之后就会开启循环队列，等待系统消息的分发处理。但是在这之前，还有一个重要的 attach() 方法，这个方法中就有我们要找的答案。</p>\n<p>ActivityThread#main() &amp; ActivityThread#attach()   </p>\n<pre><code class=\"java\">public static void main(String[] args) {\n      // 初始化主线程 MainLooper\n    Looper.prepareMainLooper();\n\n      // 初始化 ActivityThread 实例，调用 attach 方法，入参 false\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false);\n\n      // 开启 Looper 循环\n    Looper.loop();\n\n      // 主线程 Looper 不可以停止，一旦停止就会抛异常\n    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);\n}\n\nprivate void attach(boolean system) {\n    sCurrentActivityThread = this;\n    mSystemThread = system;\n      // \n    if (!system) {\n          IActivityManager mgr = ActivityManager.getService();\n          mgr.attachApplication(mAppThread);\n    } else {\n          // 如果是系统进程，那初始化一个 Instrumentation 对象，创建 Context、Application 对象\n          // 调用 application 的 onCreate 方法\n        mInstrumentation = new Instrumentation();\n        ContextImpl context = ContextImpl.createAppContext(\n          this, getSystemContext().mPackageInfo);\n        mInitialApplication = context.mPackageInfo.makeApplication(true, null);\n        mInitialApplication.onCreate();\n    }\n}\n</code></pre>\n<p>如上所示，在 attach() 方法中，会判断一下当前是否为系统进程，而在 ActivityThread 中调用此方法时，传入的值一律为 false，而在 SystemServer 初始化时才会传入 true。</p>\n<p>ActivityThread#systemMain，在 SystemServer#createSystemContext() 中调用：</p>\n<pre><code class=\"java\">public static ActivityThread systemMain() {\n    ActivityThread thread = new ActivityThread();\n    thread.attach(true);\n    return thread;\n}\n</code></pre>\n<p>如果不是系统进程，则会根据 binder 机制，通过 IActivityManager 与 AMS 建立连接，调用  attachApplication 方法，并将 IApplicationThread 实例对象传入 AMS，这样一来，IActivityManager 和 IApplicationThread 就建立了绑定关系。</p>\n<h2 id=\"Application-又是什么时候初始化的\"><a href=\"#Application-又是什么时候初始化的\" class=\"headerlink\" title=\"Application 又是什么时候初始化的\"></a>Application 又是什么时候初始化的</h2><p>接下来我们看一下 application 绑定的过程。</p>\n<pre><code class=\"java\">// ActivityManagerService#attachApplication\npublic final void attachApplication(IApplicationThread thread) {\n    synchronized (this) {\n      int callingPid = Binder.getCallingPid();\n      final long origId = Binder.clearCallingIdentity();\n      attachApplicationLocked(thread, callingPid);\n      Binder.restoreCallingIdentity(origId);\n    }\n}\n\n// ActivityManagerService#attachApplicationLocked\nprivate boolean attachApplicationLocked(IApplicationThread thread, int pid) {\n\n    if (app.instr != null) {\n      thread.bindApplication(processName, appInfo, providers,\n                             app.instr.mClass,\n                             profilerInfo, app.instr.mArguments,\n                             app.instr.mWatcher,\n                             app.instr.mUiAutomationConnection, testMode,\n                             mBinderTransactionTrackingEnabled, enableTrackAllocation,\n                             isRestrictedBackupMode || !normalMode, app.persistent,\n                             new Configuration(getGlobalConfiguration()), app.compat,\n                             getCommonServicesLocked(app.isolated),\n                             mCoreSettingsObserver.getCoreSettingsLocked(),\n                             buildSerial);\n    } else {\n      thread.bindApplication(processName, appInfo, providers, null, profilerInfo,\n                             null, null, null, testMode,\n                             mBinderTransactionTrackingEnabled, enableTrackAllocation,\n                             isRestrictedBackupMode || !normalMode, app.persistent,\n                             new Configuration(getGlobalConfiguration()), app.compat,\n                             getCommonServicesLocked(app.isolated),\n                             mCoreSettingsObserver.getCoreSettingsLocked(),\n                             buildSerial);\n    }\n\n      return true;\n}\n\n// 很明显，通过 IApplicationThread 又将代码回调到了 Client 端\n// ApplicationThread#bindApplication\npublic final void bindApplication(... ...) {\n      sendMessage(H.BIND_APPLICATION, data);\n}\n\n// 根据消息机制，我们在 ActivityThread#H 中寻找消息处理\npublic void handleMessage(Message msg) {\n    case BIND_APPLICATION:\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);\n        AppBindData data = (AppBindData)msg.obj;\n        handleBindApplication(data);\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    break;\n}\n\n// ActivityThread#handleBindApplication\nprivate void handleBindApplication(AppBindData data) {\n\n    final InstrumentationInfo ii;\n    if (data.instrumentationName != null) {\n        ii = new ApplicationPackageManager(null, getPackageManager())\n          .getInstrumentationInfo(data.instrumentationName, 0);\n    } else {\n          ii = null;\n    }\n\n    // 根据上层调用传入的参数，决定初始化 mInstrumentation 实例的方式\n      // 1. 使用 ClassLoader 初始化；2. 直接 new 对象\n    if (ii != null) {\n        final ApplicationInfo instrApp = new ApplicationInfo();\n        ii.copyTo(instrApp);\n        instrApp.initForUser(UserHandle.myUserId());\n        final LoadedApk pi = getPackageInfo(......);\n        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);\n\n        try {\n          final ClassLoader cl = instrContext.getClassLoader();\n          mInstrumentation = (Instrumentation)\n            cl.loadClass(data.instrumentationName.getClassName()).newInstance();\n        } \n\n        final ComponentName component = new ComponentName(ii.packageName, ii.name);\n        mInstrumentation.init(... ...);\n    } else {\n          mInstrumentation = new Instrumentation();\n    }\n\n    try {\n          // 调用 makeApplication 创建当前 App 的 Application 对象\n        Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n        mInitialApplication = app; \n\n          // 初始化 application 对象后，通过 mInstrumentation 调用 application 的 onCreate 方法\n        mInstrumentation.onCreate(data.instrumentationArgs);\n        mInstrumentation.callApplicationOnCreate(app);\n    }\n}\n\n// LoadedApk#makeApplication\npublic Application makeApplication(boolean forceDefaultAppClass,\n                                   Instrumentation instrumentation) {\n    if (mApplication != null) {\n      return mApplication;\n    }\n\n    java.lang.ClassLoader cl = getClassLoader();\n    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n    // 入参的 instrumentation 为 null，使用 ActivityThread 的 mInstrumentation\n    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);\n    appContext.setOuterContext(app);\n\n    // 调用时传入的值为 null，所以不会进 if\n    if (instrumentation != null) {\n      instrumentation.callApplicationOnCreate(app);   \n    }\n\n    return app;\n}\n\n</code></pre>\n<p>经过层层调用，我们最终发现，Application 的初始化也是通过 Instrumentation 来处理的，现在大家能理解为什么管它叫应用程序的大管家了吧，因为事无巨细，全是它来做的呀！</p>\n<pre><code class=\"java\">public Application newApplication(ClassLoader cl, String className, Context context) {\n      return newApplication(cl.loadClass(className), context);\n}\n\nstatic public Application newApplication(Class&lt;?&gt; clazz, Context context){\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n</code></pre>\n<p>我们可以发现，application 实例的创建也是通过反射的方式实现的。</p>\n<p>流程走到这里，Application 实例是怎么创建的，C/S 是怎么发生绑定的，整个 App 是怎么被 Instumentation 支配的，大概都已经介绍清楚了。</p>\n<p>完结，撒花！！</p>\n","site":{"data":{}},"excerpt":"<p>当我们调用 startActivity() 的时候，实际上发生了什么？</p>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇来介绍一下 Activity 启动流程。</p>\n<p>这几乎是向高级工程师进阶时无法跳过的一步，整个过程涉及到的知识点也纷繁复杂，加之系统源码在 API23 之后又做过大幅修改，所以大家可能会发现点开不同的文章，贴的源码都不一样，也不知道谁是对的，其实他们都是对的。在这种情况下，在这篇文章中，我们也不打算一堆一堆地贴源码，只能是通过文章梳理出思路，理清脉络，初探系统源码，帮助我们更好地进行应用层的开发。</p>\n<p>要理解 Activity 的启动流程，有几个基本的门槛需要了解，虽说不用全部精通吧，但是起码要混个脸熟：</p>\n<ol>\n<li>Binder 机制</li>\n<li>Handler 机制 </li>\n<li>Instrumentation</li>\n<li>ActivityThread</li>\n<li>ApplicationThread</li>\n<li>ActivityManagerService</li>\n</ol>\n<p>乍一看这么多没见过的东西，可能都有点慌，我们来一个个的解释一下。</p>\n<h2 id=\"门槛简介\"><a href=\"#门槛简介\" class=\"headerlink\" title=\"门槛简介\"></a>门槛简介</h2><h3 id=\"对-Binder-机制的理解\"><a href=\"#对-Binder-机制的理解\" class=\"headerlink\" title=\"对 Binder 机制的理解\"></a>对 Binder 机制的理解</h3><p>其实我也不是很懂 Binder 机制，只能差不多说个大概。我们都知道 Android 是基于 Linux 内核的，每个 App 都是一个单独的进程，一些系统服务需要在开机时就初始化好，这些系统应用也是运行在某个进程中的。那我们在 Android 系统中进行的所有操作，都是需要通过这些系统服务来实现的。但是不同的进程间要进行通信，就需要借助特殊的方式。</p>\n<p>常见的进程间通信的方式一般包括管道、socket、共享内存等，但是 Android 系统有其特殊性，Binder 机制就是 Android 系统中特有的进程间通信机制，整体设计思想也是面向对象的。Binder 的英文释义为<strong>粘合剂</strong>，这与 Binder 机制的工作原理十分契合。诸如 ActivityManagerService 这种的系统级服务，在系统进程中初始化完成后，通过 Binder 机制配合代理模式，将服务的引用散落在系统的各个 App 进程中，各个 App 的代理引用就用过 Binder 机制与系统进程的实际对象进行了映射和绑定，就实现了<strong>粘合</strong>，也就是面向对象思想的体现。</p>\n<p>掉书袋的解释就是，<strong>Binder 本质上就是一种底层的通信机制，与具体的服务没有关系。Binder 机制采用代理设计模式，定义一个抽象接口，Client 和 Server 都实现该接口，Server 端是真正的功能实现，Client 端只是对这些函数远程调用请求的包装，C/S 两端通过 binder 驱动来进行具体的细节交互。</strong></p>\n<p>就好比说，</p>\n<p>我其实是个菜鸡，但是满世界给人吹牛说自己技术有多好，等真有复杂的需求了，我其实是把要做的事情打包给认识的大佬，大佬做好之后直接给我，我再直接把成果给人家需求方。</p>\n<p>在这个例子中，我就是 Client，大佬就是 Server，我打包资料给他这个动作就是 binder 驱动做的工作，在 binder 机制中，这个过程是通过面向接口的方式完成的。</p>\n<p>这么说大家应该对 binder 机制有个大概的认识了，实际上 binder 机制还很复杂，有兴趣的可以拜读一下<a href=\"https://blog.csdn.net/universus/article/details/6211589\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，8 年过去了，还是没人能够超越作者当年的水平……</p>\n<h3 id=\"Instrumentation\"><a href=\"#Instrumentation\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><p>翻译为仪器。每一个应用程序，或者说每一个进程，只有一个 Instrumentation 对象，优先于 application 创建。当前 App 中，每个 activity 内都有对 Instrumentation 对象的引用。Instrumentation 可以理解成应用进程的大管家，Activity 的所有动作，从创建到销毁，实际上都是用 Instrumentation 来操作的。</p>\n<h3 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h3><p>这里就是每个 App 的入口。写太久 Android，大家可能忘记了 Java 程序的入口是 main() 方法，Android 程序的 main() 方法就在 ActivityThread 这个类中。这里就是 App 真正的入口。当开启 App 时，会初始化一个 Looper 对象，调用 attach() 方法，进行 App 的初始化工作，之后就会开启消息循环队列，与 AMS 配合，一起完成 App 的交互管理工作。</p>\n<p>ActivityThread 实际上并不是 Thread，它只是运行在主线程，也就是我们常说的 UI 线程中，可以理解成 ActivityThread 是 UI 线程的表现形式。</p>\n<h3 id=\"ApplicationThread\"><a href=\"#ApplicationThread\" class=\"headerlink\" title=\"ApplicationThread\"></a>ApplicationThread</h3><p>ApplicationThread 是 ActivityThread 的内部类，实现了 IApplicationThread，通过 ApplicationThreadProxy 代理类来与 ActivityManagerService 进行 binder 通信。简单来说，ActivityManagerService 通过 ApplicationThreadProxy 来与 ApplicationThread 进行 binder 通信，从而执行对 application 以及 activity 的各项操作。</p>\n<h3 id=\"ActivityManagerService\"><a href=\"#ActivityManagerService\" class=\"headerlink\" title=\"ActivityManagerService\"></a>ActivityManagerService</h3><p>服务端对象，简称 AMS。AMS 是 Android 中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在 Android 中非常重要。AMS 主要通过 binder 机制与应用层进行通信，在之前的例子中，AMS 就是在背后处理工作的大佬。</p>\n<h2 id=\"Activity-启动的大体流程\"><a href=\"#Activity-启动的大体流程\" class=\"headerlink\" title=\"Activity 启动的大体流程\"></a>Activity 启动的大体流程</h2><p>正如之前所说，系统源码在不同的版本中不完全相同，就我实际翻找来看，目前至少有三个版本的系统源码，所以我们暂时不打算详细了解这部分差异内容，有机会的话，等下次再写篇文章对比。</p>\n<p>但是不管怎么说，万变不离其宗，大体的启动流程还是没有发生变化的，今天我们的重点就是这部分内容。</p>\n<p>在开始之前，请先允许我高水平地用一句话概括一下 Activity 的启动流程。</p>\n<p><strong>当 startActivity 方法被调用时，首先经由 Instrumentation 类中转，然后在过程中对任务栈等信息进行处理（不同版本源码的区别都在这一步），最终在 AMS 中通过 binder 通信的方式，将启动命令回调到 ApplicationThread 类中进行处理，该类通过 Handler 消息机制发送 LAUNCH_ACTIVITY 的消息并接收处理，最终将启动命令交回给 Instrumentation 处理，利用反射机制初始化待启动 Activity 的实例。</strong></p>\n<p>好了，下面我要开始贴源码了。</p>\n<ol>\n<li><p>Activity#startActivity -&gt; Activity#startActivityForResult </p>\n<pre><code class=\"java\">@Override\npublic void startActivity(Intent intent) {\n  this.startActivity(intent, null);\n}\n\n@Override\npublic void startActivity(Intent intent, @Nullable Bundle options) {\n  if (options != null) {\n    startActivityForResult(intent, -1, options);\n  } else {\n    // Note we want to go through this call for compatibility with\n    // applications that may have overridden the method.\n    startActivityForResult(intent, -1);\n  }\n}\n\npublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {\n    startActivityForResult(intent, requestCode, null);\n}\n\npublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n            @Nullable Bundle options) {\n    if (mParent == null) {\n      Instrumentation.ActivityResult ar =\n        mInstrumentation.execStartActivity(\n        this, mMainThread.getApplicationThread(), mToken, this,\n        intent, requestCode, options);\n    } else {\n      if (options != null) {\n        mParent.startActivityFromChild(this, intent, requestCode, options);\n      } else {\n        mParent.startActivityFromChild(this, intent, requestCode);\n      }\n    }\n}\n</code></pre>\n<p>我们看源码会发现，当 startActivity 被调用时，实际上在源码层面都是调用了 startActivityForResult，requestCode 传入的值为 -1，这也给我们提了个醒，就是真正调用 startActivityForResult 时，不可以在 requestCode 传入 -1，否则一定拿不到回调。</p>\n<p>我们继续向下看会发现，经过一层层的方法重载，最终在一个 startActivityForResult 方法中，会调用 Instrumentation#execStartActivity，然后正式开启 IPC 之旅。</p>\n</li>\n<li><p>Instrumentation#execStartActivity</p>\n<pre><code class=\"java\">public ActivityResult execStartActivity(\n  Context who, IBinder contextThread, IBinder token, Activity target,\n  Intent intent, int requestCode, Bundle options) {\n\n      // 从上边的调用可以看到，contextThread 传入的值为 mMainThread.getApplicationThread()\n      // 继续探究源码会发现，实际传入的为 ActivityThread 内部类 ApplicationThread 的实例对象\n    IApplicationThread whoThread = (IApplicationThread) contextThread;\n\n      // 重点就在这里\n    int result = ActivityManager.getService()\n      .startActivity(whoThread, who.getBasePackageName(), intent,\n                     intent.resolveTypeIfNeeded(who.getContentResolver()),\n                     token, target != null ? target.mEmbeddedID : null,\n                     requestCode, 0, null, options);\n\n    checkStartActivityResult(result, intent);\n\n    return null;\n}\n\n</code></pre>\n<p>binder 通信就从这个方法开始：</p>\n<pre><code class=\"java\">public static IActivityManager getService() {\n      return IActivityManagerSingleton.get();\n}\n\nprivate static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =\n    new Singleton&lt;IActivityManager&gt;() {\n        @Override\n        protected IActivityManager create() {\n            final IBinder b =ServiceManager.getService(Context.ACTIVITY_SERVICE);\n            final IActivityManager am = IActivityManager.Stub.asInterface(b);\n            return am;\n        }\n};\n</code></pre>\n<p>接触过 AIDL 的朋友可能会对这部分代码相对熟悉，简单来说，就是 ActivityManager.getService() 返回了一个 IActivityManager 的实例对象。可以理解成面向接口编程，接口无法被实例化，所以 getService() 返回的一定是 IActivityManager 的实现类对象。</p>\n<p>这里我们不需要关心 binder 机制是如何实现的，只需要知道这个方法通过 binder 驱动，利用 IActivityManager 与系统进程的 ActivityManagerService 建立了连接，并为我们返回了它的引用即可。也就是说，getService() 方法的返回值就是 AMS 的实例。</p>\n<p>我们再看之前的代码：</p>\n<pre><code class=\"java\">int result = ActivityManager.getService().startActivity()\n</code></pre>\n<p>很明显，我们的下一站，就是 AMS 的 startActivity() 方法</p>\n</li>\n<li><p>ActivityManagerService#startActivity</p>\n<pre><code class=\"java\">@Override\npublic final int startActivity( ... ... ) {\n      return startActivityAsUser(... ...);\n}\n</code></pre>\n<p>从这一步开始，AMS 就会利用几个管理类来对待启动的 activity 进行一些任务栈、启动模式等的处理。如我们之前所说，不同版本的系统源码正是在这个位置有所区别：</p>\n<ul>\n<li>API 23 之前，利用 ActivityStackSupervisor、ActivityStack等对任务栈、启动模式等进行处理，启动过程中将当前所在的 Activity 先暂停，判断目标 activity 是否有实例，有则复用，没有就新建，在流程的最后，调用 ActivityStackSupervisor#realStartActivityLocked 方法，回到客户端层，即 ApplicationThread，处理启动逻辑</li>\n<li>API 28 之前，引入 ActivityStarter 类，它是 AMS 管理 Activity 启动过程的一个管理类，并在 ActivityStackSupervisor 中新增了一些诸如 resolveIntent、resolveActivity 等方法，用来解析待启动的 activity 信息等，在 AMS 旅途的终点同样是 ActivityStackSupervisor#realStartActivityLocked 方法</li>\n<li>API 28 再次对源码做了修改，Android 9.0 首次引入了事务机制来启动Activity，而以前都是通过主线程，直接 app.thread.scheduleLaunchActivity 调度执行，这是最大的差别</li>\n</ul>\n</li>\n<li><p>ActivityStackSupervisor#realStartActivityLocked</p>\n<pre><code class=\"java\">final boolean realStartActivityLocked(... ...) {\n      app.thread.scheduleLaunchActivity(... ...);\n        return true;\n}\n</code></pre>\n<p>上面的方法我删减了大量代码，只留下了最关键的一行调用。点进去看，我们会发现 app.thread 是 IApplicationThread 对象，而 IApplicationThread 在 Client 端的实现正是 ApplicationThread，也就是说我们要看 ApplicationThread 的 scheduleLaunchActivity。</p>\n</li>\n<li><p>ApplicationThread#scheduleLaunchActivity</p>\n<pre><code class=\"java\">@Override\npublic final void scheduleLaunchActivity( ... ...) {\n    ActivityClientRecord r = new ActivityClientRecord();\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n}\n\npublic void handleMessage(Message msg) {\n    switch (msg.what) {\n        case LAUNCH_ACTIVITY: \n            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);\n            break;\n    }\n}\n\nprivate void handleLaunchActivity(... ...) {\n        Activity a = performLaunchActivity(... ...);\n}\n\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n       Activity activity = null;\n     java.lang.ClassLoader cl = appContext.getClassLoader();\n     activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n       return activity;\n}\n</code></pre>\n<p>顺着代码看下来，就会发现，代码经过 IApplicationThread 回调回到 Client 端 ActivityThread 后，发送了 LAUNCH_ACTIVITY 的消息，然后在 Handler 的回调中，调用了 handleLaunchActivity 方法，最后进入了 performLaunchActivity() 方法中。</p>\n<p>在这个方法中，我们会发现目标 activity 的初始化就是在这里完成的，由之前我们提到的 Instrumentation 对象，通过反射的方式进行的初始化。</p>\n</li>\n</ol>\n<p>好了，Activity 启动流程大概就是这样了。</p>\n<h2 id=\"UI-进程是怎么和服务进程发生绑定的？\"><a href=\"#UI-进程是怎么和服务进程发生绑定的？\" class=\"headerlink\" title=\"UI 进程是怎么和服务进程发生绑定的？\"></a>UI 进程是怎么和服务进程发生绑定的？</h2><p>如果大家认真走过整个流程，会发现在 Activity 启动的流程中，binder 机制都是单向的。在流程开始时，通过 ActivityManager.getService() 拿到的是 IActivityManager 接口的实现，也就是 Server 端的 AMS 对象；而在流程快要结束，AMS 的工作处理完成后，是通过 IApplicationThread 接口将操作逻辑还给 Client 端的，也就是 ApplicationThread 对象。</p>\n<p>那细心的朋友可能就会问，这两个对象又是怎么发生绑定的？我在 Server 端，也就是 AMS 中是怎么知道我对应的 Client 端是谁，我处理完业务后怎么把结果回传给 Client 呢？下面我们就来为大家解答一下这个疑问。</p>\n<p>故事的重点就在于 App 的入口，ActivityThread#main()  中。</p>\n<p>我们之前说过，在这个 main() 方法中，程序会初始化一个 mainLooper，然后做一些初始化操作，之后就会开启循环队列，等待系统消息的分发处理。但是在这之前，还有一个重要的 attach() 方法，这个方法中就有我们要找的答案。</p>\n<p>ActivityThread#main() &amp; ActivityThread#attach()   </p>\n<pre><code class=\"java\">public static void main(String[] args) {\n      // 初始化主线程 MainLooper\n    Looper.prepareMainLooper();\n\n      // 初始化 ActivityThread 实例，调用 attach 方法，入参 false\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false);\n\n      // 开启 Looper 循环\n    Looper.loop();\n\n      // 主线程 Looper 不可以停止，一旦停止就会抛异常\n    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);\n}\n\nprivate void attach(boolean system) {\n    sCurrentActivityThread = this;\n    mSystemThread = system;\n      // \n    if (!system) {\n          IActivityManager mgr = ActivityManager.getService();\n          mgr.attachApplication(mAppThread);\n    } else {\n          // 如果是系统进程，那初始化一个 Instrumentation 对象，创建 Context、Application 对象\n          // 调用 application 的 onCreate 方法\n        mInstrumentation = new Instrumentation();\n        ContextImpl context = ContextImpl.createAppContext(\n          this, getSystemContext().mPackageInfo);\n        mInitialApplication = context.mPackageInfo.makeApplication(true, null);\n        mInitialApplication.onCreate();\n    }\n}\n</code></pre>\n<p>如上所示，在 attach() 方法中，会判断一下当前是否为系统进程，而在 ActivityThread 中调用此方法时，传入的值一律为 false，而在 SystemServer 初始化时才会传入 true。</p>\n<p>ActivityThread#systemMain，在 SystemServer#createSystemContext() 中调用：</p>\n<pre><code class=\"java\">public static ActivityThread systemMain() {\n    ActivityThread thread = new ActivityThread();\n    thread.attach(true);\n    return thread;\n}\n</code></pre>\n<p>如果不是系统进程，则会根据 binder 机制，通过 IActivityManager 与 AMS 建立连接，调用  attachApplication 方法，并将 IApplicationThread 实例对象传入 AMS，这样一来，IActivityManager 和 IApplicationThread 就建立了绑定关系。</p>\n<h2 id=\"Application-又是什么时候初始化的\"><a href=\"#Application-又是什么时候初始化的\" class=\"headerlink\" title=\"Application 又是什么时候初始化的\"></a>Application 又是什么时候初始化的</h2><p>接下来我们看一下 application 绑定的过程。</p>\n<pre><code class=\"java\">// ActivityManagerService#attachApplication\npublic final void attachApplication(IApplicationThread thread) {\n    synchronized (this) {\n      int callingPid = Binder.getCallingPid();\n      final long origId = Binder.clearCallingIdentity();\n      attachApplicationLocked(thread, callingPid);\n      Binder.restoreCallingIdentity(origId);\n    }\n}\n\n// ActivityManagerService#attachApplicationLocked\nprivate boolean attachApplicationLocked(IApplicationThread thread, int pid) {\n\n    if (app.instr != null) {\n      thread.bindApplication(processName, appInfo, providers,\n                             app.instr.mClass,\n                             profilerInfo, app.instr.mArguments,\n                             app.instr.mWatcher,\n                             app.instr.mUiAutomationConnection, testMode,\n                             mBinderTransactionTrackingEnabled, enableTrackAllocation,\n                             isRestrictedBackupMode || !normalMode, app.persistent,\n                             new Configuration(getGlobalConfiguration()), app.compat,\n                             getCommonServicesLocked(app.isolated),\n                             mCoreSettingsObserver.getCoreSettingsLocked(),\n                             buildSerial);\n    } else {\n      thread.bindApplication(processName, appInfo, providers, null, profilerInfo,\n                             null, null, null, testMode,\n                             mBinderTransactionTrackingEnabled, enableTrackAllocation,\n                             isRestrictedBackupMode || !normalMode, app.persistent,\n                             new Configuration(getGlobalConfiguration()), app.compat,\n                             getCommonServicesLocked(app.isolated),\n                             mCoreSettingsObserver.getCoreSettingsLocked(),\n                             buildSerial);\n    }\n\n      return true;\n}\n\n// 很明显，通过 IApplicationThread 又将代码回调到了 Client 端\n// ApplicationThread#bindApplication\npublic final void bindApplication(... ...) {\n      sendMessage(H.BIND_APPLICATION, data);\n}\n\n// 根据消息机制，我们在 ActivityThread#H 中寻找消息处理\npublic void handleMessage(Message msg) {\n    case BIND_APPLICATION:\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);\n        AppBindData data = (AppBindData)msg.obj;\n        handleBindApplication(data);\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    break;\n}\n\n// ActivityThread#handleBindApplication\nprivate void handleBindApplication(AppBindData data) {\n\n    final InstrumentationInfo ii;\n    if (data.instrumentationName != null) {\n        ii = new ApplicationPackageManager(null, getPackageManager())\n          .getInstrumentationInfo(data.instrumentationName, 0);\n    } else {\n          ii = null;\n    }\n\n    // 根据上层调用传入的参数，决定初始化 mInstrumentation 实例的方式\n      // 1. 使用 ClassLoader 初始化；2. 直接 new 对象\n    if (ii != null) {\n        final ApplicationInfo instrApp = new ApplicationInfo();\n        ii.copyTo(instrApp);\n        instrApp.initForUser(UserHandle.myUserId());\n        final LoadedApk pi = getPackageInfo(......);\n        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);\n\n        try {\n          final ClassLoader cl = instrContext.getClassLoader();\n          mInstrumentation = (Instrumentation)\n            cl.loadClass(data.instrumentationName.getClassName()).newInstance();\n        } \n\n        final ComponentName component = new ComponentName(ii.packageName, ii.name);\n        mInstrumentation.init(... ...);\n    } else {\n          mInstrumentation = new Instrumentation();\n    }\n\n    try {\n          // 调用 makeApplication 创建当前 App 的 Application 对象\n        Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n        mInitialApplication = app; \n\n          // 初始化 application 对象后，通过 mInstrumentation 调用 application 的 onCreate 方法\n        mInstrumentation.onCreate(data.instrumentationArgs);\n        mInstrumentation.callApplicationOnCreate(app);\n    }\n}\n\n// LoadedApk#makeApplication\npublic Application makeApplication(boolean forceDefaultAppClass,\n                                   Instrumentation instrumentation) {\n    if (mApplication != null) {\n      return mApplication;\n    }\n\n    java.lang.ClassLoader cl = getClassLoader();\n    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n    // 入参的 instrumentation 为 null，使用 ActivityThread 的 mInstrumentation\n    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);\n    appContext.setOuterContext(app);\n\n    // 调用时传入的值为 null，所以不会进 if\n    if (instrumentation != null) {\n      instrumentation.callApplicationOnCreate(app);   \n    }\n\n    return app;\n}\n\n</code></pre>\n<p>经过层层调用，我们最终发现，Application 的初始化也是通过 Instrumentation 来处理的，现在大家能理解为什么管它叫应用程序的大管家了吧，因为事无巨细，全是它来做的呀！</p>\n<pre><code class=\"java\">public Application newApplication(ClassLoader cl, String className, Context context) {\n      return newApplication(cl.loadClass(className), context);\n}\n\nstatic public Application newApplication(Class&lt;?&gt; clazz, Context context){\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n</code></pre>\n<p>我们可以发现，application 实例的创建也是通过反射的方式实现的。</p>\n<p>流程走到这里，Application 实例是怎么创建的，C/S 是怎么发生绑定的，整个 App 是怎么被 Instumentation 支配的，大概都已经介绍清楚了。</p>\n<p>完结，撒花！！</p>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181341.jpg","title":"线程间通信 下篇","date":"2018-09-08T16:00:00.000Z","_content":"\n> Efficient.Android.Threading 第四章读书笔记 下篇\n\n<!--more-->\n\n### Android 消息机制\n\n迄今为止，我们介绍的线程通信都是 Java 层面的，管道、共享内存、阻塞队列等等，都是所有 Java 应用都有的机制。然而，因为阻塞线程特性的存在，这些机制对于 Android 系统都不适用，因为 UI 线程绝不允许阻塞。\n\n因此，Android 系统为了协同 UI 线程和工作线程，定义了一套系统级别的消息机制。Android 消息机制是一个没有阻塞状态的生产者-消费者模式，UI 线程可以将耗时操作转移给工作线程在后台处理，同时生产者线程与消费者线程都不会发生阻塞。\n\nAndroid 平台的消息机制相关的 API 从属于 `android.os` 包：\n\n![Android Message API](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182551.jpg)\n\n`android.os.Looper`\n\n唯一关联某个消费者线程的消息调度器\n\n`android.os.Handler`\n\n消费者线程的消息处理器，同时生产者线程也使用该对象将消息插入队列。一个 Looper 对象可以绑定多个 Handler 对象，但是所有的消息都是插入同一个消息队列的。\n\n`android.os.MessageQueue`\n\n消费者线程中待处理消息的链表，但是不同的消息之间并没有绑定关系。每个 Looper 对象最多只能有一个消息队列；由于每个线程只能有一个 Looper 对象，也就是说每个线程最多只能有一个消息队列。\n\n名叫 MessageQueue, 实际上是一个 LinkedList\n\n`android.os.Message`\n\n消费者线程中待执行的消息\n\n消息机制的工作原理大抵如下图示意：\n\n![消息机制示意](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182556.jpg)\n\n生产者线程发送消息，消费者线程处理消息：\n\n1. 插入：生产者线程使用与消费者线程相绑定的 Handler 对象，将消息插入消息队列\n2. 取出：Looper 运行在消费者线程中，按一定的顺序取出消息队列中的消息\n3. 分发：Handler 负责在消费者线程中处理消息；某个线程可以有多个 Handler 对象，Looper 可以确保每条消息能够正确分发给对应的 Handler 。\n\n#### 消息传递基本示例\n\n```java\npublic class LooperActivity extends Activity {\n\n    LooperThread mLooperThread;\n\n    // 1.声明一个工作线程，扮演消费者线程角色\n    private static class LooperThread extends Thread {\n\n        public Handler mHandler;\n\n        public void run() {\n            // 2.为当前线程关联 Looper，也就是关联了 MessageQueue\n            Looper.prepare();\n            // 3.使用默认构造器，即将 Handler 与当前线程的 Looper 绑定\n            // 也就决定了它只能在 Looper.prepare() 后初始化，否则没有可以绑定的 Looper\n            mHandler = new Handler() {\n                // 4. 工作线程中处理分发下来的消息的回调\n                public void handleMessage(Message msg) {\n                    if(msg.what == 0) {\n                        doLongRunningOperation();\n                    }\n                }\n            };\n            // 5. 开启对消息队列的轮询，对消息进行分发；\n            // 这是个 blocking call，因此此工作线程不会结束\n            Looper.loop();\n        }\n\n        private void doLongRunningOperation() {\n            // Add long running operation here.\n        }\n    }\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_looper);\n        // 6. 开启工作线程，准备处理消息\n        mLooperThread = new LooperThread();\n        mLooperThread.start();\n    }\n\n    public void onClick(View v) {\n        // 7. Handler 初始化完成和点击事件是异步的，因次校验一下 Handler 不为空\n        if (mLooperThread.mHandler != null) {\n            // 8. 初始化一个 Message 对象，what 属性赋值为 0\n            Message msg = mLooperThread.mHandler.obtainMessage(0);\n            // 9. 向消息队列中插入消息\n            mLooperThread.mHandler.sendMessage(msg);\n        }\n    }\n\n    protected void onDestroy() {\n        super.onDestroy();\n        // 10. 结束 loop() 方法的阻塞状态，从而结束后台线程的执行\n        mLooperThread.mHandler.getLooper().quit();\n    }\n}\n```\n\n#### 消息传递过程中涉及到的 Classes\n\n##### MessageQueue\n\n消息队列主要由 `android.os.MessageQueue` 类来实现，其内部实现一个没有绑定关系的单向链表，用于存储一系列待处理的消息。生产者线程插入消息，之后消息会分发到对应的消费者线程去处理。一般来讲，不同的消息是按照时间戳来排序的。也就是说，时间戳值越小，在消息队列中排序顺序就越靠前。但是只有到达当前时间的消息才会被分发；如果还没有到当前时间，则会等到当前时间才会对消息进行分发。\n\n![消息分发的时间点](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182557.jpg)\n\n上图展示了消息队列中按时间排序的消息是如何向下分发的，其中 t1 < t2 < t3，即 t1 的时间要早于 t3。现在只有一条消息越过了 `disptch barrier` , 实际上也就是当前时间点。可以被分发下去的消息所绑定的时间戳，一定比当前时间小，也就是已经到了分发的时间。\n\n如果当前 Looper 获取消息时，消息队列中还没有消息穿越过 `dispatch barrier` ，此时消费者线程就会阻塞，直到有消息越过 `dispatch barrier` 。而生产者线程可以在任何时间、任意位置插入消息，因为消息列表的排列只和消息发送的时间有关系，如果需要插入一条立即发送的消息，则即使消息队列中有一百条待发送的消息，但它们都是一分钟后才发送，那刚插入的这条消息也会在链表的首位，也就是下一个被分发的消息。\n\n##### MessageQueue.IdleHandler\n\n正常来讲，如果 Looper 获取不到应分发的消息时，线程就会阻塞等待；但是除了干等以外，还可以将这段时间利用起来，用来执行一些其他的任务。而这个任务则由 `android.os.MessageQueue.IdleHandler` 来完成。\n\n```java\n/**\n * 当线程等待新消息，即将进入阻塞（闲置）状态时的回调接口\n */\npublic static interface IdleHandler {  \n    boolean queueIdle();\n}\n\n// 具体使用：\n// 获取当前线程的消息队列\nMessageQueue myQueue = Looper.myQueue();\n// 声明一个 IdleHandler 对象\nMessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() {\n    @Override\n    public boolean queueIdle() {\n        return false;\n    }\n};\n// 与消息队列进行绑定\nmyQueue.addIdleHandler(idleHandler);\n// 与消息队列解除绑定\nmyQueue.removeIdleHandler(idleHandler);\n\n```\n\n当消息队列检测到分发消息的空闲时间时，它会唤醒所有注册到当前消息队列的 IdleHandler 实例，并调用他们的 `queueIdle` 方法，而具体的回调由应用自身来进行实现。\n\n `queueIdle` 方法返回值为布尔类型：\n\n- true\n\n  当前 IdleHandler 实例保持存活，下次再有 time slots 时，MessageQueue 还会唤醒该实例\n\n- false\n\n  当前 IdleHandler 实例不再存活，处理完消息后就会主动调用 MessageQueue.removeIdleHandler() 将该实例与 MessageQueue 解绑\n\n##### 使用 IdleHandler 来终止闲置线程的运行\n\n假定现在有多个生产者线程要连续不断的向消费者线程发送消息，那就可以在消费者线程将所有任务的处理完以偶胡，使用 IdleHandler 来终止线程的执行，从而保证该线程对象不会在内存中游荡。\n\n在这种情况下使用 IdleHandler ，就不用追踪最后一条插入队列的消息，以期得到回收该线程的确切时间。\n\n不过这种场景只适用于生产者线程连续不断地向消费者线程插入消息，从而保证在处理完所有消息之前，消费者线程都没有 time slots.\n\n```java\npublic class ConsumeAndQuitThreadActivity extends Activity {\n    \n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ConsumeAndQuitThread consumeAndQuitThread = new ConsumeAndQuitThread();\n        consumeAndQuitThread.start();\n        for (int i = 0; i < 10; i++) {\n            // 由多个线程并发向消费者线程发送消息，随机模拟发送的时间\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0; i < 10; i++) {\n                        SystemClock.sleep(new Random().nextInt(10));\n                        consumeAndQuitThread.enqueueData(i);\n                    }\n                }\n            }).start();\n        }\n    }\n\n    /**\n     * 此线程为绑定了 Looper 对象的消费者线程，接收生产者线程的消息并进行处理；\n     * 处理完消息后，会终止 Looper.loop() 方法，结束线程的执行\n     */\n    private static class ConsumeAndQuitThread extends Thread implements MessageQueue.IdleHandler {\n\n        private static final String THREAD_NAME = \"ConsumeAndQuitThread\";\n\n        public Handler mConsumerHandler;\n        private boolean mIsFirstIdle = true;\n\n        public ConsumeAndQuitThread() {\n            super(THREAD_NAME);\n        }\n\n        @Override\n        public void run() {\n            Looper.prepare();\n\n            mConsumerHandler = new Handler() {\n                @Override\n                public void handleMessage(Message msg) {\n                    // Consume data\n                }\n            };\n            // 1. 为当前线程初始化 Looper，并为该线程的消息队列绑定 IdleHandler 对象\n            Looper.myQueue().addIdleHandler(this);\n            Looper.loop();\n        }\n\n\n        @Override\n        public boolean queueIdle() {\n            // 2. 第一次 queueIdle() 的调用会发生在接收消息之前\n            // 因此需要让首次调用返回 true，从而保证此对象仍然与消息队列绑定\n            if (mIsFirstIdle) { \n                mIsFirstIdle = false;\n                return true;\n            }\n            // 3. 结束消费者线程的执行\n            mConsumerHandler.getLooper().quit();\n            return false;\n        }\n\n        public void enqueueData(int i) {\n            mConsumerHandler.sendEmptyMessage(i);\n        }\n    }\n}\n```\n\n\n\n##### Message\n\nMessage 是一个容器类，可以承载各种类型的数据或者一个 Runnable 对象，但是不能同时携带二者。所携带的数据会在消费者线程被处理，但任务则会在消息分发时直接得到执行，而不需要调用者做其他额外的工作。\n\n正常来讲，Message 的插入由 Handler 来完成，因为它在插入消息时有更多的选择，更加灵活；但是实际上每条消息对象都知道自己对应的处理器是谁，也就是知道自己对应的 Handler 对象，所以一条消息可以自己实现入队操作。\n\n```java\n// 通过 obtain() 传递一个 Handler 对象进去，赋值给 Message.target 属性\nMessage m = Message.obtain(handler, runnbale);\nm.sendToTarget();\n\npublic void sendToTarget() {\n    // target 是 Handler 对象，此方法会调用 Handler 的 sendMessage 方法\n\ttarget.sendMessage(this);\n}\n```\n\n如之前所说，Message 可以携带数据或者任务，具体如下图所示：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182601.jpg)\n\n消息队列可以包含任何数据和任务消息的组合，消费者线程具体在处理消息的时候，也仅仅是按照消息的排序顺序，而不和消息的类型有任何关系。如果消息携带的是数据，那消费者线程就会在 handleMessage 中处理数据；如果消息携带的是任务，则该 Runnable 的 run 方法则会在消费者线程得到执行，但是不会再触发 handleMessage 方法的回调。\n\nMessage 的生命周期大概可以分为四个方面：初始化，等待，分发，回收。需要注意的是，系统并没有对消息的状态进行监听，尽管这在技术上也是可行的，所以应用在处理消息不该对该消息的当前状态做出任何假设。\n\n- Initialized\n\n  在初始化状态下，应用程序可以使用以下方法来创建 Message 对象：\n\n  - 使用构造器初始化\n\n    ```java\n    Message m = new Message();\n    ```\n\n  - 工厂方法\n\n    - 空消息\n\n      ```java\n      Message m = Message.obtain();\n      ```\n\n    - 数据消息\n\n      ```java\n      Message m = Message.obtain(Handler h);\n      Message m = Message.obtain(Handler h, int what);\n      Message m = Message.obtain(Handler h, int what, Object o);\n      Message m = Message.obtain(Handler h, int what, int arg1, int arg2); \n      Message m = Message.obtain(Handler h, int what, int arg1, int arg2, Object o);\n      ```\n\n    - 任务消息\n\n      ```java\n      Message m = Message.obtain(Handler h, Runnable task);\n      ```\n\n    - 复制构造器\n\n      ```java\n      Message m = Message.obtain(Message originalMsg);\n      ```\n\n- Pending\n\n  消息已经被插入消息队列中，但还没到发送时间，正在等待分发\n\n- Disptached\n\n  在这个阶段，Looper 已经从消息队列中取出了消息，消息队列也将其移除。Looper 在 loop 方法中，会通过访问 Message.target 属性，来获取到该消息对应的 Handler ，然后将消息发送到对应的回调中进行处理。\n\n- Recycled\n\n  在这个阶段，Message 的状态被清除，该实例也回到了消息池中等待复用。在消费者线程完成数据处理后，Looper 负责 Message 的回收工作。这个回收过程由虚拟机来完成，而不应该由应用程序来主动处理。\n\n  > 需要注意的是，一旦消息入队后，其携带的数据就不应该再被更改。理论上来讲，在消息被分发之前，对数据做出的更改都是有效的。但由于 Handler 机制在设计之初就没有对 Message 的处理状态进行监听，因此调用者正在对数据进行更改时，消费者线程正在处理数据，从而导致线程安全的问题。而如果该消息对象已经被回收了，问题则会更加严重，因为该对象回到消息池后，会在之后被应用程序所复用，有可能会携带之前的数据到新的消息队列中。\n\n\n\n##### Looper\n\n`android.os.Looper` 复杂将队列中的消息分发给对应的 Handler 去处理。所有越过分发栅栏的消息都可以被 Looper 所分发。所有待分发的消息一定是越过分发栅栏的，当没有消息待分发时，消费线程则会阻塞，直至有消息等待处理。\n\n消费线程并不直接与消息队列发生关系，而是通过 Looper 作为中间者来协调消息的分发与处理：消费电车绑定 Looper，而 Looper 会绑定一个 MessageQueue。默认只有 UI 线程自带 Looper ，其他子线程需要调用者显式声明 Looper 。\n\n```java\nnew Thread() {\n    @Override\n    public void run() {\n        // prepare() 方法会初始化一个消息队列，并将其与当前线程绑定\n        // 在此时，该消息队列已经可以插入消息，但是无法分发到消费线程处理\n        Looper.prepare();\n        \n        // ... ...\n        \n        // 此方法为一个 blocking call，确保 run() 方法不会结束执行\n        // 当 run() 方法阻塞的时候，Looper 可以循环消息队列，然后向消费线程分发消息\n        Looper.loop();\n    }\n}.start();\n```\n\n一个线程只能绑定一个 Looper，而 Looper 会绑定一个 MessageQueue，也就是说一个线程只能有一个消息队列；这也就保证了无论多少工作线程向主线程发送消息，主线程也只能按照一定顺序来处理消息。因此，当前执行的消息处理时间的长短会影响到之后的消息，我们在实际使用时，应该规避处理耗时过长的消息。\n\n##### Looper 的终止\n\n- quit()\n\n  丢弃消息队列中所有未分发的消息，不管其有没有越过分发栅栏\n\n- quitSafely()\n\n  丢弃还没越过分发栅栏的消息，Looper 会等到已经处于待分发状态的消息正确分发后再结束\n\n终止 Looper 并不会终止线程的执行，它只是将 loop() 方法结束了；但需要注意的是，终止 Looper 后此线程将不再是 Looper 线程，既不能重新绑定新的 Looper ，也无法唤醒已经终止的 Looper。调用 Looper.prepare() 会抛异常，提示已经绑定；重新调用 Looper.loop() 会进入阻塞状态，但是消息队列中的消息不会再得到分发。\n\n##### UI 线程的 Looper\n\nUI 线程是唯一一个自带 Looper 的线程，其与其他线程有以下几点不同：\n\n- 在程序任何位置都可以通过调用 Looper.getMainLooper() 来获取 UI Looper\n- UI 线程的 Looper 不能被终止\n- Java 虚拟机通过 Looper.prepareMainLooper() 为 UI 线程初始化 Looper，此动作只能执行一次，因此尝试将 main looper 与其他子线程关联会抛异常。\n\n\n\n##### Handler\n\nAndroid 系统中使用 `android.os.Handler` 来协调工作线程与 UI 线程的调度，消息的插入和处理都由它来完成，具体工作包括以下几点：\n\n- 消息的创建\n- 插入消息\n- 在消费线程中处理消息\n- 管理消息队列中的消息\n\nHandler 的工作需要 Looper 和 MQ 的支持，因此 Handler 在声明时就应该绑定 Looper 对象：\n\n1. 构造器中不接收 Looper 的，该 Handler 与当前线程绑定\n\n   ```java\n   // 这种与当前线程绑定的，如果当前不是 Looper 线程，就会抛出异常\n   new Handler();\n   new Handler(Handler.Callback);\n   ```\n\n2. 构造器明确需要传入 Looper 对象的\n\n   ```java\n   new Handler(Looper);\n   new Handler(Looper, Handler.Callback);\n   ```\n\n一个线程可以有多个 Handler ，不同 Handler 发送的消息可以在消息队列中共存，并不会有什么冲突；具体在分发的时候又会通过 Message 的 target 属性发送回该消息对应的 Handler：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182554.jpg)\n\n> 多个 Handler 发出的消息也不会导致并发，Message 的处理仍然是按顺序执行的。\n\n##### Message creation\n\nHandler 可以通过以下几个包装方法直接获取 Message 对象，而这些对象则会和 Handler 发生绑定关系：\n\n```java\n// 这些方法内部都会调用 Message.obtain() 方法，并将 Handler 传入，从而产生绑定关系\nMessage obtainMessage(int what, int arg1, int arg2)\nMessage obtainMessage()\nMessage obtainMessage(int what, int arg1, int arg2, Object obj) \nMessage obtainMessage(int what)\nMessage obtainMessage(int what, Object obj)\n```\n\n##### Message insertion\n\n根据消息类型的不同，Handler 插入消息的方式也略有差别。\n\n```java\n// 携带任务的消息，使用 postXxx() 方法\nboolean post(Runnable r)\nboolean postAtFrontOfQueue(Runnable r)\nboolean postAtTime(Runnable r, Object token, long uptimeMillis) \nboolean postAtTime(Runnable r, long uptimeMillis)\nboolean postDelayed(Runnable r, long delayMillis)\n    \n// 携带数据的消息或者空消息，使用 sendXxx() 方法\n// 默认，立即分发\nboolean sendMessage(Message msg) \n// 下一个分发\nboolean sendMessageAtFrontOfQueue(Message msg)\n// 指定某个确切的时间进行分发\nboolean sendMessageAtTime(Message msg, long uptimeMillis) \nboolean sendMessageDelayed(Message msg, long delayMillis)\nboolean sendEmptyMessage(int what)\nboolean sendEmptyMessageAtTime(int what, long uptimeMillis) \nboolean sendEmptyMessageDelayed(int what, long delayMillis)\n```\n\n每条消息都有会有一个 when 属性，用来记录当前消息应该何时被分发；该属性也是唯一一个会影响分发顺序的因素。需要注意的是，尽管我们可以指定确定的时机分发，但是由于之前消息的处理也会影响到后一条消息的分发，因此这个时间还是不确定的。\n\n向消息队列中插入消息时，有可能导致某些错误的产生：\n\n- Message has no Handler\n\n  Message was created from a Message.obtain() method without a specified Handler.\n\n- Message has already been disptached and is being processed\n\n  The same message instance was inserted twice.\n\n- Looper has exited\n\n  Message is inserted after Looper.quit() has been called.\n\n> Looper 在分发消息时，会调用 Handler 的 dispatchMessage 方法。如果此方法被应用程序主动调用，那该消息会在发起调用的线程立即得到执行，而不是在消费线程执行。\n\n##### Message processing\n\nMessage 根据携带数据类型的不同，有不同的处理方式：\n\n- Task messages\n\n  如果携带的是 Runnbale 对象，那等轮到该条消息分发的时候，则该 Runnable 对象的 run 方法会直接得到执行，而不会再触发 `Handler.handMessage()` 方法。\n\n- Data messages\n\n  如果消息携带的是数据的话，那处理消息则需要重写 `Handler.handMessage()` 方法（两种方式）。\n\n一种是正常的实现自己的 Handler ，然后重写该方法；或者在初始化 Handler 的时候直接重写该方法，但需要注意的是，如果在子线程中，该方法的重写要在消息队列就绪以后立刻声明，否则 loop() 循环开启后，就无法再声明了：\n\n```java\nclass ConsumerThread extends Thread{\n    Handler mHandler;\n    @Override\n    public void run(){\n        Looper.prepare();\n        mHandler = new Handler(){\n            public void handleMessage(Message msg){\n                // process data message here\n            }\n        };\n        Looper.loop();\n    }\n}\n```\n\n另一种方式是利用 `Handler.Callback` 接口，该接口方法为一个带布尔类型返回值的 `handleMessage` 方法：\n\n```java\npublic interface Callback {\n    // true: 代表实现类处理完消息即终止\n    // false: 代表实现类处理完以后，还要继续下发到 Handler.handleMessage 方法\n\tpublic boolean handleMessage(Message msg);\n}\n\n// 消息分发\npublic void dispatchMessage(Message msg) {\n\tif (msg.callback != null) {\n\t\thandleCallback(msg);\n\t} else {\n\t\tif (mCallback != null) {\n            // 如果返回 true ，则不会继续向下分发了\n\t\t\tif (mCallback.handleMessage(msg)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\thandleMessage(msg);\n\t}\t\n}\n```\n\n使用这种方式，调用者不再需要继承自 Handler ，而只需要将 Callback 接口的实现类当做 Handler 构造器传入即可，然后该 Handler 就会回调到 handleMessage()：\n\n```java\npublic class HandlerCallbackActivity extends Activity implements Handler.Callback {\n    Handler mUiHandler;\n    \n    @Override\n    public void onCreate(Bundle savedInstanceState){\n        super.onCreate(savedInstanceState);\n        mUiHandler = new Handler(this); // 直接通过构造器传入，即可通过此类处理消息\n    }\n    \n    @Override\n    public boolean handleMessage(Message msg){\n        // process msg\n        return true;\n    }\n}\n```\n\n#### 与 UI 线程通信\n\n正如之前所说，UI 线程是唯一一个自带 Looper 的线程，其他线程可以向 UI 线程发送消息，但要注意避免耗时操作，因为 UI 线程是全局的，每个任务的时长都会对全局任务的执行产生影响。\n\n有以下几种方式将消息转交到 UI 线程处理：\n\n1. 为 Handler 指定 UI 线程的 Looper\n\n   ```java\n   Runnable task = new Runnable(){...};\n   new Handler(Looper.getMainLooper()).post(task);\n   ```\n\n   使用这种方式，不管调用线程，task 都会通过 UI Looper 直接插入 UI MessageQueue。\n\n2. 直接在 UI 线程向自身发送消息，该任务会在当前正在执行的消息处理完后得到执行\n\n   ```java\n   private void postFromUiThreadToUiThread(){\n       new Handler().post(new Runnable(){...})\n   }\n   ```\n\n3. Activity.runOnUiThread\n\n   ```java\n   private void postFromUiThreadToUiThread(){\n       runOnUiThread(new Runnable(){...})\n   }\n   ```\n\n   如果此方法在其他线程调用，则它会将消息插入到 UI 线程的消息队列中。此方法只能由 Activity 的实例来调用，但是也可以实现自己的 runOnUIThread 方法，只要追踪 UI 线程的 ID 即可：\n\n   ```java\n   public class MyApplication extends Application{\n       private long mUiThreadId;\n       private Handler mUiHandler;\n       \n       @Override\n       public void onCreate(){\n           super.onCreate();\n           mUiThread = Thread.currentThread().getId();\n           mUiHandler = new Handler();\n       }\n       \n       public void customRunOnUiThread(Runnable action){\n           if(Thread.currentThread().getId() != mUiThreadId){\n               mUiHandler.post(action);\n           } else{\n               action.run();\n           }\n       }\n   }\n   ```\n\n   ","source":"_posts/Efficient-Android-Threading-chapter-4-2.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181341.jpg\ntitle: 线程间通信 下篇\ntags: [读书笔记, Efficient.Android.Threading]\ndate: 2018-09-09\n---\n\n> Efficient.Android.Threading 第四章读书笔记 下篇\n\n<!--more-->\n\n### Android 消息机制\n\n迄今为止，我们介绍的线程通信都是 Java 层面的，管道、共享内存、阻塞队列等等，都是所有 Java 应用都有的机制。然而，因为阻塞线程特性的存在，这些机制对于 Android 系统都不适用，因为 UI 线程绝不允许阻塞。\n\n因此，Android 系统为了协同 UI 线程和工作线程，定义了一套系统级别的消息机制。Android 消息机制是一个没有阻塞状态的生产者-消费者模式，UI 线程可以将耗时操作转移给工作线程在后台处理，同时生产者线程与消费者线程都不会发生阻塞。\n\nAndroid 平台的消息机制相关的 API 从属于 `android.os` 包：\n\n![Android Message API](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182551.jpg)\n\n`android.os.Looper`\n\n唯一关联某个消费者线程的消息调度器\n\n`android.os.Handler`\n\n消费者线程的消息处理器，同时生产者线程也使用该对象将消息插入队列。一个 Looper 对象可以绑定多个 Handler 对象，但是所有的消息都是插入同一个消息队列的。\n\n`android.os.MessageQueue`\n\n消费者线程中待处理消息的链表，但是不同的消息之间并没有绑定关系。每个 Looper 对象最多只能有一个消息队列；由于每个线程只能有一个 Looper 对象，也就是说每个线程最多只能有一个消息队列。\n\n名叫 MessageQueue, 实际上是一个 LinkedList\n\n`android.os.Message`\n\n消费者线程中待执行的消息\n\n消息机制的工作原理大抵如下图示意：\n\n![消息机制示意](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182556.jpg)\n\n生产者线程发送消息，消费者线程处理消息：\n\n1. 插入：生产者线程使用与消费者线程相绑定的 Handler 对象，将消息插入消息队列\n2. 取出：Looper 运行在消费者线程中，按一定的顺序取出消息队列中的消息\n3. 分发：Handler 负责在消费者线程中处理消息；某个线程可以有多个 Handler 对象，Looper 可以确保每条消息能够正确分发给对应的 Handler 。\n\n#### 消息传递基本示例\n\n```java\npublic class LooperActivity extends Activity {\n\n    LooperThread mLooperThread;\n\n    // 1.声明一个工作线程，扮演消费者线程角色\n    private static class LooperThread extends Thread {\n\n        public Handler mHandler;\n\n        public void run() {\n            // 2.为当前线程关联 Looper，也就是关联了 MessageQueue\n            Looper.prepare();\n            // 3.使用默认构造器，即将 Handler 与当前线程的 Looper 绑定\n            // 也就决定了它只能在 Looper.prepare() 后初始化，否则没有可以绑定的 Looper\n            mHandler = new Handler() {\n                // 4. 工作线程中处理分发下来的消息的回调\n                public void handleMessage(Message msg) {\n                    if(msg.what == 0) {\n                        doLongRunningOperation();\n                    }\n                }\n            };\n            // 5. 开启对消息队列的轮询，对消息进行分发；\n            // 这是个 blocking call，因此此工作线程不会结束\n            Looper.loop();\n        }\n\n        private void doLongRunningOperation() {\n            // Add long running operation here.\n        }\n    }\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_looper);\n        // 6. 开启工作线程，准备处理消息\n        mLooperThread = new LooperThread();\n        mLooperThread.start();\n    }\n\n    public void onClick(View v) {\n        // 7. Handler 初始化完成和点击事件是异步的，因次校验一下 Handler 不为空\n        if (mLooperThread.mHandler != null) {\n            // 8. 初始化一个 Message 对象，what 属性赋值为 0\n            Message msg = mLooperThread.mHandler.obtainMessage(0);\n            // 9. 向消息队列中插入消息\n            mLooperThread.mHandler.sendMessage(msg);\n        }\n    }\n\n    protected void onDestroy() {\n        super.onDestroy();\n        // 10. 结束 loop() 方法的阻塞状态，从而结束后台线程的执行\n        mLooperThread.mHandler.getLooper().quit();\n    }\n}\n```\n\n#### 消息传递过程中涉及到的 Classes\n\n##### MessageQueue\n\n消息队列主要由 `android.os.MessageQueue` 类来实现，其内部实现一个没有绑定关系的单向链表，用于存储一系列待处理的消息。生产者线程插入消息，之后消息会分发到对应的消费者线程去处理。一般来讲，不同的消息是按照时间戳来排序的。也就是说，时间戳值越小，在消息队列中排序顺序就越靠前。但是只有到达当前时间的消息才会被分发；如果还没有到当前时间，则会等到当前时间才会对消息进行分发。\n\n![消息分发的时间点](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182557.jpg)\n\n上图展示了消息队列中按时间排序的消息是如何向下分发的，其中 t1 < t2 < t3，即 t1 的时间要早于 t3。现在只有一条消息越过了 `disptch barrier` , 实际上也就是当前时间点。可以被分发下去的消息所绑定的时间戳，一定比当前时间小，也就是已经到了分发的时间。\n\n如果当前 Looper 获取消息时，消息队列中还没有消息穿越过 `dispatch barrier` ，此时消费者线程就会阻塞，直到有消息越过 `dispatch barrier` 。而生产者线程可以在任何时间、任意位置插入消息，因为消息列表的排列只和消息发送的时间有关系，如果需要插入一条立即发送的消息，则即使消息队列中有一百条待发送的消息，但它们都是一分钟后才发送，那刚插入的这条消息也会在链表的首位，也就是下一个被分发的消息。\n\n##### MessageQueue.IdleHandler\n\n正常来讲，如果 Looper 获取不到应分发的消息时，线程就会阻塞等待；但是除了干等以外，还可以将这段时间利用起来，用来执行一些其他的任务。而这个任务则由 `android.os.MessageQueue.IdleHandler` 来完成。\n\n```java\n/**\n * 当线程等待新消息，即将进入阻塞（闲置）状态时的回调接口\n */\npublic static interface IdleHandler {  \n    boolean queueIdle();\n}\n\n// 具体使用：\n// 获取当前线程的消息队列\nMessageQueue myQueue = Looper.myQueue();\n// 声明一个 IdleHandler 对象\nMessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() {\n    @Override\n    public boolean queueIdle() {\n        return false;\n    }\n};\n// 与消息队列进行绑定\nmyQueue.addIdleHandler(idleHandler);\n// 与消息队列解除绑定\nmyQueue.removeIdleHandler(idleHandler);\n\n```\n\n当消息队列检测到分发消息的空闲时间时，它会唤醒所有注册到当前消息队列的 IdleHandler 实例，并调用他们的 `queueIdle` 方法，而具体的回调由应用自身来进行实现。\n\n `queueIdle` 方法返回值为布尔类型：\n\n- true\n\n  当前 IdleHandler 实例保持存活，下次再有 time slots 时，MessageQueue 还会唤醒该实例\n\n- false\n\n  当前 IdleHandler 实例不再存活，处理完消息后就会主动调用 MessageQueue.removeIdleHandler() 将该实例与 MessageQueue 解绑\n\n##### 使用 IdleHandler 来终止闲置线程的运行\n\n假定现在有多个生产者线程要连续不断的向消费者线程发送消息，那就可以在消费者线程将所有任务的处理完以偶胡，使用 IdleHandler 来终止线程的执行，从而保证该线程对象不会在内存中游荡。\n\n在这种情况下使用 IdleHandler ，就不用追踪最后一条插入队列的消息，以期得到回收该线程的确切时间。\n\n不过这种场景只适用于生产者线程连续不断地向消费者线程插入消息，从而保证在处理完所有消息之前，消费者线程都没有 time slots.\n\n```java\npublic class ConsumeAndQuitThreadActivity extends Activity {\n    \n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ConsumeAndQuitThread consumeAndQuitThread = new ConsumeAndQuitThread();\n        consumeAndQuitThread.start();\n        for (int i = 0; i < 10; i++) {\n            // 由多个线程并发向消费者线程发送消息，随机模拟发送的时间\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0; i < 10; i++) {\n                        SystemClock.sleep(new Random().nextInt(10));\n                        consumeAndQuitThread.enqueueData(i);\n                    }\n                }\n            }).start();\n        }\n    }\n\n    /**\n     * 此线程为绑定了 Looper 对象的消费者线程，接收生产者线程的消息并进行处理；\n     * 处理完消息后，会终止 Looper.loop() 方法，结束线程的执行\n     */\n    private static class ConsumeAndQuitThread extends Thread implements MessageQueue.IdleHandler {\n\n        private static final String THREAD_NAME = \"ConsumeAndQuitThread\";\n\n        public Handler mConsumerHandler;\n        private boolean mIsFirstIdle = true;\n\n        public ConsumeAndQuitThread() {\n            super(THREAD_NAME);\n        }\n\n        @Override\n        public void run() {\n            Looper.prepare();\n\n            mConsumerHandler = new Handler() {\n                @Override\n                public void handleMessage(Message msg) {\n                    // Consume data\n                }\n            };\n            // 1. 为当前线程初始化 Looper，并为该线程的消息队列绑定 IdleHandler 对象\n            Looper.myQueue().addIdleHandler(this);\n            Looper.loop();\n        }\n\n\n        @Override\n        public boolean queueIdle() {\n            // 2. 第一次 queueIdle() 的调用会发生在接收消息之前\n            // 因此需要让首次调用返回 true，从而保证此对象仍然与消息队列绑定\n            if (mIsFirstIdle) { \n                mIsFirstIdle = false;\n                return true;\n            }\n            // 3. 结束消费者线程的执行\n            mConsumerHandler.getLooper().quit();\n            return false;\n        }\n\n        public void enqueueData(int i) {\n            mConsumerHandler.sendEmptyMessage(i);\n        }\n    }\n}\n```\n\n\n\n##### Message\n\nMessage 是一个容器类，可以承载各种类型的数据或者一个 Runnable 对象，但是不能同时携带二者。所携带的数据会在消费者线程被处理，但任务则会在消息分发时直接得到执行，而不需要调用者做其他额外的工作。\n\n正常来讲，Message 的插入由 Handler 来完成，因为它在插入消息时有更多的选择，更加灵活；但是实际上每条消息对象都知道自己对应的处理器是谁，也就是知道自己对应的 Handler 对象，所以一条消息可以自己实现入队操作。\n\n```java\n// 通过 obtain() 传递一个 Handler 对象进去，赋值给 Message.target 属性\nMessage m = Message.obtain(handler, runnbale);\nm.sendToTarget();\n\npublic void sendToTarget() {\n    // target 是 Handler 对象，此方法会调用 Handler 的 sendMessage 方法\n\ttarget.sendMessage(this);\n}\n```\n\n如之前所说，Message 可以携带数据或者任务，具体如下图所示：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182601.jpg)\n\n消息队列可以包含任何数据和任务消息的组合，消费者线程具体在处理消息的时候，也仅仅是按照消息的排序顺序，而不和消息的类型有任何关系。如果消息携带的是数据，那消费者线程就会在 handleMessage 中处理数据；如果消息携带的是任务，则该 Runnable 的 run 方法则会在消费者线程得到执行，但是不会再触发 handleMessage 方法的回调。\n\nMessage 的生命周期大概可以分为四个方面：初始化，等待，分发，回收。需要注意的是，系统并没有对消息的状态进行监听，尽管这在技术上也是可行的，所以应用在处理消息不该对该消息的当前状态做出任何假设。\n\n- Initialized\n\n  在初始化状态下，应用程序可以使用以下方法来创建 Message 对象：\n\n  - 使用构造器初始化\n\n    ```java\n    Message m = new Message();\n    ```\n\n  - 工厂方法\n\n    - 空消息\n\n      ```java\n      Message m = Message.obtain();\n      ```\n\n    - 数据消息\n\n      ```java\n      Message m = Message.obtain(Handler h);\n      Message m = Message.obtain(Handler h, int what);\n      Message m = Message.obtain(Handler h, int what, Object o);\n      Message m = Message.obtain(Handler h, int what, int arg1, int arg2); \n      Message m = Message.obtain(Handler h, int what, int arg1, int arg2, Object o);\n      ```\n\n    - 任务消息\n\n      ```java\n      Message m = Message.obtain(Handler h, Runnable task);\n      ```\n\n    - 复制构造器\n\n      ```java\n      Message m = Message.obtain(Message originalMsg);\n      ```\n\n- Pending\n\n  消息已经被插入消息队列中，但还没到发送时间，正在等待分发\n\n- Disptached\n\n  在这个阶段，Looper 已经从消息队列中取出了消息，消息队列也将其移除。Looper 在 loop 方法中，会通过访问 Message.target 属性，来获取到该消息对应的 Handler ，然后将消息发送到对应的回调中进行处理。\n\n- Recycled\n\n  在这个阶段，Message 的状态被清除，该实例也回到了消息池中等待复用。在消费者线程完成数据处理后，Looper 负责 Message 的回收工作。这个回收过程由虚拟机来完成，而不应该由应用程序来主动处理。\n\n  > 需要注意的是，一旦消息入队后，其携带的数据就不应该再被更改。理论上来讲，在消息被分发之前，对数据做出的更改都是有效的。但由于 Handler 机制在设计之初就没有对 Message 的处理状态进行监听，因此调用者正在对数据进行更改时，消费者线程正在处理数据，从而导致线程安全的问题。而如果该消息对象已经被回收了，问题则会更加严重，因为该对象回到消息池后，会在之后被应用程序所复用，有可能会携带之前的数据到新的消息队列中。\n\n\n\n##### Looper\n\n`android.os.Looper` 复杂将队列中的消息分发给对应的 Handler 去处理。所有越过分发栅栏的消息都可以被 Looper 所分发。所有待分发的消息一定是越过分发栅栏的，当没有消息待分发时，消费线程则会阻塞，直至有消息等待处理。\n\n消费线程并不直接与消息队列发生关系，而是通过 Looper 作为中间者来协调消息的分发与处理：消费电车绑定 Looper，而 Looper 会绑定一个 MessageQueue。默认只有 UI 线程自带 Looper ，其他子线程需要调用者显式声明 Looper 。\n\n```java\nnew Thread() {\n    @Override\n    public void run() {\n        // prepare() 方法会初始化一个消息队列，并将其与当前线程绑定\n        // 在此时，该消息队列已经可以插入消息，但是无法分发到消费线程处理\n        Looper.prepare();\n        \n        // ... ...\n        \n        // 此方法为一个 blocking call，确保 run() 方法不会结束执行\n        // 当 run() 方法阻塞的时候，Looper 可以循环消息队列，然后向消费线程分发消息\n        Looper.loop();\n    }\n}.start();\n```\n\n一个线程只能绑定一个 Looper，而 Looper 会绑定一个 MessageQueue，也就是说一个线程只能有一个消息队列；这也就保证了无论多少工作线程向主线程发送消息，主线程也只能按照一定顺序来处理消息。因此，当前执行的消息处理时间的长短会影响到之后的消息，我们在实际使用时，应该规避处理耗时过长的消息。\n\n##### Looper 的终止\n\n- quit()\n\n  丢弃消息队列中所有未分发的消息，不管其有没有越过分发栅栏\n\n- quitSafely()\n\n  丢弃还没越过分发栅栏的消息，Looper 会等到已经处于待分发状态的消息正确分发后再结束\n\n终止 Looper 并不会终止线程的执行，它只是将 loop() 方法结束了；但需要注意的是，终止 Looper 后此线程将不再是 Looper 线程，既不能重新绑定新的 Looper ，也无法唤醒已经终止的 Looper。调用 Looper.prepare() 会抛异常，提示已经绑定；重新调用 Looper.loop() 会进入阻塞状态，但是消息队列中的消息不会再得到分发。\n\n##### UI 线程的 Looper\n\nUI 线程是唯一一个自带 Looper 的线程，其与其他线程有以下几点不同：\n\n- 在程序任何位置都可以通过调用 Looper.getMainLooper() 来获取 UI Looper\n- UI 线程的 Looper 不能被终止\n- Java 虚拟机通过 Looper.prepareMainLooper() 为 UI 线程初始化 Looper，此动作只能执行一次，因此尝试将 main looper 与其他子线程关联会抛异常。\n\n\n\n##### Handler\n\nAndroid 系统中使用 `android.os.Handler` 来协调工作线程与 UI 线程的调度，消息的插入和处理都由它来完成，具体工作包括以下几点：\n\n- 消息的创建\n- 插入消息\n- 在消费线程中处理消息\n- 管理消息队列中的消息\n\nHandler 的工作需要 Looper 和 MQ 的支持，因此 Handler 在声明时就应该绑定 Looper 对象：\n\n1. 构造器中不接收 Looper 的，该 Handler 与当前线程绑定\n\n   ```java\n   // 这种与当前线程绑定的，如果当前不是 Looper 线程，就会抛出异常\n   new Handler();\n   new Handler(Handler.Callback);\n   ```\n\n2. 构造器明确需要传入 Looper 对象的\n\n   ```java\n   new Handler(Looper);\n   new Handler(Looper, Handler.Callback);\n   ```\n\n一个线程可以有多个 Handler ，不同 Handler 发送的消息可以在消息队列中共存，并不会有什么冲突；具体在分发的时候又会通过 Message 的 target 属性发送回该消息对应的 Handler：\n\n![](https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182554.jpg)\n\n> 多个 Handler 发出的消息也不会导致并发，Message 的处理仍然是按顺序执行的。\n\n##### Message creation\n\nHandler 可以通过以下几个包装方法直接获取 Message 对象，而这些对象则会和 Handler 发生绑定关系：\n\n```java\n// 这些方法内部都会调用 Message.obtain() 方法，并将 Handler 传入，从而产生绑定关系\nMessage obtainMessage(int what, int arg1, int arg2)\nMessage obtainMessage()\nMessage obtainMessage(int what, int arg1, int arg2, Object obj) \nMessage obtainMessage(int what)\nMessage obtainMessage(int what, Object obj)\n```\n\n##### Message insertion\n\n根据消息类型的不同，Handler 插入消息的方式也略有差别。\n\n```java\n// 携带任务的消息，使用 postXxx() 方法\nboolean post(Runnable r)\nboolean postAtFrontOfQueue(Runnable r)\nboolean postAtTime(Runnable r, Object token, long uptimeMillis) \nboolean postAtTime(Runnable r, long uptimeMillis)\nboolean postDelayed(Runnable r, long delayMillis)\n    \n// 携带数据的消息或者空消息，使用 sendXxx() 方法\n// 默认，立即分发\nboolean sendMessage(Message msg) \n// 下一个分发\nboolean sendMessageAtFrontOfQueue(Message msg)\n// 指定某个确切的时间进行分发\nboolean sendMessageAtTime(Message msg, long uptimeMillis) \nboolean sendMessageDelayed(Message msg, long delayMillis)\nboolean sendEmptyMessage(int what)\nboolean sendEmptyMessageAtTime(int what, long uptimeMillis) \nboolean sendEmptyMessageDelayed(int what, long delayMillis)\n```\n\n每条消息都有会有一个 when 属性，用来记录当前消息应该何时被分发；该属性也是唯一一个会影响分发顺序的因素。需要注意的是，尽管我们可以指定确定的时机分发，但是由于之前消息的处理也会影响到后一条消息的分发，因此这个时间还是不确定的。\n\n向消息队列中插入消息时，有可能导致某些错误的产生：\n\n- Message has no Handler\n\n  Message was created from a Message.obtain() method without a specified Handler.\n\n- Message has already been disptached and is being processed\n\n  The same message instance was inserted twice.\n\n- Looper has exited\n\n  Message is inserted after Looper.quit() has been called.\n\n> Looper 在分发消息时，会调用 Handler 的 dispatchMessage 方法。如果此方法被应用程序主动调用，那该消息会在发起调用的线程立即得到执行，而不是在消费线程执行。\n\n##### Message processing\n\nMessage 根据携带数据类型的不同，有不同的处理方式：\n\n- Task messages\n\n  如果携带的是 Runnbale 对象，那等轮到该条消息分发的时候，则该 Runnable 对象的 run 方法会直接得到执行，而不会再触发 `Handler.handMessage()` 方法。\n\n- Data messages\n\n  如果消息携带的是数据的话，那处理消息则需要重写 `Handler.handMessage()` 方法（两种方式）。\n\n一种是正常的实现自己的 Handler ，然后重写该方法；或者在初始化 Handler 的时候直接重写该方法，但需要注意的是，如果在子线程中，该方法的重写要在消息队列就绪以后立刻声明，否则 loop() 循环开启后，就无法再声明了：\n\n```java\nclass ConsumerThread extends Thread{\n    Handler mHandler;\n    @Override\n    public void run(){\n        Looper.prepare();\n        mHandler = new Handler(){\n            public void handleMessage(Message msg){\n                // process data message here\n            }\n        };\n        Looper.loop();\n    }\n}\n```\n\n另一种方式是利用 `Handler.Callback` 接口，该接口方法为一个带布尔类型返回值的 `handleMessage` 方法：\n\n```java\npublic interface Callback {\n    // true: 代表实现类处理完消息即终止\n    // false: 代表实现类处理完以后，还要继续下发到 Handler.handleMessage 方法\n\tpublic boolean handleMessage(Message msg);\n}\n\n// 消息分发\npublic void dispatchMessage(Message msg) {\n\tif (msg.callback != null) {\n\t\thandleCallback(msg);\n\t} else {\n\t\tif (mCallback != null) {\n            // 如果返回 true ，则不会继续向下分发了\n\t\t\tif (mCallback.handleMessage(msg)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\thandleMessage(msg);\n\t}\t\n}\n```\n\n使用这种方式，调用者不再需要继承自 Handler ，而只需要将 Callback 接口的实现类当做 Handler 构造器传入即可，然后该 Handler 就会回调到 handleMessage()：\n\n```java\npublic class HandlerCallbackActivity extends Activity implements Handler.Callback {\n    Handler mUiHandler;\n    \n    @Override\n    public void onCreate(Bundle savedInstanceState){\n        super.onCreate(savedInstanceState);\n        mUiHandler = new Handler(this); // 直接通过构造器传入，即可通过此类处理消息\n    }\n    \n    @Override\n    public boolean handleMessage(Message msg){\n        // process msg\n        return true;\n    }\n}\n```\n\n#### 与 UI 线程通信\n\n正如之前所说，UI 线程是唯一一个自带 Looper 的线程，其他线程可以向 UI 线程发送消息，但要注意避免耗时操作，因为 UI 线程是全局的，每个任务的时长都会对全局任务的执行产生影响。\n\n有以下几种方式将消息转交到 UI 线程处理：\n\n1. 为 Handler 指定 UI 线程的 Looper\n\n   ```java\n   Runnable task = new Runnable(){...};\n   new Handler(Looper.getMainLooper()).post(task);\n   ```\n\n   使用这种方式，不管调用线程，task 都会通过 UI Looper 直接插入 UI MessageQueue。\n\n2. 直接在 UI 线程向自身发送消息，该任务会在当前正在执行的消息处理完后得到执行\n\n   ```java\n   private void postFromUiThreadToUiThread(){\n       new Handler().post(new Runnable(){...})\n   }\n   ```\n\n3. Activity.runOnUiThread\n\n   ```java\n   private void postFromUiThreadToUiThread(){\n       runOnUiThread(new Runnable(){...})\n   }\n   ```\n\n   如果此方法在其他线程调用，则它会将消息插入到 UI 线程的消息队列中。此方法只能由 Activity 的实例来调用，但是也可以实现自己的 runOnUIThread 方法，只要追踪 UI 线程的 ID 即可：\n\n   ```java\n   public class MyApplication extends Application{\n       private long mUiThreadId;\n       private Handler mUiHandler;\n       \n       @Override\n       public void onCreate(){\n           super.onCreate();\n           mUiThread = Thread.currentThread().getId();\n           mUiHandler = new Handler();\n       }\n       \n       public void customRunOnUiThread(Runnable action){\n           if(Thread.currentThread().getId() != mUiThreadId){\n               mUiHandler.post(action);\n           } else{\n               action.run();\n           }\n       }\n   }\n   ```\n\n   ","slug":"Efficient-Android-Threading-chapter-4-2","published":1,"updated":"2019-03-21T10:47:37.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86f6001zlh1pji1bujb1","content":"<blockquote>\n<p>Efficient.Android.Threading 第四章读书笔记 下篇</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Android-消息机制\"><a href=\"#Android-消息机制\" class=\"headerlink\" title=\"Android 消息机制\"></a>Android 消息机制</h3><p>迄今为止，我们介绍的线程通信都是 Java 层面的，管道、共享内存、阻塞队列等等，都是所有 Java 应用都有的机制。然而，因为阻塞线程特性的存在，这些机制对于 Android 系统都不适用，因为 UI 线程绝不允许阻塞。</p>\n<p>因此，Android 系统为了协同 UI 线程和工作线程，定义了一套系统级别的消息机制。Android 消息机制是一个没有阻塞状态的生产者-消费者模式，UI 线程可以将耗时操作转移给工作线程在后台处理，同时生产者线程与消费者线程都不会发生阻塞。</p>\n<p>Android 平台的消息机制相关的 API 从属于 <code>android.os</code> 包：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182551.jpg\" alt=\"Android Message API\"></p>\n<p><code>android.os.Looper</code></p>\n<p>唯一关联某个消费者线程的消息调度器</p>\n<p><code>android.os.Handler</code></p>\n<p>消费者线程的消息处理器，同时生产者线程也使用该对象将消息插入队列。一个 Looper 对象可以绑定多个 Handler 对象，但是所有的消息都是插入同一个消息队列的。</p>\n<p><code>android.os.MessageQueue</code></p>\n<p>消费者线程中待处理消息的链表，但是不同的消息之间并没有绑定关系。每个 Looper 对象最多只能有一个消息队列；由于每个线程只能有一个 Looper 对象，也就是说每个线程最多只能有一个消息队列。</p>\n<p>名叫 MessageQueue, 实际上是一个 LinkedList</p>\n<p><code>android.os.Message</code></p>\n<p>消费者线程中待执行的消息</p>\n<p>消息机制的工作原理大抵如下图示意：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182556.jpg\" alt=\"消息机制示意\"></p>\n<p>生产者线程发送消息，消费者线程处理消息：</p>\n<ol>\n<li>插入：生产者线程使用与消费者线程相绑定的 Handler 对象，将消息插入消息队列</li>\n<li>取出：Looper 运行在消费者线程中，按一定的顺序取出消息队列中的消息</li>\n<li>分发：Handler 负责在消费者线程中处理消息；某个线程可以有多个 Handler 对象，Looper 可以确保每条消息能够正确分发给对应的 Handler 。</li>\n</ol>\n<h4 id=\"消息传递基本示例\"><a href=\"#消息传递基本示例\" class=\"headerlink\" title=\"消息传递基本示例\"></a>消息传递基本示例</h4><pre><code class=\"java\">public class LooperActivity extends Activity {\n\n    LooperThread mLooperThread;\n\n    // 1.声明一个工作线程，扮演消费者线程角色\n    private static class LooperThread extends Thread {\n\n        public Handler mHandler;\n\n        public void run() {\n            // 2.为当前线程关联 Looper，也就是关联了 MessageQueue\n            Looper.prepare();\n            // 3.使用默认构造器，即将 Handler 与当前线程的 Looper 绑定\n            // 也就决定了它只能在 Looper.prepare() 后初始化，否则没有可以绑定的 Looper\n            mHandler = new Handler() {\n                // 4. 工作线程中处理分发下来的消息的回调\n                public void handleMessage(Message msg) {\n                    if(msg.what == 0) {\n                        doLongRunningOperation();\n                    }\n                }\n            };\n            // 5. 开启对消息队列的轮询，对消息进行分发；\n            // 这是个 blocking call，因此此工作线程不会结束\n            Looper.loop();\n        }\n\n        private void doLongRunningOperation() {\n            // Add long running operation here.\n        }\n    }\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_looper);\n        // 6. 开启工作线程，准备处理消息\n        mLooperThread = new LooperThread();\n        mLooperThread.start();\n    }\n\n    public void onClick(View v) {\n        // 7. Handler 初始化完成和点击事件是异步的，因次校验一下 Handler 不为空\n        if (mLooperThread.mHandler != null) {\n            // 8. 初始化一个 Message 对象，what 属性赋值为 0\n            Message msg = mLooperThread.mHandler.obtainMessage(0);\n            // 9. 向消息队列中插入消息\n            mLooperThread.mHandler.sendMessage(msg);\n        }\n    }\n\n    protected void onDestroy() {\n        super.onDestroy();\n        // 10. 结束 loop() 方法的阻塞状态，从而结束后台线程的执行\n        mLooperThread.mHandler.getLooper().quit();\n    }\n}\n</code></pre>\n<h4 id=\"消息传递过程中涉及到的-Classes\"><a href=\"#消息传递过程中涉及到的-Classes\" class=\"headerlink\" title=\"消息传递过程中涉及到的 Classes\"></a>消息传递过程中涉及到的 Classes</h4><h5 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h5><p>消息队列主要由 <code>android.os.MessageQueue</code> 类来实现，其内部实现一个没有绑定关系的单向链表，用于存储一系列待处理的消息。生产者线程插入消息，之后消息会分发到对应的消费者线程去处理。一般来讲，不同的消息是按照时间戳来排序的。也就是说，时间戳值越小，在消息队列中排序顺序就越靠前。但是只有到达当前时间的消息才会被分发；如果还没有到当前时间，则会等到当前时间才会对消息进行分发。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182557.jpg\" alt=\"消息分发的时间点\"></p>\n<p>上图展示了消息队列中按时间排序的消息是如何向下分发的，其中 t1 &lt; t2 &lt; t3，即 t1 的时间要早于 t3。现在只有一条消息越过了 <code>disptch barrier</code> , 实际上也就是当前时间点。可以被分发下去的消息所绑定的时间戳，一定比当前时间小，也就是已经到了分发的时间。</p>\n<p>如果当前 Looper 获取消息时，消息队列中还没有消息穿越过 <code>dispatch barrier</code> ，此时消费者线程就会阻塞，直到有消息越过 <code>dispatch barrier</code> 。而生产者线程可以在任何时间、任意位置插入消息，因为消息列表的排列只和消息发送的时间有关系，如果需要插入一条立即发送的消息，则即使消息队列中有一百条待发送的消息，但它们都是一分钟后才发送，那刚插入的这条消息也会在链表的首位，也就是下一个被分发的消息。</p>\n<h5 id=\"MessageQueue-IdleHandler\"><a href=\"#MessageQueue-IdleHandler\" class=\"headerlink\" title=\"MessageQueue.IdleHandler\"></a>MessageQueue.IdleHandler</h5><p>正常来讲，如果 Looper 获取不到应分发的消息时，线程就会阻塞等待；但是除了干等以外，还可以将这段时间利用起来，用来执行一些其他的任务。而这个任务则由 <code>android.os.MessageQueue.IdleHandler</code> 来完成。</p>\n<pre><code class=\"java\">/**\n * 当线程等待新消息，即将进入阻塞（闲置）状态时的回调接口\n */\npublic static interface IdleHandler {  \n    boolean queueIdle();\n}\n\n// 具体使用：\n// 获取当前线程的消息队列\nMessageQueue myQueue = Looper.myQueue();\n// 声明一个 IdleHandler 对象\nMessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() {\n    @Override\n    public boolean queueIdle() {\n        return false;\n    }\n};\n// 与消息队列进行绑定\nmyQueue.addIdleHandler(idleHandler);\n// 与消息队列解除绑定\nmyQueue.removeIdleHandler(idleHandler);\n\n</code></pre>\n<p>当消息队列检测到分发消息的空闲时间时，它会唤醒所有注册到当前消息队列的 IdleHandler 实例，并调用他们的 <code>queueIdle</code> 方法，而具体的回调由应用自身来进行实现。</p>\n<p> <code>queueIdle</code> 方法返回值为布尔类型：</p>\n<ul>\n<li><p>true</p>\n<p>当前 IdleHandler 实例保持存活，下次再有 time slots 时，MessageQueue 还会唤醒该实例</p>\n</li>\n<li><p>false</p>\n<p>当前 IdleHandler 实例不再存活，处理完消息后就会主动调用 MessageQueue.removeIdleHandler() 将该实例与 MessageQueue 解绑</p>\n</li>\n</ul>\n<h5 id=\"使用-IdleHandler-来终止闲置线程的运行\"><a href=\"#使用-IdleHandler-来终止闲置线程的运行\" class=\"headerlink\" title=\"使用 IdleHandler 来终止闲置线程的运行\"></a>使用 IdleHandler 来终止闲置线程的运行</h5><p>假定现在有多个生产者线程要连续不断的向消费者线程发送消息，那就可以在消费者线程将所有任务的处理完以偶胡，使用 IdleHandler 来终止线程的执行，从而保证该线程对象不会在内存中游荡。</p>\n<p>在这种情况下使用 IdleHandler ，就不用追踪最后一条插入队列的消息，以期得到回收该线程的确切时间。</p>\n<p>不过这种场景只适用于生产者线程连续不断地向消费者线程插入消息，从而保证在处理完所有消息之前，消费者线程都没有 time slots.</p>\n<pre><code class=\"java\">public class ConsumeAndQuitThreadActivity extends Activity {\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ConsumeAndQuitThread consumeAndQuitThread = new ConsumeAndQuitThread();\n        consumeAndQuitThread.start();\n        for (int i = 0; i &lt; 10; i++) {\n            // 由多个线程并发向消费者线程发送消息，随机模拟发送的时间\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0; i &lt; 10; i++) {\n                        SystemClock.sleep(new Random().nextInt(10));\n                        consumeAndQuitThread.enqueueData(i);\n                    }\n                }\n            }).start();\n        }\n    }\n\n    /**\n     * 此线程为绑定了 Looper 对象的消费者线程，接收生产者线程的消息并进行处理；\n     * 处理完消息后，会终止 Looper.loop() 方法，结束线程的执行\n     */\n    private static class ConsumeAndQuitThread extends Thread implements MessageQueue.IdleHandler {\n\n        private static final String THREAD_NAME = &quot;ConsumeAndQuitThread&quot;;\n\n        public Handler mConsumerHandler;\n        private boolean mIsFirstIdle = true;\n\n        public ConsumeAndQuitThread() {\n            super(THREAD_NAME);\n        }\n\n        @Override\n        public void run() {\n            Looper.prepare();\n\n            mConsumerHandler = new Handler() {\n                @Override\n                public void handleMessage(Message msg) {\n                    // Consume data\n                }\n            };\n            // 1. 为当前线程初始化 Looper，并为该线程的消息队列绑定 IdleHandler 对象\n            Looper.myQueue().addIdleHandler(this);\n            Looper.loop();\n        }\n\n\n        @Override\n        public boolean queueIdle() {\n            // 2. 第一次 queueIdle() 的调用会发生在接收消息之前\n            // 因此需要让首次调用返回 true，从而保证此对象仍然与消息队列绑定\n            if (mIsFirstIdle) { \n                mIsFirstIdle = false;\n                return true;\n            }\n            // 3. 结束消费者线程的执行\n            mConsumerHandler.getLooper().quit();\n            return false;\n        }\n\n        public void enqueueData(int i) {\n            mConsumerHandler.sendEmptyMessage(i);\n        }\n    }\n}\n</code></pre>\n<h5 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h5><p>Message 是一个容器类，可以承载各种类型的数据或者一个 Runnable 对象，但是不能同时携带二者。所携带的数据会在消费者线程被处理，但任务则会在消息分发时直接得到执行，而不需要调用者做其他额外的工作。</p>\n<p>正常来讲，Message 的插入由 Handler 来完成，因为它在插入消息时有更多的选择，更加灵活；但是实际上每条消息对象都知道自己对应的处理器是谁，也就是知道自己对应的 Handler 对象，所以一条消息可以自己实现入队操作。</p>\n<pre><code class=\"java\">// 通过 obtain() 传递一个 Handler 对象进去，赋值给 Message.target 属性\nMessage m = Message.obtain(handler, runnbale);\nm.sendToTarget();\n\npublic void sendToTarget() {\n    // target 是 Handler 对象，此方法会调用 Handler 的 sendMessage 方法\n    target.sendMessage(this);\n}\n</code></pre>\n<p>如之前所说，Message 可以携带数据或者任务，具体如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182601.jpg\" alt=\"\"></p>\n<p>消息队列可以包含任何数据和任务消息的组合，消费者线程具体在处理消息的时候，也仅仅是按照消息的排序顺序，而不和消息的类型有任何关系。如果消息携带的是数据，那消费者线程就会在 handleMessage 中处理数据；如果消息携带的是任务，则该 Runnable 的 run 方法则会在消费者线程得到执行，但是不会再触发 handleMessage 方法的回调。</p>\n<p>Message 的生命周期大概可以分为四个方面：初始化，等待，分发，回收。需要注意的是，系统并没有对消息的状态进行监听，尽管这在技术上也是可行的，所以应用在处理消息不该对该消息的当前状态做出任何假设。</p>\n<ul>\n<li><p>Initialized</p>\n<p>在初始化状态下，应用程序可以使用以下方法来创建 Message 对象：</p>\n<ul>\n<li><p>使用构造器初始化</p>\n<pre><code class=\"java\">Message m = new Message();\n</code></pre>\n</li>\n<li><p>工厂方法</p>\n<ul>\n<li><p>空消息</p>\n<pre><code class=\"java\">Message m = Message.obtain();\n</code></pre>\n</li>\n<li><p>数据消息</p>\n<pre><code class=\"java\">Message m = Message.obtain(Handler h);\nMessage m = Message.obtain(Handler h, int what);\nMessage m = Message.obtain(Handler h, int what, Object o);\nMessage m = Message.obtain(Handler h, int what, int arg1, int arg2); \nMessage m = Message.obtain(Handler h, int what, int arg1, int arg2, Object o);\n</code></pre>\n</li>\n<li><p>任务消息</p>\n<pre><code class=\"java\">Message m = Message.obtain(Handler h, Runnable task);\n</code></pre>\n</li>\n<li><p>复制构造器</p>\n<pre><code class=\"java\">Message m = Message.obtain(Message originalMsg);\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Pending</p>\n<p>消息已经被插入消息队列中，但还没到发送时间，正在等待分发</p>\n</li>\n<li><p>Disptached</p>\n<p>在这个阶段，Looper 已经从消息队列中取出了消息，消息队列也将其移除。Looper 在 loop 方法中，会通过访问 Message.target 属性，来获取到该消息对应的 Handler ，然后将消息发送到对应的回调中进行处理。</p>\n</li>\n<li><p>Recycled</p>\n<p>在这个阶段，Message 的状态被清除，该实例也回到了消息池中等待复用。在消费者线程完成数据处理后，Looper 负责 Message 的回收工作。这个回收过程由虚拟机来完成，而不应该由应用程序来主动处理。</p>\n<blockquote>\n<p>需要注意的是，一旦消息入队后，其携带的数据就不应该再被更改。理论上来讲，在消息被分发之前，对数据做出的更改都是有效的。但由于 Handler 机制在设计之初就没有对 Message 的处理状态进行监听，因此调用者正在对数据进行更改时，消费者线程正在处理数据，从而导致线程安全的问题。而如果该消息对象已经被回收了，问题则会更加严重，因为该对象回到消息池后，会在之后被应用程序所复用，有可能会携带之前的数据到新的消息队列中。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h5><p><code>android.os.Looper</code> 复杂将队列中的消息分发给对应的 Handler 去处理。所有越过分发栅栏的消息都可以被 Looper 所分发。所有待分发的消息一定是越过分发栅栏的，当没有消息待分发时，消费线程则会阻塞，直至有消息等待处理。</p>\n<p>消费线程并不直接与消息队列发生关系，而是通过 Looper 作为中间者来协调消息的分发与处理：消费电车绑定 Looper，而 Looper 会绑定一个 MessageQueue。默认只有 UI 线程自带 Looper ，其他子线程需要调用者显式声明 Looper 。</p>\n<pre><code class=\"java\">new Thread() {\n    @Override\n    public void run() {\n        // prepare() 方法会初始化一个消息队列，并将其与当前线程绑定\n        // 在此时，该消息队列已经可以插入消息，但是无法分发到消费线程处理\n        Looper.prepare();\n\n        // ... ...\n\n        // 此方法为一个 blocking call，确保 run() 方法不会结束执行\n        // 当 run() 方法阻塞的时候，Looper 可以循环消息队列，然后向消费线程分发消息\n        Looper.loop();\n    }\n}.start();\n</code></pre>\n<p>一个线程只能绑定一个 Looper，而 Looper 会绑定一个 MessageQueue，也就是说一个线程只能有一个消息队列；这也就保证了无论多少工作线程向主线程发送消息，主线程也只能按照一定顺序来处理消息。因此，当前执行的消息处理时间的长短会影响到之后的消息，我们在实际使用时，应该规避处理耗时过长的消息。</p>\n<h5 id=\"Looper-的终止\"><a href=\"#Looper-的终止\" class=\"headerlink\" title=\"Looper 的终止\"></a>Looper 的终止</h5><ul>\n<li><p>quit()</p>\n<p>丢弃消息队列中所有未分发的消息，不管其有没有越过分发栅栏</p>\n</li>\n<li><p>quitSafely()</p>\n<p>丢弃还没越过分发栅栏的消息，Looper 会等到已经处于待分发状态的消息正确分发后再结束</p>\n</li>\n</ul>\n<p>终止 Looper 并不会终止线程的执行，它只是将 loop() 方法结束了；但需要注意的是，终止 Looper 后此线程将不再是 Looper 线程，既不能重新绑定新的 Looper ，也无法唤醒已经终止的 Looper。调用 Looper.prepare() 会抛异常，提示已经绑定；重新调用 Looper.loop() 会进入阻塞状态，但是消息队列中的消息不会再得到分发。</p>\n<h5 id=\"UI-线程的-Looper\"><a href=\"#UI-线程的-Looper\" class=\"headerlink\" title=\"UI 线程的 Looper\"></a>UI 线程的 Looper</h5><p>UI 线程是唯一一个自带 Looper 的线程，其与其他线程有以下几点不同：</p>\n<ul>\n<li>在程序任何位置都可以通过调用 Looper.getMainLooper() 来获取 UI Looper</li>\n<li>UI 线程的 Looper 不能被终止</li>\n<li>Java 虚拟机通过 Looper.prepareMainLooper() 为 UI 线程初始化 Looper，此动作只能执行一次，因此尝试将 main looper 与其他子线程关联会抛异常。</li>\n</ul>\n<h5 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h5><p>Android 系统中使用 <code>android.os.Handler</code> 来协调工作线程与 UI 线程的调度，消息的插入和处理都由它来完成，具体工作包括以下几点：</p>\n<ul>\n<li>消息的创建</li>\n<li>插入消息</li>\n<li>在消费线程中处理消息</li>\n<li>管理消息队列中的消息</li>\n</ul>\n<p>Handler 的工作需要 Looper 和 MQ 的支持，因此 Handler 在声明时就应该绑定 Looper 对象：</p>\n<ol>\n<li><p>构造器中不接收 Looper 的，该 Handler 与当前线程绑定</p>\n<pre><code class=\"java\">// 这种与当前线程绑定的，如果当前不是 Looper 线程，就会抛出异常\nnew Handler();\nnew Handler(Handler.Callback);\n</code></pre>\n</li>\n<li><p>构造器明确需要传入 Looper 对象的</p>\n<pre><code class=\"java\">new Handler(Looper);\nnew Handler(Looper, Handler.Callback);\n</code></pre>\n</li>\n</ol>\n<p>一个线程可以有多个 Handler ，不同 Handler 发送的消息可以在消息队列中共存，并不会有什么冲突；具体在分发的时候又会通过 Message 的 target 属性发送回该消息对应的 Handler：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182554.jpg\" alt=\"\"></p>\n<blockquote>\n<p>多个 Handler 发出的消息也不会导致并发，Message 的处理仍然是按顺序执行的。</p>\n</blockquote>\n<h5 id=\"Message-creation\"><a href=\"#Message-creation\" class=\"headerlink\" title=\"Message creation\"></a>Message creation</h5><p>Handler 可以通过以下几个包装方法直接获取 Message 对象，而这些对象则会和 Handler 发生绑定关系：</p>\n<pre><code class=\"java\">// 这些方法内部都会调用 Message.obtain() 方法，并将 Handler 传入，从而产生绑定关系\nMessage obtainMessage(int what, int arg1, int arg2)\nMessage obtainMessage()\nMessage obtainMessage(int what, int arg1, int arg2, Object obj) \nMessage obtainMessage(int what)\nMessage obtainMessage(int what, Object obj)\n</code></pre>\n<h5 id=\"Message-insertion\"><a href=\"#Message-insertion\" class=\"headerlink\" title=\"Message insertion\"></a>Message insertion</h5><p>根据消息类型的不同，Handler 插入消息的方式也略有差别。</p>\n<pre><code class=\"java\">// 携带任务的消息，使用 postXxx() 方法\nboolean post(Runnable r)\nboolean postAtFrontOfQueue(Runnable r)\nboolean postAtTime(Runnable r, Object token, long uptimeMillis) \nboolean postAtTime(Runnable r, long uptimeMillis)\nboolean postDelayed(Runnable r, long delayMillis)\n\n// 携带数据的消息或者空消息，使用 sendXxx() 方法\n// 默认，立即分发\nboolean sendMessage(Message msg) \n// 下一个分发\nboolean sendMessageAtFrontOfQueue(Message msg)\n// 指定某个确切的时间进行分发\nboolean sendMessageAtTime(Message msg, long uptimeMillis) \nboolean sendMessageDelayed(Message msg, long delayMillis)\nboolean sendEmptyMessage(int what)\nboolean sendEmptyMessageAtTime(int what, long uptimeMillis) \nboolean sendEmptyMessageDelayed(int what, long delayMillis)\n</code></pre>\n<p>每条消息都有会有一个 when 属性，用来记录当前消息应该何时被分发；该属性也是唯一一个会影响分发顺序的因素。需要注意的是，尽管我们可以指定确定的时机分发，但是由于之前消息的处理也会影响到后一条消息的分发，因此这个时间还是不确定的。</p>\n<p>向消息队列中插入消息时，有可能导致某些错误的产生：</p>\n<ul>\n<li><p>Message has no Handler</p>\n<p>Message was created from a Message.obtain() method without a specified Handler.</p>\n</li>\n<li><p>Message has already been disptached and is being processed</p>\n<p>The same message instance was inserted twice.</p>\n</li>\n<li><p>Looper has exited</p>\n<p>Message is inserted after Looper.quit() has been called.</p>\n</li>\n</ul>\n<blockquote>\n<p>Looper 在分发消息时，会调用 Handler 的 dispatchMessage 方法。如果此方法被应用程序主动调用，那该消息会在发起调用的线程立即得到执行，而不是在消费线程执行。</p>\n</blockquote>\n<h5 id=\"Message-processing\"><a href=\"#Message-processing\" class=\"headerlink\" title=\"Message processing\"></a>Message processing</h5><p>Message 根据携带数据类型的不同，有不同的处理方式：</p>\n<ul>\n<li><p>Task messages</p>\n<p>如果携带的是 Runnbale 对象，那等轮到该条消息分发的时候，则该 Runnable 对象的 run 方法会直接得到执行，而不会再触发 <code>Handler.handMessage()</code> 方法。</p>\n</li>\n<li><p>Data messages</p>\n<p>如果消息携带的是数据的话，那处理消息则需要重写 <code>Handler.handMessage()</code> 方法（两种方式）。</p>\n</li>\n</ul>\n<p>一种是正常的实现自己的 Handler ，然后重写该方法；或者在初始化 Handler 的时候直接重写该方法，但需要注意的是，如果在子线程中，该方法的重写要在消息队列就绪以后立刻声明，否则 loop() 循环开启后，就无法再声明了：</p>\n<pre><code class=\"java\">class ConsumerThread extends Thread{\n    Handler mHandler;\n    @Override\n    public void run(){\n        Looper.prepare();\n        mHandler = new Handler(){\n            public void handleMessage(Message msg){\n                // process data message here\n            }\n        };\n        Looper.loop();\n    }\n}\n</code></pre>\n<p>另一种方式是利用 <code>Handler.Callback</code> 接口，该接口方法为一个带布尔类型返回值的 <code>handleMessage</code> 方法：</p>\n<pre><code class=\"java\">public interface Callback {\n    // true: 代表实现类处理完消息即终止\n    // false: 代表实现类处理完以后，还要继续下发到 Handler.handleMessage 方法\n    public boolean handleMessage(Message msg);\n}\n\n// 消息分发\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            // 如果返回 true ，则不会继续向下分发了\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }    \n}\n</code></pre>\n<p>使用这种方式，调用者不再需要继承自 Handler ，而只需要将 Callback 接口的实现类当做 Handler 构造器传入即可，然后该 Handler 就会回调到 handleMessage()：</p>\n<pre><code class=\"java\">public class HandlerCallbackActivity extends Activity implements Handler.Callback {\n    Handler mUiHandler;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState){\n        super.onCreate(savedInstanceState);\n        mUiHandler = new Handler(this); // 直接通过构造器传入，即可通过此类处理消息\n    }\n\n    @Override\n    public boolean handleMessage(Message msg){\n        // process msg\n        return true;\n    }\n}\n</code></pre>\n<h4 id=\"与-UI-线程通信\"><a href=\"#与-UI-线程通信\" class=\"headerlink\" title=\"与 UI 线程通信\"></a>与 UI 线程通信</h4><p>正如之前所说，UI 线程是唯一一个自带 Looper 的线程，其他线程可以向 UI 线程发送消息，但要注意避免耗时操作，因为 UI 线程是全局的，每个任务的时长都会对全局任务的执行产生影响。</p>\n<p>有以下几种方式将消息转交到 UI 线程处理：</p>\n<ol>\n<li><p>为 Handler 指定 UI 线程的 Looper</p>\n<pre><code class=\"java\">Runnable task = new Runnable(){...};\nnew Handler(Looper.getMainLooper()).post(task);\n</code></pre>\n<p>使用这种方式，不管调用线程，task 都会通过 UI Looper 直接插入 UI MessageQueue。</p>\n</li>\n<li><p>直接在 UI 线程向自身发送消息，该任务会在当前正在执行的消息处理完后得到执行</p>\n<pre><code class=\"java\">private void postFromUiThreadToUiThread(){\n    new Handler().post(new Runnable(){...})\n}\n</code></pre>\n</li>\n<li><p>Activity.runOnUiThread</p>\n<pre><code class=\"java\">private void postFromUiThreadToUiThread(){\n    runOnUiThread(new Runnable(){...})\n}\n</code></pre>\n<p>如果此方法在其他线程调用，则它会将消息插入到 UI 线程的消息队列中。此方法只能由 Activity 的实例来调用，但是也可以实现自己的 runOnUIThread 方法，只要追踪 UI 线程的 ID 即可：</p>\n<pre><code class=\"java\">public class MyApplication extends Application{\n    private long mUiThreadId;\n    private Handler mUiHandler;\n\n    @Override\n    public void onCreate(){\n        super.onCreate();\n        mUiThread = Thread.currentThread().getId();\n        mUiHandler = new Handler();\n    }\n\n    public void customRunOnUiThread(Runnable action){\n        if(Thread.currentThread().getId() != mUiThreadId){\n            mUiHandler.post(action);\n        } else{\n            action.run();\n        }\n    }\n}\n</code></pre>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Efficient.Android.Threading 第四章读书笔记 下篇</p>\n</blockquote>","more":"<h3 id=\"Android-消息机制\"><a href=\"#Android-消息机制\" class=\"headerlink\" title=\"Android 消息机制\"></a>Android 消息机制</h3><p>迄今为止，我们介绍的线程通信都是 Java 层面的，管道、共享内存、阻塞队列等等，都是所有 Java 应用都有的机制。然而，因为阻塞线程特性的存在，这些机制对于 Android 系统都不适用，因为 UI 线程绝不允许阻塞。</p>\n<p>因此，Android 系统为了协同 UI 线程和工作线程，定义了一套系统级别的消息机制。Android 消息机制是一个没有阻塞状态的生产者-消费者模式，UI 线程可以将耗时操作转移给工作线程在后台处理，同时生产者线程与消费者线程都不会发生阻塞。</p>\n<p>Android 平台的消息机制相关的 API 从属于 <code>android.os</code> 包：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182551.jpg\" alt=\"Android Message API\"></p>\n<p><code>android.os.Looper</code></p>\n<p>唯一关联某个消费者线程的消息调度器</p>\n<p><code>android.os.Handler</code></p>\n<p>消费者线程的消息处理器，同时生产者线程也使用该对象将消息插入队列。一个 Looper 对象可以绑定多个 Handler 对象，但是所有的消息都是插入同一个消息队列的。</p>\n<p><code>android.os.MessageQueue</code></p>\n<p>消费者线程中待处理消息的链表，但是不同的消息之间并没有绑定关系。每个 Looper 对象最多只能有一个消息队列；由于每个线程只能有一个 Looper 对象，也就是说每个线程最多只能有一个消息队列。</p>\n<p>名叫 MessageQueue, 实际上是一个 LinkedList</p>\n<p><code>android.os.Message</code></p>\n<p>消费者线程中待执行的消息</p>\n<p>消息机制的工作原理大抵如下图示意：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182556.jpg\" alt=\"消息机制示意\"></p>\n<p>生产者线程发送消息，消费者线程处理消息：</p>\n<ol>\n<li>插入：生产者线程使用与消费者线程相绑定的 Handler 对象，将消息插入消息队列</li>\n<li>取出：Looper 运行在消费者线程中，按一定的顺序取出消息队列中的消息</li>\n<li>分发：Handler 负责在消费者线程中处理消息；某个线程可以有多个 Handler 对象，Looper 可以确保每条消息能够正确分发给对应的 Handler 。</li>\n</ol>\n<h4 id=\"消息传递基本示例\"><a href=\"#消息传递基本示例\" class=\"headerlink\" title=\"消息传递基本示例\"></a>消息传递基本示例</h4><pre><code class=\"java\">public class LooperActivity extends Activity {\n\n    LooperThread mLooperThread;\n\n    // 1.声明一个工作线程，扮演消费者线程角色\n    private static class LooperThread extends Thread {\n\n        public Handler mHandler;\n\n        public void run() {\n            // 2.为当前线程关联 Looper，也就是关联了 MessageQueue\n            Looper.prepare();\n            // 3.使用默认构造器，即将 Handler 与当前线程的 Looper 绑定\n            // 也就决定了它只能在 Looper.prepare() 后初始化，否则没有可以绑定的 Looper\n            mHandler = new Handler() {\n                // 4. 工作线程中处理分发下来的消息的回调\n                public void handleMessage(Message msg) {\n                    if(msg.what == 0) {\n                        doLongRunningOperation();\n                    }\n                }\n            };\n            // 5. 开启对消息队列的轮询，对消息进行分发；\n            // 这是个 blocking call，因此此工作线程不会结束\n            Looper.loop();\n        }\n\n        private void doLongRunningOperation() {\n            // Add long running operation here.\n        }\n    }\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_looper);\n        // 6. 开启工作线程，准备处理消息\n        mLooperThread = new LooperThread();\n        mLooperThread.start();\n    }\n\n    public void onClick(View v) {\n        // 7. Handler 初始化完成和点击事件是异步的，因次校验一下 Handler 不为空\n        if (mLooperThread.mHandler != null) {\n            // 8. 初始化一个 Message 对象，what 属性赋值为 0\n            Message msg = mLooperThread.mHandler.obtainMessage(0);\n            // 9. 向消息队列中插入消息\n            mLooperThread.mHandler.sendMessage(msg);\n        }\n    }\n\n    protected void onDestroy() {\n        super.onDestroy();\n        // 10. 结束 loop() 方法的阻塞状态，从而结束后台线程的执行\n        mLooperThread.mHandler.getLooper().quit();\n    }\n}\n</code></pre>\n<h4 id=\"消息传递过程中涉及到的-Classes\"><a href=\"#消息传递过程中涉及到的-Classes\" class=\"headerlink\" title=\"消息传递过程中涉及到的 Classes\"></a>消息传递过程中涉及到的 Classes</h4><h5 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h5><p>消息队列主要由 <code>android.os.MessageQueue</code> 类来实现，其内部实现一个没有绑定关系的单向链表，用于存储一系列待处理的消息。生产者线程插入消息，之后消息会分发到对应的消费者线程去处理。一般来讲，不同的消息是按照时间戳来排序的。也就是说，时间戳值越小，在消息队列中排序顺序就越靠前。但是只有到达当前时间的消息才会被分发；如果还没有到当前时间，则会等到当前时间才会对消息进行分发。</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182557.jpg\" alt=\"消息分发的时间点\"></p>\n<p>上图展示了消息队列中按时间排序的消息是如何向下分发的，其中 t1 &lt; t2 &lt; t3，即 t1 的时间要早于 t3。现在只有一条消息越过了 <code>disptch barrier</code> , 实际上也就是当前时间点。可以被分发下去的消息所绑定的时间戳，一定比当前时间小，也就是已经到了分发的时间。</p>\n<p>如果当前 Looper 获取消息时，消息队列中还没有消息穿越过 <code>dispatch barrier</code> ，此时消费者线程就会阻塞，直到有消息越过 <code>dispatch barrier</code> 。而生产者线程可以在任何时间、任意位置插入消息，因为消息列表的排列只和消息发送的时间有关系，如果需要插入一条立即发送的消息，则即使消息队列中有一百条待发送的消息，但它们都是一分钟后才发送，那刚插入的这条消息也会在链表的首位，也就是下一个被分发的消息。</p>\n<h5 id=\"MessageQueue-IdleHandler\"><a href=\"#MessageQueue-IdleHandler\" class=\"headerlink\" title=\"MessageQueue.IdleHandler\"></a>MessageQueue.IdleHandler</h5><p>正常来讲，如果 Looper 获取不到应分发的消息时，线程就会阻塞等待；但是除了干等以外，还可以将这段时间利用起来，用来执行一些其他的任务。而这个任务则由 <code>android.os.MessageQueue.IdleHandler</code> 来完成。</p>\n<pre><code class=\"java\">/**\n * 当线程等待新消息，即将进入阻塞（闲置）状态时的回调接口\n */\npublic static interface IdleHandler {  \n    boolean queueIdle();\n}\n\n// 具体使用：\n// 获取当前线程的消息队列\nMessageQueue myQueue = Looper.myQueue();\n// 声明一个 IdleHandler 对象\nMessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() {\n    @Override\n    public boolean queueIdle() {\n        return false;\n    }\n};\n// 与消息队列进行绑定\nmyQueue.addIdleHandler(idleHandler);\n// 与消息队列解除绑定\nmyQueue.removeIdleHandler(idleHandler);\n\n</code></pre>\n<p>当消息队列检测到分发消息的空闲时间时，它会唤醒所有注册到当前消息队列的 IdleHandler 实例，并调用他们的 <code>queueIdle</code> 方法，而具体的回调由应用自身来进行实现。</p>\n<p> <code>queueIdle</code> 方法返回值为布尔类型：</p>\n<ul>\n<li><p>true</p>\n<p>当前 IdleHandler 实例保持存活，下次再有 time slots 时，MessageQueue 还会唤醒该实例</p>\n</li>\n<li><p>false</p>\n<p>当前 IdleHandler 实例不再存活，处理完消息后就会主动调用 MessageQueue.removeIdleHandler() 将该实例与 MessageQueue 解绑</p>\n</li>\n</ul>\n<h5 id=\"使用-IdleHandler-来终止闲置线程的运行\"><a href=\"#使用-IdleHandler-来终止闲置线程的运行\" class=\"headerlink\" title=\"使用 IdleHandler 来终止闲置线程的运行\"></a>使用 IdleHandler 来终止闲置线程的运行</h5><p>假定现在有多个生产者线程要连续不断的向消费者线程发送消息，那就可以在消费者线程将所有任务的处理完以偶胡，使用 IdleHandler 来终止线程的执行，从而保证该线程对象不会在内存中游荡。</p>\n<p>在这种情况下使用 IdleHandler ，就不用追踪最后一条插入队列的消息，以期得到回收该线程的确切时间。</p>\n<p>不过这种场景只适用于生产者线程连续不断地向消费者线程插入消息，从而保证在处理完所有消息之前，消费者线程都没有 time slots.</p>\n<pre><code class=\"java\">public class ConsumeAndQuitThreadActivity extends Activity {\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ConsumeAndQuitThread consumeAndQuitThread = new ConsumeAndQuitThread();\n        consumeAndQuitThread.start();\n        for (int i = 0; i &lt; 10; i++) {\n            // 由多个线程并发向消费者线程发送消息，随机模拟发送的时间\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0; i &lt; 10; i++) {\n                        SystemClock.sleep(new Random().nextInt(10));\n                        consumeAndQuitThread.enqueueData(i);\n                    }\n                }\n            }).start();\n        }\n    }\n\n    /**\n     * 此线程为绑定了 Looper 对象的消费者线程，接收生产者线程的消息并进行处理；\n     * 处理完消息后，会终止 Looper.loop() 方法，结束线程的执行\n     */\n    private static class ConsumeAndQuitThread extends Thread implements MessageQueue.IdleHandler {\n\n        private static final String THREAD_NAME = &quot;ConsumeAndQuitThread&quot;;\n\n        public Handler mConsumerHandler;\n        private boolean mIsFirstIdle = true;\n\n        public ConsumeAndQuitThread() {\n            super(THREAD_NAME);\n        }\n\n        @Override\n        public void run() {\n            Looper.prepare();\n\n            mConsumerHandler = new Handler() {\n                @Override\n                public void handleMessage(Message msg) {\n                    // Consume data\n                }\n            };\n            // 1. 为当前线程初始化 Looper，并为该线程的消息队列绑定 IdleHandler 对象\n            Looper.myQueue().addIdleHandler(this);\n            Looper.loop();\n        }\n\n\n        @Override\n        public boolean queueIdle() {\n            // 2. 第一次 queueIdle() 的调用会发生在接收消息之前\n            // 因此需要让首次调用返回 true，从而保证此对象仍然与消息队列绑定\n            if (mIsFirstIdle) { \n                mIsFirstIdle = false;\n                return true;\n            }\n            // 3. 结束消费者线程的执行\n            mConsumerHandler.getLooper().quit();\n            return false;\n        }\n\n        public void enqueueData(int i) {\n            mConsumerHandler.sendEmptyMessage(i);\n        }\n    }\n}\n</code></pre>\n<h5 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h5><p>Message 是一个容器类，可以承载各种类型的数据或者一个 Runnable 对象，但是不能同时携带二者。所携带的数据会在消费者线程被处理，但任务则会在消息分发时直接得到执行，而不需要调用者做其他额外的工作。</p>\n<p>正常来讲，Message 的插入由 Handler 来完成，因为它在插入消息时有更多的选择，更加灵活；但是实际上每条消息对象都知道自己对应的处理器是谁，也就是知道自己对应的 Handler 对象，所以一条消息可以自己实现入队操作。</p>\n<pre><code class=\"java\">// 通过 obtain() 传递一个 Handler 对象进去，赋值给 Message.target 属性\nMessage m = Message.obtain(handler, runnbale);\nm.sendToTarget();\n\npublic void sendToTarget() {\n    // target 是 Handler 对象，此方法会调用 Handler 的 sendMessage 方法\n    target.sendMessage(this);\n}\n</code></pre>\n<p>如之前所说，Message 可以携带数据或者任务，具体如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182601.jpg\" alt=\"\"></p>\n<p>消息队列可以包含任何数据和任务消息的组合，消费者线程具体在处理消息的时候，也仅仅是按照消息的排序顺序，而不和消息的类型有任何关系。如果消息携带的是数据，那消费者线程就会在 handleMessage 中处理数据；如果消息携带的是任务，则该 Runnable 的 run 方法则会在消费者线程得到执行，但是不会再触发 handleMessage 方法的回调。</p>\n<p>Message 的生命周期大概可以分为四个方面：初始化，等待，分发，回收。需要注意的是，系统并没有对消息的状态进行监听，尽管这在技术上也是可行的，所以应用在处理消息不该对该消息的当前状态做出任何假设。</p>\n<ul>\n<li><p>Initialized</p>\n<p>在初始化状态下，应用程序可以使用以下方法来创建 Message 对象：</p>\n<ul>\n<li><p>使用构造器初始化</p>\n<pre><code class=\"java\">Message m = new Message();\n</code></pre>\n</li>\n<li><p>工厂方法</p>\n<ul>\n<li><p>空消息</p>\n<pre><code class=\"java\">Message m = Message.obtain();\n</code></pre>\n</li>\n<li><p>数据消息</p>\n<pre><code class=\"java\">Message m = Message.obtain(Handler h);\nMessage m = Message.obtain(Handler h, int what);\nMessage m = Message.obtain(Handler h, int what, Object o);\nMessage m = Message.obtain(Handler h, int what, int arg1, int arg2); \nMessage m = Message.obtain(Handler h, int what, int arg1, int arg2, Object o);\n</code></pre>\n</li>\n<li><p>任务消息</p>\n<pre><code class=\"java\">Message m = Message.obtain(Handler h, Runnable task);\n</code></pre>\n</li>\n<li><p>复制构造器</p>\n<pre><code class=\"java\">Message m = Message.obtain(Message originalMsg);\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Pending</p>\n<p>消息已经被插入消息队列中，但还没到发送时间，正在等待分发</p>\n</li>\n<li><p>Disptached</p>\n<p>在这个阶段，Looper 已经从消息队列中取出了消息，消息队列也将其移除。Looper 在 loop 方法中，会通过访问 Message.target 属性，来获取到该消息对应的 Handler ，然后将消息发送到对应的回调中进行处理。</p>\n</li>\n<li><p>Recycled</p>\n<p>在这个阶段，Message 的状态被清除，该实例也回到了消息池中等待复用。在消费者线程完成数据处理后，Looper 负责 Message 的回收工作。这个回收过程由虚拟机来完成，而不应该由应用程序来主动处理。</p>\n<blockquote>\n<p>需要注意的是，一旦消息入队后，其携带的数据就不应该再被更改。理论上来讲，在消息被分发之前，对数据做出的更改都是有效的。但由于 Handler 机制在设计之初就没有对 Message 的处理状态进行监听，因此调用者正在对数据进行更改时，消费者线程正在处理数据，从而导致线程安全的问题。而如果该消息对象已经被回收了，问题则会更加严重，因为该对象回到消息池后，会在之后被应用程序所复用，有可能会携带之前的数据到新的消息队列中。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h5><p><code>android.os.Looper</code> 复杂将队列中的消息分发给对应的 Handler 去处理。所有越过分发栅栏的消息都可以被 Looper 所分发。所有待分发的消息一定是越过分发栅栏的，当没有消息待分发时，消费线程则会阻塞，直至有消息等待处理。</p>\n<p>消费线程并不直接与消息队列发生关系，而是通过 Looper 作为中间者来协调消息的分发与处理：消费电车绑定 Looper，而 Looper 会绑定一个 MessageQueue。默认只有 UI 线程自带 Looper ，其他子线程需要调用者显式声明 Looper 。</p>\n<pre><code class=\"java\">new Thread() {\n    @Override\n    public void run() {\n        // prepare() 方法会初始化一个消息队列，并将其与当前线程绑定\n        // 在此时，该消息队列已经可以插入消息，但是无法分发到消费线程处理\n        Looper.prepare();\n\n        // ... ...\n\n        // 此方法为一个 blocking call，确保 run() 方法不会结束执行\n        // 当 run() 方法阻塞的时候，Looper 可以循环消息队列，然后向消费线程分发消息\n        Looper.loop();\n    }\n}.start();\n</code></pre>\n<p>一个线程只能绑定一个 Looper，而 Looper 会绑定一个 MessageQueue，也就是说一个线程只能有一个消息队列；这也就保证了无论多少工作线程向主线程发送消息，主线程也只能按照一定顺序来处理消息。因此，当前执行的消息处理时间的长短会影响到之后的消息，我们在实际使用时，应该规避处理耗时过长的消息。</p>\n<h5 id=\"Looper-的终止\"><a href=\"#Looper-的终止\" class=\"headerlink\" title=\"Looper 的终止\"></a>Looper 的终止</h5><ul>\n<li><p>quit()</p>\n<p>丢弃消息队列中所有未分发的消息，不管其有没有越过分发栅栏</p>\n</li>\n<li><p>quitSafely()</p>\n<p>丢弃还没越过分发栅栏的消息，Looper 会等到已经处于待分发状态的消息正确分发后再结束</p>\n</li>\n</ul>\n<p>终止 Looper 并不会终止线程的执行，它只是将 loop() 方法结束了；但需要注意的是，终止 Looper 后此线程将不再是 Looper 线程，既不能重新绑定新的 Looper ，也无法唤醒已经终止的 Looper。调用 Looper.prepare() 会抛异常，提示已经绑定；重新调用 Looper.loop() 会进入阻塞状态，但是消息队列中的消息不会再得到分发。</p>\n<h5 id=\"UI-线程的-Looper\"><a href=\"#UI-线程的-Looper\" class=\"headerlink\" title=\"UI 线程的 Looper\"></a>UI 线程的 Looper</h5><p>UI 线程是唯一一个自带 Looper 的线程，其与其他线程有以下几点不同：</p>\n<ul>\n<li>在程序任何位置都可以通过调用 Looper.getMainLooper() 来获取 UI Looper</li>\n<li>UI 线程的 Looper 不能被终止</li>\n<li>Java 虚拟机通过 Looper.prepareMainLooper() 为 UI 线程初始化 Looper，此动作只能执行一次，因此尝试将 main looper 与其他子线程关联会抛异常。</li>\n</ul>\n<h5 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h5><p>Android 系统中使用 <code>android.os.Handler</code> 来协调工作线程与 UI 线程的调度，消息的插入和处理都由它来完成，具体工作包括以下几点：</p>\n<ul>\n<li>消息的创建</li>\n<li>插入消息</li>\n<li>在消费线程中处理消息</li>\n<li>管理消息队列中的消息</li>\n</ul>\n<p>Handler 的工作需要 Looper 和 MQ 的支持，因此 Handler 在声明时就应该绑定 Looper 对象：</p>\n<ol>\n<li><p>构造器中不接收 Looper 的，该 Handler 与当前线程绑定</p>\n<pre><code class=\"java\">// 这种与当前线程绑定的，如果当前不是 Looper 线程，就会抛出异常\nnew Handler();\nnew Handler(Handler.Callback);\n</code></pre>\n</li>\n<li><p>构造器明确需要传入 Looper 对象的</p>\n<pre><code class=\"java\">new Handler(Looper);\nnew Handler(Looper, Handler.Callback);\n</code></pre>\n</li>\n</ol>\n<p>一个线程可以有多个 Handler ，不同 Handler 发送的消息可以在消息队列中共存，并不会有什么冲突；具体在分发的时候又会通过 Message 的 target 属性发送回该消息对应的 Handler：</p>\n<p><img src=\"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182554.jpg\" alt=\"\"></p>\n<blockquote>\n<p>多个 Handler 发出的消息也不会导致并发，Message 的处理仍然是按顺序执行的。</p>\n</blockquote>\n<h5 id=\"Message-creation\"><a href=\"#Message-creation\" class=\"headerlink\" title=\"Message creation\"></a>Message creation</h5><p>Handler 可以通过以下几个包装方法直接获取 Message 对象，而这些对象则会和 Handler 发生绑定关系：</p>\n<pre><code class=\"java\">// 这些方法内部都会调用 Message.obtain() 方法，并将 Handler 传入，从而产生绑定关系\nMessage obtainMessage(int what, int arg1, int arg2)\nMessage obtainMessage()\nMessage obtainMessage(int what, int arg1, int arg2, Object obj) \nMessage obtainMessage(int what)\nMessage obtainMessage(int what, Object obj)\n</code></pre>\n<h5 id=\"Message-insertion\"><a href=\"#Message-insertion\" class=\"headerlink\" title=\"Message insertion\"></a>Message insertion</h5><p>根据消息类型的不同，Handler 插入消息的方式也略有差别。</p>\n<pre><code class=\"java\">// 携带任务的消息，使用 postXxx() 方法\nboolean post(Runnable r)\nboolean postAtFrontOfQueue(Runnable r)\nboolean postAtTime(Runnable r, Object token, long uptimeMillis) \nboolean postAtTime(Runnable r, long uptimeMillis)\nboolean postDelayed(Runnable r, long delayMillis)\n\n// 携带数据的消息或者空消息，使用 sendXxx() 方法\n// 默认，立即分发\nboolean sendMessage(Message msg) \n// 下一个分发\nboolean sendMessageAtFrontOfQueue(Message msg)\n// 指定某个确切的时间进行分发\nboolean sendMessageAtTime(Message msg, long uptimeMillis) \nboolean sendMessageDelayed(Message msg, long delayMillis)\nboolean sendEmptyMessage(int what)\nboolean sendEmptyMessageAtTime(int what, long uptimeMillis) \nboolean sendEmptyMessageDelayed(int what, long delayMillis)\n</code></pre>\n<p>每条消息都有会有一个 when 属性，用来记录当前消息应该何时被分发；该属性也是唯一一个会影响分发顺序的因素。需要注意的是，尽管我们可以指定确定的时机分发，但是由于之前消息的处理也会影响到后一条消息的分发，因此这个时间还是不确定的。</p>\n<p>向消息队列中插入消息时，有可能导致某些错误的产生：</p>\n<ul>\n<li><p>Message has no Handler</p>\n<p>Message was created from a Message.obtain() method without a specified Handler.</p>\n</li>\n<li><p>Message has already been disptached and is being processed</p>\n<p>The same message instance was inserted twice.</p>\n</li>\n<li><p>Looper has exited</p>\n<p>Message is inserted after Looper.quit() has been called.</p>\n</li>\n</ul>\n<blockquote>\n<p>Looper 在分发消息时，会调用 Handler 的 dispatchMessage 方法。如果此方法被应用程序主动调用，那该消息会在发起调用的线程立即得到执行，而不是在消费线程执行。</p>\n</blockquote>\n<h5 id=\"Message-processing\"><a href=\"#Message-processing\" class=\"headerlink\" title=\"Message processing\"></a>Message processing</h5><p>Message 根据携带数据类型的不同，有不同的处理方式：</p>\n<ul>\n<li><p>Task messages</p>\n<p>如果携带的是 Runnbale 对象，那等轮到该条消息分发的时候，则该 Runnable 对象的 run 方法会直接得到执行，而不会再触发 <code>Handler.handMessage()</code> 方法。</p>\n</li>\n<li><p>Data messages</p>\n<p>如果消息携带的是数据的话，那处理消息则需要重写 <code>Handler.handMessage()</code> 方法（两种方式）。</p>\n</li>\n</ul>\n<p>一种是正常的实现自己的 Handler ，然后重写该方法；或者在初始化 Handler 的时候直接重写该方法，但需要注意的是，如果在子线程中，该方法的重写要在消息队列就绪以后立刻声明，否则 loop() 循环开启后，就无法再声明了：</p>\n<pre><code class=\"java\">class ConsumerThread extends Thread{\n    Handler mHandler;\n    @Override\n    public void run(){\n        Looper.prepare();\n        mHandler = new Handler(){\n            public void handleMessage(Message msg){\n                // process data message here\n            }\n        };\n        Looper.loop();\n    }\n}\n</code></pre>\n<p>另一种方式是利用 <code>Handler.Callback</code> 接口，该接口方法为一个带布尔类型返回值的 <code>handleMessage</code> 方法：</p>\n<pre><code class=\"java\">public interface Callback {\n    // true: 代表实现类处理完消息即终止\n    // false: 代表实现类处理完以后，还要继续下发到 Handler.handleMessage 方法\n    public boolean handleMessage(Message msg);\n}\n\n// 消息分发\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            // 如果返回 true ，则不会继续向下分发了\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }    \n}\n</code></pre>\n<p>使用这种方式，调用者不再需要继承自 Handler ，而只需要将 Callback 接口的实现类当做 Handler 构造器传入即可，然后该 Handler 就会回调到 handleMessage()：</p>\n<pre><code class=\"java\">public class HandlerCallbackActivity extends Activity implements Handler.Callback {\n    Handler mUiHandler;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState){\n        super.onCreate(savedInstanceState);\n        mUiHandler = new Handler(this); // 直接通过构造器传入，即可通过此类处理消息\n    }\n\n    @Override\n    public boolean handleMessage(Message msg){\n        // process msg\n        return true;\n    }\n}\n</code></pre>\n<h4 id=\"与-UI-线程通信\"><a href=\"#与-UI-线程通信\" class=\"headerlink\" title=\"与 UI 线程通信\"></a>与 UI 线程通信</h4><p>正如之前所说，UI 线程是唯一一个自带 Looper 的线程，其他线程可以向 UI 线程发送消息，但要注意避免耗时操作，因为 UI 线程是全局的，每个任务的时长都会对全局任务的执行产生影响。</p>\n<p>有以下几种方式将消息转交到 UI 线程处理：</p>\n<ol>\n<li><p>为 Handler 指定 UI 线程的 Looper</p>\n<pre><code class=\"java\">Runnable task = new Runnable(){...};\nnew Handler(Looper.getMainLooper()).post(task);\n</code></pre>\n<p>使用这种方式，不管调用线程，task 都会通过 UI Looper 直接插入 UI MessageQueue。</p>\n</li>\n<li><p>直接在 UI 线程向自身发送消息，该任务会在当前正在执行的消息处理完后得到执行</p>\n<pre><code class=\"java\">private void postFromUiThreadToUiThread(){\n    new Handler().post(new Runnable(){...})\n}\n</code></pre>\n</li>\n<li><p>Activity.runOnUiThread</p>\n<pre><code class=\"java\">private void postFromUiThreadToUiThread(){\n    runOnUiThread(new Runnable(){...})\n}\n</code></pre>\n<p>如果此方法在其他线程调用，则它会将消息插入到 UI 线程的消息队列中。此方法只能由 Activity 的实例来调用，但是也可以实现自己的 runOnUIThread 方法，只要追踪 UI 线程的 ID 即可：</p>\n<pre><code class=\"java\">public class MyApplication extends Application{\n    private long mUiThreadId;\n    private Handler mUiHandler;\n\n    @Override\n    public void onCreate(){\n        super.onCreate();\n        mUiThread = Thread.currentThread().getId();\n        mUiHandler = new Handler();\n    }\n\n    public void customRunOnUiThread(Runnable action){\n        if(Thread.currentThread().getId() != mUiThreadId){\n            mUiHandler.post(action);\n        } else{\n            action.run();\n        }\n    }\n}\n</code></pre>\n</li>\n</ol>"},{"thumbnail":"https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321185255.png","title":"ViewDragHelper 源码解析","date":"2019-05-12T16:00:00.000Z","_content":"\n[这文章是转来的，写的实在是好，怕哪天失踪了……](https://www.cnblogs.com/lqstayreal/p/4500219.html)\n\n<!-- more -->\n\n\n\n在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，ViewDragHelper的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。\n\n要想完全掌握ViewDragHelper的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾ViewDragHelper的原理、用法、注意事项等。\n\n### 基本用法\n\n1. 在自定义ViewGroup的构造方法里调用ViewDragHelper的静态工厂方法create()创建ViewDragHelper实例\n\n2. 实现ViewDragHelper.Callback\n\n   最重要的几个方法是tryCaptureView()、clampViewPositionVertical()、clampViewPositionHorizontal()、getViewHorizontalDragRange()、getViewVerticalDragRange()\n\n   - tryCaptureView()里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回true，否则返回false。\n   - clampViewPositionVertical()决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。\n   - clampViewPositionHorizontal()与clampViewPositionVertical()同理，只不过是发生在水平方向上，最终返回的是View的left值。\n   - getViewVerticalDragRange()要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。\n   - getViewHorizontalDragRange()与getViewVerticalDragRange()同理，只不过是发生在水平方向上。\n\n3. 在onInterceptTouchEvent()方法里调用并返回ViewDragHelper的shouldInterceptTouchEvent()方法\n\n4. 在onTouchEvent()方法里调用ViewDragHelper()的processTouchEvent()方法。ACTION_DOWN事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在onTouchEvent()返回true，否则将收不到后续事件，不会产生拖动。\n\n5. 上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的computeScroll()方法，方法实现如下：\n\n   ```\n    @Override\n    public void computeScroll() {\n        if (mDragHelper.continueSettling(true)) {\n            postInvalidate();\n        }\n    }\n   ```\n\n   并在ViewDragHelper.Callback的onViewReleased()方法里调用settleCapturedViewAt()、flingCapturedView()，或在任意地方调用smoothSlideViewTo()方法。\n\n6. 如果要实现边缘拖动的效果，需要调用ViewDragHelper的setEdgeTrackingEnabled()方法，注册想要监听的边缘。然后实现ViewDragHelper.Callback里的onEdgeDragStarted()方法，在此手动调用captureChildView()传递要拖动的子View。\n\n具体的使用Demo请见最后面公布的几个案例。\n\n### 源码详解\n\nViewDragHelper的完整源码可在[GitHub](https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java)或[GrepCode](http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper)上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。\n\n#### 预备知识\n\n1. 了解View的坐标系统，[Android View坐标getLeft, getRight, getTop, getBottom](http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html)\n2. 了解MotionEvent中关于多点触控的机制，[android触控,先了解MotionEvent(一)](http://my.oschina.net/banxi/blog/56421)\n3. 了解Scroller类原理，[Android中滑屏实现----手把手教你如何实现触摸滑屏以及Scroller类详解](http://blog.csdn.net/qinjuning/article/details/7419207)\n4. 了解Touch事件的分发机制，[Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制](http://blog.csdn.net/xiaanming/article/details/21696315)\n\n#### ViewDragHelper实例的创建\n\nViewDragHelper重载了两个create()静态方法，先看两个参数的create()方法：\n\n```\n/**\n * Factory method to create a new ViewDragHelper.\n *\n * @param forParent Parent view to monitor\n * @param cb Callback to provide information and receive events\n * @return a new ViewDragHelper instance\n */\npublic static ViewDragHelper create(ViewGroup forParent, Callback cb) {\n    return new ViewDragHelper(forParent.getContext(), forParent, cb);\n}\n```\n\ncreate()的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。create()直接调用了ViewDragHelper构造方法，我们再来看看这个构造方法。\n\n```\n/**\n * Apps should use ViewDragHelper.create() to get a new instance.\n * This will allow VDH to use internal compatibility implementations for different\n * platform versions.\n *\n * @param context Context to initialize config-dependent params from\n * @param forParent Parent view to monitor\n */\nprivate ViewDragHelper(Context context, ViewGroup forParent, Callback cb) {\n    if (forParent == null) {\n        throw new IllegalArgumentException(\"Parent view may not be null\");\n    }\n    if (cb == null) {\n        throw new IllegalArgumentException(\"Callback may not be null\");\n    }\n\n    mParentView = forParent;\n    mCallback = cb;\n\n    final ViewConfiguration vc = ViewConfiguration.get(context);\n    final float density = context.getResources().getDisplayMetrics().density;\n    mEdgeSize = (int) (EDGE_SIZE * density + 0.5f);\n\n    mTouchSlop = vc.getScaledTouchSlop();\n    mMaxVelocity = vc.getScaledMaximumFlingVelocity();\n    mMinVelocity = vc.getScaledMinimumFlingVelocity();\n    mScroller = ScrollerCompat.create(context, sInterpolator);\n}\n```\n\n这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过create()工厂方法来创建ViewDragHelper实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。\n\n- mParentView和mCallback分别保存传递过来的对应参数\n- ViewConfiguration类里定义了View相关的一系列时间、大小、距离等常量\n- mEdgeSize表示边缘触摸的范围。例如mEdgeSize为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于mParentView.getLeft() + mEdgeSize时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见ViewDragHelper的getEdgesTouched()方法。\n- mTouchSlop是一个很小的距离值，只有在前后两次触摸点的距离超过mTouchSlop的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。\n- mMaxVelocity、mMinVelocity是fling时的最大、最小速率，单位是像素每秒。\n- mScroller是View滚动的辅助类，该类的详细解析参见下面几篇文章\n  - [Android中滑屏实现----手把手教你如何实现触摸滑屏以及Scroller类详解](http://blog.csdn.net/qinjuning/article/details/7419207)\n  - [Android中Scroller类的分析](http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html)\n\n再看三个参数的create()方法：\n\n```\n/**\n * Factory method to create a new ViewDragHelper.\n *\n * @param forParent Parent view to monitor\n * @param sensitivity Multiplier for how sensitive the helper should be about detecting\n *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.\n * @param cb Callback to provide information and receive events\n * @return a new ViewDragHelper instance\n */\npublic static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {\n    final ViewDragHelper helper = create(forParent, cb);\n    helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity));\n    return helper;\n}\n```\n\n第二个参数sensitivity是用来调节mTouchSlop的值。sensitivity越大，mTouchSlop越小，对滑动的检测就越敏感。例如sensitivity为1时，前后触摸点距离超过20dp才进行滑动处理，现在sensitivity为2的话，前后触摸点距离超过10dp就进行处理了。\n\n#### 对Touch事件的处理\n\n当mParentView（自定义ViewGroup）被触摸时，首先会调用mParentView的onInterceptTouchEvent(MotionEvent ev)，接着就调用shouldInterceptTouchEvent(MotionEvent ev) ，所以先来看看这个方法的ACTION_DOWN部分：\n\n```\n/**\n * Check if this event as provided to the parent view's onInterceptTouchEvent should\n * cause the parent to intercept the touch event stream.\n *\n * @param ev MotionEvent provided to onInterceptTouchEvent\n * @return true if the parent view should return true from onInterceptTouchEvent\n */\npublic boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    final int action = MotionEventCompat.getActionMasked(ev);\n    final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n    if (action == MotionEvent.ACTION_DOWN) {\n        // Reset things for a new event stream, just in case we didn't get\n        // the whole previous stream.\n        cancel();\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n            saveInitialMotion(x, y, pointerId);\n\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n\n            // Catch a settling view if possible.\n            if (toCapture == mCapturedView && mDragState == STATE_SETTLING) {\n                tryCaptureViewForDrag(toCapture, pointerId);\n            }\n\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched & mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n            }\n            break;\n        }\n\n        // 其他case暂且省略\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n```\n\n看9~21行，首先是关于多点触控（MotionEvent的actionIndex、ACTION_POINTER_DOWN 等概念），不明白的请参阅[android触控,先了解MotionEvent(一)](http://my.oschina.net/banxi/blog/56421)。\n\nmVelocityTracker记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生ACTION_DOWN事件都会调用cancel()，而在cancel()方法里mVelocityTracker又被清空了，所以mVelocityTracker 记录下的是本次ACTION_DOWN事件直至ACTION_UP事件发生后（下次ACTION_DOWN事件发生前）的所有触摸点的信息。\n\n再来看24~42行case MotionEvent.ACTION_DOWN部分，先是调用saveInitialMotion(x, y, pointerId)保存手势的初始信息，即ACTION_DOWN发生时的触摸点坐标（x、y）、触摸手指编号（pointerId），如果触摸到了mParentView的边缘还会记录触摸的是哪个边缘。接着调用findTopChildUnder((int) x, (int) y);来获取当前触摸点下最顶层的子View，看findTopChildUnder 的源码：\n\n```\n/**\n * Find the topmost child under the given point within the parent view's coordinate system.\n * The child order is determined using {@link Callback#getOrderedChildIndex(int)}.\n *\n * @param x X position to test in the parent's coordinate system\n * @param y Y position to test in the parent's coordinate system\n * @return The topmost child view under (x, y) or null if none found.\n */\npublic View findTopChildUnder(int x, int y) {\n    final int childCount = mParentView.getChildCount();\n    for (int i = childCount - 1; i >= 0; i--) {\n        final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));\n        if (x >= child.getLeft() && x < child.getRight() &&\n                y >= child.getTop() && y < child.getBottom()) {\n            return child;\n        }\n    }\n    return null;\n}\n```\n\n代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现Callback里的getOrderedChildIndex(int index)方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（getOrderedChildIndex()默认直接返回index），会选择到topView，要想让bottomView被选中就得这么写：\n\n```\npublic int getOrderedChildIndex(int index) {\n    int indexTop = mParentView.indexOfChild(topView);\n    int indexBottom = mParentView.indexOfChild(bottomView);\n    if (index == indexTop) {\n        return indexBottom;\n    }\n    return index;\n}\n```\n\n32~35行，这里还看到了一个mDragState成员变量，它共有三种取值：\n\n1. STATE_IDLE：所有的View处于静止空闲状态\n2. STATE_DRAGGING：某个View正在被用户拖动（用户正在与设备交互）\n3. STATE_SETTLING：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中\n   mCapturedView默认为null，所以一开始不会执行这里的代码，mDragState处于STATE_SETTLING状态时才会执行tryCaptureViewForDrag()，执行的情况到后面再分析，这里先跳过。\n\n37~40行调用了Callback.onEdgeTouched向外部通知mParentView的某些边缘被触摸到了，mInitialEdgesTouched是在刚才调用过的saveInitialMotion方法里进行赋值的。\n\nACTION_DOWN 部分处理完了，跳过switch语句块，剩下的代码就只有return mDragState == STATE_DRAGGING;。在ACTION_DOWN部分没有对mDragState进行赋值，其默认值为STATE_IDLE，所以此处返回false。\n\n那么返回false后接下来应该是会调用哪个方法呢，根据[Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制](http://blog.csdn.net/xiaanming/article/details/21696315)里的解析，接下来会在mParentView的所有子View中寻找响应这个Touch事件的View（会调用每个子View的dispatchTouchEvent()方法，dispatchTouchEvent里一般又会调用onTouchEvent()）；\n\n- 如果没有子View消费这次事件（子View的dispatchTouchEvent()返回都是false），会调用mParentView的super.dispatchTouchEvent(ev)，即View中的dispatchTouchEvent(ev)，然后调用mParentView的onTouchEvent()方法，再调用ViewDragHelper的processTouchEvent(MotionEvent ev)方法。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动（除了ACTION_DOWN外的其他事件发生时返回true或false都不会影响接下来的事件接受），因为拖动的相关代码是写在processTouchEvent()里的ACTION_MOVE部分的。要注意的是返回true后mParentView的onInterceptTouchEvent()就不会收到后续的ACTION_MOVE、ACTION_UP等事件了。\n- 如果有子View消费了本次ACTION_DOWN事件，mParentView的onTouchEvent()就收不到ACTION_DOWN事件了，也就是ViewDragHelper的processTouchEvent(MotionEvent ev)收不到ACTION_DOWN事件了。不过只要该View没有调用过requestDisallowInterceptTouchEvent(true)，mParentView的onInterceptTouchEvent()的ACTION_MOVE部分还是会执行的，如果在此时返回了true拦截了ACTION_MOVE事件，processTouchEvent()里的ACTION_MOVE部分也就会正常执行，拖动也就没问题了。onInterceptTouchEvent()的ACTION_MOVE部分具体做了怎样的处理，稍后再来解析。\n\n接下来对这两种情况逐一解析。\n\n假设没有子View消费这次事件，根据刚才的分析最终就会调用processTouchEvent(MotionEvent ev)的ACTION_DOWN部分：\n\n```\n/**\n * Process a touch event received by the parent view. This method will dispatch callback events\n * as needed before returning. The parent view's onTouchEvent implementation should call this.\n *\n * @param ev The touch event received by the parent view\n */\npublic void processTouchEvent(MotionEvent ev) {\n    final int action = MotionEventCompat.getActionMasked(ev);\n    final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n    if (action == MotionEvent.ACTION_DOWN) {\n        // Reset things for a new event stream, just in case we didn't get\n        // the whole previous stream.\n        cancel();\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n\n            saveInitialMotion(x, y, pointerId);\n\n            // Since the parent is already directly processing this touch event,\n            // there is no reason to delay for a slop before dragging.\n            // Start immediately if possible.\n            tryCaptureViewForDrag(toCapture, pointerId);\n\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched & mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n            }\n            break;\n        }\n        // 其他case暂且省略\n    }\n}\n```\n\n这段代码跟shouldInterceptTouchEvent()里ACTION_DOWN那部分基本一致，唯一区别就是这里没有约束条件直接调用了tryCaptureViewForDrag()方法，现在来看看这个方法：\n\n```\n/**\n * Attempt to capture the view with the given pointer ID. The callback will be involved.\n * This will put us into the \"dragging\" state. If we've already captured this view with\n * this pointer this method will immediately return true without consulting the callback.\n *\n * @param toCapture View to capture\n * @param pointerId Pointer to capture with\n * @return true if capture was successful\n */\nboolean tryCaptureViewForDrag(View toCapture, int pointerId) {\n    if (toCapture == mCapturedView && mActivePointerId == pointerId) {\n        // Already done!\n        return true;\n    }\n    if (toCapture != null && mCallback.tryCaptureView(toCapture, pointerId)) {\n        mActivePointerId = pointerId;\n        captureChildView(toCapture, pointerId);\n        return true;\n    }\n    return false;\n}\n```\n\n这里调用了Callback的tryCaptureView(View child, int pointerId)方法，把当前触摸到的View和触摸手指编号传递了过去，在tryCaptureView()中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在tryCaptureView()中返回true，让ViewDragHelper把当前触摸的View捕获下来，接着就调用了captureChildView(toCapture, pointerId)方法：\n\n```\n/**\n * Capture a specific child view for dragging within the parent. The callback will be notified\n * but {@link Callback#tryCaptureView(android.view.View, int)} will not be asked permission to\n * capture this view.\n *\n * @param childView Child view to capture\n * @param activePointerId ID of the pointer that is dragging the captured child view\n */\npublic void captureChildView(View childView, int activePointerId) {\n    if (childView.getParent() != mParentView) {\n        throw new IllegalArgumentException(\"captureChildView: parameter must be a descendant \" +\n                \"of the ViewDragHelper's tracked parent view (\" + mParentView + \")\");\n    }\n\n    mCapturedView = childView;\n    mActivePointerId = activePointerId;\n    mCallback.onViewCaptured(childView, activePointerId);\n    setDragState(STATE_DRAGGING);\n}\n```\n\n代码很简单，在captureChildView(toCapture, pointerId)中将要拖动的View和触摸的手指编号记录下来，并调用Callback的onViewCaptured(childView, activePointerId)通知外部有子View被捕获到了，再调用setDragState()设置当前的状态为STATE_DRAGGING，看setDragState()源码：\n\n```\nvoid setDragState(int state) {\n    if (mDragState != state) {\n        mDragState = state;\n        mCallback.onViewDragStateChanged(state);\n        if (mDragState == STATE_IDLE) {\n            mCapturedView = null;\n        }\n    }\n}\n```\n\n状态改变后会调用Callback的onViewDragStateChanged()通知状态的变化。\n\n假设ACTION_DOWN发生后在mParentView的onTouchEvent()返回了true，接下来就会执行ACTION_MOVE部分：\n\n```\npublic void processTouchEvent(MotionEvent ev) {\n\n    switch (action) {\n        // 省略其他case...\n        \n        case MotionEvent.ACTION_MOVE: {\n            if (mDragState == STATE_DRAGGING) {\n                final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, index);\n                final float y = MotionEventCompat.getY(ev, index);\n                final int idx = (int) (x - mLastMotionX[mActivePointerId]);\n                final int idy = (int) (y - mLastMotionY[mActivePointerId]);\n\n                dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);\n\n                saveLastMotion(ev);\n            } else {\n                // Check to see if any pointer is now over a draggable view.\n                final int pointerCount = MotionEventCompat.getPointerCount(ev);\n                for (int i = 0; i < pointerCount; i++) {\n                    final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                    final float x = MotionEventCompat.getX(ev, i);\n                    final float y = MotionEventCompat.getY(ev, i);\n                    final float dx = x - mInitialMotionX[pointerId];\n                    final float dy = y - mInitialMotionY[pointerId];\n\n                    reportNewEdgeDrags(dx, dy, pointerId);\n                    if (mDragState == STATE_DRAGGING) {\n                        // Callback might have started an edge drag.\n                        break;\n                    }\n\n                    final View toCapture = findTopChildUnder((int) x, (int) y);\n                    if (checkTouchSlop(toCapture, dx, dy) &&\n                            tryCaptureViewForDrag(toCapture, pointerId)) {\n                        break;\n                    }\n                }\n                saveLastMotion(ev);\n            }\n            break;\n        }\n\n        // 省略其他case...\n    }\n}\n```\n\n要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断mDragState是否为STATE_DRAGGING，而唯一调用setDragState(STATE_DRAGGING)的地方就是tryCaptureViewForDrag()了，刚才在ACTION_DOWN里调用过tryCaptureViewForDrag()，现在又要分两种情况。\n如果刚才在ACTION_DOWN里捕获到要拖动的View，那么就执行if部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，mDragState依然是STATE_IDLE，然后会执行else部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让mDragState变为STATE_DRAGGING，之后就会执行if部分的代码了。这里还有两个方法涉及到了Callback里的方法，需要来解析一下，分别是reportNewEdgeDrags()和checkTouchSlop()，先看reportNewEdgeDrags()：\n\n```\nprivate void reportNewEdgeDrags(float dx, float dy, int pointerId) {\n    int dragsStarted = 0;\n    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) {\n        dragsStarted |= EDGE_LEFT;\n    }\n    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) {\n        dragsStarted |= EDGE_TOP;\n    }\n    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) {\n        dragsStarted |= EDGE_RIGHT;\n    }\n    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) {\n        dragsStarted |= EDGE_BOTTOM;\n    }\n\n    if (dragsStarted != 0) {\n        mEdgeDragsInProgress[pointerId] |= dragsStarted;\n        mCallback.onEdgeDragStarted(dragsStarted, pointerId);\n    }\n}\n```\n\n这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在mEdgeDragsInProgress中，再调用Callback的onEdgeDragStarted(int edgeFlags, int pointerId)通知某个边缘开始产生拖动了。虽然reportNewEdgeDrags()会被调用很多次（因为processTouchEvent()的ACTION_MOVE部分会执行很多次），但mCallback.onEdgeDragStarted(dragsStarted, pointerId)只会调用一次，具体的要看checkNewEdgeDrag()这个方法：\n\n```\nprivate boolean checkNewEdgeDrag(float delta, float odelta, int pointerId, int edge) {\n    final float absDelta = Math.abs(delta);\n    final float absODelta = Math.abs(odelta);\n\n    if ((mInitialEdgesTouched[pointerId] & edge) != edge  || (mTrackingEdges & edge) == 0 ||\n            (mEdgeDragsLocked[pointerId] & edge) == edge ||\n            (mEdgeDragsInProgress[pointerId] & edge) == edge ||\n            (absDelta <= mTouchSlop && absODelta <= mTouchSlop)) {\n        return false;\n    }\n    if (absDelta < absODelta * 0.5f && mCallback.onEdgeLock(edge)) {\n        mEdgeDragsLocked[pointerId] |= edge;\n        return false;\n    }\n    return (mEdgeDragsInProgress[pointerId] & edge) == 0 && absDelta > mTouchSlop;\n}\n```\n\n- checkNewEdgeDrag()返回true表示在指定的edge（边缘）开始产生拖动了。\n- 方法的两个参数delta和odelta需要解释一下，odelta里的o应该代表opposite，这是什么意思呢，以reportNewEdgeDrags()里调用checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里delta为dx，odelta为dy，也就是说delta是指我们主要监测的方向上的变化，odelta是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。\n- mInitialEdgesTouched是在ACTION_DOWN部分的saveInitialMotion()里生成的，ACTION_DOWN发生时触摸到的边缘会被记录在mInitialEdgesTouched中。如果ACTION_DOWN发生时没有触摸到边缘，或者触摸到的边缘不是指定的edge，就直接返回false了。\n- mTrackingEdges是由setEdgeTrackingEnabled(int edgeFlags)设置的，当我们想要追踪监听边缘触摸时才需要调用setEdgeTrackingEnabled(int edgeFlags)，如果我们没有调用过它，这里就直接返回false了。\n- mEdgeDragsLocked它在这个方法里被引用了多次，它在整个ViewDragHelper里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行mEdgeDragsLocked[pointerId] & edge) == edge执行的结果是false。我们再跳到11到14行看看，absDelta < absODelta * 0.5f的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用Callback的onEdgeLock(edge)检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在mEdgeDragsInProgress里了，也不会收到Callback的onEdgeDragStarted()通知了。并且将锁定的边缘记录在mEdgeDragsLocked变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的edge被锁定，就直接返回false了。\n- 回到第7行的(mEdgeDragsInProgress[pointerId] & edge) == edge，mEdgeDragsInProgress是保存已发生过拖动事件的边缘的，如果给定的edge已经保存过了，那就没必要再检测其他东西了，直接返回false了。\n- 第8行(absDelta <= mTouchSlop && absODelta <= mTouchSlop)很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。\n- 最后一句返回的时候再次检查给定的edge有没有记录过，确保了每个边缘只会调用一次reportNewEdgeDrags的mCallback.onEdgeDragStarted(dragsStarted, pointerId)\n\n再来看checkTouchSlop()方法：\n\n```\n/**\n * Check if we've crossed a reasonable touch slop for the given child view.\n * If the child cannot be dragged along the horizontal or vertical axis, motion\n * along that axis will not count toward the slop check.\n *\n * @param child Child to check\n * @param dx Motion since initial position along X axis\n * @param dy Motion since initial position along Y axis\n * @return true if the touch slop has been crossed\n */\nprivate boolean checkTouchSlop(View child, float dx, float dy) {\n    if (child == null) {\n        return false;\n    }\n    final boolean checkHorizontal = mCallback.getViewHorizontalDragRange(child) > 0;\n    final boolean checkVertical = mCallback.getViewVerticalDragRange(child) > 0;\n\n    if (checkHorizontal && checkVertical) {\n        return dx * dx + dy * dy > mTouchSlop * mTouchSlop;\n    } else if (checkHorizontal) {\n        return Math.abs(dx) > mTouchSlop;\n    } else if (checkVertical) {\n        return Math.abs(dy) > mTouchSlop;\n    }\n    return false;\n}\n```\n\n这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（mTouchSlop）了，注意dx和dy指的是当前触摸点到ACTION_DOWN触摸到的点的距离。这里先检查Callback的getViewHorizontalDragRange(child)和getViewVerticalDragRange(child)是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在processTouchEvent()的ACTION_MOVE部分就不会调用tryCaptureViewForDrag()来捕获当前触摸到的View了，拖动也就没办法进行了。\n\n回到processTouchEvent()的ACTION_MOVE部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了Callback中的相关方法，让tryCaptureViewForDrag()正常的捕获到触摸到的View了，下一次ACTION_MOVE时就执行if部分的代码了，也就是开始不停的调用dragTo()对mCaptureView进行真正拖动了，看dragTo()方法：\n\n```\nprivate void dragTo(int left, int top, int dx, int dy) {\n    int clampedX = left;\n    int clampedY = top;\n    final int oldLeft = mCapturedView.getLeft();\n    final int oldTop = mCapturedView.getTop();\n    if (dx != 0) {\n        clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);\n        mCapturedView.offsetLeftAndRight(clampedX - oldLeft);\n    }\n    if (dy != 0) {\n        clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);\n        mCapturedView.offsetTopAndBottom(clampedY - oldTop);\n    }\n\n    if (dx != 0 || dy != 0) {\n        final int clampedDx = clampedX - oldLeft;\n        final int clampedDy = clampedY - oldTop;\n        mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,\n                clampedDx, clampedDy);\n    }\n}\n```\n\n参数dx和dy是前后两次ACTION_MOVE移动的距离，left和top分别为mCapturedView.getLeft() + dx, mCapturedView.getTop() + dy，也就是期望的移动后的坐标，对View的getLeft()等方法不理解的请参阅[Android View坐标getLeft, getRight, getTop, getBottom](http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html)。\n\n这里通过调用offsetLeftAndRight()和offsetTopAndBottom()来完成对mCapturedView移动，这两个是View中定义的方法，看它们的源码就知道内部是通过改变View的mLeft、mRight、mTop、mBottom，即改变View在父容器中的坐标位置，达到移动View的效果，所以如果调用mCapturedView的layout(int l, int t, int r, int b)方法也可以实现移动View的效果。\n\n具体要移动到哪里，由Callback的clampViewPositionHorizontal()和clampViewPositionVertical()来决定的，如果不想在水平方向上移动，在clampViewPositionHorizontal(View child, int left, int dx)里直接返回child.getLeft()就可以了，这样clampedX - oldLeft的值为0，这里调用mCapturedView.offsetLeftAndRight(clampedX - oldLeft)就不会起作用了。垂直方向上同理。\n\n最后会调用Callback的onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)通知捕获到的View位置改变了，并把最终的坐标（clampedX、clampedY）和最终的移动距离（clampedDx、 clampedDy）传递过去。\n\nACTION_MOVE部分就算告一段落了，接下来应该是用户松手触发ACTION_UP，或者是达到某个条件导致后续的ACTION_MOVE被mParentView的上层View给拦截了而收到ACTION_CANCEL，一起来看这两个部分：\n\n```\npublic void processTouchEvent(MotionEvent ev) {\n    // 省略\n\n    switch (action) {\n        // 省略其他case\n\n        case MotionEvent.ACTION_UP: {\n            if (mDragState == STATE_DRAGGING) {\n                releaseViewForPointerUp();\n            }\n            cancel();\n            break;\n        }\n\n        case MotionEvent.ACTION_CANCEL: {\n            if (mDragState == STATE_DRAGGING) {\n                dispatchViewReleased(0, 0);\n            }\n            cancel();\n            break;\n        }\n    }\n}\n```\n\n这两个部分都是重置所有的状态记录，并通知View被放开了，再看下releaseViewForPointerUp()和dispatchViewReleased()的源码：\n\n```\nprivate void releaseViewForPointerUp() {\n    mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity);\n    final float xvel = clampMag(\n            VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            mMinVelocity, mMaxVelocity);\n    final float yvel = clampMag(\n            VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n            mMinVelocity, mMaxVelocity);\n    dispatchViewReleased(xvel, yvel);\n}\n```\n\nreleaseViewForPointerUp()里也调用了dispatchViewReleased()，只不过传递了速率给它，这个速率就是由processTouchEvent()的mVelocityTracker追踪算出来的。再看dispatchViewReleased()：\n\n```\n/**\n * Like all callback events this must happen on the UI thread, but release\n * involves some extra semantics. During a release (mReleaseInProgress)\n * is the only time it is valid to call {@link #settleCapturedViewAt(int, int)}\n * or {@link #flingCapturedView(int, int, int, int)}.\n */\nprivate void dispatchViewReleased(float xvel, float yvel) {\n    mReleaseInProgress = true;\n    mCallback.onViewReleased(mCapturedView, xvel, yvel);\n    mReleaseInProgress = false;\n\n    if (mDragState == STATE_DRAGGING) {\n        // onViewReleased didn't call a method that would have changed this. Go idle.\n        setDragState(STATE_IDLE);\n    }\n}\n```\n\n这里调用Callback的onViewReleased(mCapturedView, xvel, yvel)通知外部捕获到的View被释放了，而在onViewReleased()前后有个mReleaseInProgress值得注意，注释里说唯一可以调用ViewDragHelper的settleCapturedViewAt()和flingCapturedView()的地方就是在Callback的onViewReleased()里了。\n\n首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。\nflingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（flingCapturedView的四个参数int minLeft, int minTop, int maxLeft, int maxTop可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用settleCapturedViewAt(int finalLeft, int finalTop)。\n\n为什么唯一可以调用settleCapturedViewAt()和flingCapturedView()的地方是Callback的onViewReleased()呢？看看它们的源码\n\n```\n/**\n * Settle the captured view at the given (left, top) position.\n * The appropriate velocity from prior motion will be taken into account.\n * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n * on each subsequent frame to continue the motion until it returns false. If this method\n * returns false there is no further work to do to complete the movement.\n *\n * @param finalLeft Settled left edge position for the captured view\n * @param finalTop Settled top edge position for the captured view\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\npublic boolean settleCapturedViewAt(int finalLeft, int finalTop) {\n    if (!mReleaseInProgress) {\n        throw new IllegalStateException(\"Cannot settleCapturedViewAt outside of a call to \" +\n                \"Callback#onViewReleased\");\n    }\n\n    return forceSettleCapturedViewAt(finalLeft, finalTop,\n            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));\n}\n\n/**\n * Settle the captured view based on standard free-moving fling behavior.\n * The caller should invoke {@link #continueSettling(boolean)} on each subsequent frame\n * to continue the motion until it returns false.\n *\n * @param minLeft Minimum X position for the view's left edge\n * @param minTop Minimum Y position for the view's top edge\n * @param maxLeft Maximum X position for the view's left edge\n * @param maxTop Maximum Y position for the view's top edge\n */\npublic void flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop) {\n    if (!mReleaseInProgress) {\n        throw new IllegalStateException(\"Cannot flingCapturedView outside of a call to \" +\n                \"Callback#onViewReleased\");\n    }\n\n    mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),\n            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n            minLeft, maxLeft, minTop, maxTop);\n\n    setDragState(STATE_SETTLING);\n}\n```\n\n这两个方法里一开始都会判断mReleaseInProgress为false，如果为false就会抛一个IllegalStateException异常，而mReleaseInProgress唯一为true的时候就是在dispatchViewReleased()里调用onViewReleased()的时候。\n\nScroller的用法请参阅[Android中滑屏实现----手把手教你如何实现触摸滑屏以及Scroller类详解](http://blog.csdn.net/qinjuning/article/details/7419207) ，或者自行解读Scroller源码，代码量不多。\n\nViewDragHelper还有一个移动View的方法是smoothSlideViewTo(View child, int finalLeft, int finalTop)，看下它的源码：\n\n```\n/**\n * Animate the view <code>child</code> to the given (left, top) position.\n * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n * on each subsequent frame to continue the motion until it returns false. If this method\n * returns false there is no further work to do to complete the movement.\n *\n * <p>This operation does not count as a capture event, though {@link #getCapturedView()}\n * will still report the sliding view while the slide is in progress.</p>\n *\n * @param child Child view to capture and animate\n * @param finalLeft Final left position of child\n * @param finalTop Final top position of child\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\npublic boolean smoothSlideViewTo(View child, int finalLeft, int finalTop) {\n    mCapturedView = child;\n    mActivePointerId = INVALID_POINTER;\n\n    boolean continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);\n    if (!continueSliding && mDragState == STATE_IDLE && mCapturedView != null) {\n        // If we're in an IDLE state to begin with and aren't moving anywhere, we\n        // end up having a non-null capturedView with an IDLE dragState\n        mCapturedView = null;\n    }\n\n    return continueSliding;\n}\n```\n\n可以看到它不受mReleaseInProgress的限制，所以可以在任何地方调用，效果和settleCapturedViewAt()类似，因为它们最终都调用了forceSettleCapturedViewAt()来启动自动滚动，区别在于settleCapturedViewAt()会以最后松手前的滑动速率为初速度将View滚动到最终位置，而smoothSlideViewTo()滚动的初速度是0。forceSettleCapturedViewAt()里有地方调用了Callback里的方法，所以再来看看这个方法：\n\n```\n/**\n * Settle the captured view at the given (left, top) position.\n *\n * @param finalLeft Target left position for the captured view\n * @param finalTop Target top position for the captured view\n * @param xvel Horizontal velocity\n * @param yvel Vertical velocity\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\nprivate boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {\n    final int startLeft = mCapturedView.getLeft();\n    final int startTop = mCapturedView.getTop();\n    final int dx = finalLeft - startLeft;\n    final int dy = finalTop - startTop;\n\n    if (dx == 0 && dy == 0) {\n        // Nothing to do. Send callbacks, be done.\n        mScroller.abortAnimation();\n        setDragState(STATE_IDLE);\n        return false;\n    }\n\n    final int duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);\n    mScroller.startScroll(startLeft, startTop, dx, dy, duration);\n\n    setDragState(STATE_SETTLING);\n    return true;\n}\n```\n\n可以看到自动滑动是靠Scroll类完成，在这里生成了调用mScroller.startScroll()需要的参数。再来看看计算滚动时间的方法computeSettleDuration()：\n\n```\nprivate int computeSettleDuration(View child, int dx, int dy, int xvel, int yvel) {\n    xvel = clampMag(xvel, (int) mMinVelocity, (int) mMaxVelocity);\n    yvel = clampMag(yvel, (int) mMinVelocity, (int) mMaxVelocity);\n    final int absDx = Math.abs(dx);\n    final int absDy = Math.abs(dy);\n    final int absXVel = Math.abs(xvel);\n    final int absYVel = Math.abs(yvel);\n    final int addedVel = absXVel + absYVel;\n    final int addedDistance = absDx + absDy;\n\n    final float xweight = xvel != 0 ? (float) absXVel / addedVel :\n            (float) absDx / addedDistance;\n    final float yweight = yvel != 0 ? (float) absYVel / addedVel :\n            (float) absDy / addedDistance;\n\n    int xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));\n    int yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));\n\n    return (int) (xduration * xweight + yduration * yweight);\n}\n```\n\nclampMag()方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过computeAxisDuration()算出来，通过它的参数可以看到最终的滚动时间是由dx、xvel、mCallback.getViewHorizontalDragRange()共同影响的。看computeAxisDuration()：\n\n```\nprivate int computeAxisDuration(int delta, int velocity, int motionRange) {\n    if (delta == 0) {\n        return 0;\n    }\n\n    final int width = mParentView.getWidth();\n    final int halfWidth = width / 2;\n    final float distanceRatio = Math.min(1f, (float) Math.abs(delta) / width);\n    final float distance = halfWidth + halfWidth *\n            distanceInfluenceForSnapDuration(distanceRatio);\n\n    int duration;\n    velocity = Math.abs(velocity);\n    if (velocity > 0) {\n        duration = 4 * Math.round(1000 * Math.abs(distance / velocity));\n    } else {\n        final float range = (float) Math.abs(delta) / motionRange;\n        duration = (int) ((range + 1) * BASE_SETTLE_DURATION);\n    }\n    return Math.min(duration, MAX_SETTLE_DURATION);\n}\n```\n\n6~10行没看明白，直接看14~19行，如果给定的速率velocity不为0，就通过距离除以速率来算出时间；如果velocity为0，就通过要滑动的距离（delta）除以总的移动范围（motionRange，就是Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过MAX_SETTLE_DURATION的，源码里的取值是600毫秒，所以不用担心在Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回错误的数而导致自动滚动时间过长了。\n\n在调用settleCapturedViewAt()、flingCapturedView()和smoothSlideViewTo()时，还需要实现mParentView的computeScroll()：\n\n```\n@Override\npublic void computeScroll() {\n    if (mDragHelper.continueSettling(true)) {\n        ViewCompat.postInvalidateOnAnimation(this);\n    }\n}\n```\n\n这属于Scroll类用法的范畴，不明白的请参阅[Android中滑屏实现----手把手教你如何实现触摸滑屏以及Scroller类详解](http://blog.csdn.net/qinjuning/article/details/7419207) 的“知识点二： computeScroll(）方法介绍”。\n\n至此，整个触摸流程和ViewDragHelper的重要的方法都过了一遍。之前在讨论shouldInterceptTouchEvent()的ACTION_DOWN部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次ACTION_DOWN事件的情况，现在来看看这种情况。\n\n假设现在shouldInterceptTouchEvent()的ACTION_DOWN部分执行完了，也有子View消费了这次的ACTION_DOWN事件，那么接下来就会调用mParentView的onInterceptTouchEvent()的ACTION_MOVE部分，不明白为什么的请参阅[Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制](http://blog.csdn.net/xiaanming/article/details/21696315)，接着调用ViewDragHelper的shouldInterceptTouchEvent()的ACTION_MOVE部分：\n\n```\npublic boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    // 省略...\n    \n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_MOVE: {\n            // First to cross a touch slop over a draggable view wins. Also report edge drags.\n            final int pointerCount = MotionEventCompat.getPointerCount(ev);\n            for (int i = 0; i < pointerCount; i++) {\n                final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                final float x = MotionEventCompat.getX(ev, i);\n                final float y = MotionEventCompat.getY(ev, i);\n                final float dx = x - mInitialMotionX[pointerId];\n                final float dy = y - mInitialMotionY[pointerId];\n\n                final View toCapture = findTopChildUnder((int) x, (int) y);\n                final boolean pastSlop = toCapture != null && checkTouchSlop(toCapture, dx, dy);\n                if (pastSlop) {\n                    // check the callback's\n                    // getView[Horizontal|Vertical]DragRange methods to know\n                    // if you can move at all along an axis, then see if it\n                    // would clamp to the same value. If you can't move at\n                    // all in every dimension with a nonzero range, bail.\n                    final int oldLeft = toCapture.getLeft();\n                    final int targetLeft = oldLeft + (int) dx;\n                    final int newLeft = mCallback.clampViewPositionHorizontal(toCapture,\n                            targetLeft, (int) dx);\n                    final int oldTop = toCapture.getTop();\n                    final int targetTop = oldTop + (int) dy;\n                    final int newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,\n                            (int) dy);\n                    final int horizontalDragRange = mCallback.getViewHorizontalDragRange(\n                            toCapture);\n                    final int verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);\n                    if ((horizontalDragRange == 0 || horizontalDragRange > 0\n                            && newLeft == oldLeft) && (verticalDragRange == 0\n                            || verticalDragRange > 0 && newTop == oldTop)) {\n                        break;\n                    }\n                }\n                reportNewEdgeDrags(dx, dy, pointerId);\n                if (mDragState == STATE_DRAGGING) {\n                    // Callback might have started an edge drag\n                    break;\n                }\n\n                if (pastSlop && tryCaptureViewForDrag(toCapture, pointerId)) {\n                    break;\n                }\n            }\n            saveLastMotion(ev);\n            break;\n        }\n\n        // 省略其他case...\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n```\n\n如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用findTopChildUnder(int x, int y)寻找触摸点处的子View，再用checkTouchSlop(View child, float dx, float dy)检查当前触摸点到ACTION_DOWN触摸点的距离是否达到了mTouchSlop，达到了才会去捕获View。\n接着看19~41行if (pastSlop){...}部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到getView[Horizontal|Vertical]DragRange和clampViewPosition[Horizontal|Vertical]四个方法。如果getView[Horizontal|Vertical]DragRange返回都是0，就会认作是不会产生拖动。clampViewPosition[Horizontal|Vertical]返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接break，不会执行后续的代码，而后续代码里有调用tryCaptureViewForDrag()，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。\n如果检查到可以在某个方向上进行拖动，就会调用后面的tryCaptureViewForDrag()捕获子View，如果捕获成功，mDragState就会变成STATE_DRAGGING，shouldInterceptTouchEvent()返回true，mParentView的onInterceptTouchEvent()返回true，后续的移动事件就会在mParentView的onTouchEvent()执行了，最后执行的就是mParentView的processTouchEvent()的ACTION_MOVE部分，拖动正常进行。\n\n回头再看之前在shouldInterceptTouchEvent()的ACTION_DOWN部分留下的坑：\n\n```\npublic boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    // 省略其他部分...\n    \n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_DOWN: {\n            // 省略其他部分...\n            \n            // Catch a settling view if possible.\n            if (toCapture == mCapturedView && mDragState == STATE_SETTLING) {\n                tryCaptureViewForDrag(toCapture, pointerId);\n            }\n            \n            // 省略其他部分...\n        }\n\n        // 省略其他case...\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n```\n\n现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的tryCaptureViewForDrag()尝试捕获View，如果捕获成功，mDragState就变为STATE_DRAGGING了，shouldInterceptTouchEvent()就返回true了，然后就是mParentView的onInterceptTouchEvent()返回true，接着执行mParentView的onTouchEvent()，再执行processTouchEvent()的ACTION_DOWN部分。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动。\n\n至此整个事件传递流程和ViewDragHelper的重要方法基本都解析完了，shouldInterceptTouchEvent()和processTouchEvent()的ACTION_POINTER_DOWN、ACTION_POINTER_UP部分就留给读者自己解析了。\n\n### 总结\n\n对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。\n\n- [单点触摸，没有考虑边缘滑动检测的最简流程图](http://www.processon.com/view/link/5550a7bae4b09739f465ec64)\n- [单点触摸，考虑了边缘滑动检测的流程图](http://www.processon.com/view/link/5550d3dce4b09739f46789bd)\n\n多点触摸情况我就没研究了，在这里忽略~\n\n三个开启自动滚动的方法：\n\n- settleCapturedViewAt(int finalLeft, int finalTop)\n  以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在Callback的onViewReleased()中调用。\n- flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)\n  以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在Callback的onViewReleased()中调用。\n- smoothSlideViewTo(View child, int finalLeft, int finalTop)\n  指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。\n\nCallback的各个方法总结：\n\n- void onViewDragStateChanged(int state)\n\n  拖动状态改变时会调用此方法，状态state有STATE_IDLE、STATE_DRAGGING、STATE_SETTLING三种取值。\n\n  它在setDragState()里被调用，而setDragState()被调用的地方有\n\n  - tryCaptureViewForDrag()成功捕获到子View时\n    - shouldInterceptTouchEvent()的ACTION_DOWN部分捕获到\n    - shouldInterceptTouchEvent()的ACTION_MOVE部分捕获到\n    - processTouchEvent()的ACTION_MOVE部分捕获到\n  - 调用settleCapturedViewAt()、smoothSlideViewTo()、flingCapturedView()时\n  - 拖动View松手时（processTouchEvent()的ACTION_UP、ACTION_CANCEL）\n  - 自动滚动停止时（continueSettling()里检测到滚动结束时）\n  - 外部调用abort()时\n\n- void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)\n\n  正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。\n\n  - 在dragTo()里被调用（正在被拖动时）\n  - 在continueSettling()里被调用（自动滚动时）\n  - 外部调用abort()时被调用\n\n- void onViewCaptured(View capturedChild, int activePointerId)\n\n  tryCaptureViewForDrag()成功捕获到子View时会调用此方法。\n\n  - 在shouldInterceptTouchEvent()的ACTION_DOWN里成功捕获\n  - 在shouldInterceptTouchEvent()的ACTION_MOVE里成功捕获\n  - 在processTouchEvent()的ACTION_MOVE里成功捕获\n  - 手动调用captureChildView()\n\n- void onViewReleased(View releasedChild, float xvel, float yvel)\n  拖动View松手时（processTouchEvent()的ACTION_UP）或被父View拦截事件时（processTouchEvent()的ACTION_CANCEL）会调用此方法。\n\n- void onEdgeTouched(int edgeFlags, int pointerId)\n  ACTION_DOWN或ACTION_POINTER_DOWN事件发生时如果触摸到监听的边缘会调用此方法。edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。\n\n- boolean onEdgeLock(int edgeFlags)\n  返回true表示锁定edgeFlags对应的边缘，锁定后的那些边缘就不会在onEdgeDragStarted()被通知了，默认返回false不锁定给定的边缘，edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM其中之一。\n\n- void onEdgeDragStarted(int edgeFlags, int pointerId)\n  ACTION_MOVE事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。edgeFlags取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。可在此手动调用captureChildView()触发从边缘拖动子View的效果。\n\n- int getOrderedChildIndex(int index)\n  在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给tryCaptureViewForDrag()来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。\n\n- int getViewHorizontalDragRange(View child)、int getViewVerticalDragRange(View child)\n\n  返回给定的child在相应的方向上可以被拖动的最远距离，默认返回0。ACTION_DOWN发生时，若触摸点处的child消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。\n\n  被调用的地方有三处：\n\n  - 在checkTouchSlop()中被调用，返回值大于0才会去检查mTouchSlop。在ACTION_MOVE里调用tryCaptureViewForDrag()之前会调用checkTouchSlop()。如果checkTouchSlop()失败，就不会去捕获View了。\n  - 如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。\n  - 在调用smoothSlideViewTo()时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在getView[Horizontal|Vertical]DragRange里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。\n\n- boolean tryCaptureView(View child, int pointerId)\n\n  在tryCaptureViewForDrag()中被调用，返回true表示捕获给定的child。tryCaptureViewForDrag()被调用的地方有\n\n  - shouldInterceptTouchEvent()的ACTION_DOWN里\n  - shouldInterceptTouchEvent()的ACTION_MOVE里\n  - processTouchEvent()的ACTION_MOVE里\n\n- int clampViewPositionHorizontal(View child, int left, int dx)、int clampViewPositionVertical(View child, int top, int dy)\n\n  child在某方向上被拖动时会调用对应方法，返回值是child移动过后的坐标位置，clampViewPositionHorizontal()返回child移动过后的left值，clampViewPositionVertical()返回child移动过后的top值。\n\n  两个方法被调用的地方有两处：\n\n  - 在dragTo()中被调用，dragTo()在processTouchEvent()的ACTION_MOVE里被调用。用来获取被拖动的View要移动到的位置。\n  - 如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。\n\n### 案例参考\n\n在这里列举一部分对ViewDragHelper的应用案例，大家自己剖析它们的源码来实践巩固。\n\n1. [YoutubeLayout](https://github.com/flavienlaurent/flavienlaurent.com)，这是最简单的Demo\n2. [QQ5.x侧滑菜单](https://github.com/BlueMor/DragLayout)、[ResideLayout](https://github.com/kyze8439690/ResideLayout)\n3. [SwipeBackLayout](https://github.com/ikew0ng/SwipeBackLayout)、[SwipeBack](https://github.com/liuguangqiang/SwipeBack)\n4. [SlidingUpPanel](https://github.com/umano/AndroidSlidingUpPanel)\n5. [DrawerLayout](https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java)\n\n### 其他关于ViewDragHelper的分析文章\n\n- [Each Navigation Drawer Hides a ViewDragHelper](http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper)，文中的源码就是上面的[YoutubeLayout](https://github.com/flavienlaurent/flavienlaurent.com)\n- [ViewDragHelper详解](http://blog.csdn.net/pi9nc/article/details/39583377)，这是上面文章的简略中文版","source":"_posts/ViewDragHelper-source-code.md","raw":"---\nthumbnail: https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321185255.png\ntitle: ViewDragHelper 源码解析\ntags: [Android, 源码解析]\ndate: 2019-05-13\n---\n\n[这文章是转来的，写的实在是好，怕哪天失踪了……](https://www.cnblogs.com/lqstayreal/p/4500219.html)\n\n<!-- more -->\n\n\n\n在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，ViewDragHelper的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。\n\n要想完全掌握ViewDragHelper的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾ViewDragHelper的原理、用法、注意事项等。\n\n### 基本用法\n\n1. 在自定义ViewGroup的构造方法里调用ViewDragHelper的静态工厂方法create()创建ViewDragHelper实例\n\n2. 实现ViewDragHelper.Callback\n\n   最重要的几个方法是tryCaptureView()、clampViewPositionVertical()、clampViewPositionHorizontal()、getViewHorizontalDragRange()、getViewVerticalDragRange()\n\n   - tryCaptureView()里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回true，否则返回false。\n   - clampViewPositionVertical()决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。\n   - clampViewPositionHorizontal()与clampViewPositionVertical()同理，只不过是发生在水平方向上，最终返回的是View的left值。\n   - getViewVerticalDragRange()要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。\n   - getViewHorizontalDragRange()与getViewVerticalDragRange()同理，只不过是发生在水平方向上。\n\n3. 在onInterceptTouchEvent()方法里调用并返回ViewDragHelper的shouldInterceptTouchEvent()方法\n\n4. 在onTouchEvent()方法里调用ViewDragHelper()的processTouchEvent()方法。ACTION_DOWN事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在onTouchEvent()返回true，否则将收不到后续事件，不会产生拖动。\n\n5. 上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的computeScroll()方法，方法实现如下：\n\n   ```\n    @Override\n    public void computeScroll() {\n        if (mDragHelper.continueSettling(true)) {\n            postInvalidate();\n        }\n    }\n   ```\n\n   并在ViewDragHelper.Callback的onViewReleased()方法里调用settleCapturedViewAt()、flingCapturedView()，或在任意地方调用smoothSlideViewTo()方法。\n\n6. 如果要实现边缘拖动的效果，需要调用ViewDragHelper的setEdgeTrackingEnabled()方法，注册想要监听的边缘。然后实现ViewDragHelper.Callback里的onEdgeDragStarted()方法，在此手动调用captureChildView()传递要拖动的子View。\n\n具体的使用Demo请见最后面公布的几个案例。\n\n### 源码详解\n\nViewDragHelper的完整源码可在[GitHub](https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java)或[GrepCode](http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper)上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。\n\n#### 预备知识\n\n1. 了解View的坐标系统，[Android View坐标getLeft, getRight, getTop, getBottom](http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html)\n2. 了解MotionEvent中关于多点触控的机制，[android触控,先了解MotionEvent(一)](http://my.oschina.net/banxi/blog/56421)\n3. 了解Scroller类原理，[Android中滑屏实现----手把手教你如何实现触摸滑屏以及Scroller类详解](http://blog.csdn.net/qinjuning/article/details/7419207)\n4. 了解Touch事件的分发机制，[Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制](http://blog.csdn.net/xiaanming/article/details/21696315)\n\n#### ViewDragHelper实例的创建\n\nViewDragHelper重载了两个create()静态方法，先看两个参数的create()方法：\n\n```\n/**\n * Factory method to create a new ViewDragHelper.\n *\n * @param forParent Parent view to monitor\n * @param cb Callback to provide information and receive events\n * @return a new ViewDragHelper instance\n */\npublic static ViewDragHelper create(ViewGroup forParent, Callback cb) {\n    return new ViewDragHelper(forParent.getContext(), forParent, cb);\n}\n```\n\ncreate()的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。create()直接调用了ViewDragHelper构造方法，我们再来看看这个构造方法。\n\n```\n/**\n * Apps should use ViewDragHelper.create() to get a new instance.\n * This will allow VDH to use internal compatibility implementations for different\n * platform versions.\n *\n * @param context Context to initialize config-dependent params from\n * @param forParent Parent view to monitor\n */\nprivate ViewDragHelper(Context context, ViewGroup forParent, Callback cb) {\n    if (forParent == null) {\n        throw new IllegalArgumentException(\"Parent view may not be null\");\n    }\n    if (cb == null) {\n        throw new IllegalArgumentException(\"Callback may not be null\");\n    }\n\n    mParentView = forParent;\n    mCallback = cb;\n\n    final ViewConfiguration vc = ViewConfiguration.get(context);\n    final float density = context.getResources().getDisplayMetrics().density;\n    mEdgeSize = (int) (EDGE_SIZE * density + 0.5f);\n\n    mTouchSlop = vc.getScaledTouchSlop();\n    mMaxVelocity = vc.getScaledMaximumFlingVelocity();\n    mMinVelocity = vc.getScaledMinimumFlingVelocity();\n    mScroller = ScrollerCompat.create(context, sInterpolator);\n}\n```\n\n这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过create()工厂方法来创建ViewDragHelper实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。\n\n- mParentView和mCallback分别保存传递过来的对应参数\n- ViewConfiguration类里定义了View相关的一系列时间、大小、距离等常量\n- mEdgeSize表示边缘触摸的范围。例如mEdgeSize为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于mParentView.getLeft() + mEdgeSize时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见ViewDragHelper的getEdgesTouched()方法。\n- mTouchSlop是一个很小的距离值，只有在前后两次触摸点的距离超过mTouchSlop的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。\n- mMaxVelocity、mMinVelocity是fling时的最大、最小速率，单位是像素每秒。\n- mScroller是View滚动的辅助类，该类的详细解析参见下面几篇文章\n  - [Android中滑屏实现----手把手教你如何实现触摸滑屏以及Scroller类详解](http://blog.csdn.net/qinjuning/article/details/7419207)\n  - [Android中Scroller类的分析](http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html)\n\n再看三个参数的create()方法：\n\n```\n/**\n * Factory method to create a new ViewDragHelper.\n *\n * @param forParent Parent view to monitor\n * @param sensitivity Multiplier for how sensitive the helper should be about detecting\n *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.\n * @param cb Callback to provide information and receive events\n * @return a new ViewDragHelper instance\n */\npublic static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {\n    final ViewDragHelper helper = create(forParent, cb);\n    helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity));\n    return helper;\n}\n```\n\n第二个参数sensitivity是用来调节mTouchSlop的值。sensitivity越大，mTouchSlop越小，对滑动的检测就越敏感。例如sensitivity为1时，前后触摸点距离超过20dp才进行滑动处理，现在sensitivity为2的话，前后触摸点距离超过10dp就进行处理了。\n\n#### 对Touch事件的处理\n\n当mParentView（自定义ViewGroup）被触摸时，首先会调用mParentView的onInterceptTouchEvent(MotionEvent ev)，接着就调用shouldInterceptTouchEvent(MotionEvent ev) ，所以先来看看这个方法的ACTION_DOWN部分：\n\n```\n/**\n * Check if this event as provided to the parent view's onInterceptTouchEvent should\n * cause the parent to intercept the touch event stream.\n *\n * @param ev MotionEvent provided to onInterceptTouchEvent\n * @return true if the parent view should return true from onInterceptTouchEvent\n */\npublic boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    final int action = MotionEventCompat.getActionMasked(ev);\n    final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n    if (action == MotionEvent.ACTION_DOWN) {\n        // Reset things for a new event stream, just in case we didn't get\n        // the whole previous stream.\n        cancel();\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n            saveInitialMotion(x, y, pointerId);\n\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n\n            // Catch a settling view if possible.\n            if (toCapture == mCapturedView && mDragState == STATE_SETTLING) {\n                tryCaptureViewForDrag(toCapture, pointerId);\n            }\n\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched & mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n            }\n            break;\n        }\n\n        // 其他case暂且省略\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n```\n\n看9~21行，首先是关于多点触控（MotionEvent的actionIndex、ACTION_POINTER_DOWN 等概念），不明白的请参阅[android触控,先了解MotionEvent(一)](http://my.oschina.net/banxi/blog/56421)。\n\nmVelocityTracker记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生ACTION_DOWN事件都会调用cancel()，而在cancel()方法里mVelocityTracker又被清空了，所以mVelocityTracker 记录下的是本次ACTION_DOWN事件直至ACTION_UP事件发生后（下次ACTION_DOWN事件发生前）的所有触摸点的信息。\n\n再来看24~42行case MotionEvent.ACTION_DOWN部分，先是调用saveInitialMotion(x, y, pointerId)保存手势的初始信息，即ACTION_DOWN发生时的触摸点坐标（x、y）、触摸手指编号（pointerId），如果触摸到了mParentView的边缘还会记录触摸的是哪个边缘。接着调用findTopChildUnder((int) x, (int) y);来获取当前触摸点下最顶层的子View，看findTopChildUnder 的源码：\n\n```\n/**\n * Find the topmost child under the given point within the parent view's coordinate system.\n * The child order is determined using {@link Callback#getOrderedChildIndex(int)}.\n *\n * @param x X position to test in the parent's coordinate system\n * @param y Y position to test in the parent's coordinate system\n * @return The topmost child view under (x, y) or null if none found.\n */\npublic View findTopChildUnder(int x, int y) {\n    final int childCount = mParentView.getChildCount();\n    for (int i = childCount - 1; i >= 0; i--) {\n        final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));\n        if (x >= child.getLeft() && x < child.getRight() &&\n                y >= child.getTop() && y < child.getBottom()) {\n            return child;\n        }\n    }\n    return null;\n}\n```\n\n代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现Callback里的getOrderedChildIndex(int index)方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（getOrderedChildIndex()默认直接返回index），会选择到topView，要想让bottomView被选中就得这么写：\n\n```\npublic int getOrderedChildIndex(int index) {\n    int indexTop = mParentView.indexOfChild(topView);\n    int indexBottom = mParentView.indexOfChild(bottomView);\n    if (index == indexTop) {\n        return indexBottom;\n    }\n    return index;\n}\n```\n\n32~35行，这里还看到了一个mDragState成员变量，它共有三种取值：\n\n1. STATE_IDLE：所有的View处于静止空闲状态\n2. STATE_DRAGGING：某个View正在被用户拖动（用户正在与设备交互）\n3. STATE_SETTLING：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中\n   mCapturedView默认为null，所以一开始不会执行这里的代码，mDragState处于STATE_SETTLING状态时才会执行tryCaptureViewForDrag()，执行的情况到后面再分析，这里先跳过。\n\n37~40行调用了Callback.onEdgeTouched向外部通知mParentView的某些边缘被触摸到了，mInitialEdgesTouched是在刚才调用过的saveInitialMotion方法里进行赋值的。\n\nACTION_DOWN 部分处理完了，跳过switch语句块，剩下的代码就只有return mDragState == STATE_DRAGGING;。在ACTION_DOWN部分没有对mDragState进行赋值，其默认值为STATE_IDLE，所以此处返回false。\n\n那么返回false后接下来应该是会调用哪个方法呢，根据[Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制](http://blog.csdn.net/xiaanming/article/details/21696315)里的解析，接下来会在mParentView的所有子View中寻找响应这个Touch事件的View（会调用每个子View的dispatchTouchEvent()方法，dispatchTouchEvent里一般又会调用onTouchEvent()）；\n\n- 如果没有子View消费这次事件（子View的dispatchTouchEvent()返回都是false），会调用mParentView的super.dispatchTouchEvent(ev)，即View中的dispatchTouchEvent(ev)，然后调用mParentView的onTouchEvent()方法，再调用ViewDragHelper的processTouchEvent(MotionEvent ev)方法。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动（除了ACTION_DOWN外的其他事件发生时返回true或false都不会影响接下来的事件接受），因为拖动的相关代码是写在processTouchEvent()里的ACTION_MOVE部分的。要注意的是返回true后mParentView的onInterceptTouchEvent()就不会收到后续的ACTION_MOVE、ACTION_UP等事件了。\n- 如果有子View消费了本次ACTION_DOWN事件，mParentView的onTouchEvent()就收不到ACTION_DOWN事件了，也就是ViewDragHelper的processTouchEvent(MotionEvent ev)收不到ACTION_DOWN事件了。不过只要该View没有调用过requestDisallowInterceptTouchEvent(true)，mParentView的onInterceptTouchEvent()的ACTION_MOVE部分还是会执行的，如果在此时返回了true拦截了ACTION_MOVE事件，processTouchEvent()里的ACTION_MOVE部分也就会正常执行，拖动也就没问题了。onInterceptTouchEvent()的ACTION_MOVE部分具体做了怎样的处理，稍后再来解析。\n\n接下来对这两种情况逐一解析。\n\n假设没有子View消费这次事件，根据刚才的分析最终就会调用processTouchEvent(MotionEvent ev)的ACTION_DOWN部分：\n\n```\n/**\n * Process a touch event received by the parent view. This method will dispatch callback events\n * as needed before returning. The parent view's onTouchEvent implementation should call this.\n *\n * @param ev The touch event received by the parent view\n */\npublic void processTouchEvent(MotionEvent ev) {\n    final int action = MotionEventCompat.getActionMasked(ev);\n    final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n    if (action == MotionEvent.ACTION_DOWN) {\n        // Reset things for a new event stream, just in case we didn't get\n        // the whole previous stream.\n        cancel();\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n\n            saveInitialMotion(x, y, pointerId);\n\n            // Since the parent is already directly processing this touch event,\n            // there is no reason to delay for a slop before dragging.\n            // Start immediately if possible.\n            tryCaptureViewForDrag(toCapture, pointerId);\n\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched & mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n            }\n            break;\n        }\n        // 其他case暂且省略\n    }\n}\n```\n\n这段代码跟shouldInterceptTouchEvent()里ACTION_DOWN那部分基本一致，唯一区别就是这里没有约束条件直接调用了tryCaptureViewForDrag()方法，现在来看看这个方法：\n\n```\n/**\n * Attempt to capture the view with the given pointer ID. The callback will be involved.\n * This will put us into the \"dragging\" state. If we've already captured this view with\n * this pointer this method will immediately return true without consulting the callback.\n *\n * @param toCapture View to capture\n * @param pointerId Pointer to capture with\n * @return true if capture was successful\n */\nboolean tryCaptureViewForDrag(View toCapture, int pointerId) {\n    if (toCapture == mCapturedView && mActivePointerId == pointerId) {\n        // Already done!\n        return true;\n    }\n    if (toCapture != null && mCallback.tryCaptureView(toCapture, pointerId)) {\n        mActivePointerId = pointerId;\n        captureChildView(toCapture, pointerId);\n        return true;\n    }\n    return false;\n}\n```\n\n这里调用了Callback的tryCaptureView(View child, int pointerId)方法，把当前触摸到的View和触摸手指编号传递了过去，在tryCaptureView()中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在tryCaptureView()中返回true，让ViewDragHelper把当前触摸的View捕获下来，接着就调用了captureChildView(toCapture, pointerId)方法：\n\n```\n/**\n * Capture a specific child view for dragging within the parent. The callback will be notified\n * but {@link Callback#tryCaptureView(android.view.View, int)} will not be asked permission to\n * capture this view.\n *\n * @param childView Child view to capture\n * @param activePointerId ID of the pointer that is dragging the captured child view\n */\npublic void captureChildView(View childView, int activePointerId) {\n    if (childView.getParent() != mParentView) {\n        throw new IllegalArgumentException(\"captureChildView: parameter must be a descendant \" +\n                \"of the ViewDragHelper's tracked parent view (\" + mParentView + \")\");\n    }\n\n    mCapturedView = childView;\n    mActivePointerId = activePointerId;\n    mCallback.onViewCaptured(childView, activePointerId);\n    setDragState(STATE_DRAGGING);\n}\n```\n\n代码很简单，在captureChildView(toCapture, pointerId)中将要拖动的View和触摸的手指编号记录下来，并调用Callback的onViewCaptured(childView, activePointerId)通知外部有子View被捕获到了，再调用setDragState()设置当前的状态为STATE_DRAGGING，看setDragState()源码：\n\n```\nvoid setDragState(int state) {\n    if (mDragState != state) {\n        mDragState = state;\n        mCallback.onViewDragStateChanged(state);\n        if (mDragState == STATE_IDLE) {\n            mCapturedView = null;\n        }\n    }\n}\n```\n\n状态改变后会调用Callback的onViewDragStateChanged()通知状态的变化。\n\n假设ACTION_DOWN发生后在mParentView的onTouchEvent()返回了true，接下来就会执行ACTION_MOVE部分：\n\n```\npublic void processTouchEvent(MotionEvent ev) {\n\n    switch (action) {\n        // 省略其他case...\n        \n        case MotionEvent.ACTION_MOVE: {\n            if (mDragState == STATE_DRAGGING) {\n                final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, index);\n                final float y = MotionEventCompat.getY(ev, index);\n                final int idx = (int) (x - mLastMotionX[mActivePointerId]);\n                final int idy = (int) (y - mLastMotionY[mActivePointerId]);\n\n                dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);\n\n                saveLastMotion(ev);\n            } else {\n                // Check to see if any pointer is now over a draggable view.\n                final int pointerCount = MotionEventCompat.getPointerCount(ev);\n                for (int i = 0; i < pointerCount; i++) {\n                    final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                    final float x = MotionEventCompat.getX(ev, i);\n                    final float y = MotionEventCompat.getY(ev, i);\n                    final float dx = x - mInitialMotionX[pointerId];\n                    final float dy = y - mInitialMotionY[pointerId];\n\n                    reportNewEdgeDrags(dx, dy, pointerId);\n                    if (mDragState == STATE_DRAGGING) {\n                        // Callback might have started an edge drag.\n                        break;\n                    }\n\n                    final View toCapture = findTopChildUnder((int) x, (int) y);\n                    if (checkTouchSlop(toCapture, dx, dy) &&\n                            tryCaptureViewForDrag(toCapture, pointerId)) {\n                        break;\n                    }\n                }\n                saveLastMotion(ev);\n            }\n            break;\n        }\n\n        // 省略其他case...\n    }\n}\n```\n\n要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断mDragState是否为STATE_DRAGGING，而唯一调用setDragState(STATE_DRAGGING)的地方就是tryCaptureViewForDrag()了，刚才在ACTION_DOWN里调用过tryCaptureViewForDrag()，现在又要分两种情况。\n如果刚才在ACTION_DOWN里捕获到要拖动的View，那么就执行if部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，mDragState依然是STATE_IDLE，然后会执行else部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让mDragState变为STATE_DRAGGING，之后就会执行if部分的代码了。这里还有两个方法涉及到了Callback里的方法，需要来解析一下，分别是reportNewEdgeDrags()和checkTouchSlop()，先看reportNewEdgeDrags()：\n\n```\nprivate void reportNewEdgeDrags(float dx, float dy, int pointerId) {\n    int dragsStarted = 0;\n    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) {\n        dragsStarted |= EDGE_LEFT;\n    }\n    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) {\n        dragsStarted |= EDGE_TOP;\n    }\n    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) {\n        dragsStarted |= EDGE_RIGHT;\n    }\n    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) {\n        dragsStarted |= EDGE_BOTTOM;\n    }\n\n    if (dragsStarted != 0) {\n        mEdgeDragsInProgress[pointerId] |= dragsStarted;\n        mCallback.onEdgeDragStarted(dragsStarted, pointerId);\n    }\n}\n```\n\n这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在mEdgeDragsInProgress中，再调用Callback的onEdgeDragStarted(int edgeFlags, int pointerId)通知某个边缘开始产生拖动了。虽然reportNewEdgeDrags()会被调用很多次（因为processTouchEvent()的ACTION_MOVE部分会执行很多次），但mCallback.onEdgeDragStarted(dragsStarted, pointerId)只会调用一次，具体的要看checkNewEdgeDrag()这个方法：\n\n```\nprivate boolean checkNewEdgeDrag(float delta, float odelta, int pointerId, int edge) {\n    final float absDelta = Math.abs(delta);\n    final float absODelta = Math.abs(odelta);\n\n    if ((mInitialEdgesTouched[pointerId] & edge) != edge  || (mTrackingEdges & edge) == 0 ||\n            (mEdgeDragsLocked[pointerId] & edge) == edge ||\n            (mEdgeDragsInProgress[pointerId] & edge) == edge ||\n            (absDelta <= mTouchSlop && absODelta <= mTouchSlop)) {\n        return false;\n    }\n    if (absDelta < absODelta * 0.5f && mCallback.onEdgeLock(edge)) {\n        mEdgeDragsLocked[pointerId] |= edge;\n        return false;\n    }\n    return (mEdgeDragsInProgress[pointerId] & edge) == 0 && absDelta > mTouchSlop;\n}\n```\n\n- checkNewEdgeDrag()返回true表示在指定的edge（边缘）开始产生拖动了。\n- 方法的两个参数delta和odelta需要解释一下，odelta里的o应该代表opposite，这是什么意思呢，以reportNewEdgeDrags()里调用checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里delta为dx，odelta为dy，也就是说delta是指我们主要监测的方向上的变化，odelta是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。\n- mInitialEdgesTouched是在ACTION_DOWN部分的saveInitialMotion()里生成的，ACTION_DOWN发生时触摸到的边缘会被记录在mInitialEdgesTouched中。如果ACTION_DOWN发生时没有触摸到边缘，或者触摸到的边缘不是指定的edge，就直接返回false了。\n- mTrackingEdges是由setEdgeTrackingEnabled(int edgeFlags)设置的，当我们想要追踪监听边缘触摸时才需要调用setEdgeTrackingEnabled(int edgeFlags)，如果我们没有调用过它，这里就直接返回false了。\n- mEdgeDragsLocked它在这个方法里被引用了多次，它在整个ViewDragHelper里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行mEdgeDragsLocked[pointerId] & edge) == edge执行的结果是false。我们再跳到11到14行看看，absDelta < absODelta * 0.5f的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用Callback的onEdgeLock(edge)检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在mEdgeDragsInProgress里了，也不会收到Callback的onEdgeDragStarted()通知了。并且将锁定的边缘记录在mEdgeDragsLocked变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的edge被锁定，就直接返回false了。\n- 回到第7行的(mEdgeDragsInProgress[pointerId] & edge) == edge，mEdgeDragsInProgress是保存已发生过拖动事件的边缘的，如果给定的edge已经保存过了，那就没必要再检测其他东西了，直接返回false了。\n- 第8行(absDelta <= mTouchSlop && absODelta <= mTouchSlop)很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。\n- 最后一句返回的时候再次检查给定的edge有没有记录过，确保了每个边缘只会调用一次reportNewEdgeDrags的mCallback.onEdgeDragStarted(dragsStarted, pointerId)\n\n再来看checkTouchSlop()方法：\n\n```\n/**\n * Check if we've crossed a reasonable touch slop for the given child view.\n * If the child cannot be dragged along the horizontal or vertical axis, motion\n * along that axis will not count toward the slop check.\n *\n * @param child Child to check\n * @param dx Motion since initial position along X axis\n * @param dy Motion since initial position along Y axis\n * @return true if the touch slop has been crossed\n */\nprivate boolean checkTouchSlop(View child, float dx, float dy) {\n    if (child == null) {\n        return false;\n    }\n    final boolean checkHorizontal = mCallback.getViewHorizontalDragRange(child) > 0;\n    final boolean checkVertical = mCallback.getViewVerticalDragRange(child) > 0;\n\n    if (checkHorizontal && checkVertical) {\n        return dx * dx + dy * dy > mTouchSlop * mTouchSlop;\n    } else if (checkHorizontal) {\n        return Math.abs(dx) > mTouchSlop;\n    } else if (checkVertical) {\n        return Math.abs(dy) > mTouchSlop;\n    }\n    return false;\n}\n```\n\n这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（mTouchSlop）了，注意dx和dy指的是当前触摸点到ACTION_DOWN触摸到的点的距离。这里先检查Callback的getViewHorizontalDragRange(child)和getViewVerticalDragRange(child)是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在processTouchEvent()的ACTION_MOVE部分就不会调用tryCaptureViewForDrag()来捕获当前触摸到的View了，拖动也就没办法进行了。\n\n回到processTouchEvent()的ACTION_MOVE部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了Callback中的相关方法，让tryCaptureViewForDrag()正常的捕获到触摸到的View了，下一次ACTION_MOVE时就执行if部分的代码了，也就是开始不停的调用dragTo()对mCaptureView进行真正拖动了，看dragTo()方法：\n\n```\nprivate void dragTo(int left, int top, int dx, int dy) {\n    int clampedX = left;\n    int clampedY = top;\n    final int oldLeft = mCapturedView.getLeft();\n    final int oldTop = mCapturedView.getTop();\n    if (dx != 0) {\n        clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);\n        mCapturedView.offsetLeftAndRight(clampedX - oldLeft);\n    }\n    if (dy != 0) {\n        clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);\n        mCapturedView.offsetTopAndBottom(clampedY - oldTop);\n    }\n\n    if (dx != 0 || dy != 0) {\n        final int clampedDx = clampedX - oldLeft;\n        final int clampedDy = clampedY - oldTop;\n        mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,\n                clampedDx, clampedDy);\n    }\n}\n```\n\n参数dx和dy是前后两次ACTION_MOVE移动的距离，left和top分别为mCapturedView.getLeft() + dx, mCapturedView.getTop() + dy，也就是期望的移动后的坐标，对View的getLeft()等方法不理解的请参阅[Android View坐标getLeft, getRight, getTop, getBottom](http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html)。\n\n这里通过调用offsetLeftAndRight()和offsetTopAndBottom()来完成对mCapturedView移动，这两个是View中定义的方法，看它们的源码就知道内部是通过改变View的mLeft、mRight、mTop、mBottom，即改变View在父容器中的坐标位置，达到移动View的效果，所以如果调用mCapturedView的layout(int l, int t, int r, int b)方法也可以实现移动View的效果。\n\n具体要移动到哪里，由Callback的clampViewPositionHorizontal()和clampViewPositionVertical()来决定的，如果不想在水平方向上移动，在clampViewPositionHorizontal(View child, int left, int dx)里直接返回child.getLeft()就可以了，这样clampedX - oldLeft的值为0，这里调用mCapturedView.offsetLeftAndRight(clampedX - oldLeft)就不会起作用了。垂直方向上同理。\n\n最后会调用Callback的onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)通知捕获到的View位置改变了，并把最终的坐标（clampedX、clampedY）和最终的移动距离（clampedDx、 clampedDy）传递过去。\n\nACTION_MOVE部分就算告一段落了，接下来应该是用户松手触发ACTION_UP，或者是达到某个条件导致后续的ACTION_MOVE被mParentView的上层View给拦截了而收到ACTION_CANCEL，一起来看这两个部分：\n\n```\npublic void processTouchEvent(MotionEvent ev) {\n    // 省略\n\n    switch (action) {\n        // 省略其他case\n\n        case MotionEvent.ACTION_UP: {\n            if (mDragState == STATE_DRAGGING) {\n                releaseViewForPointerUp();\n            }\n            cancel();\n            break;\n        }\n\n        case MotionEvent.ACTION_CANCEL: {\n            if (mDragState == STATE_DRAGGING) {\n                dispatchViewReleased(0, 0);\n            }\n            cancel();\n            break;\n        }\n    }\n}\n```\n\n这两个部分都是重置所有的状态记录，并通知View被放开了，再看下releaseViewForPointerUp()和dispatchViewReleased()的源码：\n\n```\nprivate void releaseViewForPointerUp() {\n    mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity);\n    final float xvel = clampMag(\n            VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            mMinVelocity, mMaxVelocity);\n    final float yvel = clampMag(\n            VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n            mMinVelocity, mMaxVelocity);\n    dispatchViewReleased(xvel, yvel);\n}\n```\n\nreleaseViewForPointerUp()里也调用了dispatchViewReleased()，只不过传递了速率给它，这个速率就是由processTouchEvent()的mVelocityTracker追踪算出来的。再看dispatchViewReleased()：\n\n```\n/**\n * Like all callback events this must happen on the UI thread, but release\n * involves some extra semantics. During a release (mReleaseInProgress)\n * is the only time it is valid to call {@link #settleCapturedViewAt(int, int)}\n * or {@link #flingCapturedView(int, int, int, int)}.\n */\nprivate void dispatchViewReleased(float xvel, float yvel) {\n    mReleaseInProgress = true;\n    mCallback.onViewReleased(mCapturedView, xvel, yvel);\n    mReleaseInProgress = false;\n\n    if (mDragState == STATE_DRAGGING) {\n        // onViewReleased didn't call a method that would have changed this. Go idle.\n        setDragState(STATE_IDLE);\n    }\n}\n```\n\n这里调用Callback的onViewReleased(mCapturedView, xvel, yvel)通知外部捕获到的View被释放了，而在onViewReleased()前后有个mReleaseInProgress值得注意，注释里说唯一可以调用ViewDragHelper的settleCapturedViewAt()和flingCapturedView()的地方就是在Callback的onViewReleased()里了。\n\n首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。\nflingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（flingCapturedView的四个参数int minLeft, int minTop, int maxLeft, int maxTop可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用settleCapturedViewAt(int finalLeft, int finalTop)。\n\n为什么唯一可以调用settleCapturedViewAt()和flingCapturedView()的地方是Callback的onViewReleased()呢？看看它们的源码\n\n```\n/**\n * Settle the captured view at the given (left, top) position.\n * The appropriate velocity from prior motion will be taken into account.\n * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n * on each subsequent frame to continue the motion until it returns false. If this method\n * returns false there is no further work to do to complete the movement.\n *\n * @param finalLeft Settled left edge position for the captured view\n * @param finalTop Settled top edge position for the captured view\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\npublic boolean settleCapturedViewAt(int finalLeft, int finalTop) {\n    if (!mReleaseInProgress) {\n        throw new IllegalStateException(\"Cannot settleCapturedViewAt outside of a call to \" +\n                \"Callback#onViewReleased\");\n    }\n\n    return forceSettleCapturedViewAt(finalLeft, finalTop,\n            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));\n}\n\n/**\n * Settle the captured view based on standard free-moving fling behavior.\n * The caller should invoke {@link #continueSettling(boolean)} on each subsequent frame\n * to continue the motion until it returns false.\n *\n * @param minLeft Minimum X position for the view's left edge\n * @param minTop Minimum Y position for the view's top edge\n * @param maxLeft Maximum X position for the view's left edge\n * @param maxTop Maximum Y position for the view's top edge\n */\npublic void flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop) {\n    if (!mReleaseInProgress) {\n        throw new IllegalStateException(\"Cannot flingCapturedView outside of a call to \" +\n                \"Callback#onViewReleased\");\n    }\n\n    mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),\n            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n            minLeft, maxLeft, minTop, maxTop);\n\n    setDragState(STATE_SETTLING);\n}\n```\n\n这两个方法里一开始都会判断mReleaseInProgress为false，如果为false就会抛一个IllegalStateException异常，而mReleaseInProgress唯一为true的时候就是在dispatchViewReleased()里调用onViewReleased()的时候。\n\nScroller的用法请参阅[Android中滑屏实现----手把手教你如何实现触摸滑屏以及Scroller类详解](http://blog.csdn.net/qinjuning/article/details/7419207) ，或者自行解读Scroller源码，代码量不多。\n\nViewDragHelper还有一个移动View的方法是smoothSlideViewTo(View child, int finalLeft, int finalTop)，看下它的源码：\n\n```\n/**\n * Animate the view <code>child</code> to the given (left, top) position.\n * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n * on each subsequent frame to continue the motion until it returns false. If this method\n * returns false there is no further work to do to complete the movement.\n *\n * <p>This operation does not count as a capture event, though {@link #getCapturedView()}\n * will still report the sliding view while the slide is in progress.</p>\n *\n * @param child Child view to capture and animate\n * @param finalLeft Final left position of child\n * @param finalTop Final top position of child\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\npublic boolean smoothSlideViewTo(View child, int finalLeft, int finalTop) {\n    mCapturedView = child;\n    mActivePointerId = INVALID_POINTER;\n\n    boolean continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);\n    if (!continueSliding && mDragState == STATE_IDLE && mCapturedView != null) {\n        // If we're in an IDLE state to begin with and aren't moving anywhere, we\n        // end up having a non-null capturedView with an IDLE dragState\n        mCapturedView = null;\n    }\n\n    return continueSliding;\n}\n```\n\n可以看到它不受mReleaseInProgress的限制，所以可以在任何地方调用，效果和settleCapturedViewAt()类似，因为它们最终都调用了forceSettleCapturedViewAt()来启动自动滚动，区别在于settleCapturedViewAt()会以最后松手前的滑动速率为初速度将View滚动到最终位置，而smoothSlideViewTo()滚动的初速度是0。forceSettleCapturedViewAt()里有地方调用了Callback里的方法，所以再来看看这个方法：\n\n```\n/**\n * Settle the captured view at the given (left, top) position.\n *\n * @param finalLeft Target left position for the captured view\n * @param finalTop Target top position for the captured view\n * @param xvel Horizontal velocity\n * @param yvel Vertical velocity\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\nprivate boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {\n    final int startLeft = mCapturedView.getLeft();\n    final int startTop = mCapturedView.getTop();\n    final int dx = finalLeft - startLeft;\n    final int dy = finalTop - startTop;\n\n    if (dx == 0 && dy == 0) {\n        // Nothing to do. Send callbacks, be done.\n        mScroller.abortAnimation();\n        setDragState(STATE_IDLE);\n        return false;\n    }\n\n    final int duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);\n    mScroller.startScroll(startLeft, startTop, dx, dy, duration);\n\n    setDragState(STATE_SETTLING);\n    return true;\n}\n```\n\n可以看到自动滑动是靠Scroll类完成，在这里生成了调用mScroller.startScroll()需要的参数。再来看看计算滚动时间的方法computeSettleDuration()：\n\n```\nprivate int computeSettleDuration(View child, int dx, int dy, int xvel, int yvel) {\n    xvel = clampMag(xvel, (int) mMinVelocity, (int) mMaxVelocity);\n    yvel = clampMag(yvel, (int) mMinVelocity, (int) mMaxVelocity);\n    final int absDx = Math.abs(dx);\n    final int absDy = Math.abs(dy);\n    final int absXVel = Math.abs(xvel);\n    final int absYVel = Math.abs(yvel);\n    final int addedVel = absXVel + absYVel;\n    final int addedDistance = absDx + absDy;\n\n    final float xweight = xvel != 0 ? (float) absXVel / addedVel :\n            (float) absDx / addedDistance;\n    final float yweight = yvel != 0 ? (float) absYVel / addedVel :\n            (float) absDy / addedDistance;\n\n    int xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));\n    int yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));\n\n    return (int) (xduration * xweight + yduration * yweight);\n}\n```\n\nclampMag()方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过computeAxisDuration()算出来，通过它的参数可以看到最终的滚动时间是由dx、xvel、mCallback.getViewHorizontalDragRange()共同影响的。看computeAxisDuration()：\n\n```\nprivate int computeAxisDuration(int delta, int velocity, int motionRange) {\n    if (delta == 0) {\n        return 0;\n    }\n\n    final int width = mParentView.getWidth();\n    final int halfWidth = width / 2;\n    final float distanceRatio = Math.min(1f, (float) Math.abs(delta) / width);\n    final float distance = halfWidth + halfWidth *\n            distanceInfluenceForSnapDuration(distanceRatio);\n\n    int duration;\n    velocity = Math.abs(velocity);\n    if (velocity > 0) {\n        duration = 4 * Math.round(1000 * Math.abs(distance / velocity));\n    } else {\n        final float range = (float) Math.abs(delta) / motionRange;\n        duration = (int) ((range + 1) * BASE_SETTLE_DURATION);\n    }\n    return Math.min(duration, MAX_SETTLE_DURATION);\n}\n```\n\n6~10行没看明白，直接看14~19行，如果给定的速率velocity不为0，就通过距离除以速率来算出时间；如果velocity为0，就通过要滑动的距离（delta）除以总的移动范围（motionRange，就是Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过MAX_SETTLE_DURATION的，源码里的取值是600毫秒，所以不用担心在Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回错误的数而导致自动滚动时间过长了。\n\n在调用settleCapturedViewAt()、flingCapturedView()和smoothSlideViewTo()时，还需要实现mParentView的computeScroll()：\n\n```\n@Override\npublic void computeScroll() {\n    if (mDragHelper.continueSettling(true)) {\n        ViewCompat.postInvalidateOnAnimation(this);\n    }\n}\n```\n\n这属于Scroll类用法的范畴，不明白的请参阅[Android中滑屏实现----手把手教你如何实现触摸滑屏以及Scroller类详解](http://blog.csdn.net/qinjuning/article/details/7419207) 的“知识点二： computeScroll(）方法介绍”。\n\n至此，整个触摸流程和ViewDragHelper的重要的方法都过了一遍。之前在讨论shouldInterceptTouchEvent()的ACTION_DOWN部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次ACTION_DOWN事件的情况，现在来看看这种情况。\n\n假设现在shouldInterceptTouchEvent()的ACTION_DOWN部分执行完了，也有子View消费了这次的ACTION_DOWN事件，那么接下来就会调用mParentView的onInterceptTouchEvent()的ACTION_MOVE部分，不明白为什么的请参阅[Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制](http://blog.csdn.net/xiaanming/article/details/21696315)，接着调用ViewDragHelper的shouldInterceptTouchEvent()的ACTION_MOVE部分：\n\n```\npublic boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    // 省略...\n    \n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_MOVE: {\n            // First to cross a touch slop over a draggable view wins. Also report edge drags.\n            final int pointerCount = MotionEventCompat.getPointerCount(ev);\n            for (int i = 0; i < pointerCount; i++) {\n                final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                final float x = MotionEventCompat.getX(ev, i);\n                final float y = MotionEventCompat.getY(ev, i);\n                final float dx = x - mInitialMotionX[pointerId];\n                final float dy = y - mInitialMotionY[pointerId];\n\n                final View toCapture = findTopChildUnder((int) x, (int) y);\n                final boolean pastSlop = toCapture != null && checkTouchSlop(toCapture, dx, dy);\n                if (pastSlop) {\n                    // check the callback's\n                    // getView[Horizontal|Vertical]DragRange methods to know\n                    // if you can move at all along an axis, then see if it\n                    // would clamp to the same value. If you can't move at\n                    // all in every dimension with a nonzero range, bail.\n                    final int oldLeft = toCapture.getLeft();\n                    final int targetLeft = oldLeft + (int) dx;\n                    final int newLeft = mCallback.clampViewPositionHorizontal(toCapture,\n                            targetLeft, (int) dx);\n                    final int oldTop = toCapture.getTop();\n                    final int targetTop = oldTop + (int) dy;\n                    final int newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,\n                            (int) dy);\n                    final int horizontalDragRange = mCallback.getViewHorizontalDragRange(\n                            toCapture);\n                    final int verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);\n                    if ((horizontalDragRange == 0 || horizontalDragRange > 0\n                            && newLeft == oldLeft) && (verticalDragRange == 0\n                            || verticalDragRange > 0 && newTop == oldTop)) {\n                        break;\n                    }\n                }\n                reportNewEdgeDrags(dx, dy, pointerId);\n                if (mDragState == STATE_DRAGGING) {\n                    // Callback might have started an edge drag\n                    break;\n                }\n\n                if (pastSlop && tryCaptureViewForDrag(toCapture, pointerId)) {\n                    break;\n                }\n            }\n            saveLastMotion(ev);\n            break;\n        }\n\n        // 省略其他case...\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n```\n\n如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用findTopChildUnder(int x, int y)寻找触摸点处的子View，再用checkTouchSlop(View child, float dx, float dy)检查当前触摸点到ACTION_DOWN触摸点的距离是否达到了mTouchSlop，达到了才会去捕获View。\n接着看19~41行if (pastSlop){...}部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到getView[Horizontal|Vertical]DragRange和clampViewPosition[Horizontal|Vertical]四个方法。如果getView[Horizontal|Vertical]DragRange返回都是0，就会认作是不会产生拖动。clampViewPosition[Horizontal|Vertical]返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接break，不会执行后续的代码，而后续代码里有调用tryCaptureViewForDrag()，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。\n如果检查到可以在某个方向上进行拖动，就会调用后面的tryCaptureViewForDrag()捕获子View，如果捕获成功，mDragState就会变成STATE_DRAGGING，shouldInterceptTouchEvent()返回true，mParentView的onInterceptTouchEvent()返回true，后续的移动事件就会在mParentView的onTouchEvent()执行了，最后执行的就是mParentView的processTouchEvent()的ACTION_MOVE部分，拖动正常进行。\n\n回头再看之前在shouldInterceptTouchEvent()的ACTION_DOWN部分留下的坑：\n\n```\npublic boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    // 省略其他部分...\n    \n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_DOWN: {\n            // 省略其他部分...\n            \n            // Catch a settling view if possible.\n            if (toCapture == mCapturedView && mDragState == STATE_SETTLING) {\n                tryCaptureViewForDrag(toCapture, pointerId);\n            }\n            \n            // 省略其他部分...\n        }\n\n        // 省略其他case...\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n```\n\n现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的tryCaptureViewForDrag()尝试捕获View，如果捕获成功，mDragState就变为STATE_DRAGGING了，shouldInterceptTouchEvent()就返回true了，然后就是mParentView的onInterceptTouchEvent()返回true，接着执行mParentView的onTouchEvent()，再执行processTouchEvent()的ACTION_DOWN部分。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动。\n\n至此整个事件传递流程和ViewDragHelper的重要方法基本都解析完了，shouldInterceptTouchEvent()和processTouchEvent()的ACTION_POINTER_DOWN、ACTION_POINTER_UP部分就留给读者自己解析了。\n\n### 总结\n\n对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。\n\n- [单点触摸，没有考虑边缘滑动检测的最简流程图](http://www.processon.com/view/link/5550a7bae4b09739f465ec64)\n- [单点触摸，考虑了边缘滑动检测的流程图](http://www.processon.com/view/link/5550d3dce4b09739f46789bd)\n\n多点触摸情况我就没研究了，在这里忽略~\n\n三个开启自动滚动的方法：\n\n- settleCapturedViewAt(int finalLeft, int finalTop)\n  以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在Callback的onViewReleased()中调用。\n- flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)\n  以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在Callback的onViewReleased()中调用。\n- smoothSlideViewTo(View child, int finalLeft, int finalTop)\n  指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。\n\nCallback的各个方法总结：\n\n- void onViewDragStateChanged(int state)\n\n  拖动状态改变时会调用此方法，状态state有STATE_IDLE、STATE_DRAGGING、STATE_SETTLING三种取值。\n\n  它在setDragState()里被调用，而setDragState()被调用的地方有\n\n  - tryCaptureViewForDrag()成功捕获到子View时\n    - shouldInterceptTouchEvent()的ACTION_DOWN部分捕获到\n    - shouldInterceptTouchEvent()的ACTION_MOVE部分捕获到\n    - processTouchEvent()的ACTION_MOVE部分捕获到\n  - 调用settleCapturedViewAt()、smoothSlideViewTo()、flingCapturedView()时\n  - 拖动View松手时（processTouchEvent()的ACTION_UP、ACTION_CANCEL）\n  - 自动滚动停止时（continueSettling()里检测到滚动结束时）\n  - 外部调用abort()时\n\n- void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)\n\n  正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。\n\n  - 在dragTo()里被调用（正在被拖动时）\n  - 在continueSettling()里被调用（自动滚动时）\n  - 外部调用abort()时被调用\n\n- void onViewCaptured(View capturedChild, int activePointerId)\n\n  tryCaptureViewForDrag()成功捕获到子View时会调用此方法。\n\n  - 在shouldInterceptTouchEvent()的ACTION_DOWN里成功捕获\n  - 在shouldInterceptTouchEvent()的ACTION_MOVE里成功捕获\n  - 在processTouchEvent()的ACTION_MOVE里成功捕获\n  - 手动调用captureChildView()\n\n- void onViewReleased(View releasedChild, float xvel, float yvel)\n  拖动View松手时（processTouchEvent()的ACTION_UP）或被父View拦截事件时（processTouchEvent()的ACTION_CANCEL）会调用此方法。\n\n- void onEdgeTouched(int edgeFlags, int pointerId)\n  ACTION_DOWN或ACTION_POINTER_DOWN事件发生时如果触摸到监听的边缘会调用此方法。edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。\n\n- boolean onEdgeLock(int edgeFlags)\n  返回true表示锁定edgeFlags对应的边缘，锁定后的那些边缘就不会在onEdgeDragStarted()被通知了，默认返回false不锁定给定的边缘，edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM其中之一。\n\n- void onEdgeDragStarted(int edgeFlags, int pointerId)\n  ACTION_MOVE事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。edgeFlags取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。可在此手动调用captureChildView()触发从边缘拖动子View的效果。\n\n- int getOrderedChildIndex(int index)\n  在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给tryCaptureViewForDrag()来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。\n\n- int getViewHorizontalDragRange(View child)、int getViewVerticalDragRange(View child)\n\n  返回给定的child在相应的方向上可以被拖动的最远距离，默认返回0。ACTION_DOWN发生时，若触摸点处的child消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。\n\n  被调用的地方有三处：\n\n  - 在checkTouchSlop()中被调用，返回值大于0才会去检查mTouchSlop。在ACTION_MOVE里调用tryCaptureViewForDrag()之前会调用checkTouchSlop()。如果checkTouchSlop()失败，就不会去捕获View了。\n  - 如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。\n  - 在调用smoothSlideViewTo()时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在getView[Horizontal|Vertical]DragRange里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。\n\n- boolean tryCaptureView(View child, int pointerId)\n\n  在tryCaptureViewForDrag()中被调用，返回true表示捕获给定的child。tryCaptureViewForDrag()被调用的地方有\n\n  - shouldInterceptTouchEvent()的ACTION_DOWN里\n  - shouldInterceptTouchEvent()的ACTION_MOVE里\n  - processTouchEvent()的ACTION_MOVE里\n\n- int clampViewPositionHorizontal(View child, int left, int dx)、int clampViewPositionVertical(View child, int top, int dy)\n\n  child在某方向上被拖动时会调用对应方法，返回值是child移动过后的坐标位置，clampViewPositionHorizontal()返回child移动过后的left值，clampViewPositionVertical()返回child移动过后的top值。\n\n  两个方法被调用的地方有两处：\n\n  - 在dragTo()中被调用，dragTo()在processTouchEvent()的ACTION_MOVE里被调用。用来获取被拖动的View要移动到的位置。\n  - 如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。\n\n### 案例参考\n\n在这里列举一部分对ViewDragHelper的应用案例，大家自己剖析它们的源码来实践巩固。\n\n1. [YoutubeLayout](https://github.com/flavienlaurent/flavienlaurent.com)，这是最简单的Demo\n2. [QQ5.x侧滑菜单](https://github.com/BlueMor/DragLayout)、[ResideLayout](https://github.com/kyze8439690/ResideLayout)\n3. [SwipeBackLayout](https://github.com/ikew0ng/SwipeBackLayout)、[SwipeBack](https://github.com/liuguangqiang/SwipeBack)\n4. [SlidingUpPanel](https://github.com/umano/AndroidSlidingUpPanel)\n5. [DrawerLayout](https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java)\n\n### 其他关于ViewDragHelper的分析文章\n\n- [Each Navigation Drawer Hides a ViewDragHelper](http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper)，文中的源码就是上面的[YoutubeLayout](https://github.com/flavienlaurent/flavienlaurent.com)\n- [ViewDragHelper详解](http://blog.csdn.net/pi9nc/article/details/39583377)，这是上面文章的简略中文版","slug":"ViewDragHelper-source-code","published":1,"updated":"2019-05-13T12:43:31.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yl86fi0022lh1p3v9rraqn","content":"<p><a href=\"https://www.cnblogs.com/lqstayreal/p/4500219.html\" target=\"_blank\" rel=\"noopener\">这文章是转来的，写的实在是好，怕哪天失踪了……</a></p>\n<a id=\"more\"></a>\n<p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，ViewDragHelper的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p>\n<p>要想完全掌握ViewDragHelper的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾ViewDragHelper的原理、用法、注意事项等。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><ol>\n<li><p>在自定义ViewGroup的构造方法里调用ViewDragHelper的静态工厂方法create()创建ViewDragHelper实例</p>\n</li>\n<li><p>实现ViewDragHelper.Callback</p>\n<p>最重要的几个方法是tryCaptureView()、clampViewPositionVertical()、clampViewPositionHorizontal()、getViewHorizontalDragRange()、getViewVerticalDragRange()</p>\n<ul>\n<li>tryCaptureView()里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回true，否则返回false。</li>\n<li>clampViewPositionVertical()决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。</li>\n<li>clampViewPositionHorizontal()与clampViewPositionVertical()同理，只不过是发生在水平方向上，最终返回的是View的left值。</li>\n<li>getViewVerticalDragRange()要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。</li>\n<li>getViewHorizontalDragRange()与getViewVerticalDragRange()同理，只不过是发生在水平方向上。</li>\n</ul>\n</li>\n<li><p>在onInterceptTouchEvent()方法里调用并返回ViewDragHelper的shouldInterceptTouchEvent()方法</p>\n</li>\n<li><p>在onTouchEvent()方法里调用ViewDragHelper()的processTouchEvent()方法。ACTION_DOWN事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在onTouchEvent()返回true，否则将收不到后续事件，不会产生拖动。</p>\n</li>\n<li><p>上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的computeScroll()方法，方法实现如下：</p>\n<pre><code> @Override\n public void computeScroll() {\n     if (mDragHelper.continueSettling(true)) {\n         postInvalidate();\n     }\n }\n</code></pre><p>并在ViewDragHelper.Callback的onViewReleased()方法里调用settleCapturedViewAt()、flingCapturedView()，或在任意地方调用smoothSlideViewTo()方法。</p>\n</li>\n<li><p>如果要实现边缘拖动的效果，需要调用ViewDragHelper的setEdgeTrackingEnabled()方法，注册想要监听的边缘。然后实现ViewDragHelper.Callback里的onEdgeDragStarted()方法，在此手动调用captureChildView()传递要拖动的子View。</p>\n</li>\n</ol>\n<p>具体的使用Demo请见最后面公布的几个案例。</p>\n<h3 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h3><p>ViewDragHelper的完整源码可在<a href=\"https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java\" target=\"_blank\" rel=\"noopener\">GitHub</a>或<a href=\"http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper\" target=\"_blank\" rel=\"noopener\">GrepCode</a>上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。</p>\n<h4 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h4><ol>\n<li>了解View的坐标系统，<a href=\"http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html\" target=\"_blank\" rel=\"noopener\">Android View坐标getLeft, getRight, getTop, getBottom</a></li>\n<li>了解MotionEvent中关于多点触控的机制，<a href=\"http://my.oschina.net/banxi/blog/56421\" target=\"_blank\" rel=\"noopener\">android触控,先了解MotionEvent(一)</a></li>\n<li>了解Scroller类原理，<a href=\"http://blog.csdn.net/qinjuning/article/details/7419207\" target=\"_blank\" rel=\"noopener\">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a></li>\n<li>了解Touch事件的分发机制，<a href=\"http://blog.csdn.net/xiaanming/article/details/21696315\" target=\"_blank\" rel=\"noopener\">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a></li>\n</ol>\n<h4 id=\"ViewDragHelper实例的创建\"><a href=\"#ViewDragHelper实例的创建\" class=\"headerlink\" title=\"ViewDragHelper实例的创建\"></a>ViewDragHelper实例的创建</h4><p>ViewDragHelper重载了两个create()静态方法，先看两个参数的create()方法：</p>\n<pre><code>/**\n * Factory method to create a new ViewDragHelper.\n *\n * @param forParent Parent view to monitor\n * @param cb Callback to provide information and receive events\n * @return a new ViewDragHelper instance\n */\npublic static ViewDragHelper create(ViewGroup forParent, Callback cb) {\n    return new ViewDragHelper(forParent.getContext(), forParent, cb);\n}\n</code></pre><p>create()的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。create()直接调用了ViewDragHelper构造方法，我们再来看看这个构造方法。</p>\n<pre><code>/**\n * Apps should use ViewDragHelper.create() to get a new instance.\n * This will allow VDH to use internal compatibility implementations for different\n * platform versions.\n *\n * @param context Context to initialize config-dependent params from\n * @param forParent Parent view to monitor\n */\nprivate ViewDragHelper(Context context, ViewGroup forParent, Callback cb) {\n    if (forParent == null) {\n        throw new IllegalArgumentException(&quot;Parent view may not be null&quot;);\n    }\n    if (cb == null) {\n        throw new IllegalArgumentException(&quot;Callback may not be null&quot;);\n    }\n\n    mParentView = forParent;\n    mCallback = cb;\n\n    final ViewConfiguration vc = ViewConfiguration.get(context);\n    final float density = context.getResources().getDisplayMetrics().density;\n    mEdgeSize = (int) (EDGE_SIZE * density + 0.5f);\n\n    mTouchSlop = vc.getScaledTouchSlop();\n    mMaxVelocity = vc.getScaledMaximumFlingVelocity();\n    mMinVelocity = vc.getScaledMinimumFlingVelocity();\n    mScroller = ScrollerCompat.create(context, sInterpolator);\n}\n</code></pre><p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过create()工厂方法来创建ViewDragHelper实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p>\n<ul>\n<li>mParentView和mCallback分别保存传递过来的对应参数</li>\n<li>ViewConfiguration类里定义了View相关的一系列时间、大小、距离等常量</li>\n<li>mEdgeSize表示边缘触摸的范围。例如mEdgeSize为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于mParentView.getLeft() + mEdgeSize时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见ViewDragHelper的getEdgesTouched()方法。</li>\n<li>mTouchSlop是一个很小的距离值，只有在前后两次触摸点的距离超过mTouchSlop的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。</li>\n<li>mMaxVelocity、mMinVelocity是fling时的最大、最小速率，单位是像素每秒。</li>\n<li>mScroller是View滚动的辅助类，该类的详细解析参见下面几篇文章<ul>\n<li><a href=\"http://blog.csdn.net/qinjuning/article/details/7419207\" target=\"_blank\" rel=\"noopener\">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a></li>\n<li><a href=\"http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html\" target=\"_blank\" rel=\"noopener\">Android中Scroller类的分析</a></li>\n</ul>\n</li>\n</ul>\n<p>再看三个参数的create()方法：</p>\n<pre><code>/**\n * Factory method to create a new ViewDragHelper.\n *\n * @param forParent Parent view to monitor\n * @param sensitivity Multiplier for how sensitive the helper should be about detecting\n *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.\n * @param cb Callback to provide information and receive events\n * @return a new ViewDragHelper instance\n */\npublic static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {\n    final ViewDragHelper helper = create(forParent, cb);\n    helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity));\n    return helper;\n}\n</code></pre><p>第二个参数sensitivity是用来调节mTouchSlop的值。sensitivity越大，mTouchSlop越小，对滑动的检测就越敏感。例如sensitivity为1时，前后触摸点距离超过20dp才进行滑动处理，现在sensitivity为2的话，前后触摸点距离超过10dp就进行处理了。</p>\n<h4 id=\"对Touch事件的处理\"><a href=\"#对Touch事件的处理\" class=\"headerlink\" title=\"对Touch事件的处理\"></a>对Touch事件的处理</h4><p>当mParentView（自定义ViewGroup）被触摸时，首先会调用mParentView的onInterceptTouchEvent(MotionEvent ev)，接着就调用shouldInterceptTouchEvent(MotionEvent ev) ，所以先来看看这个方法的ACTION_DOWN部分：</p>\n<pre><code>/**\n * Check if this event as provided to the parent view&#39;s onInterceptTouchEvent should\n * cause the parent to intercept the touch event stream.\n *\n * @param ev MotionEvent provided to onInterceptTouchEvent\n * @return true if the parent view should return true from onInterceptTouchEvent\n */\npublic boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    final int action = MotionEventCompat.getActionMasked(ev);\n    final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n    if (action == MotionEvent.ACTION_DOWN) {\n        // Reset things for a new event stream, just in case we didn&#39;t get\n        // the whole previous stream.\n        cancel();\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n            saveInitialMotion(x, y, pointerId);\n\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n\n            // Catch a settling view if possible.\n            if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) {\n                tryCaptureViewForDrag(toCapture, pointerId);\n            }\n\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched &amp; mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);\n            }\n            break;\n        }\n\n        // 其他case暂且省略\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n</code></pre><p>看9~21行，首先是关于多点触控（MotionEvent的actionIndex、ACTION_POINTER_DOWN 等概念），不明白的请参阅<a href=\"http://my.oschina.net/banxi/blog/56421\" target=\"_blank\" rel=\"noopener\">android触控,先了解MotionEvent(一)</a>。</p>\n<p>mVelocityTracker记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生ACTION_DOWN事件都会调用cancel()，而在cancel()方法里mVelocityTracker又被清空了，所以mVelocityTracker 记录下的是本次ACTION_DOWN事件直至ACTION_UP事件发生后（下次ACTION_DOWN事件发生前）的所有触摸点的信息。</p>\n<p>再来看24~42行case MotionEvent.ACTION_DOWN部分，先是调用saveInitialMotion(x, y, pointerId)保存手势的初始信息，即ACTION_DOWN发生时的触摸点坐标（x、y）、触摸手指编号（pointerId），如果触摸到了mParentView的边缘还会记录触摸的是哪个边缘。接着调用findTopChildUnder((int) x, (int) y);来获取当前触摸点下最顶层的子View，看findTopChildUnder 的源码：</p>\n<pre><code>/**\n * Find the topmost child under the given point within the parent view&#39;s coordinate system.\n * The child order is determined using {@link Callback#getOrderedChildIndex(int)}.\n *\n * @param x X position to test in the parent&#39;s coordinate system\n * @param y Y position to test in the parent&#39;s coordinate system\n * @return The topmost child view under (x, y) or null if none found.\n */\npublic View findTopChildUnder(int x, int y) {\n    final int childCount = mParentView.getChildCount();\n    for (int i = childCount - 1; i &gt;= 0; i--) {\n        final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));\n        if (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;\n                y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) {\n            return child;\n        }\n    }\n    return null;\n}\n</code></pre><p>代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现Callback里的getOrderedChildIndex(int index)方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（getOrderedChildIndex()默认直接返回index），会选择到topView，要想让bottomView被选中就得这么写：</p>\n<pre><code>public int getOrderedChildIndex(int index) {\n    int indexTop = mParentView.indexOfChild(topView);\n    int indexBottom = mParentView.indexOfChild(bottomView);\n    if (index == indexTop) {\n        return indexBottom;\n    }\n    return index;\n}\n</code></pre><p>32~35行，这里还看到了一个mDragState成员变量，它共有三种取值：</p>\n<ol>\n<li>STATE_IDLE：所有的View处于静止空闲状态</li>\n<li>STATE_DRAGGING：某个View正在被用户拖动（用户正在与设备交互）</li>\n<li>STATE_SETTLING：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中<br>mCapturedView默认为null，所以一开始不会执行这里的代码，mDragState处于STATE_SETTLING状态时才会执行tryCaptureViewForDrag()，执行的情况到后面再分析，这里先跳过。</li>\n</ol>\n<p>37~40行调用了Callback.onEdgeTouched向外部通知mParentView的某些边缘被触摸到了，mInitialEdgesTouched是在刚才调用过的saveInitialMotion方法里进行赋值的。</p>\n<p>ACTION_DOWN 部分处理完了，跳过switch语句块，剩下的代码就只有return mDragState == STATE_DRAGGING;。在ACTION_DOWN部分没有对mDragState进行赋值，其默认值为STATE_IDLE，所以此处返回false。</p>\n<p>那么返回false后接下来应该是会调用哪个方法呢，根据<a href=\"http://blog.csdn.net/xiaanming/article/details/21696315\" target=\"_blank\" rel=\"noopener\">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>里的解析，接下来会在mParentView的所有子View中寻找响应这个Touch事件的View（会调用每个子View的dispatchTouchEvent()方法，dispatchTouchEvent里一般又会调用onTouchEvent()）；</p>\n<ul>\n<li>如果没有子View消费这次事件（子View的dispatchTouchEvent()返回都是false），会调用mParentView的super.dispatchTouchEvent(ev)，即View中的dispatchTouchEvent(ev)，然后调用mParentView的onTouchEvent()方法，再调用ViewDragHelper的processTouchEvent(MotionEvent ev)方法。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动（除了ACTION_DOWN外的其他事件发生时返回true或false都不会影响接下来的事件接受），因为拖动的相关代码是写在processTouchEvent()里的ACTION_MOVE部分的。要注意的是返回true后mParentView的onInterceptTouchEvent()就不会收到后续的ACTION_MOVE、ACTION_UP等事件了。</li>\n<li>如果有子View消费了本次ACTION_DOWN事件，mParentView的onTouchEvent()就收不到ACTION_DOWN事件了，也就是ViewDragHelper的processTouchEvent(MotionEvent ev)收不到ACTION_DOWN事件了。不过只要该View没有调用过requestDisallowInterceptTouchEvent(true)，mParentView的onInterceptTouchEvent()的ACTION_MOVE部分还是会执行的，如果在此时返回了true拦截了ACTION_MOVE事件，processTouchEvent()里的ACTION_MOVE部分也就会正常执行，拖动也就没问题了。onInterceptTouchEvent()的ACTION_MOVE部分具体做了怎样的处理，稍后再来解析。</li>\n</ul>\n<p>接下来对这两种情况逐一解析。</p>\n<p>假设没有子View消费这次事件，根据刚才的分析最终就会调用processTouchEvent(MotionEvent ev)的ACTION_DOWN部分：</p>\n<pre><code>/**\n * Process a touch event received by the parent view. This method will dispatch callback events\n * as needed before returning. The parent view&#39;s onTouchEvent implementation should call this.\n *\n * @param ev The touch event received by the parent view\n */\npublic void processTouchEvent(MotionEvent ev) {\n    final int action = MotionEventCompat.getActionMasked(ev);\n    final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n    if (action == MotionEvent.ACTION_DOWN) {\n        // Reset things for a new event stream, just in case we didn&#39;t get\n        // the whole previous stream.\n        cancel();\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n\n            saveInitialMotion(x, y, pointerId);\n\n            // Since the parent is already directly processing this touch event,\n            // there is no reason to delay for a slop before dragging.\n            // Start immediately if possible.\n            tryCaptureViewForDrag(toCapture, pointerId);\n\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched &amp; mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);\n            }\n            break;\n        }\n        // 其他case暂且省略\n    }\n}\n</code></pre><p>这段代码跟shouldInterceptTouchEvent()里ACTION_DOWN那部分基本一致，唯一区别就是这里没有约束条件直接调用了tryCaptureViewForDrag()方法，现在来看看这个方法：</p>\n<pre><code>/**\n * Attempt to capture the view with the given pointer ID. The callback will be involved.\n * This will put us into the &quot;dragging&quot; state. If we&#39;ve already captured this view with\n * this pointer this method will immediately return true without consulting the callback.\n *\n * @param toCapture View to capture\n * @param pointerId Pointer to capture with\n * @return true if capture was successful\n */\nboolean tryCaptureViewForDrag(View toCapture, int pointerId) {\n    if (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) {\n        // Already done!\n        return true;\n    }\n    if (toCapture != null &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) {\n        mActivePointerId = pointerId;\n        captureChildView(toCapture, pointerId);\n        return true;\n    }\n    return false;\n}\n</code></pre><p>这里调用了Callback的tryCaptureView(View child, int pointerId)方法，把当前触摸到的View和触摸手指编号传递了过去，在tryCaptureView()中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在tryCaptureView()中返回true，让ViewDragHelper把当前触摸的View捕获下来，接着就调用了captureChildView(toCapture, pointerId)方法：</p>\n<pre><code>/**\n * Capture a specific child view for dragging within the parent. The callback will be notified\n * but {@link Callback#tryCaptureView(android.view.View, int)} will not be asked permission to\n * capture this view.\n *\n * @param childView Child view to capture\n * @param activePointerId ID of the pointer that is dragging the captured child view\n */\npublic void captureChildView(View childView, int activePointerId) {\n    if (childView.getParent() != mParentView) {\n        throw new IllegalArgumentException(&quot;captureChildView: parameter must be a descendant &quot; +\n                &quot;of the ViewDragHelper&#39;s tracked parent view (&quot; + mParentView + &quot;)&quot;);\n    }\n\n    mCapturedView = childView;\n    mActivePointerId = activePointerId;\n    mCallback.onViewCaptured(childView, activePointerId);\n    setDragState(STATE_DRAGGING);\n}\n</code></pre><p>代码很简单，在captureChildView(toCapture, pointerId)中将要拖动的View和触摸的手指编号记录下来，并调用Callback的onViewCaptured(childView, activePointerId)通知外部有子View被捕获到了，再调用setDragState()设置当前的状态为STATE_DRAGGING，看setDragState()源码：</p>\n<pre><code>void setDragState(int state) {\n    if (mDragState != state) {\n        mDragState = state;\n        mCallback.onViewDragStateChanged(state);\n        if (mDragState == STATE_IDLE) {\n            mCapturedView = null;\n        }\n    }\n}\n</code></pre><p>状态改变后会调用Callback的onViewDragStateChanged()通知状态的变化。</p>\n<p>假设ACTION_DOWN发生后在mParentView的onTouchEvent()返回了true，接下来就会执行ACTION_MOVE部分：</p>\n<pre><code>public void processTouchEvent(MotionEvent ev) {\n\n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_MOVE: {\n            if (mDragState == STATE_DRAGGING) {\n                final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, index);\n                final float y = MotionEventCompat.getY(ev, index);\n                final int idx = (int) (x - mLastMotionX[mActivePointerId]);\n                final int idy = (int) (y - mLastMotionY[mActivePointerId]);\n\n                dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);\n\n                saveLastMotion(ev);\n            } else {\n                // Check to see if any pointer is now over a draggable view.\n                final int pointerCount = MotionEventCompat.getPointerCount(ev);\n                for (int i = 0; i &lt; pointerCount; i++) {\n                    final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                    final float x = MotionEventCompat.getX(ev, i);\n                    final float y = MotionEventCompat.getY(ev, i);\n                    final float dx = x - mInitialMotionX[pointerId];\n                    final float dy = y - mInitialMotionY[pointerId];\n\n                    reportNewEdgeDrags(dx, dy, pointerId);\n                    if (mDragState == STATE_DRAGGING) {\n                        // Callback might have started an edge drag.\n                        break;\n                    }\n\n                    final View toCapture = findTopChildUnder((int) x, (int) y);\n                    if (checkTouchSlop(toCapture, dx, dy) &amp;&amp;\n                            tryCaptureViewForDrag(toCapture, pointerId)) {\n                        break;\n                    }\n                }\n                saveLastMotion(ev);\n            }\n            break;\n        }\n\n        // 省略其他case...\n    }\n}\n</code></pre><p>要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断mDragState是否为STATE_DRAGGING，而唯一调用setDragState(STATE_DRAGGING)的地方就是tryCaptureViewForDrag()了，刚才在ACTION_DOWN里调用过tryCaptureViewForDrag()，现在又要分两种情况。<br>如果刚才在ACTION_DOWN里捕获到要拖动的View，那么就执行if部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，mDragState依然是STATE_IDLE，然后会执行else部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让mDragState变为STATE_DRAGGING，之后就会执行if部分的代码了。这里还有两个方法涉及到了Callback里的方法，需要来解析一下，分别是reportNewEdgeDrags()和checkTouchSlop()，先看reportNewEdgeDrags()：</p>\n<pre><code>private void reportNewEdgeDrags(float dx, float dy, int pointerId) {\n    int dragsStarted = 0;\n    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) {\n        dragsStarted |= EDGE_LEFT;\n    }\n    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) {\n        dragsStarted |= EDGE_TOP;\n    }\n    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) {\n        dragsStarted |= EDGE_RIGHT;\n    }\n    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) {\n        dragsStarted |= EDGE_BOTTOM;\n    }\n\n    if (dragsStarted != 0) {\n        mEdgeDragsInProgress[pointerId] |= dragsStarted;\n        mCallback.onEdgeDragStarted(dragsStarted, pointerId);\n    }\n}\n</code></pre><p>这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在mEdgeDragsInProgress中，再调用Callback的onEdgeDragStarted(int edgeFlags, int pointerId)通知某个边缘开始产生拖动了。虽然reportNewEdgeDrags()会被调用很多次（因为processTouchEvent()的ACTION_MOVE部分会执行很多次），但mCallback.onEdgeDragStarted(dragsStarted, pointerId)只会调用一次，具体的要看checkNewEdgeDrag()这个方法：</p>\n<pre><code>private boolean checkNewEdgeDrag(float delta, float odelta, int pointerId, int edge) {\n    final float absDelta = Math.abs(delta);\n    final float absODelta = Math.abs(odelta);\n\n    if ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == 0 ||\n            (mEdgeDragsLocked[pointerId] &amp; edge) == edge ||\n            (mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||\n            (absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) {\n        return false;\n    }\n    if (absDelta &lt; absODelta * 0.5f &amp;&amp; mCallback.onEdgeLock(edge)) {\n        mEdgeDragsLocked[pointerId] |= edge;\n        return false;\n    }\n    return (mEdgeDragsInProgress[pointerId] &amp; edge) == 0 &amp;&amp; absDelta &gt; mTouchSlop;\n}\n</code></pre><ul>\n<li>checkNewEdgeDrag()返回true表示在指定的edge（边缘）开始产生拖动了。</li>\n<li>方法的两个参数delta和odelta需要解释一下，odelta里的o应该代表opposite，这是什么意思呢，以reportNewEdgeDrags()里调用checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里delta为dx，odelta为dy，也就是说delta是指我们主要监测的方向上的变化，odelta是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。</li>\n<li>mInitialEdgesTouched是在ACTION_DOWN部分的saveInitialMotion()里生成的，ACTION_DOWN发生时触摸到的边缘会被记录在mInitialEdgesTouched中。如果ACTION_DOWN发生时没有触摸到边缘，或者触摸到的边缘不是指定的edge，就直接返回false了。</li>\n<li>mTrackingEdges是由setEdgeTrackingEnabled(int edgeFlags)设置的，当我们想要追踪监听边缘触摸时才需要调用setEdgeTrackingEnabled(int edgeFlags)，如果我们没有调用过它，这里就直接返回false了。</li>\n<li>mEdgeDragsLocked它在这个方法里被引用了多次，它在整个ViewDragHelper里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行mEdgeDragsLocked[pointerId] &amp; edge) == edge执行的结果是false。我们再跳到11到14行看看，absDelta &lt; absODelta * 0.5f的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用Callback的onEdgeLock(edge)检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在mEdgeDragsInProgress里了，也不会收到Callback的onEdgeDragStarted()通知了。并且将锁定的边缘记录在mEdgeDragsLocked变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的edge被锁定，就直接返回false了。</li>\n<li>回到第7行的(mEdgeDragsInProgress[pointerId] &amp; edge) == edge，mEdgeDragsInProgress是保存已发生过拖动事件的边缘的，如果给定的edge已经保存过了，那就没必要再检测其他东西了，直接返回false了。</li>\n<li>第8行(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。</li>\n<li>最后一句返回的时候再次检查给定的edge有没有记录过，确保了每个边缘只会调用一次reportNewEdgeDrags的mCallback.onEdgeDragStarted(dragsStarted, pointerId)</li>\n</ul>\n<p>再来看checkTouchSlop()方法：</p>\n<pre><code>/**\n * Check if we&#39;ve crossed a reasonable touch slop for the given child view.\n * If the child cannot be dragged along the horizontal or vertical axis, motion\n * along that axis will not count toward the slop check.\n *\n * @param child Child to check\n * @param dx Motion since initial position along X axis\n * @param dy Motion since initial position along Y axis\n * @return true if the touch slop has been crossed\n */\nprivate boolean checkTouchSlop(View child, float dx, float dy) {\n    if (child == null) {\n        return false;\n    }\n    final boolean checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; 0;\n    final boolean checkVertical = mCallback.getViewVerticalDragRange(child) &gt; 0;\n\n    if (checkHorizontal &amp;&amp; checkVertical) {\n        return dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;\n    } else if (checkHorizontal) {\n        return Math.abs(dx) &gt; mTouchSlop;\n    } else if (checkVertical) {\n        return Math.abs(dy) &gt; mTouchSlop;\n    }\n    return false;\n}\n</code></pre><p>这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（mTouchSlop）了，注意dx和dy指的是当前触摸点到ACTION_DOWN触摸到的点的距离。这里先检查Callback的getViewHorizontalDragRange(child)和getViewVerticalDragRange(child)是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在processTouchEvent()的ACTION_MOVE部分就不会调用tryCaptureViewForDrag()来捕获当前触摸到的View了，拖动也就没办法进行了。</p>\n<p>回到processTouchEvent()的ACTION_MOVE部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了Callback中的相关方法，让tryCaptureViewForDrag()正常的捕获到触摸到的View了，下一次ACTION_MOVE时就执行if部分的代码了，也就是开始不停的调用dragTo()对mCaptureView进行真正拖动了，看dragTo()方法：</p>\n<pre><code>private void dragTo(int left, int top, int dx, int dy) {\n    int clampedX = left;\n    int clampedY = top;\n    final int oldLeft = mCapturedView.getLeft();\n    final int oldTop = mCapturedView.getTop();\n    if (dx != 0) {\n        clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);\n        mCapturedView.offsetLeftAndRight(clampedX - oldLeft);\n    }\n    if (dy != 0) {\n        clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);\n        mCapturedView.offsetTopAndBottom(clampedY - oldTop);\n    }\n\n    if (dx != 0 || dy != 0) {\n        final int clampedDx = clampedX - oldLeft;\n        final int clampedDy = clampedY - oldTop;\n        mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,\n                clampedDx, clampedDy);\n    }\n}\n</code></pre><p>参数dx和dy是前后两次ACTION_MOVE移动的距离，left和top分别为mCapturedView.getLeft() + dx, mCapturedView.getTop() + dy，也就是期望的移动后的坐标，对View的getLeft()等方法不理解的请参阅<a href=\"http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html\" target=\"_blank\" rel=\"noopener\">Android View坐标getLeft, getRight, getTop, getBottom</a>。</p>\n<p>这里通过调用offsetLeftAndRight()和offsetTopAndBottom()来完成对mCapturedView移动，这两个是View中定义的方法，看它们的源码就知道内部是通过改变View的mLeft、mRight、mTop、mBottom，即改变View在父容器中的坐标位置，达到移动View的效果，所以如果调用mCapturedView的layout(int l, int t, int r, int b)方法也可以实现移动View的效果。</p>\n<p>具体要移动到哪里，由Callback的clampViewPositionHorizontal()和clampViewPositionVertical()来决定的，如果不想在水平方向上移动，在clampViewPositionHorizontal(View child, int left, int dx)里直接返回child.getLeft()就可以了，这样clampedX - oldLeft的值为0，这里调用mCapturedView.offsetLeftAndRight(clampedX - oldLeft)就不会起作用了。垂直方向上同理。</p>\n<p>最后会调用Callback的onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)通知捕获到的View位置改变了，并把最终的坐标（clampedX、clampedY）和最终的移动距离（clampedDx、 clampedDy）传递过去。</p>\n<p>ACTION_MOVE部分就算告一段落了，接下来应该是用户松手触发ACTION_UP，或者是达到某个条件导致后续的ACTION_MOVE被mParentView的上层View给拦截了而收到ACTION_CANCEL，一起来看这两个部分：</p>\n<pre><code>public void processTouchEvent(MotionEvent ev) {\n    // 省略\n\n    switch (action) {\n        // 省略其他case\n\n        case MotionEvent.ACTION_UP: {\n            if (mDragState == STATE_DRAGGING) {\n                releaseViewForPointerUp();\n            }\n            cancel();\n            break;\n        }\n\n        case MotionEvent.ACTION_CANCEL: {\n            if (mDragState == STATE_DRAGGING) {\n                dispatchViewReleased(0, 0);\n            }\n            cancel();\n            break;\n        }\n    }\n}\n</code></pre><p>这两个部分都是重置所有的状态记录，并通知View被放开了，再看下releaseViewForPointerUp()和dispatchViewReleased()的源码：</p>\n<pre><code>private void releaseViewForPointerUp() {\n    mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity);\n    final float xvel = clampMag(\n            VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            mMinVelocity, mMaxVelocity);\n    final float yvel = clampMag(\n            VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n            mMinVelocity, mMaxVelocity);\n    dispatchViewReleased(xvel, yvel);\n}\n</code></pre><p>releaseViewForPointerUp()里也调用了dispatchViewReleased()，只不过传递了速率给它，这个速率就是由processTouchEvent()的mVelocityTracker追踪算出来的。再看dispatchViewReleased()：</p>\n<pre><code>/**\n * Like all callback events this must happen on the UI thread, but release\n * involves some extra semantics. During a release (mReleaseInProgress)\n * is the only time it is valid to call {@link #settleCapturedViewAt(int, int)}\n * or {@link #flingCapturedView(int, int, int, int)}.\n */\nprivate void dispatchViewReleased(float xvel, float yvel) {\n    mReleaseInProgress = true;\n    mCallback.onViewReleased(mCapturedView, xvel, yvel);\n    mReleaseInProgress = false;\n\n    if (mDragState == STATE_DRAGGING) {\n        // onViewReleased didn&#39;t call a method that would have changed this. Go idle.\n        setDragState(STATE_IDLE);\n    }\n}\n</code></pre><p>这里调用Callback的onViewReleased(mCapturedView, xvel, yvel)通知外部捕获到的View被释放了，而在onViewReleased()前后有个mReleaseInProgress值得注意，注释里说唯一可以调用ViewDragHelper的settleCapturedViewAt()和flingCapturedView()的地方就是在Callback的onViewReleased()里了。</p>\n<p>首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。<br>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（flingCapturedView的四个参数int minLeft, int minTop, int maxLeft, int maxTop可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用settleCapturedViewAt(int finalLeft, int finalTop)。</p>\n<p>为什么唯一可以调用settleCapturedViewAt()和flingCapturedView()的地方是Callback的onViewReleased()呢？看看它们的源码</p>\n<pre><code>/**\n * Settle the captured view at the given (left, top) position.\n * The appropriate velocity from prior motion will be taken into account.\n * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n * on each subsequent frame to continue the motion until it returns false. If this method\n * returns false there is no further work to do to complete the movement.\n *\n * @param finalLeft Settled left edge position for the captured view\n * @param finalTop Settled top edge position for the captured view\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\npublic boolean settleCapturedViewAt(int finalLeft, int finalTop) {\n    if (!mReleaseInProgress) {\n        throw new IllegalStateException(&quot;Cannot settleCapturedViewAt outside of a call to &quot; +\n                &quot;Callback#onViewReleased&quot;);\n    }\n\n    return forceSettleCapturedViewAt(finalLeft, finalTop,\n            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));\n}\n\n/**\n * Settle the captured view based on standard free-moving fling behavior.\n * The caller should invoke {@link #continueSettling(boolean)} on each subsequent frame\n * to continue the motion until it returns false.\n *\n * @param minLeft Minimum X position for the view&#39;s left edge\n * @param minTop Minimum Y position for the view&#39;s top edge\n * @param maxLeft Maximum X position for the view&#39;s left edge\n * @param maxTop Maximum Y position for the view&#39;s top edge\n */\npublic void flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop) {\n    if (!mReleaseInProgress) {\n        throw new IllegalStateException(&quot;Cannot flingCapturedView outside of a call to &quot; +\n                &quot;Callback#onViewReleased&quot;);\n    }\n\n    mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),\n            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n            minLeft, maxLeft, minTop, maxTop);\n\n    setDragState(STATE_SETTLING);\n}\n</code></pre><p>这两个方法里一开始都会判断mReleaseInProgress为false，如果为false就会抛一个IllegalStateException异常，而mReleaseInProgress唯一为true的时候就是在dispatchViewReleased()里调用onViewReleased()的时候。</p>\n<p>Scroller的用法请参阅<a href=\"http://blog.csdn.net/qinjuning/article/details/7419207\" target=\"_blank\" rel=\"noopener\">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> ，或者自行解读Scroller源码，代码量不多。</p>\n<p>ViewDragHelper还有一个移动View的方法是smoothSlideViewTo(View child, int finalLeft, int finalTop)，看下它的源码：</p>\n<pre><code>/**\n * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position.\n * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n * on each subsequent frame to continue the motion until it returns false. If this method\n * returns false there is no further work to do to complete the movement.\n *\n * &lt;p&gt;This operation does not count as a capture event, though {@link #getCapturedView()}\n * will still report the sliding view while the slide is in progress.&lt;/p&gt;\n *\n * @param child Child view to capture and animate\n * @param finalLeft Final left position of child\n * @param finalTop Final top position of child\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\npublic boolean smoothSlideViewTo(View child, int finalLeft, int finalTop) {\n    mCapturedView = child;\n    mActivePointerId = INVALID_POINTER;\n\n    boolean continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);\n    if (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != null) {\n        // If we&#39;re in an IDLE state to begin with and aren&#39;t moving anywhere, we\n        // end up having a non-null capturedView with an IDLE dragState\n        mCapturedView = null;\n    }\n\n    return continueSliding;\n}\n</code></pre><p>可以看到它不受mReleaseInProgress的限制，所以可以在任何地方调用，效果和settleCapturedViewAt()类似，因为它们最终都调用了forceSettleCapturedViewAt()来启动自动滚动，区别在于settleCapturedViewAt()会以最后松手前的滑动速率为初速度将View滚动到最终位置，而smoothSlideViewTo()滚动的初速度是0。forceSettleCapturedViewAt()里有地方调用了Callback里的方法，所以再来看看这个方法：</p>\n<pre><code>/**\n * Settle the captured view at the given (left, top) position.\n *\n * @param finalLeft Target left position for the captured view\n * @param finalTop Target top position for the captured view\n * @param xvel Horizontal velocity\n * @param yvel Vertical velocity\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\nprivate boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {\n    final int startLeft = mCapturedView.getLeft();\n    final int startTop = mCapturedView.getTop();\n    final int dx = finalLeft - startLeft;\n    final int dy = finalTop - startTop;\n\n    if (dx == 0 &amp;&amp; dy == 0) {\n        // Nothing to do. Send callbacks, be done.\n        mScroller.abortAnimation();\n        setDragState(STATE_IDLE);\n        return false;\n    }\n\n    final int duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);\n    mScroller.startScroll(startLeft, startTop, dx, dy, duration);\n\n    setDragState(STATE_SETTLING);\n    return true;\n}\n</code></pre><p>可以看到自动滑动是靠Scroll类完成，在这里生成了调用mScroller.startScroll()需要的参数。再来看看计算滚动时间的方法computeSettleDuration()：</p>\n<pre><code>private int computeSettleDuration(View child, int dx, int dy, int xvel, int yvel) {\n    xvel = clampMag(xvel, (int) mMinVelocity, (int) mMaxVelocity);\n    yvel = clampMag(yvel, (int) mMinVelocity, (int) mMaxVelocity);\n    final int absDx = Math.abs(dx);\n    final int absDy = Math.abs(dy);\n    final int absXVel = Math.abs(xvel);\n    final int absYVel = Math.abs(yvel);\n    final int addedVel = absXVel + absYVel;\n    final int addedDistance = absDx + absDy;\n\n    final float xweight = xvel != 0 ? (float) absXVel / addedVel :\n            (float) absDx / addedDistance;\n    final float yweight = yvel != 0 ? (float) absYVel / addedVel :\n            (float) absDy / addedDistance;\n\n    int xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));\n    int yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));\n\n    return (int) (xduration * xweight + yduration * yweight);\n}\n</code></pre><p>clampMag()方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过computeAxisDuration()算出来，通过它的参数可以看到最终的滚动时间是由dx、xvel、mCallback.getViewHorizontalDragRange()共同影响的。看computeAxisDuration()：</p>\n<pre><code>private int computeAxisDuration(int delta, int velocity, int motionRange) {\n    if (delta == 0) {\n        return 0;\n    }\n\n    final int width = mParentView.getWidth();\n    final int halfWidth = width / 2;\n    final float distanceRatio = Math.min(1f, (float) Math.abs(delta) / width);\n    final float distance = halfWidth + halfWidth *\n            distanceInfluenceForSnapDuration(distanceRatio);\n\n    int duration;\n    velocity = Math.abs(velocity);\n    if (velocity &gt; 0) {\n        duration = 4 * Math.round(1000 * Math.abs(distance / velocity));\n    } else {\n        final float range = (float) Math.abs(delta) / motionRange;\n        duration = (int) ((range + 1) * BASE_SETTLE_DURATION);\n    }\n    return Math.min(duration, MAX_SETTLE_DURATION);\n}\n</code></pre><p>6~10行没看明白，直接看14~19行，如果给定的速率velocity不为0，就通过距离除以速率来算出时间；如果velocity为0，就通过要滑动的距离（delta）除以总的移动范围（motionRange，就是Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过MAX_SETTLE_DURATION的，源码里的取值是600毫秒，所以不用担心在Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回错误的数而导致自动滚动时间过长了。</p>\n<p>在调用settleCapturedViewAt()、flingCapturedView()和smoothSlideViewTo()时，还需要实现mParentView的computeScroll()：</p>\n<pre><code>@Override\npublic void computeScroll() {\n    if (mDragHelper.continueSettling(true)) {\n        ViewCompat.postInvalidateOnAnimation(this);\n    }\n}\n</code></pre><p>这属于Scroll类用法的范畴，不明白的请参阅<a href=\"http://blog.csdn.net/qinjuning/article/details/7419207\" target=\"_blank\" rel=\"noopener\">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> 的“知识点二： computeScroll(）方法介绍”。</p>\n<p>至此，整个触摸流程和ViewDragHelper的重要的方法都过了一遍。之前在讨论shouldInterceptTouchEvent()的ACTION_DOWN部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次ACTION_DOWN事件的情况，现在来看看这种情况。</p>\n<p>假设现在shouldInterceptTouchEvent()的ACTION_DOWN部分执行完了，也有子View消费了这次的ACTION_DOWN事件，那么接下来就会调用mParentView的onInterceptTouchEvent()的ACTION_MOVE部分，不明白为什么的请参阅<a href=\"http://blog.csdn.net/xiaanming/article/details/21696315\" target=\"_blank\" rel=\"noopener\">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>，接着调用ViewDragHelper的shouldInterceptTouchEvent()的ACTION_MOVE部分：</p>\n<pre><code>public boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    // 省略...\n\n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_MOVE: {\n            // First to cross a touch slop over a draggable view wins. Also report edge drags.\n            final int pointerCount = MotionEventCompat.getPointerCount(ev);\n            for (int i = 0; i &lt; pointerCount; i++) {\n                final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                final float x = MotionEventCompat.getX(ev, i);\n                final float y = MotionEventCompat.getY(ev, i);\n                final float dx = x - mInitialMotionX[pointerId];\n                final float dy = y - mInitialMotionY[pointerId];\n\n                final View toCapture = findTopChildUnder((int) x, (int) y);\n                final boolean pastSlop = toCapture != null &amp;&amp; checkTouchSlop(toCapture, dx, dy);\n                if (pastSlop) {\n                    // check the callback&#39;s\n                    // getView[Horizontal|Vertical]DragRange methods to know\n                    // if you can move at all along an axis, then see if it\n                    // would clamp to the same value. If you can&#39;t move at\n                    // all in every dimension with a nonzero range, bail.\n                    final int oldLeft = toCapture.getLeft();\n                    final int targetLeft = oldLeft + (int) dx;\n                    final int newLeft = mCallback.clampViewPositionHorizontal(toCapture,\n                            targetLeft, (int) dx);\n                    final int oldTop = toCapture.getTop();\n                    final int targetTop = oldTop + (int) dy;\n                    final int newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,\n                            (int) dy);\n                    final int horizontalDragRange = mCallback.getViewHorizontalDragRange(\n                            toCapture);\n                    final int verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);\n                    if ((horizontalDragRange == 0 || horizontalDragRange &gt; 0\n                            &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == 0\n                            || verticalDragRange &gt; 0 &amp;&amp; newTop == oldTop)) {\n                        break;\n                    }\n                }\n                reportNewEdgeDrags(dx, dy, pointerId);\n                if (mDragState == STATE_DRAGGING) {\n                    // Callback might have started an edge drag\n                    break;\n                }\n\n                if (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) {\n                    break;\n                }\n            }\n            saveLastMotion(ev);\n            break;\n        }\n\n        // 省略其他case...\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n</code></pre><p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用findTopChildUnder(int x, int y)寻找触摸点处的子View，再用checkTouchSlop(View child, float dx, float dy)检查当前触摸点到ACTION_DOWN触摸点的距离是否达到了mTouchSlop，达到了才会去捕获View。<br>接着看19~41行if (pastSlop){…}部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到getView[Horizontal|Vertical]DragRange和clampViewPosition[Horizontal|Vertical]四个方法。如果getView[Horizontal|Vertical]DragRange返回都是0，就会认作是不会产生拖动。clampViewPosition[Horizontal|Vertical]返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接break，不会执行后续的代码，而后续代码里有调用tryCaptureViewForDrag()，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。<br>如果检查到可以在某个方向上进行拖动，就会调用后面的tryCaptureViewForDrag()捕获子View，如果捕获成功，mDragState就会变成STATE_DRAGGING，shouldInterceptTouchEvent()返回true，mParentView的onInterceptTouchEvent()返回true，后续的移动事件就会在mParentView的onTouchEvent()执行了，最后执行的就是mParentView的processTouchEvent()的ACTION_MOVE部分，拖动正常进行。</p>\n<p>回头再看之前在shouldInterceptTouchEvent()的ACTION_DOWN部分留下的坑：</p>\n<pre><code>public boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    // 省略其他部分...\n\n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_DOWN: {\n            // 省略其他部分...\n\n            // Catch a settling view if possible.\n            if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) {\n                tryCaptureViewForDrag(toCapture, pointerId);\n            }\n\n            // 省略其他部分...\n        }\n\n        // 省略其他case...\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n</code></pre><p>现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的tryCaptureViewForDrag()尝试捕获View，如果捕获成功，mDragState就变为STATE_DRAGGING了，shouldInterceptTouchEvent()就返回true了，然后就是mParentView的onInterceptTouchEvent()返回true，接着执行mParentView的onTouchEvent()，再执行processTouchEvent()的ACTION_DOWN部分。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动。</p>\n<p>至此整个事件传递流程和ViewDragHelper的重要方法基本都解析完了，shouldInterceptTouchEvent()和processTouchEvent()的ACTION_POINTER_DOWN、ACTION_POINTER_UP部分就留给读者自己解析了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。</p>\n<ul>\n<li><a href=\"http://www.processon.com/view/link/5550a7bae4b09739f465ec64\" target=\"_blank\" rel=\"noopener\">单点触摸，没有考虑边缘滑动检测的最简流程图</a></li>\n<li><a href=\"http://www.processon.com/view/link/5550d3dce4b09739f46789bd\" target=\"_blank\" rel=\"noopener\">单点触摸，考虑了边缘滑动检测的流程图</a></li>\n</ul>\n<p>多点触摸情况我就没研究了，在这里忽略~</p>\n<p>三个开启自动滚动的方法：</p>\n<ul>\n<li>settleCapturedViewAt(int finalLeft, int finalTop)<br>以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在Callback的onViewReleased()中调用。</li>\n<li>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)<br>以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在Callback的onViewReleased()中调用。</li>\n<li>smoothSlideViewTo(View child, int finalLeft, int finalTop)<br>指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。</li>\n</ul>\n<p>Callback的各个方法总结：</p>\n<ul>\n<li><p>void onViewDragStateChanged(int state)</p>\n<p>拖动状态改变时会调用此方法，状态state有STATE_IDLE、STATE_DRAGGING、STATE_SETTLING三种取值。</p>\n<p>它在setDragState()里被调用，而setDragState()被调用的地方有</p>\n<ul>\n<li>tryCaptureViewForDrag()成功捕获到子View时<ul>\n<li>shouldInterceptTouchEvent()的ACTION_DOWN部分捕获到</li>\n<li>shouldInterceptTouchEvent()的ACTION_MOVE部分捕获到</li>\n<li>processTouchEvent()的ACTION_MOVE部分捕获到</li>\n</ul>\n</li>\n<li>调用settleCapturedViewAt()、smoothSlideViewTo()、flingCapturedView()时</li>\n<li>拖动View松手时（processTouchEvent()的ACTION_UP、ACTION_CANCEL）</li>\n<li>自动滚动停止时（continueSettling()里检测到滚动结束时）</li>\n<li>外部调用abort()时</li>\n</ul>\n</li>\n<li><p>void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</p>\n<p>正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。</p>\n<ul>\n<li>在dragTo()里被调用（正在被拖动时）</li>\n<li>在continueSettling()里被调用（自动滚动时）</li>\n<li>外部调用abort()时被调用</li>\n</ul>\n</li>\n<li><p>void onViewCaptured(View capturedChild, int activePointerId)</p>\n<p>tryCaptureViewForDrag()成功捕获到子View时会调用此方法。</p>\n<ul>\n<li>在shouldInterceptTouchEvent()的ACTION_DOWN里成功捕获</li>\n<li>在shouldInterceptTouchEvent()的ACTION_MOVE里成功捕获</li>\n<li>在processTouchEvent()的ACTION_MOVE里成功捕获</li>\n<li>手动调用captureChildView()</li>\n</ul>\n</li>\n<li><p>void onViewReleased(View releasedChild, float xvel, float yvel)<br>拖动View松手时（processTouchEvent()的ACTION_UP）或被父View拦截事件时（processTouchEvent()的ACTION_CANCEL）会调用此方法。</p>\n</li>\n<li><p>void onEdgeTouched(int edgeFlags, int pointerId)<br>ACTION_DOWN或ACTION_POINTER_DOWN事件发生时如果触摸到监听的边缘会调用此方法。edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。</p>\n</li>\n<li><p>boolean onEdgeLock(int edgeFlags)<br>返回true表示锁定edgeFlags对应的边缘，锁定后的那些边缘就不会在onEdgeDragStarted()被通知了，默认返回false不锁定给定的边缘，edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM其中之一。</p>\n</li>\n<li><p>void onEdgeDragStarted(int edgeFlags, int pointerId)<br>ACTION_MOVE事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。edgeFlags取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。可在此手动调用captureChildView()触发从边缘拖动子View的效果。</p>\n</li>\n<li><p>int getOrderedChildIndex(int index)<br>在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给tryCaptureViewForDrag()来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。</p>\n</li>\n<li><p>int getViewHorizontalDragRange(View child)、int getViewVerticalDragRange(View child)</p>\n<p>返回给定的child在相应的方向上可以被拖动的最远距离，默认返回0。ACTION_DOWN发生时，若触摸点处的child消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。</p>\n<p>被调用的地方有三处：</p>\n<ul>\n<li>在checkTouchSlop()中被调用，返回值大于0才会去检查mTouchSlop。在ACTION_MOVE里调用tryCaptureViewForDrag()之前会调用checkTouchSlop()。如果checkTouchSlop()失败，就不会去捕获View了。</li>\n<li>如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。</li>\n<li>在调用smoothSlideViewTo()时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在getView[Horizontal|Vertical]DragRange里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。</li>\n</ul>\n</li>\n<li><p>boolean tryCaptureView(View child, int pointerId)</p>\n<p>在tryCaptureViewForDrag()中被调用，返回true表示捕获给定的child。tryCaptureViewForDrag()被调用的地方有</p>\n<ul>\n<li>shouldInterceptTouchEvent()的ACTION_DOWN里</li>\n<li>shouldInterceptTouchEvent()的ACTION_MOVE里</li>\n<li>processTouchEvent()的ACTION_MOVE里</li>\n</ul>\n</li>\n<li><p>int clampViewPositionHorizontal(View child, int left, int dx)、int clampViewPositionVertical(View child, int top, int dy)</p>\n<p>child在某方向上被拖动时会调用对应方法，返回值是child移动过后的坐标位置，clampViewPositionHorizontal()返回child移动过后的left值，clampViewPositionVertical()返回child移动过后的top值。</p>\n<p>两个方法被调用的地方有两处：</p>\n<ul>\n<li>在dragTo()中被调用，dragTo()在processTouchEvent()的ACTION_MOVE里被调用。用来获取被拖动的View要移动到的位置。</li>\n<li>如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"案例参考\"><a href=\"#案例参考\" class=\"headerlink\" title=\"案例参考\"></a>案例参考</h3><p>在这里列举一部分对ViewDragHelper的应用案例，大家自己剖析它们的源码来实践巩固。</p>\n<ol>\n<li><a href=\"https://github.com/flavienlaurent/flavienlaurent.com\" target=\"_blank\" rel=\"noopener\">YoutubeLayout</a>，这是最简单的Demo</li>\n<li><a href=\"https://github.com/BlueMor/DragLayout\" target=\"_blank\" rel=\"noopener\">QQ5.x侧滑菜单</a>、<a href=\"https://github.com/kyze8439690/ResideLayout\" target=\"_blank\" rel=\"noopener\">ResideLayout</a></li>\n<li><a href=\"https://github.com/ikew0ng/SwipeBackLayout\" target=\"_blank\" rel=\"noopener\">SwipeBackLayout</a>、<a href=\"https://github.com/liuguangqiang/SwipeBack\" target=\"_blank\" rel=\"noopener\">SwipeBack</a></li>\n<li><a href=\"https://github.com/umano/AndroidSlidingUpPanel\" target=\"_blank\" rel=\"noopener\">SlidingUpPanel</a></li>\n<li><a href=\"https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java\" target=\"_blank\" rel=\"noopener\">DrawerLayout</a></li>\n</ol>\n<h3 id=\"其他关于ViewDragHelper的分析文章\"><a href=\"#其他关于ViewDragHelper的分析文章\" class=\"headerlink\" title=\"其他关于ViewDragHelper的分析文章\"></a>其他关于ViewDragHelper的分析文章</h3><ul>\n<li><a href=\"http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper\" target=\"_blank\" rel=\"noopener\">Each Navigation Drawer Hides a ViewDragHelper</a>，文中的源码就是上面的<a href=\"https://github.com/flavienlaurent/flavienlaurent.com\" target=\"_blank\" rel=\"noopener\">YoutubeLayout</a></li>\n<li><a href=\"http://blog.csdn.net/pi9nc/article/details/39583377\" target=\"_blank\" rel=\"noopener\">ViewDragHelper详解</a>，这是上面文章的简略中文版</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.cnblogs.com/lqstayreal/p/4500219.html\" target=\"_blank\" rel=\"noopener\">这文章是转来的，写的实在是好，怕哪天失踪了……</a></p>","more":"<p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，ViewDragHelper的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p>\n<p>要想完全掌握ViewDragHelper的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾ViewDragHelper的原理、用法、注意事项等。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><ol>\n<li><p>在自定义ViewGroup的构造方法里调用ViewDragHelper的静态工厂方法create()创建ViewDragHelper实例</p>\n</li>\n<li><p>实现ViewDragHelper.Callback</p>\n<p>最重要的几个方法是tryCaptureView()、clampViewPositionVertical()、clampViewPositionHorizontal()、getViewHorizontalDragRange()、getViewVerticalDragRange()</p>\n<ul>\n<li>tryCaptureView()里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回true，否则返回false。</li>\n<li>clampViewPositionVertical()决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。</li>\n<li>clampViewPositionHorizontal()与clampViewPositionVertical()同理，只不过是发生在水平方向上，最终返回的是View的left值。</li>\n<li>getViewVerticalDragRange()要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。</li>\n<li>getViewHorizontalDragRange()与getViewVerticalDragRange()同理，只不过是发生在水平方向上。</li>\n</ul>\n</li>\n<li><p>在onInterceptTouchEvent()方法里调用并返回ViewDragHelper的shouldInterceptTouchEvent()方法</p>\n</li>\n<li><p>在onTouchEvent()方法里调用ViewDragHelper()的processTouchEvent()方法。ACTION_DOWN事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在onTouchEvent()返回true，否则将收不到后续事件，不会产生拖动。</p>\n</li>\n<li><p>上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的computeScroll()方法，方法实现如下：</p>\n<pre><code> @Override\n public void computeScroll() {\n     if (mDragHelper.continueSettling(true)) {\n         postInvalidate();\n     }\n }\n</code></pre><p>并在ViewDragHelper.Callback的onViewReleased()方法里调用settleCapturedViewAt()、flingCapturedView()，或在任意地方调用smoothSlideViewTo()方法。</p>\n</li>\n<li><p>如果要实现边缘拖动的效果，需要调用ViewDragHelper的setEdgeTrackingEnabled()方法，注册想要监听的边缘。然后实现ViewDragHelper.Callback里的onEdgeDragStarted()方法，在此手动调用captureChildView()传递要拖动的子View。</p>\n</li>\n</ol>\n<p>具体的使用Demo请见最后面公布的几个案例。</p>\n<h3 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h3><p>ViewDragHelper的完整源码可在<a href=\"https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java\" target=\"_blank\" rel=\"noopener\">GitHub</a>或<a href=\"http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper\" target=\"_blank\" rel=\"noopener\">GrepCode</a>上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。</p>\n<h4 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h4><ol>\n<li>了解View的坐标系统，<a href=\"http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html\" target=\"_blank\" rel=\"noopener\">Android View坐标getLeft, getRight, getTop, getBottom</a></li>\n<li>了解MotionEvent中关于多点触控的机制，<a href=\"http://my.oschina.net/banxi/blog/56421\" target=\"_blank\" rel=\"noopener\">android触控,先了解MotionEvent(一)</a></li>\n<li>了解Scroller类原理，<a href=\"http://blog.csdn.net/qinjuning/article/details/7419207\" target=\"_blank\" rel=\"noopener\">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a></li>\n<li>了解Touch事件的分发机制，<a href=\"http://blog.csdn.net/xiaanming/article/details/21696315\" target=\"_blank\" rel=\"noopener\">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a></li>\n</ol>\n<h4 id=\"ViewDragHelper实例的创建\"><a href=\"#ViewDragHelper实例的创建\" class=\"headerlink\" title=\"ViewDragHelper实例的创建\"></a>ViewDragHelper实例的创建</h4><p>ViewDragHelper重载了两个create()静态方法，先看两个参数的create()方法：</p>\n<pre><code>/**\n * Factory method to create a new ViewDragHelper.\n *\n * @param forParent Parent view to monitor\n * @param cb Callback to provide information and receive events\n * @return a new ViewDragHelper instance\n */\npublic static ViewDragHelper create(ViewGroup forParent, Callback cb) {\n    return new ViewDragHelper(forParent.getContext(), forParent, cb);\n}\n</code></pre><p>create()的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。create()直接调用了ViewDragHelper构造方法，我们再来看看这个构造方法。</p>\n<pre><code>/**\n * Apps should use ViewDragHelper.create() to get a new instance.\n * This will allow VDH to use internal compatibility implementations for different\n * platform versions.\n *\n * @param context Context to initialize config-dependent params from\n * @param forParent Parent view to monitor\n */\nprivate ViewDragHelper(Context context, ViewGroup forParent, Callback cb) {\n    if (forParent == null) {\n        throw new IllegalArgumentException(&quot;Parent view may not be null&quot;);\n    }\n    if (cb == null) {\n        throw new IllegalArgumentException(&quot;Callback may not be null&quot;);\n    }\n\n    mParentView = forParent;\n    mCallback = cb;\n\n    final ViewConfiguration vc = ViewConfiguration.get(context);\n    final float density = context.getResources().getDisplayMetrics().density;\n    mEdgeSize = (int) (EDGE_SIZE * density + 0.5f);\n\n    mTouchSlop = vc.getScaledTouchSlop();\n    mMaxVelocity = vc.getScaledMaximumFlingVelocity();\n    mMinVelocity = vc.getScaledMinimumFlingVelocity();\n    mScroller = ScrollerCompat.create(context, sInterpolator);\n}\n</code></pre><p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过create()工厂方法来创建ViewDragHelper实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p>\n<ul>\n<li>mParentView和mCallback分别保存传递过来的对应参数</li>\n<li>ViewConfiguration类里定义了View相关的一系列时间、大小、距离等常量</li>\n<li>mEdgeSize表示边缘触摸的范围。例如mEdgeSize为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于mParentView.getLeft() + mEdgeSize时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见ViewDragHelper的getEdgesTouched()方法。</li>\n<li>mTouchSlop是一个很小的距离值，只有在前后两次触摸点的距离超过mTouchSlop的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。</li>\n<li>mMaxVelocity、mMinVelocity是fling时的最大、最小速率，单位是像素每秒。</li>\n<li>mScroller是View滚动的辅助类，该类的详细解析参见下面几篇文章<ul>\n<li><a href=\"http://blog.csdn.net/qinjuning/article/details/7419207\" target=\"_blank\" rel=\"noopener\">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a></li>\n<li><a href=\"http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html\" target=\"_blank\" rel=\"noopener\">Android中Scroller类的分析</a></li>\n</ul>\n</li>\n</ul>\n<p>再看三个参数的create()方法：</p>\n<pre><code>/**\n * Factory method to create a new ViewDragHelper.\n *\n * @param forParent Parent view to monitor\n * @param sensitivity Multiplier for how sensitive the helper should be about detecting\n *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.\n * @param cb Callback to provide information and receive events\n * @return a new ViewDragHelper instance\n */\npublic static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {\n    final ViewDragHelper helper = create(forParent, cb);\n    helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity));\n    return helper;\n}\n</code></pre><p>第二个参数sensitivity是用来调节mTouchSlop的值。sensitivity越大，mTouchSlop越小，对滑动的检测就越敏感。例如sensitivity为1时，前后触摸点距离超过20dp才进行滑动处理，现在sensitivity为2的话，前后触摸点距离超过10dp就进行处理了。</p>\n<h4 id=\"对Touch事件的处理\"><a href=\"#对Touch事件的处理\" class=\"headerlink\" title=\"对Touch事件的处理\"></a>对Touch事件的处理</h4><p>当mParentView（自定义ViewGroup）被触摸时，首先会调用mParentView的onInterceptTouchEvent(MotionEvent ev)，接着就调用shouldInterceptTouchEvent(MotionEvent ev) ，所以先来看看这个方法的ACTION_DOWN部分：</p>\n<pre><code>/**\n * Check if this event as provided to the parent view&#39;s onInterceptTouchEvent should\n * cause the parent to intercept the touch event stream.\n *\n * @param ev MotionEvent provided to onInterceptTouchEvent\n * @return true if the parent view should return true from onInterceptTouchEvent\n */\npublic boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    final int action = MotionEventCompat.getActionMasked(ev);\n    final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n    if (action == MotionEvent.ACTION_DOWN) {\n        // Reset things for a new event stream, just in case we didn&#39;t get\n        // the whole previous stream.\n        cancel();\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n            saveInitialMotion(x, y, pointerId);\n\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n\n            // Catch a settling view if possible.\n            if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) {\n                tryCaptureViewForDrag(toCapture, pointerId);\n            }\n\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched &amp; mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);\n            }\n            break;\n        }\n\n        // 其他case暂且省略\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n</code></pre><p>看9~21行，首先是关于多点触控（MotionEvent的actionIndex、ACTION_POINTER_DOWN 等概念），不明白的请参阅<a href=\"http://my.oschina.net/banxi/blog/56421\" target=\"_blank\" rel=\"noopener\">android触控,先了解MotionEvent(一)</a>。</p>\n<p>mVelocityTracker记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生ACTION_DOWN事件都会调用cancel()，而在cancel()方法里mVelocityTracker又被清空了，所以mVelocityTracker 记录下的是本次ACTION_DOWN事件直至ACTION_UP事件发生后（下次ACTION_DOWN事件发生前）的所有触摸点的信息。</p>\n<p>再来看24~42行case MotionEvent.ACTION_DOWN部分，先是调用saveInitialMotion(x, y, pointerId)保存手势的初始信息，即ACTION_DOWN发生时的触摸点坐标（x、y）、触摸手指编号（pointerId），如果触摸到了mParentView的边缘还会记录触摸的是哪个边缘。接着调用findTopChildUnder((int) x, (int) y);来获取当前触摸点下最顶层的子View，看findTopChildUnder 的源码：</p>\n<pre><code>/**\n * Find the topmost child under the given point within the parent view&#39;s coordinate system.\n * The child order is determined using {@link Callback#getOrderedChildIndex(int)}.\n *\n * @param x X position to test in the parent&#39;s coordinate system\n * @param y Y position to test in the parent&#39;s coordinate system\n * @return The topmost child view under (x, y) or null if none found.\n */\npublic View findTopChildUnder(int x, int y) {\n    final int childCount = mParentView.getChildCount();\n    for (int i = childCount - 1; i &gt;= 0; i--) {\n        final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));\n        if (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;\n                y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) {\n            return child;\n        }\n    }\n    return null;\n}\n</code></pre><p>代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现Callback里的getOrderedChildIndex(int index)方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（getOrderedChildIndex()默认直接返回index），会选择到topView，要想让bottomView被选中就得这么写：</p>\n<pre><code>public int getOrderedChildIndex(int index) {\n    int indexTop = mParentView.indexOfChild(topView);\n    int indexBottom = mParentView.indexOfChild(bottomView);\n    if (index == indexTop) {\n        return indexBottom;\n    }\n    return index;\n}\n</code></pre><p>32~35行，这里还看到了一个mDragState成员变量，它共有三种取值：</p>\n<ol>\n<li>STATE_IDLE：所有的View处于静止空闲状态</li>\n<li>STATE_DRAGGING：某个View正在被用户拖动（用户正在与设备交互）</li>\n<li>STATE_SETTLING：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中<br>mCapturedView默认为null，所以一开始不会执行这里的代码，mDragState处于STATE_SETTLING状态时才会执行tryCaptureViewForDrag()，执行的情况到后面再分析，这里先跳过。</li>\n</ol>\n<p>37~40行调用了Callback.onEdgeTouched向外部通知mParentView的某些边缘被触摸到了，mInitialEdgesTouched是在刚才调用过的saveInitialMotion方法里进行赋值的。</p>\n<p>ACTION_DOWN 部分处理完了，跳过switch语句块，剩下的代码就只有return mDragState == STATE_DRAGGING;。在ACTION_DOWN部分没有对mDragState进行赋值，其默认值为STATE_IDLE，所以此处返回false。</p>\n<p>那么返回false后接下来应该是会调用哪个方法呢，根据<a href=\"http://blog.csdn.net/xiaanming/article/details/21696315\" target=\"_blank\" rel=\"noopener\">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>里的解析，接下来会在mParentView的所有子View中寻找响应这个Touch事件的View（会调用每个子View的dispatchTouchEvent()方法，dispatchTouchEvent里一般又会调用onTouchEvent()）；</p>\n<ul>\n<li>如果没有子View消费这次事件（子View的dispatchTouchEvent()返回都是false），会调用mParentView的super.dispatchTouchEvent(ev)，即View中的dispatchTouchEvent(ev)，然后调用mParentView的onTouchEvent()方法，再调用ViewDragHelper的processTouchEvent(MotionEvent ev)方法。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动（除了ACTION_DOWN外的其他事件发生时返回true或false都不会影响接下来的事件接受），因为拖动的相关代码是写在processTouchEvent()里的ACTION_MOVE部分的。要注意的是返回true后mParentView的onInterceptTouchEvent()就不会收到后续的ACTION_MOVE、ACTION_UP等事件了。</li>\n<li>如果有子View消费了本次ACTION_DOWN事件，mParentView的onTouchEvent()就收不到ACTION_DOWN事件了，也就是ViewDragHelper的processTouchEvent(MotionEvent ev)收不到ACTION_DOWN事件了。不过只要该View没有调用过requestDisallowInterceptTouchEvent(true)，mParentView的onInterceptTouchEvent()的ACTION_MOVE部分还是会执行的，如果在此时返回了true拦截了ACTION_MOVE事件，processTouchEvent()里的ACTION_MOVE部分也就会正常执行，拖动也就没问题了。onInterceptTouchEvent()的ACTION_MOVE部分具体做了怎样的处理，稍后再来解析。</li>\n</ul>\n<p>接下来对这两种情况逐一解析。</p>\n<p>假设没有子View消费这次事件，根据刚才的分析最终就会调用processTouchEvent(MotionEvent ev)的ACTION_DOWN部分：</p>\n<pre><code>/**\n * Process a touch event received by the parent view. This method will dispatch callback events\n * as needed before returning. The parent view&#39;s onTouchEvent implementation should call this.\n *\n * @param ev The touch event received by the parent view\n */\npublic void processTouchEvent(MotionEvent ev) {\n    final int action = MotionEventCompat.getActionMasked(ev);\n    final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n    if (action == MotionEvent.ACTION_DOWN) {\n        // Reset things for a new event stream, just in case we didn&#39;t get\n        // the whole previous stream.\n        cancel();\n    }\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n\n            saveInitialMotion(x, y, pointerId);\n\n            // Since the parent is already directly processing this touch event,\n            // there is no reason to delay for a slop before dragging.\n            // Start immediately if possible.\n            tryCaptureViewForDrag(toCapture, pointerId);\n\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched &amp; mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);\n            }\n            break;\n        }\n        // 其他case暂且省略\n    }\n}\n</code></pre><p>这段代码跟shouldInterceptTouchEvent()里ACTION_DOWN那部分基本一致，唯一区别就是这里没有约束条件直接调用了tryCaptureViewForDrag()方法，现在来看看这个方法：</p>\n<pre><code>/**\n * Attempt to capture the view with the given pointer ID. The callback will be involved.\n * This will put us into the &quot;dragging&quot; state. If we&#39;ve already captured this view with\n * this pointer this method will immediately return true without consulting the callback.\n *\n * @param toCapture View to capture\n * @param pointerId Pointer to capture with\n * @return true if capture was successful\n */\nboolean tryCaptureViewForDrag(View toCapture, int pointerId) {\n    if (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) {\n        // Already done!\n        return true;\n    }\n    if (toCapture != null &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) {\n        mActivePointerId = pointerId;\n        captureChildView(toCapture, pointerId);\n        return true;\n    }\n    return false;\n}\n</code></pre><p>这里调用了Callback的tryCaptureView(View child, int pointerId)方法，把当前触摸到的View和触摸手指编号传递了过去，在tryCaptureView()中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在tryCaptureView()中返回true，让ViewDragHelper把当前触摸的View捕获下来，接着就调用了captureChildView(toCapture, pointerId)方法：</p>\n<pre><code>/**\n * Capture a specific child view for dragging within the parent. The callback will be notified\n * but {@link Callback#tryCaptureView(android.view.View, int)} will not be asked permission to\n * capture this view.\n *\n * @param childView Child view to capture\n * @param activePointerId ID of the pointer that is dragging the captured child view\n */\npublic void captureChildView(View childView, int activePointerId) {\n    if (childView.getParent() != mParentView) {\n        throw new IllegalArgumentException(&quot;captureChildView: parameter must be a descendant &quot; +\n                &quot;of the ViewDragHelper&#39;s tracked parent view (&quot; + mParentView + &quot;)&quot;);\n    }\n\n    mCapturedView = childView;\n    mActivePointerId = activePointerId;\n    mCallback.onViewCaptured(childView, activePointerId);\n    setDragState(STATE_DRAGGING);\n}\n</code></pre><p>代码很简单，在captureChildView(toCapture, pointerId)中将要拖动的View和触摸的手指编号记录下来，并调用Callback的onViewCaptured(childView, activePointerId)通知外部有子View被捕获到了，再调用setDragState()设置当前的状态为STATE_DRAGGING，看setDragState()源码：</p>\n<pre><code>void setDragState(int state) {\n    if (mDragState != state) {\n        mDragState = state;\n        mCallback.onViewDragStateChanged(state);\n        if (mDragState == STATE_IDLE) {\n            mCapturedView = null;\n        }\n    }\n}\n</code></pre><p>状态改变后会调用Callback的onViewDragStateChanged()通知状态的变化。</p>\n<p>假设ACTION_DOWN发生后在mParentView的onTouchEvent()返回了true，接下来就会执行ACTION_MOVE部分：</p>\n<pre><code>public void processTouchEvent(MotionEvent ev) {\n\n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_MOVE: {\n            if (mDragState == STATE_DRAGGING) {\n                final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, index);\n                final float y = MotionEventCompat.getY(ev, index);\n                final int idx = (int) (x - mLastMotionX[mActivePointerId]);\n                final int idy = (int) (y - mLastMotionY[mActivePointerId]);\n\n                dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);\n\n                saveLastMotion(ev);\n            } else {\n                // Check to see if any pointer is now over a draggable view.\n                final int pointerCount = MotionEventCompat.getPointerCount(ev);\n                for (int i = 0; i &lt; pointerCount; i++) {\n                    final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                    final float x = MotionEventCompat.getX(ev, i);\n                    final float y = MotionEventCompat.getY(ev, i);\n                    final float dx = x - mInitialMotionX[pointerId];\n                    final float dy = y - mInitialMotionY[pointerId];\n\n                    reportNewEdgeDrags(dx, dy, pointerId);\n                    if (mDragState == STATE_DRAGGING) {\n                        // Callback might have started an edge drag.\n                        break;\n                    }\n\n                    final View toCapture = findTopChildUnder((int) x, (int) y);\n                    if (checkTouchSlop(toCapture, dx, dy) &amp;&amp;\n                            tryCaptureViewForDrag(toCapture, pointerId)) {\n                        break;\n                    }\n                }\n                saveLastMotion(ev);\n            }\n            break;\n        }\n\n        // 省略其他case...\n    }\n}\n</code></pre><p>要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断mDragState是否为STATE_DRAGGING，而唯一调用setDragState(STATE_DRAGGING)的地方就是tryCaptureViewForDrag()了，刚才在ACTION_DOWN里调用过tryCaptureViewForDrag()，现在又要分两种情况。<br>如果刚才在ACTION_DOWN里捕获到要拖动的View，那么就执行if部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，mDragState依然是STATE_IDLE，然后会执行else部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让mDragState变为STATE_DRAGGING，之后就会执行if部分的代码了。这里还有两个方法涉及到了Callback里的方法，需要来解析一下，分别是reportNewEdgeDrags()和checkTouchSlop()，先看reportNewEdgeDrags()：</p>\n<pre><code>private void reportNewEdgeDrags(float dx, float dy, int pointerId) {\n    int dragsStarted = 0;\n    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) {\n        dragsStarted |= EDGE_LEFT;\n    }\n    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) {\n        dragsStarted |= EDGE_TOP;\n    }\n    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) {\n        dragsStarted |= EDGE_RIGHT;\n    }\n    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) {\n        dragsStarted |= EDGE_BOTTOM;\n    }\n\n    if (dragsStarted != 0) {\n        mEdgeDragsInProgress[pointerId] |= dragsStarted;\n        mCallback.onEdgeDragStarted(dragsStarted, pointerId);\n    }\n}\n</code></pre><p>这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在mEdgeDragsInProgress中，再调用Callback的onEdgeDragStarted(int edgeFlags, int pointerId)通知某个边缘开始产生拖动了。虽然reportNewEdgeDrags()会被调用很多次（因为processTouchEvent()的ACTION_MOVE部分会执行很多次），但mCallback.onEdgeDragStarted(dragsStarted, pointerId)只会调用一次，具体的要看checkNewEdgeDrag()这个方法：</p>\n<pre><code>private boolean checkNewEdgeDrag(float delta, float odelta, int pointerId, int edge) {\n    final float absDelta = Math.abs(delta);\n    final float absODelta = Math.abs(odelta);\n\n    if ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == 0 ||\n            (mEdgeDragsLocked[pointerId] &amp; edge) == edge ||\n            (mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||\n            (absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) {\n        return false;\n    }\n    if (absDelta &lt; absODelta * 0.5f &amp;&amp; mCallback.onEdgeLock(edge)) {\n        mEdgeDragsLocked[pointerId] |= edge;\n        return false;\n    }\n    return (mEdgeDragsInProgress[pointerId] &amp; edge) == 0 &amp;&amp; absDelta &gt; mTouchSlop;\n}\n</code></pre><ul>\n<li>checkNewEdgeDrag()返回true表示在指定的edge（边缘）开始产生拖动了。</li>\n<li>方法的两个参数delta和odelta需要解释一下，odelta里的o应该代表opposite，这是什么意思呢，以reportNewEdgeDrags()里调用checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里delta为dx，odelta为dy，也就是说delta是指我们主要监测的方向上的变化，odelta是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。</li>\n<li>mInitialEdgesTouched是在ACTION_DOWN部分的saveInitialMotion()里生成的，ACTION_DOWN发生时触摸到的边缘会被记录在mInitialEdgesTouched中。如果ACTION_DOWN发生时没有触摸到边缘，或者触摸到的边缘不是指定的edge，就直接返回false了。</li>\n<li>mTrackingEdges是由setEdgeTrackingEnabled(int edgeFlags)设置的，当我们想要追踪监听边缘触摸时才需要调用setEdgeTrackingEnabled(int edgeFlags)，如果我们没有调用过它，这里就直接返回false了。</li>\n<li>mEdgeDragsLocked它在这个方法里被引用了多次，它在整个ViewDragHelper里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行mEdgeDragsLocked[pointerId] &amp; edge) == edge执行的结果是false。我们再跳到11到14行看看，absDelta &lt; absODelta * 0.5f的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用Callback的onEdgeLock(edge)检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在mEdgeDragsInProgress里了，也不会收到Callback的onEdgeDragStarted()通知了。并且将锁定的边缘记录在mEdgeDragsLocked变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的edge被锁定，就直接返回false了。</li>\n<li>回到第7行的(mEdgeDragsInProgress[pointerId] &amp; edge) == edge，mEdgeDragsInProgress是保存已发生过拖动事件的边缘的，如果给定的edge已经保存过了，那就没必要再检测其他东西了，直接返回false了。</li>\n<li>第8行(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。</li>\n<li>最后一句返回的时候再次检查给定的edge有没有记录过，确保了每个边缘只会调用一次reportNewEdgeDrags的mCallback.onEdgeDragStarted(dragsStarted, pointerId)</li>\n</ul>\n<p>再来看checkTouchSlop()方法：</p>\n<pre><code>/**\n * Check if we&#39;ve crossed a reasonable touch slop for the given child view.\n * If the child cannot be dragged along the horizontal or vertical axis, motion\n * along that axis will not count toward the slop check.\n *\n * @param child Child to check\n * @param dx Motion since initial position along X axis\n * @param dy Motion since initial position along Y axis\n * @return true if the touch slop has been crossed\n */\nprivate boolean checkTouchSlop(View child, float dx, float dy) {\n    if (child == null) {\n        return false;\n    }\n    final boolean checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; 0;\n    final boolean checkVertical = mCallback.getViewVerticalDragRange(child) &gt; 0;\n\n    if (checkHorizontal &amp;&amp; checkVertical) {\n        return dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;\n    } else if (checkHorizontal) {\n        return Math.abs(dx) &gt; mTouchSlop;\n    } else if (checkVertical) {\n        return Math.abs(dy) &gt; mTouchSlop;\n    }\n    return false;\n}\n</code></pre><p>这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（mTouchSlop）了，注意dx和dy指的是当前触摸点到ACTION_DOWN触摸到的点的距离。这里先检查Callback的getViewHorizontalDragRange(child)和getViewVerticalDragRange(child)是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在processTouchEvent()的ACTION_MOVE部分就不会调用tryCaptureViewForDrag()来捕获当前触摸到的View了，拖动也就没办法进行了。</p>\n<p>回到processTouchEvent()的ACTION_MOVE部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了Callback中的相关方法，让tryCaptureViewForDrag()正常的捕获到触摸到的View了，下一次ACTION_MOVE时就执行if部分的代码了，也就是开始不停的调用dragTo()对mCaptureView进行真正拖动了，看dragTo()方法：</p>\n<pre><code>private void dragTo(int left, int top, int dx, int dy) {\n    int clampedX = left;\n    int clampedY = top;\n    final int oldLeft = mCapturedView.getLeft();\n    final int oldTop = mCapturedView.getTop();\n    if (dx != 0) {\n        clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);\n        mCapturedView.offsetLeftAndRight(clampedX - oldLeft);\n    }\n    if (dy != 0) {\n        clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);\n        mCapturedView.offsetTopAndBottom(clampedY - oldTop);\n    }\n\n    if (dx != 0 || dy != 0) {\n        final int clampedDx = clampedX - oldLeft;\n        final int clampedDy = clampedY - oldTop;\n        mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,\n                clampedDx, clampedDy);\n    }\n}\n</code></pre><p>参数dx和dy是前后两次ACTION_MOVE移动的距离，left和top分别为mCapturedView.getLeft() + dx, mCapturedView.getTop() + dy，也就是期望的移动后的坐标，对View的getLeft()等方法不理解的请参阅<a href=\"http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html\" target=\"_blank\" rel=\"noopener\">Android View坐标getLeft, getRight, getTop, getBottom</a>。</p>\n<p>这里通过调用offsetLeftAndRight()和offsetTopAndBottom()来完成对mCapturedView移动，这两个是View中定义的方法，看它们的源码就知道内部是通过改变View的mLeft、mRight、mTop、mBottom，即改变View在父容器中的坐标位置，达到移动View的效果，所以如果调用mCapturedView的layout(int l, int t, int r, int b)方法也可以实现移动View的效果。</p>\n<p>具体要移动到哪里，由Callback的clampViewPositionHorizontal()和clampViewPositionVertical()来决定的，如果不想在水平方向上移动，在clampViewPositionHorizontal(View child, int left, int dx)里直接返回child.getLeft()就可以了，这样clampedX - oldLeft的值为0，这里调用mCapturedView.offsetLeftAndRight(clampedX - oldLeft)就不会起作用了。垂直方向上同理。</p>\n<p>最后会调用Callback的onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)通知捕获到的View位置改变了，并把最终的坐标（clampedX、clampedY）和最终的移动距离（clampedDx、 clampedDy）传递过去。</p>\n<p>ACTION_MOVE部分就算告一段落了，接下来应该是用户松手触发ACTION_UP，或者是达到某个条件导致后续的ACTION_MOVE被mParentView的上层View给拦截了而收到ACTION_CANCEL，一起来看这两个部分：</p>\n<pre><code>public void processTouchEvent(MotionEvent ev) {\n    // 省略\n\n    switch (action) {\n        // 省略其他case\n\n        case MotionEvent.ACTION_UP: {\n            if (mDragState == STATE_DRAGGING) {\n                releaseViewForPointerUp();\n            }\n            cancel();\n            break;\n        }\n\n        case MotionEvent.ACTION_CANCEL: {\n            if (mDragState == STATE_DRAGGING) {\n                dispatchViewReleased(0, 0);\n            }\n            cancel();\n            break;\n        }\n    }\n}\n</code></pre><p>这两个部分都是重置所有的状态记录，并通知View被放开了，再看下releaseViewForPointerUp()和dispatchViewReleased()的源码：</p>\n<pre><code>private void releaseViewForPointerUp() {\n    mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity);\n    final float xvel = clampMag(\n            VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            mMinVelocity, mMaxVelocity);\n    final float yvel = clampMag(\n            VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n            mMinVelocity, mMaxVelocity);\n    dispatchViewReleased(xvel, yvel);\n}\n</code></pre><p>releaseViewForPointerUp()里也调用了dispatchViewReleased()，只不过传递了速率给它，这个速率就是由processTouchEvent()的mVelocityTracker追踪算出来的。再看dispatchViewReleased()：</p>\n<pre><code>/**\n * Like all callback events this must happen on the UI thread, but release\n * involves some extra semantics. During a release (mReleaseInProgress)\n * is the only time it is valid to call {@link #settleCapturedViewAt(int, int)}\n * or {@link #flingCapturedView(int, int, int, int)}.\n */\nprivate void dispatchViewReleased(float xvel, float yvel) {\n    mReleaseInProgress = true;\n    mCallback.onViewReleased(mCapturedView, xvel, yvel);\n    mReleaseInProgress = false;\n\n    if (mDragState == STATE_DRAGGING) {\n        // onViewReleased didn&#39;t call a method that would have changed this. Go idle.\n        setDragState(STATE_IDLE);\n    }\n}\n</code></pre><p>这里调用Callback的onViewReleased(mCapturedView, xvel, yvel)通知外部捕获到的View被释放了，而在onViewReleased()前后有个mReleaseInProgress值得注意，注释里说唯一可以调用ViewDragHelper的settleCapturedViewAt()和flingCapturedView()的地方就是在Callback的onViewReleased()里了。</p>\n<p>首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。<br>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（flingCapturedView的四个参数int minLeft, int minTop, int maxLeft, int maxTop可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用settleCapturedViewAt(int finalLeft, int finalTop)。</p>\n<p>为什么唯一可以调用settleCapturedViewAt()和flingCapturedView()的地方是Callback的onViewReleased()呢？看看它们的源码</p>\n<pre><code>/**\n * Settle the captured view at the given (left, top) position.\n * The appropriate velocity from prior motion will be taken into account.\n * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n * on each subsequent frame to continue the motion until it returns false. If this method\n * returns false there is no further work to do to complete the movement.\n *\n * @param finalLeft Settled left edge position for the captured view\n * @param finalTop Settled top edge position for the captured view\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\npublic boolean settleCapturedViewAt(int finalLeft, int finalTop) {\n    if (!mReleaseInProgress) {\n        throw new IllegalStateException(&quot;Cannot settleCapturedViewAt outside of a call to &quot; +\n                &quot;Callback#onViewReleased&quot;);\n    }\n\n    return forceSettleCapturedViewAt(finalLeft, finalTop,\n            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));\n}\n\n/**\n * Settle the captured view based on standard free-moving fling behavior.\n * The caller should invoke {@link #continueSettling(boolean)} on each subsequent frame\n * to continue the motion until it returns false.\n *\n * @param minLeft Minimum X position for the view&#39;s left edge\n * @param minTop Minimum Y position for the view&#39;s top edge\n * @param maxLeft Maximum X position for the view&#39;s left edge\n * @param maxTop Maximum Y position for the view&#39;s top edge\n */\npublic void flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop) {\n    if (!mReleaseInProgress) {\n        throw new IllegalStateException(&quot;Cannot flingCapturedView outside of a call to &quot; +\n                &quot;Callback#onViewReleased&quot;);\n    }\n\n    mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),\n            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n            minLeft, maxLeft, minTop, maxTop);\n\n    setDragState(STATE_SETTLING);\n}\n</code></pre><p>这两个方法里一开始都会判断mReleaseInProgress为false，如果为false就会抛一个IllegalStateException异常，而mReleaseInProgress唯一为true的时候就是在dispatchViewReleased()里调用onViewReleased()的时候。</p>\n<p>Scroller的用法请参阅<a href=\"http://blog.csdn.net/qinjuning/article/details/7419207\" target=\"_blank\" rel=\"noopener\">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> ，或者自行解读Scroller源码，代码量不多。</p>\n<p>ViewDragHelper还有一个移动View的方法是smoothSlideViewTo(View child, int finalLeft, int finalTop)，看下它的源码：</p>\n<pre><code>/**\n * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position.\n * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n * on each subsequent frame to continue the motion until it returns false. If this method\n * returns false there is no further work to do to complete the movement.\n *\n * &lt;p&gt;This operation does not count as a capture event, though {@link #getCapturedView()}\n * will still report the sliding view while the slide is in progress.&lt;/p&gt;\n *\n * @param child Child view to capture and animate\n * @param finalLeft Final left position of child\n * @param finalTop Final top position of child\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\npublic boolean smoothSlideViewTo(View child, int finalLeft, int finalTop) {\n    mCapturedView = child;\n    mActivePointerId = INVALID_POINTER;\n\n    boolean continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);\n    if (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != null) {\n        // If we&#39;re in an IDLE state to begin with and aren&#39;t moving anywhere, we\n        // end up having a non-null capturedView with an IDLE dragState\n        mCapturedView = null;\n    }\n\n    return continueSliding;\n}\n</code></pre><p>可以看到它不受mReleaseInProgress的限制，所以可以在任何地方调用，效果和settleCapturedViewAt()类似，因为它们最终都调用了forceSettleCapturedViewAt()来启动自动滚动，区别在于settleCapturedViewAt()会以最后松手前的滑动速率为初速度将View滚动到最终位置，而smoothSlideViewTo()滚动的初速度是0。forceSettleCapturedViewAt()里有地方调用了Callback里的方法，所以再来看看这个方法：</p>\n<pre><code>/**\n * Settle the captured view at the given (left, top) position.\n *\n * @param finalLeft Target left position for the captured view\n * @param finalTop Target top position for the captured view\n * @param xvel Horizontal velocity\n * @param yvel Vertical velocity\n * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n */\nprivate boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {\n    final int startLeft = mCapturedView.getLeft();\n    final int startTop = mCapturedView.getTop();\n    final int dx = finalLeft - startLeft;\n    final int dy = finalTop - startTop;\n\n    if (dx == 0 &amp;&amp; dy == 0) {\n        // Nothing to do. Send callbacks, be done.\n        mScroller.abortAnimation();\n        setDragState(STATE_IDLE);\n        return false;\n    }\n\n    final int duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);\n    mScroller.startScroll(startLeft, startTop, dx, dy, duration);\n\n    setDragState(STATE_SETTLING);\n    return true;\n}\n</code></pre><p>可以看到自动滑动是靠Scroll类完成，在这里生成了调用mScroller.startScroll()需要的参数。再来看看计算滚动时间的方法computeSettleDuration()：</p>\n<pre><code>private int computeSettleDuration(View child, int dx, int dy, int xvel, int yvel) {\n    xvel = clampMag(xvel, (int) mMinVelocity, (int) mMaxVelocity);\n    yvel = clampMag(yvel, (int) mMinVelocity, (int) mMaxVelocity);\n    final int absDx = Math.abs(dx);\n    final int absDy = Math.abs(dy);\n    final int absXVel = Math.abs(xvel);\n    final int absYVel = Math.abs(yvel);\n    final int addedVel = absXVel + absYVel;\n    final int addedDistance = absDx + absDy;\n\n    final float xweight = xvel != 0 ? (float) absXVel / addedVel :\n            (float) absDx / addedDistance;\n    final float yweight = yvel != 0 ? (float) absYVel / addedVel :\n            (float) absDy / addedDistance;\n\n    int xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));\n    int yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));\n\n    return (int) (xduration * xweight + yduration * yweight);\n}\n</code></pre><p>clampMag()方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过computeAxisDuration()算出来，通过它的参数可以看到最终的滚动时间是由dx、xvel、mCallback.getViewHorizontalDragRange()共同影响的。看computeAxisDuration()：</p>\n<pre><code>private int computeAxisDuration(int delta, int velocity, int motionRange) {\n    if (delta == 0) {\n        return 0;\n    }\n\n    final int width = mParentView.getWidth();\n    final int halfWidth = width / 2;\n    final float distanceRatio = Math.min(1f, (float) Math.abs(delta) / width);\n    final float distance = halfWidth + halfWidth *\n            distanceInfluenceForSnapDuration(distanceRatio);\n\n    int duration;\n    velocity = Math.abs(velocity);\n    if (velocity &gt; 0) {\n        duration = 4 * Math.round(1000 * Math.abs(distance / velocity));\n    } else {\n        final float range = (float) Math.abs(delta) / motionRange;\n        duration = (int) ((range + 1) * BASE_SETTLE_DURATION);\n    }\n    return Math.min(duration, MAX_SETTLE_DURATION);\n}\n</code></pre><p>6~10行没看明白，直接看14~19行，如果给定的速率velocity不为0，就通过距离除以速率来算出时间；如果velocity为0，就通过要滑动的距离（delta）除以总的移动范围（motionRange，就是Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过MAX_SETTLE_DURATION的，源码里的取值是600毫秒，所以不用担心在Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回错误的数而导致自动滚动时间过长了。</p>\n<p>在调用settleCapturedViewAt()、flingCapturedView()和smoothSlideViewTo()时，还需要实现mParentView的computeScroll()：</p>\n<pre><code>@Override\npublic void computeScroll() {\n    if (mDragHelper.continueSettling(true)) {\n        ViewCompat.postInvalidateOnAnimation(this);\n    }\n}\n</code></pre><p>这属于Scroll类用法的范畴，不明白的请参阅<a href=\"http://blog.csdn.net/qinjuning/article/details/7419207\" target=\"_blank\" rel=\"noopener\">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> 的“知识点二： computeScroll(）方法介绍”。</p>\n<p>至此，整个触摸流程和ViewDragHelper的重要的方法都过了一遍。之前在讨论shouldInterceptTouchEvent()的ACTION_DOWN部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次ACTION_DOWN事件的情况，现在来看看这种情况。</p>\n<p>假设现在shouldInterceptTouchEvent()的ACTION_DOWN部分执行完了，也有子View消费了这次的ACTION_DOWN事件，那么接下来就会调用mParentView的onInterceptTouchEvent()的ACTION_MOVE部分，不明白为什么的请参阅<a href=\"http://blog.csdn.net/xiaanming/article/details/21696315\" target=\"_blank\" rel=\"noopener\">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>，接着调用ViewDragHelper的shouldInterceptTouchEvent()的ACTION_MOVE部分：</p>\n<pre><code>public boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    // 省略...\n\n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_MOVE: {\n            // First to cross a touch slop over a draggable view wins. Also report edge drags.\n            final int pointerCount = MotionEventCompat.getPointerCount(ev);\n            for (int i = 0; i &lt; pointerCount; i++) {\n                final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                final float x = MotionEventCompat.getX(ev, i);\n                final float y = MotionEventCompat.getY(ev, i);\n                final float dx = x - mInitialMotionX[pointerId];\n                final float dy = y - mInitialMotionY[pointerId];\n\n                final View toCapture = findTopChildUnder((int) x, (int) y);\n                final boolean pastSlop = toCapture != null &amp;&amp; checkTouchSlop(toCapture, dx, dy);\n                if (pastSlop) {\n                    // check the callback&#39;s\n                    // getView[Horizontal|Vertical]DragRange methods to know\n                    // if you can move at all along an axis, then see if it\n                    // would clamp to the same value. If you can&#39;t move at\n                    // all in every dimension with a nonzero range, bail.\n                    final int oldLeft = toCapture.getLeft();\n                    final int targetLeft = oldLeft + (int) dx;\n                    final int newLeft = mCallback.clampViewPositionHorizontal(toCapture,\n                            targetLeft, (int) dx);\n                    final int oldTop = toCapture.getTop();\n                    final int targetTop = oldTop + (int) dy;\n                    final int newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,\n                            (int) dy);\n                    final int horizontalDragRange = mCallback.getViewHorizontalDragRange(\n                            toCapture);\n                    final int verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);\n                    if ((horizontalDragRange == 0 || horizontalDragRange &gt; 0\n                            &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == 0\n                            || verticalDragRange &gt; 0 &amp;&amp; newTop == oldTop)) {\n                        break;\n                    }\n                }\n                reportNewEdgeDrags(dx, dy, pointerId);\n                if (mDragState == STATE_DRAGGING) {\n                    // Callback might have started an edge drag\n                    break;\n                }\n\n                if (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) {\n                    break;\n                }\n            }\n            saveLastMotion(ev);\n            break;\n        }\n\n        // 省略其他case...\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n</code></pre><p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用findTopChildUnder(int x, int y)寻找触摸点处的子View，再用checkTouchSlop(View child, float dx, float dy)检查当前触摸点到ACTION_DOWN触摸点的距离是否达到了mTouchSlop，达到了才会去捕获View。<br>接着看19~41行if (pastSlop){…}部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到getView[Horizontal|Vertical]DragRange和clampViewPosition[Horizontal|Vertical]四个方法。如果getView[Horizontal|Vertical]DragRange返回都是0，就会认作是不会产生拖动。clampViewPosition[Horizontal|Vertical]返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接break，不会执行后续的代码，而后续代码里有调用tryCaptureViewForDrag()，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。<br>如果检查到可以在某个方向上进行拖动，就会调用后面的tryCaptureViewForDrag()捕获子View，如果捕获成功，mDragState就会变成STATE_DRAGGING，shouldInterceptTouchEvent()返回true，mParentView的onInterceptTouchEvent()返回true，后续的移动事件就会在mParentView的onTouchEvent()执行了，最后执行的就是mParentView的processTouchEvent()的ACTION_MOVE部分，拖动正常进行。</p>\n<p>回头再看之前在shouldInterceptTouchEvent()的ACTION_DOWN部分留下的坑：</p>\n<pre><code>public boolean shouldInterceptTouchEvent(MotionEvent ev) {\n    // 省略其他部分...\n\n    switch (action) {\n        // 省略其他case...\n\n        case MotionEvent.ACTION_DOWN: {\n            // 省略其他部分...\n\n            // Catch a settling view if possible.\n            if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) {\n                tryCaptureViewForDrag(toCapture, pointerId);\n            }\n\n            // 省略其他部分...\n        }\n\n        // 省略其他case...\n    }\n\n    return mDragState == STATE_DRAGGING;\n}\n</code></pre><p>现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的tryCaptureViewForDrag()尝试捕获View，如果捕获成功，mDragState就变为STATE_DRAGGING了，shouldInterceptTouchEvent()就返回true了，然后就是mParentView的onInterceptTouchEvent()返回true，接着执行mParentView的onTouchEvent()，再执行processTouchEvent()的ACTION_DOWN部分。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动。</p>\n<p>至此整个事件传递流程和ViewDragHelper的重要方法基本都解析完了，shouldInterceptTouchEvent()和processTouchEvent()的ACTION_POINTER_DOWN、ACTION_POINTER_UP部分就留给读者自己解析了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。</p>\n<ul>\n<li><a href=\"http://www.processon.com/view/link/5550a7bae4b09739f465ec64\" target=\"_blank\" rel=\"noopener\">单点触摸，没有考虑边缘滑动检测的最简流程图</a></li>\n<li><a href=\"http://www.processon.com/view/link/5550d3dce4b09739f46789bd\" target=\"_blank\" rel=\"noopener\">单点触摸，考虑了边缘滑动检测的流程图</a></li>\n</ul>\n<p>多点触摸情况我就没研究了，在这里忽略~</p>\n<p>三个开启自动滚动的方法：</p>\n<ul>\n<li>settleCapturedViewAt(int finalLeft, int finalTop)<br>以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在Callback的onViewReleased()中调用。</li>\n<li>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)<br>以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在Callback的onViewReleased()中调用。</li>\n<li>smoothSlideViewTo(View child, int finalLeft, int finalTop)<br>指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。</li>\n</ul>\n<p>Callback的各个方法总结：</p>\n<ul>\n<li><p>void onViewDragStateChanged(int state)</p>\n<p>拖动状态改变时会调用此方法，状态state有STATE_IDLE、STATE_DRAGGING、STATE_SETTLING三种取值。</p>\n<p>它在setDragState()里被调用，而setDragState()被调用的地方有</p>\n<ul>\n<li>tryCaptureViewForDrag()成功捕获到子View时<ul>\n<li>shouldInterceptTouchEvent()的ACTION_DOWN部分捕获到</li>\n<li>shouldInterceptTouchEvent()的ACTION_MOVE部分捕获到</li>\n<li>processTouchEvent()的ACTION_MOVE部分捕获到</li>\n</ul>\n</li>\n<li>调用settleCapturedViewAt()、smoothSlideViewTo()、flingCapturedView()时</li>\n<li>拖动View松手时（processTouchEvent()的ACTION_UP、ACTION_CANCEL）</li>\n<li>自动滚动停止时（continueSettling()里检测到滚动结束时）</li>\n<li>外部调用abort()时</li>\n</ul>\n</li>\n<li><p>void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</p>\n<p>正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。</p>\n<ul>\n<li>在dragTo()里被调用（正在被拖动时）</li>\n<li>在continueSettling()里被调用（自动滚动时）</li>\n<li>外部调用abort()时被调用</li>\n</ul>\n</li>\n<li><p>void onViewCaptured(View capturedChild, int activePointerId)</p>\n<p>tryCaptureViewForDrag()成功捕获到子View时会调用此方法。</p>\n<ul>\n<li>在shouldInterceptTouchEvent()的ACTION_DOWN里成功捕获</li>\n<li>在shouldInterceptTouchEvent()的ACTION_MOVE里成功捕获</li>\n<li>在processTouchEvent()的ACTION_MOVE里成功捕获</li>\n<li>手动调用captureChildView()</li>\n</ul>\n</li>\n<li><p>void onViewReleased(View releasedChild, float xvel, float yvel)<br>拖动View松手时（processTouchEvent()的ACTION_UP）或被父View拦截事件时（processTouchEvent()的ACTION_CANCEL）会调用此方法。</p>\n</li>\n<li><p>void onEdgeTouched(int edgeFlags, int pointerId)<br>ACTION_DOWN或ACTION_POINTER_DOWN事件发生时如果触摸到监听的边缘会调用此方法。edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。</p>\n</li>\n<li><p>boolean onEdgeLock(int edgeFlags)<br>返回true表示锁定edgeFlags对应的边缘，锁定后的那些边缘就不会在onEdgeDragStarted()被通知了，默认返回false不锁定给定的边缘，edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM其中之一。</p>\n</li>\n<li><p>void onEdgeDragStarted(int edgeFlags, int pointerId)<br>ACTION_MOVE事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。edgeFlags取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。可在此手动调用captureChildView()触发从边缘拖动子View的效果。</p>\n</li>\n<li><p>int getOrderedChildIndex(int index)<br>在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给tryCaptureViewForDrag()来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。</p>\n</li>\n<li><p>int getViewHorizontalDragRange(View child)、int getViewVerticalDragRange(View child)</p>\n<p>返回给定的child在相应的方向上可以被拖动的最远距离，默认返回0。ACTION_DOWN发生时，若触摸点处的child消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。</p>\n<p>被调用的地方有三处：</p>\n<ul>\n<li>在checkTouchSlop()中被调用，返回值大于0才会去检查mTouchSlop。在ACTION_MOVE里调用tryCaptureViewForDrag()之前会调用checkTouchSlop()。如果checkTouchSlop()失败，就不会去捕获View了。</li>\n<li>如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。</li>\n<li>在调用smoothSlideViewTo()时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在getView[Horizontal|Vertical]DragRange里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。</li>\n</ul>\n</li>\n<li><p>boolean tryCaptureView(View child, int pointerId)</p>\n<p>在tryCaptureViewForDrag()中被调用，返回true表示捕获给定的child。tryCaptureViewForDrag()被调用的地方有</p>\n<ul>\n<li>shouldInterceptTouchEvent()的ACTION_DOWN里</li>\n<li>shouldInterceptTouchEvent()的ACTION_MOVE里</li>\n<li>processTouchEvent()的ACTION_MOVE里</li>\n</ul>\n</li>\n<li><p>int clampViewPositionHorizontal(View child, int left, int dx)、int clampViewPositionVertical(View child, int top, int dy)</p>\n<p>child在某方向上被拖动时会调用对应方法，返回值是child移动过后的坐标位置，clampViewPositionHorizontal()返回child移动过后的left值，clampViewPositionVertical()返回child移动过后的top值。</p>\n<p>两个方法被调用的地方有两处：</p>\n<ul>\n<li>在dragTo()中被调用，dragTo()在processTouchEvent()的ACTION_MOVE里被调用。用来获取被拖动的View要移动到的位置。</li>\n<li>如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"案例参考\"><a href=\"#案例参考\" class=\"headerlink\" title=\"案例参考\"></a>案例参考</h3><p>在这里列举一部分对ViewDragHelper的应用案例，大家自己剖析它们的源码来实践巩固。</p>\n<ol>\n<li><a href=\"https://github.com/flavienlaurent/flavienlaurent.com\" target=\"_blank\" rel=\"noopener\">YoutubeLayout</a>，这是最简单的Demo</li>\n<li><a href=\"https://github.com/BlueMor/DragLayout\" target=\"_blank\" rel=\"noopener\">QQ5.x侧滑菜单</a>、<a href=\"https://github.com/kyze8439690/ResideLayout\" target=\"_blank\" rel=\"noopener\">ResideLayout</a></li>\n<li><a href=\"https://github.com/ikew0ng/SwipeBackLayout\" target=\"_blank\" rel=\"noopener\">SwipeBackLayout</a>、<a href=\"https://github.com/liuguangqiang/SwipeBack\" target=\"_blank\" rel=\"noopener\">SwipeBack</a></li>\n<li><a href=\"https://github.com/umano/AndroidSlidingUpPanel\" target=\"_blank\" rel=\"noopener\">SlidingUpPanel</a></li>\n<li><a href=\"https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java\" target=\"_blank\" rel=\"noopener\">DrawerLayout</a></li>\n</ol>\n<h3 id=\"其他关于ViewDragHelper的分析文章\"><a href=\"#其他关于ViewDragHelper的分析文章\" class=\"headerlink\" title=\"其他关于ViewDragHelper的分析文章\"></a>其他关于ViewDragHelper的分析文章</h3><ul>\n<li><a href=\"http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper\" target=\"_blank\" rel=\"noopener\">Each Navigation Drawer Hides a ViewDragHelper</a>，文中的源码就是上面的<a href=\"https://github.com/flavienlaurent/flavienlaurent.com\" target=\"_blank\" rel=\"noopener\">YoutubeLayout</a></li>\n<li><a href=\"http://blog.csdn.net/pi9nc/article/details/39583377\" target=\"_blank\" rel=\"noopener\">ViewDragHelper详解</a>，这是上面文章的简略中文版</li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck2yl86ay0001lh1pmzb7qwil","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86b30003lh1pfc6viuay"},{"post_id":"ck2yl86bv0004lh1pcdyds597","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86c10008lh1pw5p07kco"},{"post_id":"ck2yl86c5000blh1px246pmbu","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86c9000elh1ph8ix12cx"},{"post_id":"ck2yl86c3000alh1pygir4rq5","tag_id":"ck2yl86c7000clh1pq6g9vvah","_id":"ck2yl86cd000ilh1pk6hhsksh"},{"post_id":"ck2yl86cd000jlh1px5hwn8uk","tag_id":"ck2yl86cd000hlh1pfuo0e1jd","_id":"ck2yl86ci000mlh1pumixqm7h"},{"post_id":"ck2yl86c7000dlh1pma10bvvf","tag_id":"ck2yl86cd000hlh1pfuo0e1jd","_id":"ck2yl86ck000olh1phhahcuzm"},{"post_id":"ck2yl86cf000klh1plklptp9a","tag_id":"ck2yl86cd000hlh1pfuo0e1jd","_id":"ck2yl86cm000rlh1pz0jpr5an"},{"post_id":"ck2yl86ci000nlh1ps1e2mcj7","tag_id":"ck2yl86cd000hlh1pfuo0e1jd","_id":"ck2yl86co000tlh1p1a4093ps"},{"post_id":"ck2yl86ca000flh1pdt4qtfci","tag_id":"ck2yl86cd000hlh1pfuo0e1jd","_id":"ck2yl86cp000wlh1p3s6zzocz"},{"post_id":"ck2yl86cm000slh1poacbevkx","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86cq000xlh1p3tb1q0im"},{"post_id":"ck2yl86cc000glh1p0w5h4dho","tag_id":"ck2yl86cd000hlh1pfuo0e1jd","_id":"ck2yl86cr000zlh1pc6itltbs"},{"post_id":"ck2yl86ck000plh1pwfojm0kt","tag_id":"ck2yl86cp000vlh1poxbpjnwv","_id":"ck2yl86cr0010lh1pefeice9v"},{"post_id":"ck2yl86co000ulh1p4nyxiwdg","tag_id":"ck2yl86cp000vlh1poxbpjnwv","_id":"ck2yl86cs0011lh1pwdl4amm3"},{"post_id":"ck2yl86df0012lh1pdh6pyici","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86di0014lh1pby1w7o1g"},{"post_id":"ck2yl86dl0018lh1pucv074ej","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86dp001blh1p2uzj1kbr"},{"post_id":"ck2yl86dn0019lh1pqqq8oa2h","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86dq001dlh1p8ego5023"},{"post_id":"ck2yl86dp001clh1pmwrxyvss","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86ds001glh1p6ld0w93t"},{"post_id":"ck2yl86dh0013lh1pkq0tk3hu","tag_id":"ck2yl86dk0016lh1pcd7dgvhb","_id":"ck2yl86dt001ilh1pa3yhc1wu"},{"post_id":"ck2yl86dh0013lh1pkq0tk3hu","tag_id":"ck2yl86do001alh1pc0tnbex5","_id":"ck2yl86du001klh1pwk2q8ro5"},{"post_id":"ck2yl86dr001elh1p2e8klfdt","tag_id":"ck2yl86cd000hlh1pfuo0e1jd","_id":"ck2yl86dv001llh1phcoruyco"},{"post_id":"ck2yl86dt001hlh1p7ddmr0qu","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86dv001nlh1pi16zl9qs"},{"post_id":"ck2yl86di0015lh1pu5edl6e8","tag_id":"ck2yl86dk0016lh1pcd7dgvhb","_id":"ck2yl86dw001olh1pnsrw5yu3"},{"post_id":"ck2yl86di0015lh1pu5edl6e8","tag_id":"ck2yl86do001alh1pc0tnbex5","_id":"ck2yl86dw001qlh1pvgcpaynn"},{"post_id":"ck2yl86dk0017lh1p03r88n5a","tag_id":"ck2yl86dk0016lh1pcd7dgvhb","_id":"ck2yl86dx001rlh1pheq8y2ki"},{"post_id":"ck2yl86dk0017lh1p03r88n5a","tag_id":"ck2yl86do001alh1pc0tnbex5","_id":"ck2yl86dx001slh1pj0kp1vsn"},{"post_id":"ck2yl86ep001tlh1pxdspgpfw","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86eq001vlh1p9ox35dbq"},{"post_id":"ck2yl86ep001ulh1p5atkwl16","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86es001xlh1pamwm3hlz"},{"post_id":"ck2yl86eq001wlh1pzl6ybvq9","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86es001ylh1p0mwqswkr"},{"post_id":"ck2yl86f6001zlh1pji1bujb1","tag_id":"ck2yl86dk0016lh1pcd7dgvhb","_id":"ck2yl86f70020lh1pmdnajz8r"},{"post_id":"ck2yl86f6001zlh1pji1bujb1","tag_id":"ck2yl86do001alh1pc0tnbex5","_id":"ck2yl86f70021lh1p75wejlmz"},{"post_id":"ck2yl86fi0022lh1p3v9rraqn","tag_id":"ck2yl86b10002lh1ppxijhwmw","_id":"ck2yl86fj0024lh1pwwz4yl95"},{"post_id":"ck2yl86fi0022lh1p3v9rraqn","tag_id":"ck2yl86fj0023lh1p2vuepgpd","_id":"ck2yl86fj0025lh1pj3122w1v"}],"Tag":[{"name":"Android","_id":"ck2yl86b10002lh1ppxijhwmw"},{"name":"android","_id":"ck2yl86c7000clh1pq6g9vvah"},{"name":"design-pattern","_id":"ck2yl86cd000hlh1pfuo0e1jd"},{"name":"java基础","_id":"ck2yl86cp000vlh1poxbpjnwv"},{"name":"读书笔记","_id":"ck2yl86dk0016lh1pcd7dgvhb"},{"name":"Efficient.Android.Threading","_id":"ck2yl86do001alh1pc0tnbex5"},{"name":"源码解析","_id":"ck2yl86fj0023lh1p2vuepgpd"}]}}