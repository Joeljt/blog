<!DOCTYPE html>
<html style="display: none;" lang="en">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source"/>














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            Java 中的多线程 | 
        
        Joe&#39;s blog
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="
Efficient.Android.Threading 第二章读书笔记
">
    <meta name="keywords" content=",读书笔记,Efficient.Android.Threading">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/css/material.min.css",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/css/style.min.css",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    
        
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/css/fontawesome.min.css">
        
    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/css/material-icons.css",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/js/jquery.min.js", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Joe&#39;s blog">
    <meta name="msapplication-starturl" content="http://joeljt.top/2018/08/25/Efficient-Android-Threading-chapter-2/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Joe&#39;s blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://joeljt.top/2018/08/25/Efficient-Android-Threading-chapter-2/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Java 中的多线程 | Joe&#39;s blog">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="
Efficient.Android.Threading 第二章读书笔记
">
    <meta property="og:article:tag" content="读书笔记"> <meta property="og:article:tag" content="Efficient.Android.Threading"> 

    
        <meta property="article:published_time" content="Sat Aug 25 2018 00:00:00 GMT+0800">
        <meta property="article:modified_time" content="Sat Aug 25 2018 14:32:37 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://joeljt.top/2018/08/25/Efficient-Android-Threading-chapter-2/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://joeljt.top/2018/08/25/Efficient-Android-Threading-chapter-2/index.html",
    "headline": "Java 中的多线程",
    "datePublished": "Sat Aug 25 2018 00:00:00 GMT+0800",
    "dateModified": "Sat Aug 25 2018 14:32:37 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "joe",
        "image": {
            "@type": "ImageObject",
            "url": "/img/portrait.jpeg"
        },
        "description": "今でもあなたは私の光。"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Joe&#39;s blog",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",读书笔记,Efficient.Android.Threading",
    "description": "
Efficient.Android.Threading 第二章读书笔记
",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Isolation" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                
                    <!-- Isolation Header -->
                    <header class="header">
    <div class="header-wrapper">
        <!-- Header Copyright -->
        <div class="header-copyright">
            <div class="header-site">
                ©&nbsp;
                <script type="text/javascript">
                    var fd = new Date();
                    document.write(fd.getFullYear());
                </script>
                &nbsp;Joe's blog
            </div>
            <!--
            I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright.
            It will not impact the appearance and can give developers a lot of support :)

            很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
            它不会影响美观并可以给开发者很大的支持。 :)
            -->
            <div>
                Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a>
                <br>
                Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a>
            </div>
        </div>

        <!-- Header Title -->
        <span class="header-title header-item">
            <a href="/" title="Joe&#39;s blog">
                Joe&#39;s blog
            </a>
        </span>

        <p class="header-slogan header-item">
        
            
                今でもあなたは私の光。
            
        
        </p>

        <!-- Header Nav -->
        <nav class="header-nav header-item">
            <span class="header-nav-item">
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </span>

            <!-- Pages  -->
            
                <span class="header-nav-item">
                    <a href="/tags" title="归档">
                        <span>归档</span>
                    </a>
                </span>
            
            
        </nav>

        <!-- Header SNS -->
        <div class="header-item header-sns_list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/Joeljt" target="_blank">
            <i class="fa fa-github fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- LinkedIn -->
    

    <!-- Telegram -->
    
</div>

    </div>
</header>

                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    

                    <!-- Post TOC -->

    



<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                


    <!-- Isolation Post Header -->
    <!-- Post thumbnail -->
    
        <!-- Post Header Info -->
        <div class="post-header_info with-thumbnail">
            <!-- Author Avatar & Name -->
            <img src="/img/portrait.jpeg" class="avatar-img" width="44px" height="44px" alt="joe's avatar">
            <span class="name-span">joe</span>
        </div>

        <!-- Custom thumbnail -->
        <div class="post_thumbnail-custom">
            <img src="http://p5zd0id9p.bkt.clouddn.com/18-8-25/78521256.jpg">
    
        </div>



                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    

    
        <div class="post-content_wrapper">
            <p class="post-title">
                Java 中的多线程
            </p>
            <blockquote>
<p>Efficient.Android.Threading 第二章读书笔记</p>
</blockquote>
<a id="more"></a>
<p>所有 Android 应用都应该进行多线程编程，因为其可以大幅度的提高应用的性能以及响应效果；但是也会由此带来一系列的问题，导致编码的过程更加复杂。</p>
<ul>
<li>处理 Java 并发</li>
<li>在多个线程中保证共享数据的稳定性</li>
<li>定制以及优化不同线程的执行策略</li>
</ul>
<h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><p>线程 <code>thread</code> 是 CPU 最小调度单元，一般来讲，一个应用中的任务会按代码顺序来执行。线程中待执行的代码被称作任务 <code>task</code>。一个线程可以只执行一个任务，也可以按顺序执行多个任务。</p>
<h4 id="线程的执行"><a href="#线程的执行" class="headerlink" title="线程的执行"></a>线程的执行</h4><p>Android 应用中的常用线程即 <code>java.lang.Thread</code>，线程生命周期的长度取决于执行任务的大小以及耗时。</p>
<p>线程支持执行实现了 <code>java.lang.Runnable</code> 接口的任务，具体的任务是实现在 <code>run</code> 方法中的，具体如下：</p>
<pre><code class="java">private class MyTask implements Runnable { 
    public void run() {
        // 在 run 方法中直接或间接调用到的所有局部变量，都将存储在该线程本地内存堆栈中
        int i = 0; 
    }
}
</code></pre>
<p>通过实例化和启动 Thread 对象，来启动任务的执行：</p>
<pre><code class="java">Thread thread = new Thread(new MyTask());
thread.start();
</code></pre>
<p>从操作系统层面来说，线程同时具有指令和堆栈指针。指令指针引用要处理的下一条指令，堆栈指针指向一个私有内存区域（对其他线程不可见），该区域用于存储当前线程的数据。当前线程的数据 <code>thread local data</code> 一般指的是在 Java 方法中定义的变量信息。</p>
<p>一般来讲，系统都希望能将 CPU 最大限度的利用起来，但矛盾的地方在于，同一 CPU 在同一时间只能运行一个线程。在这种情况下，为了让用户感知不同的程序正在同时运行，就必须让 CPU 忙起来，在不同的线程之间来回切换，进行任务的执行，这个过程被称为线程的调度<code>scheduler</code>。在 Java 中，线程调度的基准是线程的优先级 <code>priority</code> ，优先级默认为 5，范围为 1-8 。</p>
<p>但是，如果线程的调度是完全基于优先级的话，就有可能导致低优先级的线程任务永远得不到执行，也就是所谓的饥饿致死。为解决这个问题，Java 调度器在执行线程调度时，还会将线程的执行时间列入考虑的范围。</p>
<p>每次不同线程的切换被称为上下文切换 <code>context switch</code> 。每次进行上下文切换时，CPU 会先将当前正在执行的线程状态进行保存，以方便下一次恢复当前线程的执行；其后暂停当前线程，同时恢复另一线程的执行。</p>
<p>具体的线程调度可以通过下图进行理解，图中的 C 就是上下文切换的过程。</p>
<p><img src="http://p5zd0id9p.bkt.clouddn.com/18-8-23/75211234.jpg" alt="线程调度示例"></p>
<h4 id="单线程应用"><a href="#单线程应用" class="headerlink" title="单线程应用"></a>单线程应用</h4><p>每个应用至少会有一个线程，也就是我们所熟知的主线程，默认情况下，编写的代码都将在这个线程中进行执行。</p>
<p>单线程编程是最简单的编码方式，但是很多情况下这种方式并不能满足我们的需求，因此，我们就需要将代码分别运行在不同的线程中，从而保证代码执行的高效性以及程序的性能。</p>
<h4 id="多线程应用"><a href="#多线程应用" class="headerlink" title="多线程应用"></a>多线程应用</h4><p>如果执行线程的数量超过处理器数量，则无法实现真正的并发，但调度程序在要处理的线程之间快速切换，以便将每个代码路径拆分为按顺序处理的执行间隔。尽管多线程编程会极大的提高应用的性能，但是这是有一定代价的。具体表现为：复杂性的提高，内存开销的增加，不确定的执行顺序等。</p>
<h5 id="复杂性提高，不确定的执行顺序"><a href="#复杂性提高，不确定的执行顺序" class="headerlink" title="复杂性提高，不确定的执行顺序"></a>复杂性提高，不确定的执行顺序</h5><p>分析单线程应用程序的执行相对简单，因为执行顺序是已知的。在多线程应用程序中，分析程序如何执行以及代码以何种顺序处理要困难得多。执行顺序在线程之间是不确定的，因为调度器将如何分配执行时间给线程是未知的。因此，多线程的执行过程是不确定的。这种不确定性不仅使代码中的错误调试变得更加困难，而且协调线程的过程中也有很大可能会引入新的错误。</p>
<h5 id="资源开销的增加"><a href="#资源开销的增加" class="headerlink" title="资源开销的增加"></a>资源开销的增加</h5><p>线程在内存和处理器使用方面具有开销。之前提到过，每个线程都会申请一块私有内存区域，用来存储线程数据。这片私有内存在线程创建之初就会申请出来备用，直到线程终止才会被回收并重新分配。在这个过程中，只要当前线程是存活的，即便它是闲置或是阻塞状态，也会持续占用系统资源。</p>
<p>处理器的开销主要来自于初始化、回收线程，以及在上下文切换中存储和恢复线程。执行的线程越多，上下文切换就越多，性能就越差。</p>
<h5 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h5><p>多线程程序对资源的访问还会产生一个新的问题，就是数据的共享。如果两个或更多线程同时操作某一个数据，则我们无法确定哪个线程正在对这个数据进行什么样的操作，这就导致了最后数据的不可靠性。</p>
<p>因为上下文切换可能发生在一个线程中不应中断的位置(比如正在对某个关键性数据进行操作时），所以必须创建代码指令的原子区域 <code>atomic region</code>。如果线程在原子区域中执行，则其他线程将被阻塞，直到在原子区域中没有其他线程执行。因此，Java中的原子区被认为是互斥的，因为它只允许访问一个线程。</p>
<p>可以用不同的方式创建原子区域  <code>atomic region</code>，但是最基本的同步机制是 <code>synchronized</code> 关键字 ：</p>
<pre><code class="java">synchronized (this) { 
    sharedResource++;
}
</code></pre>
<p>如果对共享资源的每次访问都是同步的，那么尽管多线程访问，数据也都将是一致的。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在多线程应用中，共享资源有可能会被多方同时访问，同时读写，这就导致了数据的不可靠性。在这种情况下，需要通过使用锁定机制来实现同步。</p>
<p>Android 中的锁定机制主要包括两种：</p>
<ul>
<li><p>对象内在锁定</p>
<p><code>synchronized</code> 关键字</p>
</li>
<li><p>显式锁</p>
<p><code>java.util.concurrent.locks.ReentrantLock</code><br><code>java.util.concurrent.locks.ReentrantReadWriteLock</code></p>
</li>
</ul>
<h4 id="内在锁和Java监视器"><a href="#内在锁和Java监视器" class="headerlink" title="内在锁和Java监视器"></a>内在锁和Java监视器</h4><p><code>synchronized</code> 关键字适用于每个 Java 对象，其内部包含一个隐式可用的锁。内部锁是互斥的，这意味着同步关键字的代码区域（临界区）中的线程执行是某一个线程独占的。当临界区被占用时，其他线程则会处于阻塞状态，在同步锁释放前，该线程代码无法继续正常执行。</p>
<p>内在锁充当一个监视器的角色，该监视器有三种状态：</p>
<ol>
<li><p>阻塞状态 <code>Blocked</code></p>
<p>当前线程要等待正在被其他线程占用的内在锁，从而处于挂起状态；</p>
</li>
<li><p>运行状态 <code>Executing</code></p>
<p>当前线程唯一占据内部锁并且正在临界区内执行代码；</p>
</li>
<li><p>等待状态 <code>Waiting</code></p>
<p>当前线程刚刚将临界区代码执行完毕，主动释放了锁；并等待下次获取内部锁；</p>
</li>
</ol>
<p><img src="http://p5zd0id9p.bkt.clouddn.com/18-8-24/6478868.jpg" alt="Java监视器示例"></p>
<p>一个完整的线程锁工作流大体如下：</p>
<ol>
<li><p><code>Enter the monitor</code></p>
<p>某个线程尝试去操作被同步锁锁住的的代码片段，此时该线程进入 Java 监视器中，如果当前同步锁被其他线程占用，则当前线程挂起；</p>
</li>
<li><p><code>Acquire the lock</code></p>
<p>如果当前同步锁处于空闲状态，则阻塞状态的线程则可以获取锁，并进入同步代码块开始执行。如果有多个线程阻塞等待，则由调度器决定谁将获取锁，而并不是先来后到的；</p>
</li>
<li><p><code>Release the lock and wait</code></p>
<p>满足某种条件后，持有锁对象的线程会主动调用锁对象的 <code>Object.wait()</code> 将锁资源释放，然后等待满足某种条件后，重新获取执行权；</p>
</li>
<li><p><code>Acquire the lock after signal</code></p>
<p>如果某个等待状态的线程被调度器选择为下一个执行线程，则它会在其他线程调用 <code>Object.notify()</code> 或者 <code>Objecct.notifyAll()</code> 时，获得同步锁并进入同步代码块；需要注意的是，等待线程相比较于阻塞线程并没有绝对的优先权，因为二者都想执行这部分同步代码，也就是说最终的选择权在于调度器；</p>
</li>
<li><p><code>Release the lock and exit the monitor</code></p>
<p>在代码执行完毕后，线程会退出监视器，让其他真正有需要的线程做操作。</p>
</li>
</ol>
<p>具体的同步代码块示例：</p>
<pre><code class="java">// (1) 
synchronized (this) { 
    // Execute code (2) 
    wait(); // (3)
    // Execute code (4)
} 
// (5)
</code></pre>
<h4 id="同步对共享资源的访问"><a href="#同步对共享资源的访问" class="headerlink" title="同步对共享资源的访问"></a>同步对共享资源的访问</h4><p>在多线程应用中，共享资源可能被多方同时获取及修改，这种情况下就需要有一个有效的同步机制，来保证多线程下数据的统一性。这种机制具体包括同步锁类型的选择，以及同步代码块范围的设定。</p>
<h5 id="使用内部锁"><a href="#使用内部锁" class="headerlink" title="使用内部锁"></a>使用内部锁</h5><p><code>synchronized</code> 关键字有多种使用方式：</p>
<ul>
<li><p>作用在方法上</p>
<pre><code class="java">synchronized void changeState() { 
    sharedResource++;
}
</code></pre>
</li>
<li><p>同步代码块，使用当前类作为同步锁</p>
<pre><code class="java">void changeState() { 
    synchronized(this) {
        sharedResource++;
    }
}
</code></pre>
</li>
<li><p>同步代码块，使用其他对象作为同步锁</p>
<pre><code class="java">private final Object mLock = new Object();
void changeState() { 
    synchronized(mLock) {
        sharedResource++;
    } 
}
</code></pre>
</li>
<li><p>作用于静态方法</p>
<pre><code class="java">synchronized static void changeState() { 
    staticSharedResource++;
}
</code></pre>
</li>
<li><p>静态方法的同步代码块，使用当前类作为同步锁</p>
<pre><code class="java">static void changeState() { 
    synchronized(this.getClass()) {
        staticSharedResource++;
    }
}
</code></pre>
</li>
</ul>
<p>使用 this 在代码块内作为同步锁，与直接在方法上加 <code>synchronized</code> 关键字是相同的。但是更建议使用同步代码块，因为不一定方法内的全部代码都需要保证同步，滥用同步有可能导致不必要的性能损耗。</p>
<p>值得注意的是，作用于静态方法的同步锁对象是当前 Class 类对象，而并非其实例对象。</p>
<h5 id="使用显式锁机制"><a href="#使用显式锁机制" class="headerlink" title="使用显式锁机制"></a>使用显式锁机制</h5><p><code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 类可以用来替代 <code>synchronized</code> 关键字充当监视器。这种情况下，同步代码块的锁定和解锁都是由调用者手动调用的。</p>
<pre><code class="java">// ReentrantLock 显式锁调用示例
int sharedResource;
private ReentrantLock mLock = new ReentrantLock();

public void changeState(){
    mLock.lock();
    try{
        sharedResource ++;
    }
    finally{
        mLock.unlock();
    }
}
</code></pre>
<p><code>ReentrantLock</code> 和 <code>synchronized</code> 关键字语义相同，都会将同步代码块隔离开，保证只有一个线程能够对其进行操作。二者都是一种防御性策略，假设所有并发访问都存在问题，但多线程同时读取共享变量并不是有害的。因此，synchronized 和 ReentrantLock 可能存在过度保护。</p>
<p><code>ReentrantReadWriteLock</code> 则允许多个线程对共享数据同时进行读取，但是仍然禁止同时读写或者同时写入。示例代码如下：</p>
<pre><code class="java">// ReentrantReadWriteLock 显式锁调用示例
int sharedResource;
private ReentrantReadWriteLock mLock = new ReentrantReadWriteLock();

public void changeState() { 
    mLock.writeLock().lock(); 
    try {
        sharedResource++;
    }
    finally{
        mLock.unlock();
    }
}

public int readState(){
    mLock.readLock().lock();
    try{
        return sharedResource;
    }
    finally{
        mLock.readLock().unlock();
    }
}
</code></pre>
<p><code>ReentrantReadWriteLock</code> 相对复杂，从而会对性能造成影响。因为相对于 <code>ReentrantLock</code> 和 <code>synchronized</code> 来讲，<code>ReentrantReadWriteLock</code> 要花费更多的时间去判断应不应该阻塞当前线程，这也相当于是让读取操作同步执行的一种妥协。实际上，<code>ReentrantReadWriteLock</code> 的典型应用应该是多个线程进行读取，但只有少量线程会进行写入操作。</p>
<h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p>生产者消费者是线程协作的经典模型，生产者线程和消费者线程共享一个列表，当该列表为空时，生产者线程向其中添加商品；如果列表不为空，则消费者线程会将商品移除。也就是说，当列表为空时，消费者线程应该阻塞等待；当列表已满时，生产者线程应该阻塞等待。</p>
<p><code>ComsumerProducer</code> 类包括两个线程，一个生产者线程，一个消费者线程，二者共享一个 LinkedList 对象，分别对其进行增加和删除操作：</p>
<pre><code class="java">public class ConsumerProducer{
    private LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();
    private final int LIMIT = 10;
    private Object lock = new Object();

    public void produce(){
        int value = 0;
        while(true){
            synchronized(lock){
                while(list.size() == LIMIT){
                    lock.wait();
                }
                list.add(value++);
                lock.notify();
            }
        }
    }

    public void consume(){
        int value = 0;
        while(true){
            synchronized(lock){
                while(list.size() == 0){
                    lock.wait();
                }
                list.removeFirst();
                lock.notify();
            }
        }
    } 
}
</code></pre>
<p>生产者线程和消费者线程共用同一把锁，来保证共享数据 list 的一致性。当列表为满时，生产者主动挂起等待；当列表为空时，消费者主动挂起等待。两个线程在挂起的同时，又会调用 <code>lock.notify()</code> 给正在等待的对方发送信号，通知其获取同步锁并执行代码，从而完成共享数据的同步。</p>
<pre><code class="java">final ConsumerProducer cp = new ConsumerProducer();

// producer
new Thread(new Runnable(){
    @Override
    public void run(){
        cp.produce();
    }
}).start();

// consumer
new Thread(new Runnable(){
    @Override
    public void run(){
        cp.consume();
    }
}).start();
</code></pre>
<h4 id="任务执行策略"><a href="#任务执行策略" class="headerlink" title="任务执行策略"></a>任务执行策略</h4><p>一般来讲，两种极端的执行策略如下：</p>
<ol>
<li>所有的任务都执行在同一线程上</li>
<li>每一个任务都对应一个线程</li>
</ol>
<p>很明显上述两种策略都过于极端：前者效率过低，后者大量的线程初始化和回收会造成大量的性能消耗。尽管如此，上述两种策略还是目前最常用的两种执行方式：</p>
<ol>
<li><p>顺序执行</p>
<p>各个任务按照先后顺序进行执行，各任务的执行时间不会有重叠。这样做的优势是数据绝对安全，而且只有一个线程执行，占用内存会比多线程更少；缺点在于吞吐量过低，一个任务的执行与否取决于前一个任务能否成功完成；</p>
</li>
<li><p>并发执行</p>
<p>所有的任务都并行执行，最大化利用 CPU ，但是会带来数据的不安全性，需要进行同步机制规避。</p>
</li>
</ol>
<p>一个出色的执行策略应该是顺序执行和并发执行并重的。相对独立的任务应该并发执行以提高效率，但是有相对严格执行顺序的任务则应该执行在单一线程中。</p>
<h5 id="并发执行设计原则"><a href="#并发执行设计原则" class="headerlink" title="并发执行设计原则"></a>并发执行设计原则</h5><ul>
<li>控制新线程的重复创建，而应该注意对已有线程的复用，从而降低创建、回收线程的频率</li>
<li>提高线程使用效率，多余的线程对于内存和处理器都是一种资源浪费</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Android应用程序应该是多线程的，以提高单处理器和多处理器平台的性能。线程可以在单个处理器上顺序执行，或者在多个处理器可用时实现真正的并发。性能的提高是以增加复杂性为代价的，同样需要维护同步机制，以保证线程之间共享资源数据的一致性。</p>

            
                <blockquote>
                    <p>
                         
                            转载请注明出处
                        
                        <br>
                        Link to this article:  http://joeljt.top/2018/08/25/Efficient-Android-Threading-chapter-2/
                    </p>
                </blockquote>
            
        </div>
    
</div>


                
                    <!-- Paradox Post Info -->
                    
                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/08/14/android-view-post/" id="post_nav-older" class="next-content">
            Older
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/js/lazyload.min.js", true)</script>



    <script>lsloader.load("js_js","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/js/js.min.js", true)</script>



    <script>lsloader.load("np_js","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/js/nprogress.js", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
