<!DOCTYPE html>
<html style="display: none;" lang="en">
    <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            线程间通信 下篇 | 
        
        Joe&#39;s blog
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no">
    <meta name="description" itemprop="description" content="
Efficient.Android.Threading 第四章读书笔记 下篇
">
    <meta name="keywords" content=",读书笔记,Efficient.Android.Threading">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/css/material.min.css",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/css/style.min.css",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    
        
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/css/fontawesome.min.css">
        
    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/css/material-icons.css",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/js/jquery.min.js", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Joe&#39;s blog">
    <meta name="msapplication-starturl" content="http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-2/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Joe&#39;s blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-2/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="线程间通信 下篇 | Joe&#39;s blog">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="
Efficient.Android.Threading 第四章读书笔记 下篇
">
    <meta property="og:article:tag" content="读书笔记"> <meta property="og:article:tag" content="Efficient.Android.Threading"> 

    
        <meta property="article:published_time" content="Sun Sep 09 2018 00:00:00 GMT+0800">
        <meta property="article:modified_time" content="Thu Mar 21 2019 18:47:37 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-2/index.html">
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-2/index.html",
    "headline": "线程间通信 下篇",
    "datePublished": "Sun Sep 09 2018 00:00:00 GMT+0800",
    "dateModified": "Thu Mar 21 2019 18:47:37 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "joe",
        "image": {
            "@type": "ImageObject",
            "url": "/img/portrait.jpeg"
        },
        "description": "今でもあなたは私の光。"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Joe&#39;s blog",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",读书笔记,Efficient.Android.Threading",
    "description": "
Efficient.Android.Threading 第四章读书笔记 下篇
",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Isolation" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                
                    <!-- Isolation Header -->
                    <header class="header">
    <div class="header-wrapper">
        <!-- Header Copyright -->
        <div class="header-copyright">
            <div class="header-site">
                ©&nbsp;
                <script type="text/javascript">
                    var fd = new Date();
                    document.write(fd.getFullYear());
                </script>
                &nbsp;Joe's blog
            </div>
            <!--
            I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright.
            It will not impact the appearance and can give developers a lot of support :)

            很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
            它不会影响美观并可以给开发者很大的支持。 :)
            -->
            <div>
                Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a>
                <br>
                Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a>
            </div>
        </div>

        <!-- Header Title -->
        <span class="header-title header-item">
            <a href="/" title="Joe&#39;s blog">
                Joe&#39;s blog
            </a>
        </span>

        <p class="header-slogan header-item">
        
            
                今でもあなたは私の光。
            
        
        </p>

        <!-- Header Nav -->
        <nav class="header-nav header-item">
            <span class="header-nav-item">
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </span>

            <!-- Pages  -->
            
                <span class="header-nav-item">
                    <a href="/tags" title="归档">
                        <span>归档</span>
                    </a>
                </span>
            
            
        </nav>

        <!-- Header SNS -->
        <div class="header-item header-sns_list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/Joeljt" target="_blank">
            <i class="fa fa-github fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- LinkedIn -->
    

    <!-- Telegram -->
    
</div>

    </div>
</header>

                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    

                    <!-- Post TOC -->

    



<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                


    <!-- Isolation Post Header -->
    <!-- Post thumbnail -->
    
        <!-- Post Header Info -->
        <div class="post-header_info with-thumbnail">
            <!-- Author Avatar & Name -->
            <img src="/img/portrait.jpeg" class="avatar-img" width="44px" height="44px" alt="joe's avatar">
            <span class="name-span">joe</span>
        </div>

        <!-- Custom thumbnail -->
        <div class="post_thumbnail-custom">
            <img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321181341.jpg">
    
        </div>



                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    

    
        <div class="post-content_wrapper">
            <p class="post-title">
                线程间通信 下篇
            </p>
            <blockquote>
<p>Efficient.Android.Threading 第四章读书笔记 下篇</p>
</blockquote>
<a id="more"></a>
<h3 id="Android-消息机制"><a href="#Android-消息机制" class="headerlink" title="Android 消息机制"></a>Android 消息机制</h3><p>迄今为止，我们介绍的线程通信都是 Java 层面的，管道、共享内存、阻塞队列等等，都是所有 Java 应用都有的机制。然而，因为阻塞线程特性的存在，这些机制对于 Android 系统都不适用，因为 UI 线程绝不允许阻塞。</p>
<p>因此，Android 系统为了协同 UI 线程和工作线程，定义了一套系统级别的消息机制。Android 消息机制是一个没有阻塞状态的生产者-消费者模式，UI 线程可以将耗时操作转移给工作线程在后台处理，同时生产者线程与消费者线程都不会发生阻塞。</p>
<p>Android 平台的消息机制相关的 API 从属于 <code>android.os</code> 包：</p>
<p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182551.jpg" alt="Android Message API"></p>
<p><code>android.os.Looper</code></p>
<p>唯一关联某个消费者线程的消息调度器</p>
<p><code>android.os.Handler</code></p>
<p>消费者线程的消息处理器，同时生产者线程也使用该对象将消息插入队列。一个 Looper 对象可以绑定多个 Handler 对象，但是所有的消息都是插入同一个消息队列的。</p>
<p><code>android.os.MessageQueue</code></p>
<p>消费者线程中待处理消息的链表，但是不同的消息之间并没有绑定关系。每个 Looper 对象最多只能有一个消息队列；由于每个线程只能有一个 Looper 对象，也就是说每个线程最多只能有一个消息队列。</p>
<p>名叫 MessageQueue, 实际上是一个 LinkedList</p>
<p><code>android.os.Message</code></p>
<p>消费者线程中待执行的消息</p>
<p>消息机制的工作原理大抵如下图示意：</p>
<p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182556.jpg" alt="消息机制示意"></p>
<p>生产者线程发送消息，消费者线程处理消息：</p>
<ol>
<li>插入：生产者线程使用与消费者线程相绑定的 Handler 对象，将消息插入消息队列</li>
<li>取出：Looper 运行在消费者线程中，按一定的顺序取出消息队列中的消息</li>
<li>分发：Handler 负责在消费者线程中处理消息；某个线程可以有多个 Handler 对象，Looper 可以确保每条消息能够正确分发给对应的 Handler 。</li>
</ol>
<h4 id="消息传递基本示例"><a href="#消息传递基本示例" class="headerlink" title="消息传递基本示例"></a>消息传递基本示例</h4><pre><code class="java">public class LooperActivity extends Activity {

    LooperThread mLooperThread;

    // 1.声明一个工作线程，扮演消费者线程角色
    private static class LooperThread extends Thread {

        public Handler mHandler;

        public void run() {
            // 2.为当前线程关联 Looper，也就是关联了 MessageQueue
            Looper.prepare();
            // 3.使用默认构造器，即将 Handler 与当前线程的 Looper 绑定
            // 也就决定了它只能在 Looper.prepare() 后初始化，否则没有可以绑定的 Looper
            mHandler = new Handler() {
                // 4. 工作线程中处理分发下来的消息的回调
                public void handleMessage(Message msg) {
                    if(msg.what == 0) {
                        doLongRunningOperation();
                    }
                }
            };
            // 5. 开启对消息队列的轮询，对消息进行分发；
            // 这是个 blocking call，因此此工作线程不会结束
            Looper.loop();
        }

        private void doLongRunningOperation() {
            // Add long running operation here.
        }
    }

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_looper);
        // 6. 开启工作线程，准备处理消息
        mLooperThread = new LooperThread();
        mLooperThread.start();
    }

    public void onClick(View v) {
        // 7. Handler 初始化完成和点击事件是异步的，因次校验一下 Handler 不为空
        if (mLooperThread.mHandler != null) {
            // 8. 初始化一个 Message 对象，what 属性赋值为 0
            Message msg = mLooperThread.mHandler.obtainMessage(0);
            // 9. 向消息队列中插入消息
            mLooperThread.mHandler.sendMessage(msg);
        }
    }

    protected void onDestroy() {
        super.onDestroy();
        // 10. 结束 loop() 方法的阻塞状态，从而结束后台线程的执行
        mLooperThread.mHandler.getLooper().quit();
    }
}
</code></pre>
<h4 id="消息传递过程中涉及到的-Classes"><a href="#消息传递过程中涉及到的-Classes" class="headerlink" title="消息传递过程中涉及到的 Classes"></a>消息传递过程中涉及到的 Classes</h4><h5 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h5><p>消息队列主要由 <code>android.os.MessageQueue</code> 类来实现，其内部实现一个没有绑定关系的单向链表，用于存储一系列待处理的消息。生产者线程插入消息，之后消息会分发到对应的消费者线程去处理。一般来讲，不同的消息是按照时间戳来排序的。也就是说，时间戳值越小，在消息队列中排序顺序就越靠前。但是只有到达当前时间的消息才会被分发；如果还没有到当前时间，则会等到当前时间才会对消息进行分发。</p>
<p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182557.jpg" alt="消息分发的时间点"></p>
<p>上图展示了消息队列中按时间排序的消息是如何向下分发的，其中 t1 &lt; t2 &lt; t3，即 t1 的时间要早于 t3。现在只有一条消息越过了 <code>disptch barrier</code> , 实际上也就是当前时间点。可以被分发下去的消息所绑定的时间戳，一定比当前时间小，也就是已经到了分发的时间。</p>
<p>如果当前 Looper 获取消息时，消息队列中还没有消息穿越过 <code>dispatch barrier</code> ，此时消费者线程就会阻塞，直到有消息越过 <code>dispatch barrier</code> 。而生产者线程可以在任何时间、任意位置插入消息，因为消息列表的排列只和消息发送的时间有关系，如果需要插入一条立即发送的消息，则即使消息队列中有一百条待发送的消息，但它们都是一分钟后才发送，那刚插入的这条消息也会在链表的首位，也就是下一个被分发的消息。</p>
<h5 id="MessageQueue-IdleHandler"><a href="#MessageQueue-IdleHandler" class="headerlink" title="MessageQueue.IdleHandler"></a>MessageQueue.IdleHandler</h5><p>正常来讲，如果 Looper 获取不到应分发的消息时，线程就会阻塞等待；但是除了干等以外，还可以将这段时间利用起来，用来执行一些其他的任务。而这个任务则由 <code>android.os.MessageQueue.IdleHandler</code> 来完成。</p>
<pre><code class="java">/**
 * 当线程等待新消息，即将进入阻塞（闲置）状态时的回调接口
 */
public static interface IdleHandler {  
    boolean queueIdle();
}

// 具体使用：
// 获取当前线程的消息队列
MessageQueue myQueue = Looper.myQueue();
// 声明一个 IdleHandler 对象
MessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() {
    @Override
    public boolean queueIdle() {
        return false;
    }
};
// 与消息队列进行绑定
myQueue.addIdleHandler(idleHandler);
// 与消息队列解除绑定
myQueue.removeIdleHandler(idleHandler);

</code></pre>
<p>当消息队列检测到分发消息的空闲时间时，它会唤醒所有注册到当前消息队列的 IdleHandler 实例，并调用他们的 <code>queueIdle</code> 方法，而具体的回调由应用自身来进行实现。</p>
<p> <code>queueIdle</code> 方法返回值为布尔类型：</p>
<ul>
<li><p>true</p>
<p>当前 IdleHandler 实例保持存活，下次再有 time slots 时，MessageQueue 还会唤醒该实例</p>
</li>
<li><p>false</p>
<p>当前 IdleHandler 实例不再存活，处理完消息后就会主动调用 MessageQueue.removeIdleHandler() 将该实例与 MessageQueue 解绑</p>
</li>
</ul>
<h5 id="使用-IdleHandler-来终止闲置线程的运行"><a href="#使用-IdleHandler-来终止闲置线程的运行" class="headerlink" title="使用 IdleHandler 来终止闲置线程的运行"></a>使用 IdleHandler 来终止闲置线程的运行</h5><p>假定现在有多个生产者线程要连续不断的向消费者线程发送消息，那就可以在消费者线程将所有任务的处理完以偶胡，使用 IdleHandler 来终止线程的执行，从而保证该线程对象不会在内存中游荡。</p>
<p>在这种情况下使用 IdleHandler ，就不用追踪最后一条插入队列的消息，以期得到回收该线程的确切时间。</p>
<p>不过这种场景只适用于生产者线程连续不断地向消费者线程插入消息，从而保证在处理完所有消息之前，消费者线程都没有 time slots.</p>
<pre><code class="java">public class ConsumeAndQuitThreadActivity extends Activity {

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final ConsumeAndQuitThread consumeAndQuitThread = new ConsumeAndQuitThread();
        consumeAndQuitThread.start();
        for (int i = 0; i &lt; 10; i++) {
            // 由多个线程并发向消费者线程发送消息，随机模拟发送的时间
            new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i &lt; 10; i++) {
                        SystemClock.sleep(new Random().nextInt(10));
                        consumeAndQuitThread.enqueueData(i);
                    }
                }
            }).start();
        }
    }

    /**
     * 此线程为绑定了 Looper 对象的消费者线程，接收生产者线程的消息并进行处理；
     * 处理完消息后，会终止 Looper.loop() 方法，结束线程的执行
     */
    private static class ConsumeAndQuitThread extends Thread implements MessageQueue.IdleHandler {

        private static final String THREAD_NAME = &quot;ConsumeAndQuitThread&quot;;

        public Handler mConsumerHandler;
        private boolean mIsFirstIdle = true;

        public ConsumeAndQuitThread() {
            super(THREAD_NAME);
        }

        @Override
        public void run() {
            Looper.prepare();

            mConsumerHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    // Consume data
                }
            };
            // 1. 为当前线程初始化 Looper，并为该线程的消息队列绑定 IdleHandler 对象
            Looper.myQueue().addIdleHandler(this);
            Looper.loop();
        }


        @Override
        public boolean queueIdle() {
            // 2. 第一次 queueIdle() 的调用会发生在接收消息之前
            // 因此需要让首次调用返回 true，从而保证此对象仍然与消息队列绑定
            if (mIsFirstIdle) { 
                mIsFirstIdle = false;
                return true;
            }
            // 3. 结束消费者线程的执行
            mConsumerHandler.getLooper().quit();
            return false;
        }

        public void enqueueData(int i) {
            mConsumerHandler.sendEmptyMessage(i);
        }
    }
}
</code></pre>
<h5 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h5><p>Message 是一个容器类，可以承载各种类型的数据或者一个 Runnable 对象，但是不能同时携带二者。所携带的数据会在消费者线程被处理，但任务则会在消息分发时直接得到执行，而不需要调用者做其他额外的工作。</p>
<p>正常来讲，Message 的插入由 Handler 来完成，因为它在插入消息时有更多的选择，更加灵活；但是实际上每条消息对象都知道自己对应的处理器是谁，也就是知道自己对应的 Handler 对象，所以一条消息可以自己实现入队操作。</p>
<pre><code class="java">// 通过 obtain() 传递一个 Handler 对象进去，赋值给 Message.target 属性
Message m = Message.obtain(handler, runnbale);
m.sendToTarget();

public void sendToTarget() {
    // target 是 Handler 对象，此方法会调用 Handler 的 sendMessage 方法
    target.sendMessage(this);
}
</code></pre>
<p>如之前所说，Message 可以携带数据或者任务，具体如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182601.jpg" alt=""></p>
<p>消息队列可以包含任何数据和任务消息的组合，消费者线程具体在处理消息的时候，也仅仅是按照消息的排序顺序，而不和消息的类型有任何关系。如果消息携带的是数据，那消费者线程就会在 handleMessage 中处理数据；如果消息携带的是任务，则该 Runnable 的 run 方法则会在消费者线程得到执行，但是不会再触发 handleMessage 方法的回调。</p>
<p>Message 的生命周期大概可以分为四个方面：初始化，等待，分发，回收。需要注意的是，系统并没有对消息的状态进行监听，尽管这在技术上也是可行的，所以应用在处理消息不该对该消息的当前状态做出任何假设。</p>
<ul>
<li><p>Initialized</p>
<p>在初始化状态下，应用程序可以使用以下方法来创建 Message 对象：</p>
<ul>
<li><p>使用构造器初始化</p>
<pre><code class="java">Message m = new Message();
</code></pre>
</li>
<li><p>工厂方法</p>
<ul>
<li><p>空消息</p>
<pre><code class="java">Message m = Message.obtain();
</code></pre>
</li>
<li><p>数据消息</p>
<pre><code class="java">Message m = Message.obtain(Handler h);
Message m = Message.obtain(Handler h, int what);
Message m = Message.obtain(Handler h, int what, Object o);
Message m = Message.obtain(Handler h, int what, int arg1, int arg2); 
Message m = Message.obtain(Handler h, int what, int arg1, int arg2, Object o);
</code></pre>
</li>
<li><p>任务消息</p>
<pre><code class="java">Message m = Message.obtain(Handler h, Runnable task);
</code></pre>
</li>
<li><p>复制构造器</p>
<pre><code class="java">Message m = Message.obtain(Message originalMsg);
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Pending</p>
<p>消息已经被插入消息队列中，但还没到发送时间，正在等待分发</p>
</li>
<li><p>Disptached</p>
<p>在这个阶段，Looper 已经从消息队列中取出了消息，消息队列也将其移除。Looper 在 loop 方法中，会通过访问 Message.target 属性，来获取到该消息对应的 Handler ，然后将消息发送到对应的回调中进行处理。</p>
</li>
<li><p>Recycled</p>
<p>在这个阶段，Message 的状态被清除，该实例也回到了消息池中等待复用。在消费者线程完成数据处理后，Looper 负责 Message 的回收工作。这个回收过程由虚拟机来完成，而不应该由应用程序来主动处理。</p>
<blockquote>
<p>需要注意的是，一旦消息入队后，其携带的数据就不应该再被更改。理论上来讲，在消息被分发之前，对数据做出的更改都是有效的。但由于 Handler 机制在设计之初就没有对 Message 的处理状态进行监听，因此调用者正在对数据进行更改时，消费者线程正在处理数据，从而导致线程安全的问题。而如果该消息对象已经被回收了，问题则会更加严重，因为该对象回到消息池后，会在之后被应用程序所复用，有可能会携带之前的数据到新的消息队列中。</p>
</blockquote>
</li>
</ul>
<h5 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h5><p><code>android.os.Looper</code> 复杂将队列中的消息分发给对应的 Handler 去处理。所有越过分发栅栏的消息都可以被 Looper 所分发。所有待分发的消息一定是越过分发栅栏的，当没有消息待分发时，消费线程则会阻塞，直至有消息等待处理。</p>
<p>消费线程并不直接与消息队列发生关系，而是通过 Looper 作为中间者来协调消息的分发与处理：消费电车绑定 Looper，而 Looper 会绑定一个 MessageQueue。默认只有 UI 线程自带 Looper ，其他子线程需要调用者显式声明 Looper 。</p>
<pre><code class="java">new Thread() {
    @Override
    public void run() {
        // prepare() 方法会初始化一个消息队列，并将其与当前线程绑定
        // 在此时，该消息队列已经可以插入消息，但是无法分发到消费线程处理
        Looper.prepare();

        // ... ...

        // 此方法为一个 blocking call，确保 run() 方法不会结束执行
        // 当 run() 方法阻塞的时候，Looper 可以循环消息队列，然后向消费线程分发消息
        Looper.loop();
    }
}.start();
</code></pre>
<p>一个线程只能绑定一个 Looper，而 Looper 会绑定一个 MessageQueue，也就是说一个线程只能有一个消息队列；这也就保证了无论多少工作线程向主线程发送消息，主线程也只能按照一定顺序来处理消息。因此，当前执行的消息处理时间的长短会影响到之后的消息，我们在实际使用时，应该规避处理耗时过长的消息。</p>
<h5 id="Looper-的终止"><a href="#Looper-的终止" class="headerlink" title="Looper 的终止"></a>Looper 的终止</h5><ul>
<li><p>quit()</p>
<p>丢弃消息队列中所有未分发的消息，不管其有没有越过分发栅栏</p>
</li>
<li><p>quitSafely()</p>
<p>丢弃还没越过分发栅栏的消息，Looper 会等到已经处于待分发状态的消息正确分发后再结束</p>
</li>
</ul>
<p>终止 Looper 并不会终止线程的执行，它只是将 loop() 方法结束了；但需要注意的是，终止 Looper 后此线程将不再是 Looper 线程，既不能重新绑定新的 Looper ，也无法唤醒已经终止的 Looper。调用 Looper.prepare() 会抛异常，提示已经绑定；重新调用 Looper.loop() 会进入阻塞状态，但是消息队列中的消息不会再得到分发。</p>
<h5 id="UI-线程的-Looper"><a href="#UI-线程的-Looper" class="headerlink" title="UI 线程的 Looper"></a>UI 线程的 Looper</h5><p>UI 线程是唯一一个自带 Looper 的线程，其与其他线程有以下几点不同：</p>
<ul>
<li>在程序任何位置都可以通过调用 Looper.getMainLooper() 来获取 UI Looper</li>
<li>UI 线程的 Looper 不能被终止</li>
<li>Java 虚拟机通过 Looper.prepareMainLooper() 为 UI 线程初始化 Looper，此动作只能执行一次，因此尝试将 main looper 与其他子线程关联会抛异常。</li>
</ul>
<h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>Android 系统中使用 <code>android.os.Handler</code> 来协调工作线程与 UI 线程的调度，消息的插入和处理都由它来完成，具体工作包括以下几点：</p>
<ul>
<li>消息的创建</li>
<li>插入消息</li>
<li>在消费线程中处理消息</li>
<li>管理消息队列中的消息</li>
</ul>
<p>Handler 的工作需要 Looper 和 MQ 的支持，因此 Handler 在声明时就应该绑定 Looper 对象：</p>
<ol>
<li><p>构造器中不接收 Looper 的，该 Handler 与当前线程绑定</p>
<pre><code class="java">// 这种与当前线程绑定的，如果当前不是 Looper 线程，就会抛出异常
new Handler();
new Handler(Handler.Callback);
</code></pre>
</li>
<li><p>构造器明确需要传入 Looper 对象的</p>
<pre><code class="java">new Handler(Looper);
new Handler(Looper, Handler.Callback);
</code></pre>
</li>
</ol>
<p>一个线程可以有多个 Handler ，不同 Handler 发送的消息可以在消息队列中共存，并不会有什么冲突；具体在分发的时候又会通过 Message 的 target 属性发送回该消息对应的 Handler：</p>
<p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182554.jpg" alt=""></p>
<blockquote>
<p>多个 Handler 发出的消息也不会导致并发，Message 的处理仍然是按顺序执行的。</p>
</blockquote>
<h5 id="Message-creation"><a href="#Message-creation" class="headerlink" title="Message creation"></a>Message creation</h5><p>Handler 可以通过以下几个包装方法直接获取 Message 对象，而这些对象则会和 Handler 发生绑定关系：</p>
<pre><code class="java">// 这些方法内部都会调用 Message.obtain() 方法，并将 Handler 传入，从而产生绑定关系
Message obtainMessage(int what, int arg1, int arg2)
Message obtainMessage()
Message obtainMessage(int what, int arg1, int arg2, Object obj) 
Message obtainMessage(int what)
Message obtainMessage(int what, Object obj)
</code></pre>
<h5 id="Message-insertion"><a href="#Message-insertion" class="headerlink" title="Message insertion"></a>Message insertion</h5><p>根据消息类型的不同，Handler 插入消息的方式也略有差别。</p>
<pre><code class="java">// 携带任务的消息，使用 postXxx() 方法
boolean post(Runnable r)
boolean postAtFrontOfQueue(Runnable r)
boolean postAtTime(Runnable r, Object token, long uptimeMillis) 
boolean postAtTime(Runnable r, long uptimeMillis)
boolean postDelayed(Runnable r, long delayMillis)

// 携带数据的消息或者空消息，使用 sendXxx() 方法
// 默认，立即分发
boolean sendMessage(Message msg) 
// 下一个分发
boolean sendMessageAtFrontOfQueue(Message msg)
// 指定某个确切的时间进行分发
boolean sendMessageAtTime(Message msg, long uptimeMillis) 
boolean sendMessageDelayed(Message msg, long delayMillis)
boolean sendEmptyMessage(int what)
boolean sendEmptyMessageAtTime(int what, long uptimeMillis) 
boolean sendEmptyMessageDelayed(int what, long delayMillis)
</code></pre>
<p>每条消息都有会有一个 when 属性，用来记录当前消息应该何时被分发；该属性也是唯一一个会影响分发顺序的因素。需要注意的是，尽管我们可以指定确定的时机分发，但是由于之前消息的处理也会影响到后一条消息的分发，因此这个时间还是不确定的。</p>
<p>向消息队列中插入消息时，有可能导致某些错误的产生：</p>
<ul>
<li><p>Message has no Handler</p>
<p>Message was created from a Message.obtain() method without a specified Handler.</p>
</li>
<li><p>Message has already been disptached and is being processed</p>
<p>The same message instance was inserted twice.</p>
</li>
<li><p>Looper has exited</p>
<p>Message is inserted after Looper.quit() has been called.</p>
</li>
</ul>
<blockquote>
<p>Looper 在分发消息时，会调用 Handler 的 dispatchMessage 方法。如果此方法被应用程序主动调用，那该消息会在发起调用的线程立即得到执行，而不是在消费线程执行。</p>
</blockquote>
<h5 id="Message-processing"><a href="#Message-processing" class="headerlink" title="Message processing"></a>Message processing</h5><p>Message 根据携带数据类型的不同，有不同的处理方式：</p>
<ul>
<li><p>Task messages</p>
<p>如果携带的是 Runnbale 对象，那等轮到该条消息分发的时候，则该 Runnable 对象的 run 方法会直接得到执行，而不会再触发 <code>Handler.handMessage()</code> 方法。</p>
</li>
<li><p>Data messages</p>
<p>如果消息携带的是数据的话，那处理消息则需要重写 <code>Handler.handMessage()</code> 方法（两种方式）。</p>
</li>
</ul>
<p>一种是正常的实现自己的 Handler ，然后重写该方法；或者在初始化 Handler 的时候直接重写该方法，但需要注意的是，如果在子线程中，该方法的重写要在消息队列就绪以后立刻声明，否则 loop() 循环开启后，就无法再声明了：</p>
<pre><code class="java">class ConsumerThread extends Thread{
    Handler mHandler;
    @Override
    public void run(){
        Looper.prepare();
        mHandler = new Handler(){
            public void handleMessage(Message msg){
                // process data message here
            }
        };
        Looper.loop();
    }
}
</code></pre>
<p>另一种方式是利用 <code>Handler.Callback</code> 接口，该接口方法为一个带布尔类型返回值的 <code>handleMessage</code> 方法：</p>
<pre><code class="java">public interface Callback {
    // true: 代表实现类处理完消息即终止
    // false: 代表实现类处理完以后，还要继续下发到 Handler.handleMessage 方法
    public boolean handleMessage(Message msg);
}

// 消息分发
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            // 如果返回 true ，则不会继续向下分发了
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }    
}
</code></pre>
<p>使用这种方式，调用者不再需要继承自 Handler ，而只需要将 Callback 接口的实现类当做 Handler 构造器传入即可，然后该 Handler 就会回调到 handleMessage()：</p>
<pre><code class="java">public class HandlerCallbackActivity extends Activity implements Handler.Callback {
    Handler mUiHandler;

    @Override
    public void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        mUiHandler = new Handler(this); // 直接通过构造器传入，即可通过此类处理消息
    }

    @Override
    public boolean handleMessage(Message msg){
        // process msg
        return true;
    }
}
</code></pre>
<h4 id="与-UI-线程通信"><a href="#与-UI-线程通信" class="headerlink" title="与 UI 线程通信"></a>与 UI 线程通信</h4><p>正如之前所说，UI 线程是唯一一个自带 Looper 的线程，其他线程可以向 UI 线程发送消息，但要注意避免耗时操作，因为 UI 线程是全局的，每个任务的时长都会对全局任务的执行产生影响。</p>
<p>有以下几种方式将消息转交到 UI 线程处理：</p>
<ol>
<li><p>为 Handler 指定 UI 线程的 Looper</p>
<pre><code class="java">Runnable task = new Runnable(){...};
new Handler(Looper.getMainLooper()).post(task);
</code></pre>
<p>使用这种方式，不管调用线程，task 都会通过 UI Looper 直接插入 UI MessageQueue。</p>
</li>
<li><p>直接在 UI 线程向自身发送消息，该任务会在当前正在执行的消息处理完后得到执行</p>
<pre><code class="java">private void postFromUiThreadToUiThread(){
    new Handler().post(new Runnable(){...})
}
</code></pre>
</li>
<li><p>Activity.runOnUiThread</p>
<pre><code class="java">private void postFromUiThreadToUiThread(){
    runOnUiThread(new Runnable(){...})
}
</code></pre>
<p>如果此方法在其他线程调用，则它会将消息插入到 UI 线程的消息队列中。此方法只能由 Activity 的实例来调用，但是也可以实现自己的 runOnUIThread 方法，只要追踪 UI 线程的 ID 即可：</p>
<pre><code class="java">public class MyApplication extends Application{
    private long mUiThreadId;
    private Handler mUiHandler;

    @Override
    public void onCreate(){
        super.onCreate();
        mUiThread = Thread.currentThread().getId();
        mUiHandler = new Handler();
    }

    public void customRunOnUiThread(Runnable action){
        if(Thread.currentThread().getId() != mUiThreadId){
            mUiHandler.post(action);
        } else{
            action.run();
        }
    }
}
</code></pre>
</li>
</ol>

            
                <blockquote>
                    <p>
                         
                            转载请注明出处
                        
                        <br>
                        Link to this article:  http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-2/
                    </p>
                </blockquote>
            
        </div>
    
</div>


                
                    <!-- Paradox Post Info -->
                    
                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2019/03/22/ConstraintLayout-learning/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Newer
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/09/09/Efficient-Android-Threading-chapter-4-1/" id="post_nav-older" class="next-content">
            Older
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/js/lazyload.min.js", true)</script>



    <script>lsloader.load("js_js","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/js/js.min.js", true)</script>



    <script>lsloader.load("np_js","https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source/js/nprogress.js", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
