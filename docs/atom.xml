<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe&#39;s blog</title>
  
  <subtitle>emmmmm</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joeljt.top/"/>
  <updated>2018-08-16T05:20:09.758Z</updated>
  <id>http://joeljt.top/</id>
  
  <author>
    <name>joe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android View.post 浅析</title>
    <link href="http://joeljt.top/2018/08/14/Android%20View.post%20%E6%B5%85%E6%9E%90/"/>
    <id>http://joeljt.top/2018/08/14/Android View.post 浅析/</id>
    <published>2018-08-13T16:00:00.000Z</published>
    <updated>2018-08-16T05:20:09.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……</p></blockquote><a id="more"></a><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>之前的文章里写到过，我们在 onCreate() 和 onResume() 方法中无法获取 View 的宽高信息，但在平时开发中，我们经常会用到 View#post 来进行 View 宽高信息的获取。</p><p>那么问题就来了，为什么 View#post 就可以获取到宽高信息？里边那个 run() 是在什么时候执行的？具体实现原理又是什么？</p><p>带着这些疑问，我最近研究了一下 View#post 的源码。本来以为挺简单的一个东西，但是没想到坑越挖越深，最过分的是，不同的版本源码还不相同，实现原理也有细微的差别。集中攻克了一个周末以后，感觉大概理解了，索性写下篇博客进行记录备忘。</p><p>文章大概分为以下几个方面：</p><ul><li>View#post 基本使用</li><li>post() 执行过程以及源码分析</li><li>post() 中 Runnable#run 执行的时机</li><li>View#post 整体流程的简单总结</li><li>Android 7.0 里 View#post 的变动以及原因</li><li>致谢</li></ul><h3 id="View-post-基本使用"><a href="#View-post-基本使用" class="headerlink" title="View#post 基本使用"></a>View#post 基本使用</h3><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    View view = findViewById(R.id.test);</span><br><span class="line">    view.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 可以正常获取到 View 的宽高信息</span></span><br><span class="line">            Log.e(<span class="string">"Test"</span>, <span class="string">"view.post ---- &gt; "</span> + view.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们以 API 26 为例，来尝试解答一下这个问题。</p><p>实际上，Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别，具体的改动以及原因在后文会一一给出分析。</p><h3 id="post-执行过程以及源码分析"><a href="#post-执行过程以及源码分析" class="headerlink" title="post() 执行过程以及源码分析"></a>post() 执行过程以及源码分析</h3><h4 id="1-View-post-入口"><a href="#1-View-post-入口" class="headerlink" title="1. View#post 入口"></a>1. View#post 入口</h4><p>先来看 View#post 源码，重点注意注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes the Runnable to be added to the message queue.</span></span><br><span class="line"><span class="comment"> * The runnable will be run on the user interface thread.</span></span><br><span class="line"><span class="comment"> * 将 Runnable 添加到执行队列中，其最终会在 UI 线程中执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AttachInfo 是 View 的内部类，用来存储一些基本信息</span></span><br><span class="line">    <span class="comment">// 此处可以暂时认为 mAttachInfo 为 null</span></span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// attachInfo 不为空时，转而使用其内部的 Handler 对象操作</span></span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    <span class="comment">// 在我们确定当前 Runnable 的目标运行线程之前，先将其推迟执行</span></span><br><span class="line">    <span class="comment">// 假设在 attach 完成之后，此 Runnable 对象会被成功的「placed」（暂且翻译成「放置」）</span></span><br><span class="line">    <span class="comment">// 好好理解一下这个注释，我们继续往下走</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，明确一点：<strong>Runnable 会在 UI 线程中执行</strong>；</p><p>然后，我们来看一下这个看上去很重要的 <strong>mAttachInfo</strong> 是在哪里赋值的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchAttachedToWindow</span><span class="params">(AttachInfo info, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    mAttachInfo = info;</span><br><span class="line">    <span class="comment">// Transfer all pending runnables. 转移所有待办任务</span></span><br><span class="line">    <span class="keyword">if</span> (mRunQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRunQueue.executeActions(info.mHandler);</span><br><span class="line">        mRunQueue = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调方法</span></span><br><span class="line">    onAttachedToWindow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不在意除了赋值以外的其他操作，我们继续追踪 dispatchAttachedToWindow 方法，发现其最初调用是在 ViewRootImpl#performTraversals 方法。好了，记住这个结论，我们先把它放在一旁。</p><p>接下来，我们来看一看这个 <strong>getRunQueue().post()</strong> 又做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个 RunQueue 对象，用来进行 post 操作</span></span><br><span class="line"><span class="comment"> * Returns the queue of runnable for this view.</span></span><br><span class="line"><span class="comment"> * 注释是：为当前 View 对象返回一个执行队列，记住这个「当前 View 对象」</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerActionQueue <span class="title">getRunQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRunQueue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRunQueue = <span class="keyword">new</span> HandlerActionQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mRunQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-HandlerActionQueue-又是个啥"><a href="#2-HandlerActionQueue-又是个啥" class="headerlink" title="2. HandlerActionQueue 又是个啥"></a>2. HandlerActionQueue 又是个啥</h4><p>很明显，执行 post 方法的是 HandlerActionQueue 对象，那这又是个什么东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class used to enqueue pending work from Views when no Handler is attached.</span></span><br><span class="line"><span class="comment"> * 此类用于在当前 View 没有 Handler 依附的时候，将其待完成的任务入队</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActionQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HandlerAction[] mActions;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是我们在外边调用的 post 方法，最终会调用到 postDelayed 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">        postDelayed(action, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将传入的 Runnable 对象存入数组中，等待调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postDelayed</span><span class="params">(Runnable action, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HandlerAction handlerAction = <span class="keyword">new</span> HandlerAction(action, delayMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mActions = <span class="keyword">new</span> HandlerAction[<span class="number">4</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);</span><br><span class="line">            mCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里才是真的执行方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeActions</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> HandlerAction[] actions = mActions;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = mCount; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> HandlerAction handlerAction = actions[i];</span><br><span class="line">                handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mActions = <span class="keyword">null</span>;</span><br><span class="line">            mCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看 HandlerActionQueue 的源码，我们发现了一个问题：不同于在 onCreate() 直接获取 View 的宽高，我们调用 post 方法，其中的 run 方法并没有被马上执行。</p><p>这样就不难解释为什么用这种方式可以获取到宽高了。那我们可以猜测一下，这种情况下，一定是 View 完成测量后才执行了这个方法，所以我们才可以拿到宽高信息。</p><p>事实上也正是这样的，那么这个方法到底是在什么时候执行的呢？很明显，HandlerActionQueue#executeActions 才是真正完成调用的方法，那这个方法又做了些什么工作呢？</p><p><strong>根据代码可知，该方法接收一个 Handler，然后使用这个 Handler 对当前队列中的所有 Runnable 进行处理，即 post 到该 Handler 的线程中，按照优先级对这些 Runnable 依次进行处理。</strong></p><p><strong>简单来说，就是传入的 Handler 决定着这些 Runnable 的执行线程。</strong></p><p>接下来，我们来追踪这个方法的调用情况。</p><p><img src="http://upload-images.jianshu.io/upload_images/5419805-e0cf86fbea081bc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="executeActions() 的调用情况"></p><p>我们注意到，对于该方法出现了两次调用，一次在 View#dispatchAttachToWindow（就是我们最开始找到的那个方法），另一次是在 ViewRootImpl#performTraversals。</p><h4 id="3-万恶之源-performTraversals"><a href="#3-万恶之源-performTraversals" class="headerlink" title="3. 万恶之源 performTraversals()"></a>3. 万恶之源 performTraversals()</h4><p>很明显，所有的证据都指向了 performTraversals ，那么下面我们就来重点分析一下这个方法。</p><p>如果你了解过 View 的测绘流程，那你对这个方法一定不会陌生，因为这个方法就是 View 绘制流程的起点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处的 host 是根布局 DecorView，用递归的方式一层一层的调用 dispatchAttachedToWindow</span></span><br><span class="line">    <span class="comment">// mAttachInfo 是不是很眼熟，就是最开始 View#post 的第一层判断</span></span><br><span class="line">    <span class="comment">// 这个 mAttachInfo 在 ViewRootImpl 的构造器中初始化的，其持有 ViewRootImpl 的 Handler 对象</span></span><br><span class="line">    host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">    getRunQueue().executeActions(mAttachInfo.mHandler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制流程就从这里开始</span></span><br><span class="line">    performMeasure();</span><br><span class="line">    performLayout();</span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先从 dispatchAttachedToWindow 开始，我们之前已经看过这个方法的源码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchAttachedToWindow</span><span class="params">(AttachInfo info, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    mAttachInfo = info;</span><br><span class="line">    <span class="comment">// Transfer all pending runnables. 转移所有待办任务</span></span><br><span class="line">    <span class="keyword">if</span> (mRunQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRunQueue.executeActions(info.mHandler);</span><br><span class="line">        mRunQueue = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调方法</span></span><br><span class="line">    onAttachedToWindow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现在来进行分析：</strong></p><ol><li>我们已经知道了此方法是从根视图开始递归向下调用的，那么递归到最深处，就会轮到最开始我们调用 post 方法的 View 对象来执行该方法，也就是该方法内的所有属性，都是我们 findViewById 获得的那个 View 对象的属性；</li><li>而且我们也知道，第一个参数 AttachInfo 就是 ViewRootImpl 中初始化的 AttachInfo，它持有当前 ViewRootImpl 的 Handler 对象引用，并将该引用传给了 executeActions()。此时，我们再来回顾一下 <strong>executeActions()</strong> 方法的作用，<strong>传入的 Handler 决定着队列里这些 Runnable 的执行线程</strong>。</li></ol><p>很明显，此处的 mRunQueue 就是我们最开始调用 post() 时，调用 View#getRunQueue 返回的那个对象，这个对象中有准备获取View高度的 Runnable 对象，也就是说 <strong>mRunQueue 通过调用 executeActions() 将当前 View 的所有 Runnable ，都会转由 ViewRootImpl 的 Handler 来处理！</strong>而在完成这个工作之后，当前 View 也显示地将 mRunQueue 置空，因为所有的待办任务都已经交给 ViewRootImpl 去处理了。</p><p>现在再回过头看代码的注释，就差不多可以理解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line"><span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line"><span class="comment">// 所有的 Runnable 都会在 attach 之后被正确的放到其应该运行的线程上去</span></span><br><span class="line">getRunQueue().post(action);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transfer all pending runnables.</span></span><br><span class="line"><span class="comment">// 转移所有待办任务(到 ViewRootImpl 中进行处理)</span></span><br><span class="line"><span class="keyword">if</span> (mRunQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mRunQueue.executeActions(info.mHandler);</span><br><span class="line">    mRunQueue = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch 方法执行完了，我们继续回来走 performTraversals() ，接下来一句是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有之前的经验，我们知道这句话的意思是</span></span><br><span class="line"><span class="comment">// 使用 mAttachInfo.mHandler 来处理 getRunQueue() 中的 Runnable 任务</span></span><br><span class="line">getRunQueue().executeActions(mAttachInfo.mHandler);</span><br></pre></td></tr></table></figure><p>要明确的一点是，此时我们处在 ViewRootImpl 类中，此处的 getRunQueue() 方法有别于 View#post：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl#getRunQueue</span></span><br><span class="line"><span class="comment">// 使用 ThreadLocal 来存储每个线程自身的执行队列 HandlerActionQueue</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> HandlerActionQueue <span class="title">getRunQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sRunQueues 是 ThreadLocal&lt;HandlerActionQueue&gt; 对象</span></span><br><span class="line">    HandlerActionQueue rq = sRunQueues.get();</span><br><span class="line">    <span class="keyword">if</span> (rq != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rq;</span><br><span class="line">    &#125;</span><br><span class="line">    rq = <span class="keyword">new</span> HandlerActionQueue();</span><br><span class="line">    sRunQueues.set(rq);</span><br><span class="line">    <span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// View#post</span></span><br><span class="line"><span class="comment">// 为当前 View 返回一个执行队列，但是在 dispatchAttachToWindow 时转到 UI 线程去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerActionQueue <span class="title">getRunQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRunQueue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRunQueue = <span class="keyword">new</span> HandlerActionQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mRunQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说回 performTraversals() ，很明显 getRunQueue() 是 UI 线程执行队列的第一次初始化，也就是说当前这个任务队列里并没有待执行任务！</p><p>但是需要注意的是，<strong>当前没有执行任务（</strong>HandlerActionQueue<strong>），不代表 Handler 消息队列中没有消息</strong>，这是两个概念，需要注意区分开。</p><p>总结一下：</p><ol><li>View#post 方法调用时，会为当前 View 对象初始化一个 HandlerActionQueue ，并将 Runnable 入队存储；</li><li>等在 ViewRootImpl#performTraversals 中递归调用到 View#dispatchAttachedToWindow 时，会将 ViewRootImpl 的 Handler 对象传下来，然后通过这个 Handler 将最初的 Runnable 发送到 UI 线程（消息队列中）等待执行，并将 View 的 HandlerActionQueue 对象置空，方便回收；</li><li>ViewRootImpl#performTraversals 继续执行，才会为 UI 线程首次初始化 HandlerActionQueue 对象，并通过 ThreadLocal 进行存储，方便之后的复用，但需要注意的是，此处初始化的队列中是没有任何 Runnable 对象的；</li><li>然后 ViewRootImpl#performTraversals 继续执行，开始 View 的测量流程。</li></ol><h3 id="View-post-中-Runnable-run-执行的时机"><a href="#View-post-中-Runnable-run-执行的时机" class="headerlink" title="View#post 中 Runnable#run 执行的时机"></a>View#post 中 Runnable#run 执行的时机</h3><p>但现在的问题是，无论怎么说，<strong>HandlerActionQueue#executeActions 都是先于 View 测绘流程的</strong>，为什么在还没有完成测量的时候，就可以拿到宽高信息？</p><p>我们都知道，Android 系统是基于消息机制运行的，所有的事件、行为，都是基于 Handler 消息机制在运行的。所以，当 ViewRootImpl#performTraversals 在执行的时候，也一定是基于某个消息的。而且，HandlerActionQueue#executeActions 执行的时候，也只是通过 Handler 将 Runnable post 到了 UI 线程等待执行（还记得 View#post 的注释吗？）。</p><p>不出意外的话，此时 UI 线程正忙着执行 ViewRootImpl#performTraversal ，等该方法执行完毕，View 已经完成了测量流程，此时再去执行 Runnable#run ，也就自然可以获取到 View 的宽高信息了。</p><p>下面用具体的实例佐证一下我们的猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 Add 到父布局中</span></span><br><span class="line">    view = <span class="keyword">new</span> View(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">( ... ... )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">            Log.e(<span class="string">"Test"</span>, <span class="string">"执行了onLayout()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己声明的 Handler </span></span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.e(<span class="string">"Test"</span>, <span class="string">"mHandler.post ---- &gt; "</span> + view.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onCreate() 中 mAttachInfo 还未被赋值，这里会交给 ViewRootImpl 的 Handler 来处理</span></span><br><span class="line">    <span class="comment">// 即加入消息队列，等待执行</span></span><br><span class="line">    view.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.e(<span class="string">"Test"</span>, <span class="string">"view.post ---- &gt; "</span> + view.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    viewGroup.addView(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印日志如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5419805-ec13fe6929791de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>也就是说：</p><ol><li>Handler#post 首先执行，其 post 的时间点在 onCreate() 方法内，在消息队列中的位置一定比 performTraversals() 靠前；</li><li>ViewRootImpl#performTraversal 执行，过程中执行了 View#dispatchAttachedToWindow 方法，将最初的 Runnable 入队后进行测量流程，完成了 layout 过程；</li><li>之后才执行了最初的 View#post 方法，也就说明了，在 View#dispatchAttachedToWindow 中使用 ViewRootImpl 的 Handler postDelay 的 Runnable 对象，在主线程消息队列中，确实是排在 ViewRootImpl#performTraversal 之后的</li></ol><h3 id="View-post-整体流程的简单总结"><a href="#View-post-整体流程的简单总结" class="headerlink" title="View#post 整体流程的简单总结"></a>View#post 整体流程的简单总结</h3><p>最后大概总结一下：</p><p>当我们使用 View#post 时，会有两种情况：</p><ol><li>在当前 View attach 到 Window 之前，会自己先维护一个 HandlerActionQueue 对象，用来存储当前的 Runnable 对象，然后等到 Attach 到 Window 的时候 (也就是 ViewRootImpl 执行到 performTraversal 方法时) ，会统一将 Runnable 转交给 ViewRootImpl 处理；</li><li>而在 View#dispatchAttachedToWindow 时，也会为当前 View 初始化一个 AttachInfo 对象，该对象持有 ViewRootImpl 的引用，当 View 有此对象后，后续的所有 Runnable 都将直接交给 ViewRootImpl 处理；</li><li>而 ViewRootImpl 也会在执行 performTraversal 方法，也会调用 ViewRootImpl#getRunQueue ，利用 ThreadLocal 来为主线程维护一个 HandlerActionQueue 对象，至此，ViewRootImpl 内部都将使用该队列来进行 Runnable 任务的短期维护；</li><li>但需要注意的是，各个 View 调用的 post 方法，仍然是由各自的 HandlerActionQueue 对象来入队任务的，然后在 View#dispatchAttachedToWindow 的时候转移给 ViewRootImpl 去处理。</li></ol><h3 id="Android-7-0-里-View-post-的变动以及原因"><a href="#Android-7-0-里-View-post-的变动以及原因" class="headerlink" title="Android 7.0 里 View#post 的变动以及原因"></a>Android 7.0 里 View#post 的变动以及原因</h3><p>View#post 说到这里大概就差不多了，文章开篇的时候说到：</p><blockquote><p>Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别</p></blockquote><p>下面来简单对比一下具体的差别，顺便分析一下具体为什么要这样改动。</p><p>实际上这个方法的改动主要是为了解决一个 bug，这个 bug 就是：<strong>在 View 被 attach 到 window 之前，从子线程调用的 View#post ，永远无法得到执行。</strong></p><p>具体原因，我们来看一下 API23 版本的 View#post，就大概都明白了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android API23 View#post</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Assume that post will succeed later</span></span><br><span class="line">    <span class="comment">// 注意此处，不同于我们之前介绍的，这里是直接使用 ViewRootImpl#getRunQueue 来入队任务的</span></span><br><span class="line">    ViewRootImpl.getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，不同于我们之前介绍的，API23 版本中，View#post 在没有 attach 到 window 之前，也就是 mAttachInfo 是 null 的时候，不是自己维护任务队列，而是直接使用 ViewRootImpl#getRunQueue 来入队任务的。</p><p>再来看一下 ViewRootImpl#getRunQueue 方法，我们就会发现问题出在哪里了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RunQueue&gt; sRunQueues = <span class="keyword">new</span> ThreadLocal&lt;RunQueue&gt;();</span><br><span class="line"><span class="function"><span class="keyword">static</span> RunQueue <span class="title">getRunQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RunQueue rq = sRunQueues.get();</span><br><span class="line">    <span class="keyword">if</span> (rq != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rq;</span><br><span class="line">    &#125;</span><br><span class="line">    rq = <span class="keyword">new</span> RunQueue();</span><br><span class="line">    sRunQueues.set(rq);</span><br><span class="line">    <span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，这个队列的保存与获取，是通过以线程为 key 值来存取对象 ThreadLocal 来维护的。而在这个版本的源码中，executeActions() 方法的执行，只有一次调用，那就是 ViewRootImpl#performTraversal 中（感兴趣的可以去 23 版本的源码中查看，这里就不贴图了），与此同时，该方法肯定是执行在主线程中的。</p><p>现在的问题就变成了：<strong>我在子线程中 post 了一个 runnable，并且系统以该子线程为 key 将队列存了起来等待执行；但是在具体执行的时候，系统却是去主线程中寻找待执行的 Runnable，那么当然是永远都得不到执行的了。</strong></p><p>而在<strong>具体 attach 到 window 之后</strong>，View 的 mAttachInfo 持有 ViewRootImpl 引用，会直接将所有的 Runnable 转交给 ViewRootImpl 的 Handler 处理，也<strong>就都能得到妥善处理，就与线程无关了。</strong></p><p>除此以外，ViewRootImpl 使用 ThreadLocal 来存储队列信息，在某些情境下，还会导致内存泄漏。详细信息可以参考：<a href="https://blog.csdn.net/a740169405/article/details/69668957" target="_blank" rel="noopener">https://blog.csdn.net/a740169405/article/details/69668957</a></p><p>所以，<strong>Google 工程师为了解决这两个问题（内存泄漏的问题更严重一些），就在 View#post 方法中使用 View 对象来进行队列的存储，然后在 attach 到 window 的时候，通过持有 ViewRootImpl 引用的 AttachInfo 对象直接将 View 对象的 Runnable 处理掉，就完美解决了这些问题。</strong></p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>下边是自己研究的时候具体参考过的文章，给各位前辈加个鸡腿：</p><h5 id="https-blog-csdn-net-a740169405-article-details-69668957"><a href="#https-blog-csdn-net-a740169405-article-details-69668957" class="headerlink" title="https://blog.csdn.net/a740169405/article/details/69668957"></a><a href="https://blog.csdn.net/a740169405/article/details/69668957" target="_blank" rel="noopener">https://blog.csdn.net/a740169405/article/details/69668957</a></h5><h5 id="https-blog-csdn-net-scnuxisan225-article-details-49815269"><a href="#https-blog-csdn-net-scnuxisan225-article-details-49815269" class="headerlink" title="https://blog.csdn.net/scnuxisan225/article/details/49815269"></a><a href="https://blog.csdn.net/scnuxisan225/article/details/49815269" target="_blank" rel="noopener">https://blog.csdn.net/scnuxisan225/article/details/49815269</a></h5><h5 id="https-www-cnblogs-com-plokmju-p-7481727-html"><a href="#https-www-cnblogs-com-plokmju-p-7481727-html" class="headerlink" title="https://www.cnblogs.com/plokmju/p/7481727.html"></a><a href="https://www.cnblogs.com/plokmju/p/7481727.html" target="_blank" rel="noopener">https://www.cnblogs.com/plokmju/p/7481727.html</a></h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>onCreate() 和 onResume() 里获取不到 View 的高度</title>
    <link href="http://joeljt.top/2018/08/13/onCreate()%20%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%20View%20%E5%AE%BD%E9%AB%98/"/>
    <id>http://joeljt.top/2018/08/13/onCreate() 中获取不到 View 宽高/</id>
    <published>2018-08-12T16:00:00.000Z</published>
    <updated>2018-08-16T03:49:30.369Z</updated>
    
    <content type="html"><![CDATA[<p>经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。</p><a id="more"></a><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindView</span>(R.id.tv_test)</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTv.getHeight(); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mTv.getHeight(); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要弄清这个问题，首先需要知道代码中涉及到的方法具体做了什么工作，以及具体 View 是在什么时候完成测量的。</p><h3 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView()"></a>setContentView()</h3><p>很明显，我们在 onCreate() 方法中调用了 setContentView() 方法，而<strong>设置布局</strong>这个动作会给你一种可以获取到宽高的错觉；那么我们从源码的角度来看看，setContentView() 到底干了点什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. AppCompatDelegate 的抽象方法，根据注释，会调用到 Activity 的实现方法中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> resId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Activity 的实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Window 是一个抽象类，其唯一实现类是 PhoneWindow</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 初始化 DecorView</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 4. 第一次加载窗口，mDecor 为空时，生成一个 DecorView 对象</span></span><br><span class="line">        <span class="comment">// generateDecor(-1) : return new DecorView()</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        ... ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 5. 初始化父布局</span></span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续跟踪到 generateLayout(mDecor) 方法内部</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处根据设置的主题进行一些基础设置，没什么决定性作用</span></span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的一大段代码是根据各种主题设置默认布局，篇幅原因，此处有大量源码删减</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">        setCloseOnSwipeEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                R.attr.dialogTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) != <span class="number">0</span>) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                R.layout.screen_action_bar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 默认布局样式</span></span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 重点来了：将对应的布局加载到 DecorView 中</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="keyword">int</span> layoutResource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载资源文件</span></span><br><span class="line">    <span class="keyword">final</span> View root = inflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">... ...</span><br><span class="line">    <span class="comment">// 7. 将 View 加载到当前 DecorView 中</span></span><br><span class="line">    addView(root, <span class="number">0</span>, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 页面发生变化的话，请求重新摆放布局以及重新绘制</span></span><br><span class="line">    <span class="comment">// 注意，此处的 requestLayout 是 View 的方法</span></span><br><span class="line">    requestLayout();</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">    addViewInner(child, index, params, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说出来你可能不信，但是 setContentView() 到这里就差不多结束了。</p><p>很明显，我们并没有发现任何关于 View 的测量的代码，最后的 requestLayout() 和 invalidate() 也和 View 的 measure() 关系不大，毕竟还没测量，哪里谈得上 layout 和 draw 呢？</p><p>所以， setContentView() 和 View 的测量没啥关系，那么在其之后也就自然获取不到 View 宽高的值了。</p><h3 id="测量流程到底是从哪里开始的"><a href="#测量流程到底是从哪里开始的" class="headerlink" title="测量流程到底是从哪里开始的"></a>测量流程到底是从哪里开始的</h3><p>有了上面的经验，我们已经知道，setContentView() 并不会触发 View 的测量，而只是为 DecorView 指定了布局；那么接下来的问题就是，测量流程到底是从哪里开始的呢？</p><p>我们简单回顾一下 Activity 的启动流程，然后来找到这个答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            <span class="comment">// 1. ActivityThread 内部类 H，处理 LAUNCH_ACTIVITY 的消息</span></span><br><span class="line">            handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 直接从 ActivityThread 的 handleLaunchActivity() 开始了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行 performLaunchActivity() 方法</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        <span class="comment">// 4. 执行 handleResumeActivity() 方法</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                             !r.activity.mFinished &amp;&amp; !r.startsNotResumed,</span><br><span class="line">                             r.lastProcessedSeq, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. performLaunchActivity()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基于反射，利用 Instrumentation 对象创建当前 Activity 的实例</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">            cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// attach() 方法做了一系列最基本的初始化</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                            r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                            r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                            r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 3.1 依然使用 Instrumentation 对象调用 Activity 的 onCreate() 方法</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 强制校验 super 调用</span></span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle,PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    <span class="comment">// 3.2 调用 Activity 的 performCreate() 方法</span></span><br><span class="line">    activity.performCreate(icicle, persistentState);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3 最终得以调用到实际实现的 onCreate()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    onCreate(icicle, persistentState);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 performLaunchActivity() 执行完毕后，根据代码来看，会继续执行 handleResumeActivity()</span></span><br><span class="line"><span class="comment">// 同样的，这个方法会调用到一个 performResumeActivity()，在该方法内部也会最终执行到 onResume()</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">( ... ... )</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 最终会执行到 onResume()，不是重点</span></span><br><span class="line">     r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">             r.window = r.activity.getWindow();</span><br><span class="line">             View decor = r.window.getDecorView();</span><br><span class="line">             ViewManager wm = a.getWindowManager();</span><br><span class="line">             <span class="comment">// 5. 执行到 WindowManagerImpl 的 addView()</span></span><br><span class="line">             <span class="comment">// 然后会跳转到 WindowManagerGlobal 的 addView()</span></span><br><span class="line">             <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                     a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                     wm.addView(decor, l);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">( ... ... )</span> </span>&#123;</span><br><span class="line">     ViewRootImpl root;</span><br><span class="line">     <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">         <span class="comment">// 初始化一个 ViewRootImpl 的实例</span></span><br><span class="line">         root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 调用 setView，为 root 布局 setView</span></span><br><span class="line">             <span class="comment">// 其中 view 为传下来的 DecorView 对象</span></span><br><span class="line">             <span class="comment">// 也就是说，实际上根布局并不是我们认为的 DecorView，而是 ViewRootImpl</span></span><br><span class="line">             root.setView(view, wparams, panelParentView);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 将 DecorView 加载到 WindowManager, View 的绘制流程从此刻才开始</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求对 View 进行测量和绘制</span></span><br><span class="line">    <span class="comment">// 与 setContentView() 不同，此处的方法是 ViewRootImpl 的方法</span></span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 7. 此方法内部有一个 post 了一个 Runnable 对象</span></span><br><span class="line">        <span class="comment">// 在其中又调用一个 doTraversal() 方法；</span></span><br><span class="line">        <span class="comment">// 再之后又会调用到 performTraversals() 方法，然后 View 的测绘流程就从此处开始了</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">... ...</span><br><span class="line">    <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    ... ...</span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">    ... ...</span><br><span class="line">    performDraw();</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题到这里就差不多得到了解答，View 的测绘流程是在 performTraversals() 才开始的；而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的宽高信息也就很容易理解了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字体变色效果实现分析</title>
    <link href="http://joeljt.top/2018/08/12/%E5%AD%97%E4%BD%93%E5%8F%98%E8%89%B2%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://joeljt.top/2018/08/12/字体变色效果实现分析/</id>
    <published>2018-08-11T16:00:00.000Z</published>
    <updated>2018-08-16T03:44:53.747Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>主要技术点：Canvas.clipRect()</p></blockquote><p>实际上，这个方法可以理解成裁剪画布；</p><p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p><p>而这块区域，就是接下来将要进行绘制的区域。</p><p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制前一半内容</span></span><br><span class="line">    drawText(canvas, mChangePaint, <span class="number">0</span>, getWidth()/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用另一颜色的画笔绘制后一半内容</span></span><br><span class="line">    drawText(canvas, mOriginPaint, getWidth() / <span class="number">2</span>, getWidth());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(Canvas canvas, Paint paint, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    paint.setTextSize(getTextSize());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前画布状态</span></span><br><span class="line">    canvas.save();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制</span></span><br><span class="line">    Rect rect = <span class="keyword">new</span> Rect(start, <span class="number">0</span>, end, getHeight());</span><br><span class="line">    canvas.clipRect(rect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文字的基本宽高信息</span></span><br><span class="line">    String text = getText().toString();</span><br><span class="line">    Rect textBounds = <span class="keyword">new</span> Rect();</span><br><span class="line">    paint.getTextBounds(text, <span class="number">0</span>, text.length(), textBounds);</span><br><span class="line">    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取起始位置</span></span><br><span class="line">    <span class="keyword">int</span> x = getWidth() / <span class="number">2</span> - textBounds.width() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> y = getHeight() / <span class="number">2</span> + (metrics.bottom - metrics.top) / <span class="number">2</span> - metrics.bottom;</span><br><span class="line">    canvas.drawText(text, x, y, paint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空画布属性，方便接下来绘制变色的部分</span></span><br><span class="line">    canvas.restore();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;主要技术点：Canvas.clipRect()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，这个方法可以理解成裁剪画布；&lt;/p&gt;
&lt;p&gt;方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解决可视化工具对于 MySQL 8.0 + 无法连接的问题</title>
    <link href="http://joeljt.top/2018/05/28/%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E5%AF%B9%E4%BA%8E%20MySQL%208.0%20+%20%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://joeljt.top/2018/05/28/解决可视化工具对于 MySQL 8.0 + 无法连接的问题/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。</p><a id="more"></a><p>同时还更改了加密方式，之前版本的加密方式是「mysql_native_password」，8.0 之后的加密规则更改为「caching_sha2_password 」，这里需要把用户密码加密规则更改为原来的加密方式即可。</p><p>具体方法步骤如下，记录备忘：</p><blockquote><p> 打开终端，输入命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，至少 8 个字符；密码是在最开始安装 MySQL 的时候设置的，如果忘记了，上网查询解决方法。</p></blockquote><blockquote><p>输入密码后，进入 &gt;mysql 的命令行模式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 切换到 mysql 数据库</span><br><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line"># 设置用户密码永不过期</span><br><span class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;your pwd&apos; password expire never;</span><br><span class="line"></span><br><span class="line"># 用「mysql_native_password」加密方式更新 root 用户密码</span><br><span class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;your pwd&apos;;</span><br><span class="line"></span><br><span class="line"># 刷新</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中多态的具体应用</title>
    <link href="http://joeljt.top/2018/03/09/java%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8/"/>
    <id>http://joeljt.top/2018/03/09/java中多态的具体应用/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">public class Parent &#123;</span><br><span class="line">    public int aInt = -1;</span><br><span class="line">    public void func1() &#123;</span><br><span class="line">        System.err.print(&quot; Parent func1 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void func2() &#123;</span><br><span class="line">        System.err.print(&quot; Parent func2 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 子类</span><br><span class="line">public class Child extends Parent &#123;</span><br><span class="line">    public int aInt = 1;</span><br><span class="line">    public void func1() &#123;</span><br><span class="line">        System.err.print(&quot; Child func1 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void func3() &#123;</span><br><span class="line">        System.err.print(&quot; Child func3 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// test main()</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Child child = new Child();</span><br><span class="line">    child.func1();</span><br><span class="line">    child.func2();</span><br><span class="line">    child.func3();</span><br><span class="line"></span><br><span class="line">    Parent parent = new Child();</span><br><span class="line">    parent.func1();</span><br><span class="line">    parent.func2();</span><br><span class="line">    parent.func3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，将对象声明为Child对象时，三个方法都编译通过，且输入结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Child func1</span><br><span class="line">Parent func2</span><br><span class="line">Child func3</span><br></pre></td></tr></table></figure></p><p>Child类重写了父类的func1()方法，则在运行时匹配了子类自身的重写方法，即，「运行时遵循右侧声明」。<br>但是，如果将对象声明为Parent对象时，parent.fun3()则会报错，因为「编译期遵循左侧实例」，当前对象被声明为Parent实例，而Parent中没有func3()方法，所以编译不通过。同时也正因为「运行时遵循右侧声明」，所以其运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child func1 // 尽管声明为Parent实例，但实际调用Child的方法</span><br><span class="line">Parent func2</span><br></pre></td></tr></table></figure></p><p>综上所述，在多态使用时，成员函数遵循两个原则，即「编译期遵循左侧实例，运行时遵循右侧声明」</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// test main()</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Parent parent = new Child();</span><br><span class="line">    Child child = new Child();</span><br><span class="line">    System.err.println(parent.aInt);</span><br><span class="line">    System.err.println(child.aInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>可以发现，打印结果与成员函数有所不同。因为如果是成员函数，运行时遵循右侧声明的话，打印结果应该相等，同为1才对。因此，成员变量在多态情境下的使用，无论编译还是运行，通通遵循左侧实例。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>成员函数<br>编译时遵循左侧实例，运行时遵循右侧声明</li><li>成员变量<br>编译或者运行一律遵循左侧实例</li></ul><p>其实也比较好理解，编译期间，当前类下不存在的成员函数或成员变量，肯定是无法被实例对象获取到的；<br>而在运行时，java中子类可以重写父类的方法，因此成员函数运行时会正确指向子类的方法，但是，子类并不可以重写父类的变量，当子类与父类有同名变量时，需要使用this和super关键字进行区分。在这种情况下，成员变量的访问则不可能像方法一样使用多态访问，因此只能是遵循左侧的实例了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://joeljt.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>抽象类和接口的区别</title>
    <link href="http://joeljt.top/2018/03/09/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://joeljt.top/2018/03/09/抽象类和接口的区别/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>先来一个问题，java中允许多继承吗？</p><h2 id="抽象类-单继承"><a href="#抽象类-单继承" class="headerlink" title="抽象类 - 单继承"></a>抽象类 - 单继承</h2><ul><li>关键字为abstract, extends, 被类所继承</li><li>不可以被final修饰</li><li>抽象方法不可以被private修饰，但其他三个不受限制</li><li>抽象方法一定存在于抽象类中，但是抽象类中不一定有抽象方法</li><li>抽象类的子类必须全部重写抽象方法，如果只重写部分抽象方法，则该子类同样为抽象方法</li><li>抽象类中不一定全部都是抽象方法，方法可以有方法体</li><li>抽象类不可以实例化对象</li><li>抽象类可以实现接口，因为接口的内容也都是抽象的</li></ul><h2 id="接口-多实现"><a href="#接口-多实现" class="headerlink" title="接口 - 多实现"></a>接口 - 多实现</h2><ul><li>关键字为interface, implements, 被类所实现</li><li>同样不可以被final修饰</li><li>接口只允许三种成员存在：<ol><li>公共的静态常量 public final static</li><li>公共的抽象方法 public abstract</li><li>静态内部类 static class</li></ol></li><li>由上可知，接口的作用域必须为public</li><li>接口的抽象方法也必须全部被实现类所重写，否则实现类为抽象类</li><li>不同的接口之间为继承关系，而且可以多继承</li><li>接口不可以实例化对象</li><li>接口不可以继承抽象类，因为抽象类中有可能存在非抽象方法，与接口的概念相悖</li></ul><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><ul><li>每个类只能继承一个抽象类，但是可以实现多个接口</li><li>抽象类可以有非抽象方法，接口全部为抽象方法</li><li>从作用域角度看，抽象类中抽象方法不能为private，而接口强制为public abstract</li><li>抽象类可以实现接口，但是接口不能继承抽象类</li><li>不同的接口可以多继承，但是不同的抽象类只能单继承</li></ul><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来一个问题，java中允许多继承吗？&lt;/p&gt;
&lt;h2 id=&quot;抽象类-单继承&quot;&gt;&lt;a href=&quot;#抽象类-单继承&quot; class=&quot;headerlink&quot; title=&quot;抽象类 - 单继承&quot;&gt;&lt;/a&gt;抽象类 - 单继承&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键字为abstract,
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://joeljt.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
