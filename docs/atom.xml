<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe&#39;s blog</title>
  
  <subtitle>emmmmm</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joeljt.top/"/>
  <updated>2019-05-13T15:58:54.655Z</updated>
  <id>http://joeljt.top/</id>
  
  <author>
    <name>joe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Daily Schedule</title>
    <link href="http://joeljt.top/2099/05/13/Schedule/"/>
    <id>http://joeljt.top/2099/05/13/Schedule/</id>
    <published>2099-05-12T16:00:00.000Z</published>
    <updated>2019-05-13T15:58:54.655Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="0513"><a href="#0513" class="headerlink" title="0513"></a>0513</h2><ul><li>如何阅读一本书 part</li><li>摸鱼一上午，sigh~</li><li>圆桌派 - 师徒话题</li><li>ViewDragHelper 简单实用，仿 QQ、酷狗音乐侧滑效果实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0513&quot;&gt;&lt;a href=&quot;#0513&quot; class=&quot;headerlink&quot; title=&quot;0513&quot;&gt;&lt;/a&gt;0513&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如何阅读一本书 part&lt;/li&gt;
&lt;li&gt;摸鱼一上午，sigh~&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Schedule" scheme="http://joeljt.top/tags/Schedule/"/>
    
  </entry>
  
  <entry>
    <title>Java 代理模式简单探讨</title>
    <link href="http://joeljt.top/2019/08/14/java-proxy-pattern/"/>
    <id>http://joeljt.top/2019/08/14/java-proxy-pattern/</id>
    <published>2019-08-13T16:00:00.000Z</published>
    <updated>2019-08-14T09:15:19.456Z</updated>
    
    <content type="html"><![CDATA[<p>动态代理是 Hook 技术的基础技能，下一篇暂定 activity 的启动流程，这篇先来搞一下这个代理设计模式吧。</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先上定义。</p><blockquote><p>代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p></blockquote><p>说实话我也看不太懂，但是说到代理，基本上往中介方向理解就差不多。</p><p>房产中介，就是为租客提供一种服务，以帮助租客租到心仪的房子。一个租客不可能直接接触到租房市场上所有的房源，而中介可以在租客和房子中间起到协调的作用。</p><p>哈哈，我可真他娘的是个人才，反正大概就这么个意思吧！</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>下边正经点儿，代理模式就是客户端不直接操作对象，而是由一个中间者（即代理），来对目标对象进行操作，从而间接地操纵或者增强目标对象。UML 类图我还没学会，直接上代码吧！</p><pre><code class="java">public interface IRentHouse{  void rentHouse();}public class Couple implements IRentHouse{  public void rentHouse(){    System.out.println(&quot;新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！&quot;);  }}public class RentAgent implements IRentHouse{  private IRentHouse mClient;  public RentAgent(IRentHouse client){    mClient = client;  }  public void rentHouse(){    System.out.println(&quot;联系房东，商谈价格&quot;);    if(mClient != null){          mClient.rentHouse();    }    System.out.println(&quot;双周保洁，家电保修&quot;);  }}</code></pre><p>如上，客户不需要关心租房前后一系列繁琐的事，把这一切都委托给代理去做，自己只管付钱。在这个事例中，<code>RentAgent</code> 即为 <code>Couple</code> 的代理类，帮助 <code>Couple</code> 处理租房事宜，客户端即通过 <code>RentAgent</code> 间接操纵了 <code>Couple</code> 的动作。</p><p>具体调用以及输入结果：</p><pre><code class="java">public static void main(String[] args) {  Couple couple = new Couple();  RentAgent rentAgent = new RentAgent(couple);  rentAgent.rentHouse();}</code></pre><pre><code class="java">联系房东，商谈价格新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！双周保洁，家电保修</code></pre><p>以上就是静态代理。</p><p>这种模式很简单，也很清晰，但是缺点也很明显，即代理类和主体类都需要实现接口，而且接口方法一旦发生变动，同时这一动作并非双方都需要的（比如说需要为房产中介提供一个和房东协商价格的方法，这个动作本身和租客并没有关系），那么代码可维护性会变得非常差。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在这种情况下，我们就需要了解一下动态代理。动态代理又称为 JDK 代理或者接口代理，其主要是利用 JDK API，从内存层面在运行时为目标接口动态地创建对象，从而实现对目标对象的代理功能，而不受接口方法变动的影响。</p><p>虽然思路大致相同，但是动态代理与静态代理在实现上有本质的区别。静态代理需要显式地写出代理类，委托类，接口等，开发者需要在编译期就手动编码实现代理模式；而动态代理省略了创建代理类的过程，把这个工作交给 JDK 在运行时处理。很明显，这样的设计使得 <strong>JDK 代理要求目标对象必须实现接口，否则无法使用动态代理</strong>。</p><p>废话不多说，还是直接看代码。</p><p>动态代理的实现主要依靠几个类:</p><ul><li><p>java.lang.reflect.Proxy</p><pre><code class="java">// Proxy 类静态方法，返回一个指定接口的代理类实例// 方法传入 InvocationHandler 对象，代理类会拦截所有的执行方法，并通过该处理器自行处理Object newProxyInstance(ClassLoader loader,         // 指定当前目标对象使用类加载器                        Class&lt;?&gt;[] interfaces, // 目标对象实现的接口的类型                        InvocationHandler h         // 自定义方法处理器                        ){}</code></pre></li><li><p>java.lang.reflect.InvocationHandler</p><pre><code class="java">// 代理类会拦截所有的方法，并经由此方法重新调用// 代理类即可以在此进行自己的处理Object invoke(Object proxy, Method method, Object[] args){}</code></pre></li></ul><p>下面我们使用动态代理机制，来实现一下我们之前的租房案例。</p><pre><code class="java">class RentInvocationHandler implements InvocationHandler {    private Object mClient;    public RentInvocationHandler(Object client) {        this.mClient = client;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;联系房东，商谈价格&quot;);        Object invoke = method.invoke(mClient, args);        System.out.println(&quot;双周保洁，家电保修&quot;);        return invoke;    }}</code></pre><p>具体调用：</p><pre><code class="java">Couple couple = new Couple();// 使用动态代理，办理租房业务IRentHouse rentProxy =(IRentHouse)Proxy.newProxyInstance(                                                          couple.getClass().getClassLoader(),                                               couple.getClass().getInterfaces(),                                                           new RentInvocationHandler(couple));rentProxy.rentHouse(); // 代理执行方法</code></pre><p>输入结果：</p><pre><code class="java">联系房东，商谈价格新婚快乐！但是押一付三再加服务费好多钱，自如黑中介！双周保洁，家电保修</code></pre><p>具体使用并不复杂，就不再多说，但是关于动态代理生成的代理类本身也有一些特点，下面大概罗列一下：</p><ol><li><p>类修饰符</p><p>该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承</p></li><li><p>类名</p><p>格式是 “$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是 Proxy 内部对动态代理类做了缓存，如果以前生成过相应的对象，则会直接返回该对象而不是重新创建</p></li><li><p>继承关系</p><p>$Proxy0 extends Proxy implements InterfaceA, InterfaceB, InterfaceX</p></li></ol><p>动态代理避免了静态代理代码维护的缺点，动态生成代理类，较为灵活，但是缺点也比较明显：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p><h3 id="Cglib-代理"><a href="#Cglib-代理" class="headerlink" title="Cglib 代理"></a>Cglib 代理</h3><p>这个东西就很厉害了。前文说了，动态代理的缺点是要求目标对象必须实现接口，否则就无法实现动态代理。Cglib 就是为了解决这个问题出现的，使用cglib代理的对象则无需实现接口，达到代理类无侵入。</p><p>Cglib 在 Android 使用的不多，后端的同学可能更熟悉一些，Spring 框架就集成了这个库。</p><p>使用cglib需要引入<a href="https://repo1.maven.org/maven2/cglib/cglib/3.2.5/cglib-3.2.5.jar" target="_blank" rel="noopener">cglib的jar包</a>，具体使用如下：</p><pre><code class="java">public class ProxyFactory implements MethodInterceptor{    private Object target;    //维护一个目标对象    public ProxyFactory(Object target) {        this.target = target;    }    //为目标对象生成代理对象    public Object getProxyInstance() {        //工具类        Enhancer en = new Enhancer();        //设置父类        en.setSuperclass(target.getClass());        //设置回调函数        en.setCallback(this);        //创建子类对象代理        return en.create();    }    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {        System.out.println(&quot;开启事务&quot;);        // 执行目标对象的方法        Object returnValue = method.invoke(target, args);        System.out.println(&quot;关闭事务&quot;);        return returnValue;    }}</code></pre><p>具体和动态代理大体相同，就不再赘述了。</p><h3 id="代理模式-vs-装饰模式"><a href="#代理模式-vs-装饰模式" class="headerlink" title="代理模式 vs 装饰模式"></a>代理模式 vs 装饰模式</h3><p>熟悉装饰者模式的同学可能会有点儿头疼，因为代理模式感觉和装饰者模式一毛一样……反正都是定义个接口，包裹一下委托类，然后操作一下代理类，实际操作了委托类嘛！</p><p>二者确实比较相似，从 UML 类图看都没有任何区别，代理类/装饰类与委托类都继承自同一个接口或者抽象类，然后代理类/装饰类包装委托类。</p><ul><li><p>装饰模式：能动态的新增或组合对象的行为</p><p>在不改变接口的前提下，动态扩展对象的功能</p></li><li><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问</p><p>在不改变接口的前提下，控制对象的访问</p></li></ul><p>装饰模式是“新增行为”，而代理模式是“控制访问”。关键就是我们如何判断是“新增行为”还是“控制访问”。</p><p>具体举例来说，</p><ol><li><p>网上很多封装了带上拉刷新下拉加载的 RecyclerView，实现方式就是装饰模式，一般都是定义一个 Wrapper 来包裹原 adapter 以及原 RecyclerView，在此基础上新增了「下拉刷新」、「上拉加载」的行为；</p></li><li><p>Retrofit 的 create 方法就是动态代理的应用，不对接口做出任何新增行为，只是通过动态代理创建接口对象，控制对接口的访问；</p><pre><code class="java">public &lt;T&gt; T create(final Class&lt;T&gt; service) {    return (T) Proxy.newProxyInstance(                              service.getClassLoader(),                               new Class&lt;?&gt;[] { service },                               new InvocationHandler() {}});}</code></pre></li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p><a href="https://www.jianshu.com/p/6f6bb2f0ece9" target="_blank" rel="noopener">代理模式及Java实现动态代理</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java 动态代理机制分析及扩展</a></p></li><li><p><a href="https://www.cnblogs.com/fillPv/p/5939277.html" target="_blank" rel="noopener">Java代理(jdk静态代理、动态代理和cglib动态代理)</a></p></li><li><p><a href="https://segmentfault.com/a/1190000011291179" target="_blank" rel="noopener">Java三种代理模式：静态代理、动态代理和cglib代理</a></p></li><li><p><a href="https://segmentfault.com/a/1190000009235245" target="_blank" rel="noopener">Java的三种代理模式</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态代理是 Hook 技术的基础技能，下一篇暂定 activity 的启动流程，这篇先来搞一下这个代理设计模式吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="design-pattern" scheme="http://joeljt.top/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>Android 收起通知栏</title>
    <link href="http://joeljt.top/2019/05/13/Android-collapse-status-bar/"/>
    <id>http://joeljt.top/2019/05/13/Android-collapse-status-bar/</id>
    <published>2019-05-13T12:34:22.745Z</published>
    <updated>2019-05-13T12:34:22.745Z</updated>
    
    <content type="html"><![CDATA[<p>点击通知栏RemoteView中的按钮后要收起通知栏，系统默认是不自动收起的，不过没有找到公开的API可以控制通知栏。</p><p>在android.app.StatusBarManager里提供了显示和收缩通知栏的方法，但是这个类没有公开，通过反射可以调用。</p><p>需要注意的是API LEVEL&gt;16后，对应的方法名称改变了。</p><p> 使用此方法时需要再AndroidManifest.xml中添加如下权限</p><pre><code class="xml">&lt;uses-permission android:name=&quot;android.permission.EXPAND_STATUS_BAR&quot; /&gt;</code></pre><pre><code class="java">private void collapseStatusBar() {        int currentApiVersion = android.os.Build.VERSION.SDK_INT;        try {            Object service = getSystemService(&quot;statusbar&quot;);            Class&lt;?&gt; statusbarManager = Class                    .forName(&quot;android.app.StatusBarManager&quot;);            Method collapse = null;            if (service != null) {                if (currentApiVersion &lt;= 16) {                    collapse = statusbarManager.getMethod(&quot;collapse&quot;);                } else {                    collapse = statusbarManager.getMethod(&quot;collapsePanels&quot;);                }                collapse.setAccessible(true);                collapse.invoke(service);            }        } catch (Exception e) {            e.printStackTrace();        }    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;点击通知栏RemoteView中的按钮后要收起通知栏，系统默认是不自动收起的，不过没有找到公开的API可以控制通知栏。&lt;/p&gt;
&lt;p&gt;在android.app.StatusBarManager里提供了显示和收缩通知栏的方法，但是这个类没有公开，通过反射可以调用。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ViewDragHelper 源码解析</title>
    <link href="http://joeljt.top/2019/05/13/ViewDragHelper-source-code/"/>
    <id>http://joeljt.top/2019/05/13/ViewDragHelper-source-code/</id>
    <published>2019-05-12T16:00:00.000Z</published>
    <updated>2019-05-13T12:43:31.980Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/lqstayreal/p/4500219.html" target="_blank" rel="noopener">这文章是转来的，写的实在是好，怕哪天失踪了……</a></p><a id="more"></a><p>在自定义ViewGroup的过程中，如果涉及到View的拖动滑动，ViewDragHelper的使用应该是少不了的，它提供了一系列用于用户拖动子View的辅助方法和相关的状态记录，像Navigation Drawer的边缘滑动、QQ5.x的侧滑菜单、知乎里的页面滑动返回都可以由它实现，所以有必要完全掌握它的使用。</p><p>要想完全掌握ViewDragHelper的使用和原理，最好的办法就是读懂它的源码，所以就有了这篇分析，以便在印象模糊之时可以再次快速回顾ViewDragHelper的原理、用法、注意事项等。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li><p>在自定义ViewGroup的构造方法里调用ViewDragHelper的静态工厂方法create()创建ViewDragHelper实例</p></li><li><p>实现ViewDragHelper.Callback</p><p>最重要的几个方法是tryCaptureView()、clampViewPositionVertical()、clampViewPositionHorizontal()、getViewHorizontalDragRange()、getViewVerticalDragRange()</p><ul><li>tryCaptureView()里会传递当前触摸区域下的子View实例作为参数，如果需要对当前触摸的子View进行拖拽移动就返回true，否则返回false。</li><li>clampViewPositionVertical()决定了要拖拽的子View在垂直方向上应该移动到的位置，该方法会传递三个参数：要拖拽的子View实例、期望的移动后位置子View的top值、移动的距离。返回值为子View在最终位置时的top值，一般直接返回第二个参数即可。</li><li>clampViewPositionHorizontal()与clampViewPositionVertical()同理，只不过是发生在水平方向上，最终返回的是View的left值。</li><li>getViewVerticalDragRange()要返回一个大于0的数，才会在在垂直方向上对触摸到的View进行拖动。</li><li>getViewHorizontalDragRange()与getViewVerticalDragRange()同理，只不过是发生在水平方向上。</li></ul></li><li><p>在onInterceptTouchEvent()方法里调用并返回ViewDragHelper的shouldInterceptTouchEvent()方法</p></li><li><p>在onTouchEvent()方法里调用ViewDragHelper()的processTouchEvent()方法。ACTION_DOWN事件发生时，如果当前触摸点下要拖动的子View没有消费事件，此时应该在onTouchEvent()返回true，否则将收不到后续事件，不会产生拖动。</p></li><li><p>上面几个步骤已经实现了子View拖动的效果，如果还想要实现fling效果（滑动时松手后以一定速率继续自动滑动下去并逐渐停止，类似于扔东西）或者松手后自动滑动到指定位置，需要实现自定义ViewGroup的computeScroll()方法，方法实现如下：</p><pre><code> @Override public void computeScroll() {     if (mDragHelper.continueSettling(true)) {         postInvalidate();     } }</code></pre><p>并在ViewDragHelper.Callback的onViewReleased()方法里调用settleCapturedViewAt()、flingCapturedView()，或在任意地方调用smoothSlideViewTo()方法。</p></li><li><p>如果要实现边缘拖动的效果，需要调用ViewDragHelper的setEdgeTrackingEnabled()方法，注册想要监听的边缘。然后实现ViewDragHelper.Callback里的onEdgeDragStarted()方法，在此手动调用captureChildView()传递要拖动的子View。</p></li></ol><p>具体的使用Demo请见最后面公布的几个案例。</p><h3 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h3><p>ViewDragHelper的完整源码可在<a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/ViewDragHelper.java" target="_blank" rel="noopener">GitHub</a>或<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.2_r1/android/support/v4/widget/ViewDragHelper.java#ViewDragHelper" target="_blank" rel="noopener">GrepCode</a>上在线查看。在最后的总结部分，我画了简单的流程图，梳理了整个触摸事件传递过重中相关方法的调用，有需要的就先去总结部分看看。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><ol><li>了解View的坐标系统，<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html" target="_blank" rel="noopener">Android View坐标getLeft, getRight, getTop, getBottom</a></li><li>了解MotionEvent中关于多点触控的机制，<a href="http://my.oschina.net/banxi/blog/56421" target="_blank" rel="noopener">android触控,先了解MotionEvent(一)</a></li><li>了解Scroller类原理，<a href="http://blog.csdn.net/qinjuning/article/details/7419207" target="_blank" rel="noopener">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a></li><li>了解Touch事件的分发机制，<a href="http://blog.csdn.net/xiaanming/article/details/21696315" target="_blank" rel="noopener">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a></li></ol><h4 id="ViewDragHelper实例的创建"><a href="#ViewDragHelper实例的创建" class="headerlink" title="ViewDragHelper实例的创建"></a>ViewDragHelper实例的创建</h4><p>ViewDragHelper重载了两个create()静态方法，先看两个参数的create()方法：</p><pre><code>/** * Factory method to create a new ViewDragHelper. * * @param forParent Parent view to monitor * @param cb Callback to provide information and receive events * @return a new ViewDragHelper instance */public static ViewDragHelper create(ViewGroup forParent, Callback cb) {    return new ViewDragHelper(forParent.getContext(), forParent, cb);}</code></pre><p>create()的两个参数很好理解，第一个是我们自定义的ViewGroup，第二个是控制子View拖拽需要的回调对象。create()直接调用了ViewDragHelper构造方法，我们再来看看这个构造方法。</p><pre><code>/** * Apps should use ViewDragHelper.create() to get a new instance. * This will allow VDH to use internal compatibility implementations for different * platform versions. * * @param context Context to initialize config-dependent params from * @param forParent Parent view to monitor */private ViewDragHelper(Context context, ViewGroup forParent, Callback cb) {    if (forParent == null) {        throw new IllegalArgumentException(&quot;Parent view may not be null&quot;);    }    if (cb == null) {        throw new IllegalArgumentException(&quot;Callback may not be null&quot;);    }    mParentView = forParent;    mCallback = cb;    final ViewConfiguration vc = ViewConfiguration.get(context);    final float density = context.getResources().getDisplayMetrics().density;    mEdgeSize = (int) (EDGE_SIZE * density + 0.5f);    mTouchSlop = vc.getScaledTouchSlop();    mMaxVelocity = vc.getScaledMaximumFlingVelocity();    mMinVelocity = vc.getScaledMinimumFlingVelocity();    mScroller = ScrollerCompat.create(context, sInterpolator);}</code></pre><p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过create()工厂方法来创建ViewDragHelper实例了。这里要求了我们传递的自定义ViewGroup和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p><ul><li>mParentView和mCallback分别保存传递过来的对应参数</li><li>ViewConfiguration类里定义了View相关的一系列时间、大小、距离等常量</li><li>mEdgeSize表示边缘触摸的范围。例如mEdgeSize为20dp并且用户注册监听了左侧边缘触摸时，触摸点的x坐标小于mParentView.getLeft() + mEdgeSize时（即触摸点在容器左边界往右20dp内）就算做是左侧的边缘触摸，详见ViewDragHelper的getEdgesTouched()方法。</li><li>mTouchSlop是一个很小的距离值，只有在前后两次触摸点的距离超过mTouchSlop的值时，我们才把这两次触摸算作是“滑动”，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿。</li><li>mMaxVelocity、mMinVelocity是fling时的最大、最小速率，单位是像素每秒。</li><li>mScroller是View滚动的辅助类，该类的详细解析参见下面几篇文章<ul><li><a href="http://blog.csdn.net/qinjuning/article/details/7419207" target="_blank" rel="noopener">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a></li><li><a href="http://www.cnblogs.com/supersugar/archive/2012/08/13/2636691.html" target="_blank" rel="noopener">Android中Scroller类的分析</a></li></ul></li></ul><p>再看三个参数的create()方法：</p><pre><code>/** * Factory method to create a new ViewDragHelper. * * @param forParent Parent view to monitor * @param sensitivity Multiplier for how sensitive the helper should be about detecting *                    the start of a drag. Larger values are more sensitive. 1.0f is normal. * @param cb Callback to provide information and receive events * @return a new ViewDragHelper instance */public static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {    final ViewDragHelper helper = create(forParent, cb);    helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity));    return helper;}</code></pre><p>第二个参数sensitivity是用来调节mTouchSlop的值。sensitivity越大，mTouchSlop越小，对滑动的检测就越敏感。例如sensitivity为1时，前后触摸点距离超过20dp才进行滑动处理，现在sensitivity为2的话，前后触摸点距离超过10dp就进行处理了。</p><h4 id="对Touch事件的处理"><a href="#对Touch事件的处理" class="headerlink" title="对Touch事件的处理"></a>对Touch事件的处理</h4><p>当mParentView（自定义ViewGroup）被触摸时，首先会调用mParentView的onInterceptTouchEvent(MotionEvent ev)，接着就调用shouldInterceptTouchEvent(MotionEvent ev) ，所以先来看看这个方法的ACTION_DOWN部分：</p><pre><code>/** * Check if this event as provided to the parent view&#39;s onInterceptTouchEvent should * cause the parent to intercept the touch event stream. * * @param ev MotionEvent provided to onInterceptTouchEvent * @return true if the parent view should return true from onInterceptTouchEvent */public boolean shouldInterceptTouchEvent(MotionEvent ev) {    final int action = MotionEventCompat.getActionMasked(ev);    final int actionIndex = MotionEventCompat.getActionIndex(ev);    if (action == MotionEvent.ACTION_DOWN) {        // Reset things for a new event stream, just in case we didn&#39;t get        // the whole previous stream.        cancel();    }    if (mVelocityTracker == null) {        mVelocityTracker = VelocityTracker.obtain();    }    mVelocityTracker.addMovement(ev);    switch (action) {        case MotionEvent.ACTION_DOWN: {            final float x = ev.getX();            final float y = ev.getY();            final int pointerId = MotionEventCompat.getPointerId(ev, 0);            saveInitialMotion(x, y, pointerId);            final View toCapture = findTopChildUnder((int) x, (int) y);            // Catch a settling view if possible.            if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) {                tryCaptureViewForDrag(toCapture, pointerId);            }            final int edgesTouched = mInitialEdgesTouched[pointerId];            if ((edgesTouched &amp; mTrackingEdges) != 0) {                mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);            }            break;        }        // 其他case暂且省略    }    return mDragState == STATE_DRAGGING;}</code></pre><p>看9~21行，首先是关于多点触控（MotionEvent的actionIndex、ACTION_POINTER_DOWN 等概念），不明白的请参阅<a href="http://my.oschina.net/banxi/blog/56421" target="_blank" rel="noopener">android触控,先了解MotionEvent(一)</a>。</p><p>mVelocityTracker记录下触摸的各个点信息，稍后可以用来计算本次滑动的速率，每次发生ACTION_DOWN事件都会调用cancel()，而在cancel()方法里mVelocityTracker又被清空了，所以mVelocityTracker 记录下的是本次ACTION_DOWN事件直至ACTION_UP事件发生后（下次ACTION_DOWN事件发生前）的所有触摸点的信息。</p><p>再来看24~42行case MotionEvent.ACTION_DOWN部分，先是调用saveInitialMotion(x, y, pointerId)保存手势的初始信息，即ACTION_DOWN发生时的触摸点坐标（x、y）、触摸手指编号（pointerId），如果触摸到了mParentView的边缘还会记录触摸的是哪个边缘。接着调用findTopChildUnder((int) x, (int) y);来获取当前触摸点下最顶层的子View，看findTopChildUnder 的源码：</p><pre><code>/** * Find the topmost child under the given point within the parent view&#39;s coordinate system. * The child order is determined using {@link Callback#getOrderedChildIndex(int)}. * * @param x X position to test in the parent&#39;s coordinate system * @param y Y position to test in the parent&#39;s coordinate system * @return The topmost child view under (x, y) or null if none found. */public View findTopChildUnder(int x, int y) {    final int childCount = mParentView.getChildCount();    for (int i = childCount - 1; i &gt;= 0; i--) {        final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));        if (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;                y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) {            return child;        }    }    return null;}</code></pre><p>代码很简单，注释里也说明的很清楚了。如果在同一个位置有两个子View重叠，想要让下层的子View被选中，那么就要实现Callback里的getOrderedChildIndex(int index)方法来改变查找子View的顺序；例如topView（上层View）的index是4，bottomView（下层View）的index是3，按照正常的遍历查找方式（getOrderedChildIndex()默认直接返回index），会选择到topView，要想让bottomView被选中就得这么写：</p><pre><code>public int getOrderedChildIndex(int index) {    int indexTop = mParentView.indexOfChild(topView);    int indexBottom = mParentView.indexOfChild(bottomView);    if (index == indexTop) {        return indexBottom;    }    return index;}</code></pre><p>32~35行，这里还看到了一个mDragState成员变量，它共有三种取值：</p><ol><li>STATE_IDLE：所有的View处于静止空闲状态</li><li>STATE_DRAGGING：某个View正在被用户拖动（用户正在与设备交互）</li><li>STATE_SETTLING：某个View正在安置状态中（用户并没有交互操作），就是自动滚动的过程中<br>mCapturedView默认为null，所以一开始不会执行这里的代码，mDragState处于STATE_SETTLING状态时才会执行tryCaptureViewForDrag()，执行的情况到后面再分析，这里先跳过。</li></ol><p>37~40行调用了Callback.onEdgeTouched向外部通知mParentView的某些边缘被触摸到了，mInitialEdgesTouched是在刚才调用过的saveInitialMotion方法里进行赋值的。</p><p>ACTION_DOWN 部分处理完了，跳过switch语句块，剩下的代码就只有return mDragState == STATE_DRAGGING;。在ACTION_DOWN部分没有对mDragState进行赋值，其默认值为STATE_IDLE，所以此处返回false。</p><p>那么返回false后接下来应该是会调用哪个方法呢，根据<a href="http://blog.csdn.net/xiaanming/article/details/21696315" target="_blank" rel="noopener">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>里的解析，接下来会在mParentView的所有子View中寻找响应这个Touch事件的View（会调用每个子View的dispatchTouchEvent()方法，dispatchTouchEvent里一般又会调用onTouchEvent()）；</p><ul><li>如果没有子View消费这次事件（子View的dispatchTouchEvent()返回都是false），会调用mParentView的super.dispatchTouchEvent(ev)，即View中的dispatchTouchEvent(ev)，然后调用mParentView的onTouchEvent()方法，再调用ViewDragHelper的processTouchEvent(MotionEvent ev)方法。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动（除了ACTION_DOWN外的其他事件发生时返回true或false都不会影响接下来的事件接受），因为拖动的相关代码是写在processTouchEvent()里的ACTION_MOVE部分的。要注意的是返回true后mParentView的onInterceptTouchEvent()就不会收到后续的ACTION_MOVE、ACTION_UP等事件了。</li><li>如果有子View消费了本次ACTION_DOWN事件，mParentView的onTouchEvent()就收不到ACTION_DOWN事件了，也就是ViewDragHelper的processTouchEvent(MotionEvent ev)收不到ACTION_DOWN事件了。不过只要该View没有调用过requestDisallowInterceptTouchEvent(true)，mParentView的onInterceptTouchEvent()的ACTION_MOVE部分还是会执行的，如果在此时返回了true拦截了ACTION_MOVE事件，processTouchEvent()里的ACTION_MOVE部分也就会正常执行，拖动也就没问题了。onInterceptTouchEvent()的ACTION_MOVE部分具体做了怎样的处理，稍后再来解析。</li></ul><p>接下来对这两种情况逐一解析。</p><p>假设没有子View消费这次事件，根据刚才的分析最终就会调用processTouchEvent(MotionEvent ev)的ACTION_DOWN部分：</p><pre><code>/** * Process a touch event received by the parent view. This method will dispatch callback events * as needed before returning. The parent view&#39;s onTouchEvent implementation should call this. * * @param ev The touch event received by the parent view */public void processTouchEvent(MotionEvent ev) {    final int action = MotionEventCompat.getActionMasked(ev);    final int actionIndex = MotionEventCompat.getActionIndex(ev);    if (action == MotionEvent.ACTION_DOWN) {        // Reset things for a new event stream, just in case we didn&#39;t get        // the whole previous stream.        cancel();    }    if (mVelocityTracker == null) {        mVelocityTracker = VelocityTracker.obtain();    }    mVelocityTracker.addMovement(ev);    switch (action) {        case MotionEvent.ACTION_DOWN: {            final float x = ev.getX();            final float y = ev.getY();            final int pointerId = MotionEventCompat.getPointerId(ev, 0);            final View toCapture = findTopChildUnder((int) x, (int) y);            saveInitialMotion(x, y, pointerId);            // Since the parent is already directly processing this touch event,            // there is no reason to delay for a slop before dragging.            // Start immediately if possible.            tryCaptureViewForDrag(toCapture, pointerId);            final int edgesTouched = mInitialEdgesTouched[pointerId];            if ((edgesTouched &amp; mTrackingEdges) != 0) {                mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);            }            break;        }        // 其他case暂且省略    }}</code></pre><p>这段代码跟shouldInterceptTouchEvent()里ACTION_DOWN那部分基本一致，唯一区别就是这里没有约束条件直接调用了tryCaptureViewForDrag()方法，现在来看看这个方法：</p><pre><code>/** * Attempt to capture the view with the given pointer ID. The callback will be involved. * This will put us into the &quot;dragging&quot; state. If we&#39;ve already captured this view with * this pointer this method will immediately return true without consulting the callback. * * @param toCapture View to capture * @param pointerId Pointer to capture with * @return true if capture was successful */boolean tryCaptureViewForDrag(View toCapture, int pointerId) {    if (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) {        // Already done!        return true;    }    if (toCapture != null &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) {        mActivePointerId = pointerId;        captureChildView(toCapture, pointerId);        return true;    }    return false;}</code></pre><p>这里调用了Callback的tryCaptureView(View child, int pointerId)方法，把当前触摸到的View和触摸手指编号传递了过去，在tryCaptureView()中决定是否需要拖动当前触摸到的View，如果要拖动当前触摸到的View就在tryCaptureView()中返回true，让ViewDragHelper把当前触摸的View捕获下来，接着就调用了captureChildView(toCapture, pointerId)方法：</p><pre><code>/** * Capture a specific child view for dragging within the parent. The callback will be notified * but {@link Callback#tryCaptureView(android.view.View, int)} will not be asked permission to * capture this view. * * @param childView Child view to capture * @param activePointerId ID of the pointer that is dragging the captured child view */public void captureChildView(View childView, int activePointerId) {    if (childView.getParent() != mParentView) {        throw new IllegalArgumentException(&quot;captureChildView: parameter must be a descendant &quot; +                &quot;of the ViewDragHelper&#39;s tracked parent view (&quot; + mParentView + &quot;)&quot;);    }    mCapturedView = childView;    mActivePointerId = activePointerId;    mCallback.onViewCaptured(childView, activePointerId);    setDragState(STATE_DRAGGING);}</code></pre><p>代码很简单，在captureChildView(toCapture, pointerId)中将要拖动的View和触摸的手指编号记录下来，并调用Callback的onViewCaptured(childView, activePointerId)通知外部有子View被捕获到了，再调用setDragState()设置当前的状态为STATE_DRAGGING，看setDragState()源码：</p><pre><code>void setDragState(int state) {    if (mDragState != state) {        mDragState = state;        mCallback.onViewDragStateChanged(state);        if (mDragState == STATE_IDLE) {            mCapturedView = null;        }    }}</code></pre><p>状态改变后会调用Callback的onViewDragStateChanged()通知状态的变化。</p><p>假设ACTION_DOWN发生后在mParentView的onTouchEvent()返回了true，接下来就会执行ACTION_MOVE部分：</p><pre><code>public void processTouchEvent(MotionEvent ev) {    switch (action) {        // 省略其他case...        case MotionEvent.ACTION_MOVE: {            if (mDragState == STATE_DRAGGING) {                final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);                final float x = MotionEventCompat.getX(ev, index);                final float y = MotionEventCompat.getY(ev, index);                final int idx = (int) (x - mLastMotionX[mActivePointerId]);                final int idy = (int) (y - mLastMotionY[mActivePointerId]);                dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);                saveLastMotion(ev);            } else {                // Check to see if any pointer is now over a draggable view.                final int pointerCount = MotionEventCompat.getPointerCount(ev);                for (int i = 0; i &lt; pointerCount; i++) {                    final int pointerId = MotionEventCompat.getPointerId(ev, i);                    final float x = MotionEventCompat.getX(ev, i);                    final float y = MotionEventCompat.getY(ev, i);                    final float dx = x - mInitialMotionX[pointerId];                    final float dy = y - mInitialMotionY[pointerId];                    reportNewEdgeDrags(dx, dy, pointerId);                    if (mDragState == STATE_DRAGGING) {                        // Callback might have started an edge drag.                        break;                    }                    final View toCapture = findTopChildUnder((int) x, (int) y);                    if (checkTouchSlop(toCapture, dx, dy) &amp;&amp;                            tryCaptureViewForDrag(toCapture, pointerId)) {                        break;                    }                }                saveLastMotion(ev);            }            break;        }        // 省略其他case...    }}</code></pre><p>要注意的是，如果一直没松手，这部分代码会一直调用。这里先判断mDragState是否为STATE_DRAGGING，而唯一调用setDragState(STATE_DRAGGING)的地方就是tryCaptureViewForDrag()了，刚才在ACTION_DOWN里调用过tryCaptureViewForDrag()，现在又要分两种情况。<br>如果刚才在ACTION_DOWN里捕获到要拖动的View，那么就执行if部分的代码，这个稍后解析，先考虑没有捕获到的情况。没有捕获到的话，mDragState依然是STATE_IDLE，然后会执行else部分的代码。这里主要就是检查有没有哪个手指触摸到了要拖动的View上，触摸上了就尝试捕获它，然后让mDragState变为STATE_DRAGGING，之后就会执行if部分的代码了。这里还有两个方法涉及到了Callback里的方法，需要来解析一下，分别是reportNewEdgeDrags()和checkTouchSlop()，先看reportNewEdgeDrags()：</p><pre><code>private void reportNewEdgeDrags(float dx, float dy, int pointerId) {    int dragsStarted = 0;    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) {        dragsStarted |= EDGE_LEFT;    }    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) {        dragsStarted |= EDGE_TOP;    }    if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) {        dragsStarted |= EDGE_RIGHT;    }    if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) {        dragsStarted |= EDGE_BOTTOM;    }    if (dragsStarted != 0) {        mEdgeDragsInProgress[pointerId] |= dragsStarted;        mCallback.onEdgeDragStarted(dragsStarted, pointerId);    }}</code></pre><p>这里对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在mEdgeDragsInProgress中，再调用Callback的onEdgeDragStarted(int edgeFlags, int pointerId)通知某个边缘开始产生拖动了。虽然reportNewEdgeDrags()会被调用很多次（因为processTouchEvent()的ACTION_MOVE部分会执行很多次），但mCallback.onEdgeDragStarted(dragsStarted, pointerId)只会调用一次，具体的要看checkNewEdgeDrag()这个方法：</p><pre><code>private boolean checkNewEdgeDrag(float delta, float odelta, int pointerId, int edge) {    final float absDelta = Math.abs(delta);    final float absODelta = Math.abs(odelta);    if ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == 0 ||            (mEdgeDragsLocked[pointerId] &amp; edge) == edge ||            (mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||            (absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) {        return false;    }    if (absDelta &lt; absODelta * 0.5f &amp;&amp; mCallback.onEdgeLock(edge)) {        mEdgeDragsLocked[pointerId] |= edge;        return false;    }    return (mEdgeDragsInProgress[pointerId] &amp; edge) == 0 &amp;&amp; absDelta &gt; mTouchSlop;}</code></pre><ul><li>checkNewEdgeDrag()返回true表示在指定的edge（边缘）开始产生拖动了。</li><li>方法的两个参数delta和odelta需要解释一下，odelta里的o应该代表opposite，这是什么意思呢，以reportNewEdgeDrags()里调用checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)为例，我们要监测左边缘的触摸情况，所以主要监测的是x轴方向上的变化，这里delta为dx，odelta为dy，也就是说delta是指我们主要监测的方向上的变化，odelta是另外一个方向上的变化，后面要判断假另外一个方向上的变化是否要远大于主要方向上的变化，所以需要另外一个方向上的距离变化的值。</li><li>mInitialEdgesTouched是在ACTION_DOWN部分的saveInitialMotion()里生成的，ACTION_DOWN发生时触摸到的边缘会被记录在mInitialEdgesTouched中。如果ACTION_DOWN发生时没有触摸到边缘，或者触摸到的边缘不是指定的edge，就直接返回false了。</li><li>mTrackingEdges是由setEdgeTrackingEnabled(int edgeFlags)设置的，当我们想要追踪监听边缘触摸时才需要调用setEdgeTrackingEnabled(int edgeFlags)，如果我们没有调用过它，这里就直接返回false了。</li><li>mEdgeDragsLocked它在这个方法里被引用了多次，它在整个ViewDragHelper里唯一被赋值的地方就是这里的第12行，所以默认值是0，第6行mEdgeDragsLocked[pointerId] &amp; edge) == edge执行的结果是false。我们再跳到11到14行看看，absDelta &lt; absODelta * 0.5f的意思是检查在次要方向上移动的距离是否远超过主要方向上移动的距离，如果是再调用Callback的onEdgeLock(edge)检查是否需要锁定某个边缘，如果锁定了某个边缘，那个边缘就算触摸到了也不会被记录在mEdgeDragsInProgress里了，也不会收到Callback的onEdgeDragStarted()通知了。并且将锁定的边缘记录在mEdgeDragsLocked变量里，再次调用本方法时就会在第6行进行判断了，第6行里如果检测到给定的edge被锁定，就直接返回false了。</li><li>回到第7行的(mEdgeDragsInProgress[pointerId] &amp; edge) == edge，mEdgeDragsInProgress是保存已发生过拖动事件的边缘的，如果给定的edge已经保存过了，那就没必要再检测其他东西了，直接返回false了。</li><li>第8行(absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)很简单了，就是检查本次移动的距离是不是太小了，太小就不处理了。</li><li>最后一句返回的时候再次检查给定的edge有没有记录过，确保了每个边缘只会调用一次reportNewEdgeDrags的mCallback.onEdgeDragStarted(dragsStarted, pointerId)</li></ul><p>再来看checkTouchSlop()方法：</p><pre><code>/** * Check if we&#39;ve crossed a reasonable touch slop for the given child view. * If the child cannot be dragged along the horizontal or vertical axis, motion * along that axis will not count toward the slop check. * * @param child Child to check * @param dx Motion since initial position along X axis * @param dy Motion since initial position along Y axis * @return true if the touch slop has been crossed */private boolean checkTouchSlop(View child, float dx, float dy) {    if (child == null) {        return false;    }    final boolean checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; 0;    final boolean checkVertical = mCallback.getViewVerticalDragRange(child) &gt; 0;    if (checkHorizontal &amp;&amp; checkVertical) {        return dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;    } else if (checkHorizontal) {        return Math.abs(dx) &gt; mTouchSlop;    } else if (checkVertical) {        return Math.abs(dy) &gt; mTouchSlop;    }    return false;}</code></pre><p>这个方法主要就是检查手指移动的距离有没有超过触发处理移动事件的最短距离（mTouchSlop）了，注意dx和dy指的是当前触摸点到ACTION_DOWN触摸到的点的距离。这里先检查Callback的getViewHorizontalDragRange(child)和getViewVerticalDragRange(child)是否大于0，如果想让某个View在某个方向上滑动，就要在那个方向对应的方法里返回大于0的数。否则在processTouchEvent()的ACTION_MOVE部分就不会调用tryCaptureViewForDrag()来捕获当前触摸到的View了，拖动也就没办法进行了。</p><p>回到processTouchEvent()的ACTION_MOVE部分，假设现在我们的手指已经滑动到可以被捕获到的View上了，也都正常的实现了Callback中的相关方法，让tryCaptureViewForDrag()正常的捕获到触摸到的View了，下一次ACTION_MOVE时就执行if部分的代码了，也就是开始不停的调用dragTo()对mCaptureView进行真正拖动了，看dragTo()方法：</p><pre><code>private void dragTo(int left, int top, int dx, int dy) {    int clampedX = left;    int clampedY = top;    final int oldLeft = mCapturedView.getLeft();    final int oldTop = mCapturedView.getTop();    if (dx != 0) {        clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);        mCapturedView.offsetLeftAndRight(clampedX - oldLeft);    }    if (dy != 0) {        clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);        mCapturedView.offsetTopAndBottom(clampedY - oldTop);    }    if (dx != 0 || dy != 0) {        final int clampedDx = clampedX - oldLeft;        final int clampedDy = clampedY - oldTop;        mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,                clampedDx, clampedDy);    }}</code></pre><p>参数dx和dy是前后两次ACTION_MOVE移动的距离，left和top分别为mCapturedView.getLeft() + dx, mCapturedView.getTop() + dy，也就是期望的移动后的坐标，对View的getLeft()等方法不理解的请参阅<a href="http://www.cnblogs.com/zhengbeibei/archive/2013/05/07/3065999.html" target="_blank" rel="noopener">Android View坐标getLeft, getRight, getTop, getBottom</a>。</p><p>这里通过调用offsetLeftAndRight()和offsetTopAndBottom()来完成对mCapturedView移动，这两个是View中定义的方法，看它们的源码就知道内部是通过改变View的mLeft、mRight、mTop、mBottom，即改变View在父容器中的坐标位置，达到移动View的效果，所以如果调用mCapturedView的layout(int l, int t, int r, int b)方法也可以实现移动View的效果。</p><p>具体要移动到哪里，由Callback的clampViewPositionHorizontal()和clampViewPositionVertical()来决定的，如果不想在水平方向上移动，在clampViewPositionHorizontal(View child, int left, int dx)里直接返回child.getLeft()就可以了，这样clampedX - oldLeft的值为0，这里调用mCapturedView.offsetLeftAndRight(clampedX - oldLeft)就不会起作用了。垂直方向上同理。</p><p>最后会调用Callback的onViewPositionChanged(mCapturedView, clampedX, clampedY,clampedDx, clampedDy)通知捕获到的View位置改变了，并把最终的坐标（clampedX、clampedY）和最终的移动距离（clampedDx、 clampedDy）传递过去。</p><p>ACTION_MOVE部分就算告一段落了，接下来应该是用户松手触发ACTION_UP，或者是达到某个条件导致后续的ACTION_MOVE被mParentView的上层View给拦截了而收到ACTION_CANCEL，一起来看这两个部分：</p><pre><code>public void processTouchEvent(MotionEvent ev) {    // 省略    switch (action) {        // 省略其他case        case MotionEvent.ACTION_UP: {            if (mDragState == STATE_DRAGGING) {                releaseViewForPointerUp();            }            cancel();            break;        }        case MotionEvent.ACTION_CANCEL: {            if (mDragState == STATE_DRAGGING) {                dispatchViewReleased(0, 0);            }            cancel();            break;        }    }}</code></pre><p>这两个部分都是重置所有的状态记录，并通知View被放开了，再看下releaseViewForPointerUp()和dispatchViewReleased()的源码：</p><pre><code>private void releaseViewForPointerUp() {    mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity);    final float xvel = clampMag(            VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),            mMinVelocity, mMaxVelocity);    final float yvel = clampMag(            VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),            mMinVelocity, mMaxVelocity);    dispatchViewReleased(xvel, yvel);}</code></pre><p>releaseViewForPointerUp()里也调用了dispatchViewReleased()，只不过传递了速率给它，这个速率就是由processTouchEvent()的mVelocityTracker追踪算出来的。再看dispatchViewReleased()：</p><pre><code>/** * Like all callback events this must happen on the UI thread, but release * involves some extra semantics. During a release (mReleaseInProgress) * is the only time it is valid to call {@link #settleCapturedViewAt(int, int)} * or {@link #flingCapturedView(int, int, int, int)}. */private void dispatchViewReleased(float xvel, float yvel) {    mReleaseInProgress = true;    mCallback.onViewReleased(mCapturedView, xvel, yvel);    mReleaseInProgress = false;    if (mDragState == STATE_DRAGGING) {        // onViewReleased didn&#39;t call a method that would have changed this. Go idle.        setDragState(STATE_IDLE);    }}</code></pre><p>这里调用Callback的onViewReleased(mCapturedView, xvel, yvel)通知外部捕获到的View被释放了，而在onViewReleased()前后有个mReleaseInProgress值得注意，注释里说唯一可以调用ViewDragHelper的settleCapturedViewAt()和flingCapturedView()的地方就是在Callback的onViewReleased()里了。</p><p>首先这两个方法是干什么的呢。在现实生活中保龄球的打法是，先做扔的动作让球的速度达到最大，然后突然松手，由于惯性，保龄球就以最后松手前的速度为初速度抛出去了，直至自然停止，或者撞到边界停止，这种效果叫fling。<br>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)就是对捕获到的View做出这种fling的效果，用户在屏幕上滑动松手之前也会有一个滑动的速率。fling也引出来的一个问题，就是不知道View最终会滚动到哪个位置，最后位置是在启动fling时根据最后滑动的速度来计算的（flingCapturedView的四个参数int minLeft, int minTop, int maxLeft, int maxTop可以限定最终位置的范围），假如想要让View滚动到指定位置应该怎么办，答案就是使用settleCapturedViewAt(int finalLeft, int finalTop)。</p><p>为什么唯一可以调用settleCapturedViewAt()和flingCapturedView()的地方是Callback的onViewReleased()呢？看看它们的源码</p><pre><code>/** * Settle the captured view at the given (left, top) position. * The appropriate velocity from prior motion will be taken into account. * If this method returns true, the caller should invoke {@link #continueSettling(boolean)} * on each subsequent frame to continue the motion until it returns false. If this method * returns false there is no further work to do to complete the movement. * * @param finalLeft Settled left edge position for the captured view * @param finalTop Settled top edge position for the captured view * @return true if animation should continue through {@link #continueSettling(boolean)} calls */public boolean settleCapturedViewAt(int finalLeft, int finalTop) {    if (!mReleaseInProgress) {        throw new IllegalStateException(&quot;Cannot settleCapturedViewAt outside of a call to &quot; +                &quot;Callback#onViewReleased&quot;);    }    return forceSettleCapturedViewAt(finalLeft, finalTop,            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));}/** * Settle the captured view based on standard free-moving fling behavior. * The caller should invoke {@link #continueSettling(boolean)} on each subsequent frame * to continue the motion until it returns false. * * @param minLeft Minimum X position for the view&#39;s left edge * @param minTop Minimum Y position for the view&#39;s top edge * @param maxLeft Maximum X position for the view&#39;s left edge * @param maxTop Maximum Y position for the view&#39;s top edge */public void flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop) {    if (!mReleaseInProgress) {        throw new IllegalStateException(&quot;Cannot flingCapturedView outside of a call to &quot; +                &quot;Callback#onViewReleased&quot;);    }    mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),            (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),            (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),            minLeft, maxLeft, minTop, maxTop);    setDragState(STATE_SETTLING);}</code></pre><p>这两个方法里一开始都会判断mReleaseInProgress为false，如果为false就会抛一个IllegalStateException异常，而mReleaseInProgress唯一为true的时候就是在dispatchViewReleased()里调用onViewReleased()的时候。</p><p>Scroller的用法请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207" target="_blank" rel="noopener">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> ，或者自行解读Scroller源码，代码量不多。</p><p>ViewDragHelper还有一个移动View的方法是smoothSlideViewTo(View child, int finalLeft, int finalTop)，看下它的源码：</p><pre><code>/** * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position. * If this method returns true, the caller should invoke {@link #continueSettling(boolean)} * on each subsequent frame to continue the motion until it returns false. If this method * returns false there is no further work to do to complete the movement. * * &lt;p&gt;This operation does not count as a capture event, though {@link #getCapturedView()} * will still report the sliding view while the slide is in progress.&lt;/p&gt; * * @param child Child view to capture and animate * @param finalLeft Final left position of child * @param finalTop Final top position of child * @return true if animation should continue through {@link #continueSettling(boolean)} calls */public boolean smoothSlideViewTo(View child, int finalLeft, int finalTop) {    mCapturedView = child;    mActivePointerId = INVALID_POINTER;    boolean continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);    if (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != null) {        // If we&#39;re in an IDLE state to begin with and aren&#39;t moving anywhere, we        // end up having a non-null capturedView with an IDLE dragState        mCapturedView = null;    }    return continueSliding;}</code></pre><p>可以看到它不受mReleaseInProgress的限制，所以可以在任何地方调用，效果和settleCapturedViewAt()类似，因为它们最终都调用了forceSettleCapturedViewAt()来启动自动滚动，区别在于settleCapturedViewAt()会以最后松手前的滑动速率为初速度将View滚动到最终位置，而smoothSlideViewTo()滚动的初速度是0。forceSettleCapturedViewAt()里有地方调用了Callback里的方法，所以再来看看这个方法：</p><pre><code>/** * Settle the captured view at the given (left, top) position. * * @param finalLeft Target left position for the captured view * @param finalTop Target top position for the captured view * @param xvel Horizontal velocity * @param yvel Vertical velocity * @return true if animation should continue through {@link #continueSettling(boolean)} calls */private boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {    final int startLeft = mCapturedView.getLeft();    final int startTop = mCapturedView.getTop();    final int dx = finalLeft - startLeft;    final int dy = finalTop - startTop;    if (dx == 0 &amp;&amp; dy == 0) {        // Nothing to do. Send callbacks, be done.        mScroller.abortAnimation();        setDragState(STATE_IDLE);        return false;    }    final int duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);    mScroller.startScroll(startLeft, startTop, dx, dy, duration);    setDragState(STATE_SETTLING);    return true;}</code></pre><p>可以看到自动滑动是靠Scroll类完成，在这里生成了调用mScroller.startScroll()需要的参数。再来看看计算滚动时间的方法computeSettleDuration()：</p><pre><code>private int computeSettleDuration(View child, int dx, int dy, int xvel, int yvel) {    xvel = clampMag(xvel, (int) mMinVelocity, (int) mMaxVelocity);    yvel = clampMag(yvel, (int) mMinVelocity, (int) mMaxVelocity);    final int absDx = Math.abs(dx);    final int absDy = Math.abs(dy);    final int absXVel = Math.abs(xvel);    final int absYVel = Math.abs(yvel);    final int addedVel = absXVel + absYVel;    final int addedDistance = absDx + absDy;    final float xweight = xvel != 0 ? (float) absXVel / addedVel :            (float) absDx / addedDistance;    final float yweight = yvel != 0 ? (float) absYVel / addedVel :            (float) absDy / addedDistance;    int xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));    int yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));    return (int) (xduration * xweight + yduration * yweight);}</code></pre><p>clampMag()方法确保参数中给定的速率在正常范围之内。最终的滚动时间还要经过computeAxisDuration()算出来，通过它的参数可以看到最终的滚动时间是由dx、xvel、mCallback.getViewHorizontalDragRange()共同影响的。看computeAxisDuration()：</p><pre><code>private int computeAxisDuration(int delta, int velocity, int motionRange) {    if (delta == 0) {        return 0;    }    final int width = mParentView.getWidth();    final int halfWidth = width / 2;    final float distanceRatio = Math.min(1f, (float) Math.abs(delta) / width);    final float distance = halfWidth + halfWidth *            distanceInfluenceForSnapDuration(distanceRatio);    int duration;    velocity = Math.abs(velocity);    if (velocity &gt; 0) {        duration = 4 * Math.round(1000 * Math.abs(distance / velocity));    } else {        final float range = (float) Math.abs(delta) / motionRange;        duration = (int) ((range + 1) * BASE_SETTLE_DURATION);    }    return Math.min(duration, MAX_SETTLE_DURATION);}</code></pre><p>6~10行没看明白，直接看14~19行，如果给定的速率velocity不为0，就通过距离除以速率来算出时间；如果velocity为0，就通过要滑动的距离（delta）除以总的移动范围（motionRange，就是Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回值）来算出时间。最后还会对计算出的时间做过滤，最终时间反正是不会超过MAX_SETTLE_DURATION的，源码里的取值是600毫秒，所以不用担心在Callback里getViewHorizontalDragRange()、getViewVerticalDragRange()返回错误的数而导致自动滚动时间过长了。</p><p>在调用settleCapturedViewAt()、flingCapturedView()和smoothSlideViewTo()时，还需要实现mParentView的computeScroll()：</p><pre><code>@Overridepublic void computeScroll() {    if (mDragHelper.continueSettling(true)) {        ViewCompat.postInvalidateOnAnimation(this);    }}</code></pre><p>这属于Scroll类用法的范畴，不明白的请参阅<a href="http://blog.csdn.net/qinjuning/article/details/7419207" target="_blank" rel="noopener">Android中滑屏实现—-手把手教你如何实现触摸滑屏以及Scroller类详解</a> 的“知识点二： computeScroll(）方法介绍”。</p><p>至此，整个触摸流程和ViewDragHelper的重要的方法都过了一遍。之前在讨论shouldInterceptTouchEvent()的ACTION_DOWN部分执行完后应该再执行什么的时候，还有一种情况没有展开详解，就是有子View消费了本次ACTION_DOWN事件的情况，现在来看看这种情况。</p><p>假设现在shouldInterceptTouchEvent()的ACTION_DOWN部分执行完了，也有子View消费了这次的ACTION_DOWN事件，那么接下来就会调用mParentView的onInterceptTouchEvent()的ACTION_MOVE部分，不明白为什么的请参阅<a href="http://blog.csdn.net/xiaanming/article/details/21696315" target="_blank" rel="noopener">Andriod 从源码的角度详解View,ViewGroup的Touch事件的分发机制</a>，接着调用ViewDragHelper的shouldInterceptTouchEvent()的ACTION_MOVE部分：</p><pre><code>public boolean shouldInterceptTouchEvent(MotionEvent ev) {    // 省略...    switch (action) {        // 省略其他case...        case MotionEvent.ACTION_MOVE: {            // First to cross a touch slop over a draggable view wins. Also report edge drags.            final int pointerCount = MotionEventCompat.getPointerCount(ev);            for (int i = 0; i &lt; pointerCount; i++) {                final int pointerId = MotionEventCompat.getPointerId(ev, i);                final float x = MotionEventCompat.getX(ev, i);                final float y = MotionEventCompat.getY(ev, i);                final float dx = x - mInitialMotionX[pointerId];                final float dy = y - mInitialMotionY[pointerId];                final View toCapture = findTopChildUnder((int) x, (int) y);                final boolean pastSlop = toCapture != null &amp;&amp; checkTouchSlop(toCapture, dx, dy);                if (pastSlop) {                    // check the callback&#39;s                    // getView[Horizontal|Vertical]DragRange methods to know                    // if you can move at all along an axis, then see if it                    // would clamp to the same value. If you can&#39;t move at                    // all in every dimension with a nonzero range, bail.                    final int oldLeft = toCapture.getLeft();                    final int targetLeft = oldLeft + (int) dx;                    final int newLeft = mCallback.clampViewPositionHorizontal(toCapture,                            targetLeft, (int) dx);                    final int oldTop = toCapture.getTop();                    final int targetTop = oldTop + (int) dy;                    final int newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,                            (int) dy);                    final int horizontalDragRange = mCallback.getViewHorizontalDragRange(                            toCapture);                    final int verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);                    if ((horizontalDragRange == 0 || horizontalDragRange &gt; 0                            &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == 0                            || verticalDragRange &gt; 0 &amp;&amp; newTop == oldTop)) {                        break;                    }                }                reportNewEdgeDrags(dx, dy, pointerId);                if (mDragState == STATE_DRAGGING) {                    // Callback might have started an edge drag                    break;                }                if (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) {                    break;                }            }            saveLastMotion(ev);            break;        }        // 省略其他case...    }    return mDragState == STATE_DRAGGING;}</code></pre><p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个View。这里先用findTopChildUnder(int x, int y)寻找触摸点处的子View，再用checkTouchSlop(View child, float dx, float dy)检查当前触摸点到ACTION_DOWN触摸点的距离是否达到了mTouchSlop，达到了才会去捕获View。<br>接着看19~41行if (pastSlop){…}部分，这里检查在某个方向上是否可以进行拖动，检查过程涉及到getView[Horizontal|Vertical]DragRange和clampViewPosition[Horizontal|Vertical]四个方法。如果getView[Horizontal|Vertical]DragRange返回都是0，就会认作是不会产生拖动。clampViewPosition[Horizontal|Vertical]返回的是被捕获的View的最终位置，如果和原来的位置相同，说明我们没有期望它移动，也就会认作是不会产生拖动的。不会产生拖动就会在39行直接break，不会执行后续的代码，而后续代码里有调用tryCaptureViewForDrag()，所以不会产生拖动也就不会去捕获View了，拖动也不会进行了。<br>如果检查到可以在某个方向上进行拖动，就会调用后面的tryCaptureViewForDrag()捕获子View，如果捕获成功，mDragState就会变成STATE_DRAGGING，shouldInterceptTouchEvent()返回true，mParentView的onInterceptTouchEvent()返回true，后续的移动事件就会在mParentView的onTouchEvent()执行了，最后执行的就是mParentView的processTouchEvent()的ACTION_MOVE部分，拖动正常进行。</p><p>回头再看之前在shouldInterceptTouchEvent()的ACTION_DOWN部分留下的坑：</p><pre><code>public boolean shouldInterceptTouchEvent(MotionEvent ev) {    // 省略其他部分...    switch (action) {        // 省略其他case...        case MotionEvent.ACTION_DOWN: {            // 省略其他部分...            // Catch a settling view if possible.            if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) {                tryCaptureViewForDrag(toCapture, pointerId);            }            // 省略其他部分...        }        // 省略其他case...    }    return mDragState == STATE_DRAGGING;}</code></pre><p>现在应该明白这部分代码会在什么情况下执行了。当我们松手后捕获的View处于自动滚动的过程中时，用户再次触摸屏幕，就会执行这里的tryCaptureViewForDrag()尝试捕获View，如果捕获成功，mDragState就变为STATE_DRAGGING了，shouldInterceptTouchEvent()就返回true了，然后就是mParentView的onInterceptTouchEvent()返回true，接着执行mParentView的onTouchEvent()，再执行processTouchEvent()的ACTION_DOWN部分。此时（ACTION_DOWN事件发生时）mParentView的onTouchEvent()要返回true，onTouchEvent()才能继续接受到接下来的ACTION_MOVE、ACTION_UP等事件，否则无法完成拖动。</p><p>至此整个事件传递流程和ViewDragHelper的重要方法基本都解析完了，shouldInterceptTouchEvent()和processTouchEvent()的ACTION_POINTER_DOWN、ACTION_POINTER_UP部分就留给读者自己解析了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于整个触摸事件传递过程，我画了简要的流程图，方便日后快速回顾。</p><ul><li><a href="http://www.processon.com/view/link/5550a7bae4b09739f465ec64" target="_blank" rel="noopener">单点触摸，没有考虑边缘滑动检测的最简流程图</a></li><li><a href="http://www.processon.com/view/link/5550d3dce4b09739f46789bd" target="_blank" rel="noopener">单点触摸，考虑了边缘滑动检测的流程图</a></li></ul><p>多点触摸情况我就没研究了，在这里忽略~</p><p>三个开启自动滚动的方法：</p><ul><li>settleCapturedViewAt(int finalLeft, int finalTop)<br>以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在Callback的onViewReleased()中调用。</li><li>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)<br>以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在Callback的onViewReleased()中调用。</li><li>smoothSlideViewTo(View child, int finalLeft, int finalTop)<br>指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。</li></ul><p>Callback的各个方法总结：</p><ul><li><p>void onViewDragStateChanged(int state)</p><p>拖动状态改变时会调用此方法，状态state有STATE_IDLE、STATE_DRAGGING、STATE_SETTLING三种取值。</p><p>它在setDragState()里被调用，而setDragState()被调用的地方有</p><ul><li>tryCaptureViewForDrag()成功捕获到子View时<ul><li>shouldInterceptTouchEvent()的ACTION_DOWN部分捕获到</li><li>shouldInterceptTouchEvent()的ACTION_MOVE部分捕获到</li><li>processTouchEvent()的ACTION_MOVE部分捕获到</li></ul></li><li>调用settleCapturedViewAt()、smoothSlideViewTo()、flingCapturedView()时</li><li>拖动View松手时（processTouchEvent()的ACTION_UP、ACTION_CANCEL）</li><li>自动滚动停止时（continueSettling()里检测到滚动结束时）</li><li>外部调用abort()时</li></ul></li><li><p>void onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</p><p>正在被拖动的View或者自动滚动的View的位置改变时会调用此方法。</p><ul><li>在dragTo()里被调用（正在被拖动时）</li><li>在continueSettling()里被调用（自动滚动时）</li><li>外部调用abort()时被调用</li></ul></li><li><p>void onViewCaptured(View capturedChild, int activePointerId)</p><p>tryCaptureViewForDrag()成功捕获到子View时会调用此方法。</p><ul><li>在shouldInterceptTouchEvent()的ACTION_DOWN里成功捕获</li><li>在shouldInterceptTouchEvent()的ACTION_MOVE里成功捕获</li><li>在processTouchEvent()的ACTION_MOVE里成功捕获</li><li>手动调用captureChildView()</li></ul></li><li><p>void onViewReleased(View releasedChild, float xvel, float yvel)<br>拖动View松手时（processTouchEvent()的ACTION_UP）或被父View拦截事件时（processTouchEvent()的ACTION_CANCEL）会调用此方法。</p></li><li><p>void onEdgeTouched(int edgeFlags, int pointerId)<br>ACTION_DOWN或ACTION_POINTER_DOWN事件发生时如果触摸到监听的边缘会调用此方法。edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。</p></li><li><p>boolean onEdgeLock(int edgeFlags)<br>返回true表示锁定edgeFlags对应的边缘，锁定后的那些边缘就不会在onEdgeDragStarted()被通知了，默认返回false不锁定给定的边缘，edgeFlags的取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM其中之一。</p></li><li><p>void onEdgeDragStarted(int edgeFlags, int pointerId)<br>ACTION_MOVE事件发生时，检测到开始在某些边缘有拖动的手势，也没有锁定边缘，会调用此方法。edgeFlags取值为EDGE_LEFT、EDGE_TOP、EDGE_RIGHT、EDGE_BOTTOM的组合。可在此手动调用captureChildView()触发从边缘拖动子View的效果。</p></li><li><p>int getOrderedChildIndex(int index)<br>在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给tryCaptureViewForDrag()来尝试捕获。如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。</p></li><li><p>int getViewHorizontalDragRange(View child)、int getViewVerticalDragRange(View child)</p><p>返回给定的child在相应的方向上可以被拖动的最远距离，默认返回0。ACTION_DOWN发生时，若触摸点处的child消费了事件，并且想要在某个方向上可以被拖动，就要在对应方法里返回大于0的数。</p><p>被调用的地方有三处：</p><ul><li>在checkTouchSlop()中被调用，返回值大于0才会去检查mTouchSlop。在ACTION_MOVE里调用tryCaptureViewForDrag()之前会调用checkTouchSlop()。如果checkTouchSlop()失败，就不会去捕获View了。</li><li>如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上的range都是0（两个方法都返回0），就不会去捕获View了。</li><li>在调用smoothSlideViewTo()时被调用，用于计算自动滚动要滚动多长时间，这个时间计算出来后，如果超过最大值，最终时间就取最大值，所以不用担心在getView[Horizontal|Vertical]DragRange里返回了不合适的数导致计算的时间有问题，只要返回大于0的数就行了。</li></ul></li><li><p>boolean tryCaptureView(View child, int pointerId)</p><p>在tryCaptureViewForDrag()中被调用，返回true表示捕获给定的child。tryCaptureViewForDrag()被调用的地方有</p><ul><li>shouldInterceptTouchEvent()的ACTION_DOWN里</li><li>shouldInterceptTouchEvent()的ACTION_MOVE里</li><li>processTouchEvent()的ACTION_MOVE里</li></ul></li><li><p>int clampViewPositionHorizontal(View child, int left, int dx)、int clampViewPositionVertical(View child, int top, int dy)</p><p>child在某方向上被拖动时会调用对应方法，返回值是child移动过后的坐标位置，clampViewPositionHorizontal()返回child移动过后的left值，clampViewPositionVertical()返回child移动过后的top值。</p><p>两个方法被调用的地方有两处：</p><ul><li>在dragTo()中被调用，dragTo()在processTouchEvent()的ACTION_MOVE里被调用。用来获取被拖动的View要移动到的位置。</li><li>如果ACTION_DOWN发生时，触摸点处有子View消费事件，在shouldInterceptTouchEvent()的ACTION_MOVE里会被调用。如果两个方向上返回的还是原来的left和top值，就不会去捕获View了。</li></ul></li></ul><h3 id="案例参考"><a href="#案例参考" class="headerlink" title="案例参考"></a>案例参考</h3><p>在这里列举一部分对ViewDragHelper的应用案例，大家自己剖析它们的源码来实践巩固。</p><ol><li><a href="https://github.com/flavienlaurent/flavienlaurent.com" target="_blank" rel="noopener">YoutubeLayout</a>，这是最简单的Demo</li><li><a href="https://github.com/BlueMor/DragLayout" target="_blank" rel="noopener">QQ5.x侧滑菜单</a>、<a href="https://github.com/kyze8439690/ResideLayout" target="_blank" rel="noopener">ResideLayout</a></li><li><a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="noopener">SwipeBackLayout</a>、<a href="https://github.com/liuguangqiang/SwipeBack" target="_blank" rel="noopener">SwipeBack</a></li><li><a href="https://github.com/umano/AndroidSlidingUpPanel" target="_blank" rel="noopener">SlidingUpPanel</a></li><li><a href="https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/widget/DrawerLayout.java" target="_blank" rel="noopener">DrawerLayout</a></li></ol><h3 id="其他关于ViewDragHelper的分析文章"><a href="#其他关于ViewDragHelper的分析文章" class="headerlink" title="其他关于ViewDragHelper的分析文章"></a>其他关于ViewDragHelper的分析文章</h3><ul><li><a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper" target="_blank" rel="noopener">Each Navigation Drawer Hides a ViewDragHelper</a>，文中的源码就是上面的<a href="https://github.com/flavienlaurent/flavienlaurent.com" target="_blank" rel="noopener">YoutubeLayout</a></li><li><a href="http://blog.csdn.net/pi9nc/article/details/39583377" target="_blank" rel="noopener">ViewDragHelper详解</a>，这是上面文章的简略中文版</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lqstayreal/p/4500219.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这文章是转来的，写的实在是好，怕哪天失踪了……&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
      <category term="源码解析" scheme="http://joeljt.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>一个自定义 View 的小效果</title>
    <link href="http://joeljt.top/2019/04/15/custom-view-parallax/"/>
    <id>http://joeljt.top/2019/04/15/custom-view-parallax/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-15T09:24:13.834Z</updated>
    
    <content type="html"><![CDATA[<p>最近简单学了一个自定义 View 的小效果，本身代码并不算多，但是还是有些新东西，本着好记性不如烂笔头的想法，还是要记录下来备忘，说不上什么时候就会用到。</p><a id="more"></a><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>整体效果大概如图示：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190414212815.gif" alt=""></p><h3 id="知识点概况"><a href="#知识点概况" class="headerlink" title="知识点概况"></a>知识点概况</h3><p>涉及到的知识点其实就那么几个，主要还是思路和编码风格问题；相同的效果用布局摆放，再加上监听 ViewPager 滚动完全可以实现，不过就是扩展性太差，健壮性不太好，也不满足封装的要求，本次实现基本完全使用自定义 View 实现，也是个不错的思路。</p><p>需要注意的知识点如下：</p><ol><li>最初设计的时候就要考虑到封装，代码耦合性是不是足够低，扩展性是不是足够强；</li><li>自定义 View 的生命周期，因为你需要确定 onMeasure 方法何时执行完毕，从而在合适的位置进行参数的初始化工作，保证测量完成，所以需要的空间都可以取到宽高信息；</li><li>属性动画的基本使用；</li><li>Canvas#drawColor 设置背景色</li><li>Canvas#drawCircle 要注意圆心的位置是在屏幕的左上顶点，屏幕中心的位置需要自己确定；</li><li>绘制圆环需要正确确定圆环的半径，同时要考虑到与屏幕相切的位置问题；</li><li>如何拦截 View 的创建，并从中去解析自定义属性</li></ol><p>下面把整个自定义 View 拆解成几个部分来记录，大概也就是上面的知识点，也没什么好说的，都是熟能生巧的东西，practice makes perfect，没毛病。</p><h3 id="旋转效果"><a href="#旋转效果" class="headerlink" title="旋转效果"></a>旋转效果</h3><p>先来分析一下这个效果</p><ol><li>六个小圆均匀分布在大圆上，每个扇形的角度相同，也就是 60°；</li><li>整体围成一个大圆，不断旋转，大圆位于屏幕正中，直径为屏幕宽度的 1/2；</li><li>六个圆不停的变换位置，但总体位置未发生变化，从而展现出围着大圆旋转的效果；</li></ol><p>分析完毕后，我们首先要对诸如画笔颜色，屏幕宽高信息等进行初始化，这个工作只需要执行一次，我们选择在 onLayout 方法中完成，因为需要获取 View 测量后的宽高信息。</p><pre><code class="java">private void initParams(Context context) {    // 获取颜色列表    mColorArray = context.getResources().getIntArray(R.array.splash_circle_colors);    // 获取大圆、小圆的半径    mBigCircleRadius = getMeasuredWidth() / 4;    mSmallCircleRadius = mBigCircleRadius / 7;    // 初始化画笔    mPaint = new Paint();    mPaint.setDither(true);    mPaint.setAntiAlias(true);    // 获取屏幕中心位置的坐标    mCenterX = getMeasuredWidth() / 2;    mCenterY = getMeasuredHeight() / 2;}</code></pre><p>初始化工作完成后，半径有了，画笔也有了，现在需要确定的是每个小圆圆心的位置：</p><pre><code class="java">public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)</code></pre><p>大家都学过三角函数，很明显小圆的圆心在大圆圆周上，那么大圆的半径是已知的，每个扇形的角度也是已知的，根据三角函数很容易就能求出来每个小圆圆心向直径做垂线所得到的距离，这个距离又是相对于大圆圆心的距离，大圆圆心坐标已知，很显然就能求得每个小圆的坐标信息。</p><p>现在的问题是，怎么让这个小圆转起来？</p><p>这里我们的解决办法是，利用一个属性动画，从 0 变化到 2π，也就是整个圆周，在这个过程中，不断地去重绘 View，然后在 onDraw 中更新每个小圆当前的位置，通过重绘来实现不断滚动效果。</p><p>废话就不多说了，直接上代码了。</p><pre><code class="java">private void setRotateAnimation() {    mValueAnimator = ObjectAnimator.ofFloat(0, (float) Math.PI * 2);    mValueAnimator.setRepeatCount(-1);    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME);    mValueAnimator.setInterpolator(new LinearInterpolator());    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override        public void onAnimationUpdate(ValueAnimator animation) {            mRotatedAngle = (float) animation.getAnimatedValue();            invalidate();        }    });    mValueAnimator.start();}public void draw(Canvas canvas) {    // 先绘制整个背景为白色    canvas.drawColor(Color.WHITE);    // 得到每个扇形的弧度    double percentAngle = Math.PI * 2 / mColorArray.length;    for (int i = 0; i &lt; mColorArray.length; i++) {        mPaint.setColor(mColorArray[i]);        double currAngle = percentAngle * i + mRotatedAngle;        // x轴直角边 = 半径 * cos(角度)        float cx = mCenterX + (float) (mBigCircleRadius * Math.cos(currAngle));        // y轴直角边 = 半径 * sin(角度)        float cy = mCenterY + (float) (mBigCircleRadius * Math.sin(currAngle));        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);    }}</code></pre><p>整个旋转效果基本上就是这些内容，主要还是一个思路的问题，高中数学的内容，算数过关，代码问题不大。</p><h3 id="缩放效果"><a href="#缩放效果" class="headerlink" title="缩放效果"></a>缩放效果</h3><p>这个效果就更简单了，只是一个很简单的平移动画，怕的是把问题想复杂，比如纠结做出的先放大再缩小是怎么实现的，实际上<strong>那只是属性动画的一个差值器</strong>而已。</p><p>本质上这就是每个小圆都从圆周上平移到了圆心处，就是这么简单。只不过在它不是简单的缩放，而是不断的在更改大圆的半径，让整个大圆在慢慢变小。</p><pre><code class="java">private void setMergeAnimation() {    // 从大圆半径长变化到 0，记录变化的值，并将其作为各个小圆绘制位置的参考值    mValueAnimator = ObjectAnimator.ofFloat(mBigCircleRadius, 0);    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);    mValueAnimator.setInterpolator(new AnticipateInterpolator(5f));    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override        public void onAnimationUpdate(ValueAnimator animation) {            mCurrBigCircleRadius = (float) animation.getAnimatedValue();            invalidate();        }    });    mValueAnimator.start();}public void draw(Canvas canvas) {    canvas.drawColor(Color.WHITE);    double percentAngle = Math.PI * 2 / mColorArray.length;    for (int i = 0; i &lt; mColorArray.length; i++) {        mPaint.setColor(mColorArray[i]);        double currAngle = percentAngle * i + mRotatedAngle;        // 使用 mCurrBigCircleRadius 代替固定的 大圆半径，从而实现向中心靠拢的效果        float cx = mCenterX + (float) (mCurrBigCircleRadius * Math.cos(currAngle));        float cy = mCenterY + (float) (mCurrBigCircleRadius * Math.sin(currAngle));        canvas.drawCircle(cx, cy, mSmallCircleRadius, mPaint);    }}</code></pre><h3 id="水波纹效果"><a href="#水波纹效果" class="headerlink" title="水波纹效果"></a>水波纹效果</h3><p>其实水波纹也就是个视觉效果，本质上就是又画了个圆，只不过这个圆有点大，把整个屏幕都包含进去了，也就是说，整个屏幕本质上是这个圆的内切矩形，即屏幕的对角线是这个圆形的直径。</p><p>这里需要注意的是，这个画的并不是个普通的圆，而是一个圆环。具体如图。</p><pre><code class="java">private void setMergeAnimation() {      // mExtendRadius = (int) Math.sqrt(Math.pow(mCenterX, 2) + Math.pow(mCenterX, 2));    // mExtendRadius 屏幕对角线的一半，即圆的半径    mValueAnimator = ObjectAnimator.ofFloat(0, mExtendRadius);    mValueAnimator.setDuration(ROTATION_ANIMATION_TIME / 2);    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override        public void onAnimationUpdate(ValueAnimator animation) {            mCurrBigCircleRadius = (float) animation.getAnimatedValue();            invalidate();        }    });    mValueAnimator.start();}public void draw(Canvas canvas) {        // mCurrBigCircleRadius 不停变大的半径值      // mExtendRadius - mCurrBigCircleRadius -&gt; 圆环的宽度    float strokeWidth = mExtendRadius - mCurrBigCircleRadius;    mPaint.setStrokeWidth(strokeWidth);    mPaint.setStyle(Paint.Style.STROKE); // 设置圆环    mPaint.setColor(Color.WHITE);        // 圆环真正的半径    float radius = strokeWidth / 2 + mCurrBigCircleRadius;    canvas.drawCircle(mCenterX, mCenterY, radius, mPaint);}</code></pre><h3 id="ViewPager-滚动视差效果"><a href="#ViewPager-滚动视差效果" class="headerlink" title="ViewPager 滚动视差效果"></a>ViewPager 滚动视差效果</h3><p>动画结束，下面来简单介绍一下视差效果。个别控件可以跟随 ViewPager 滚动而变化，本来也可以直接监听 ViewPager 滚动，去遍历需要移动的控件来实现同样的效果，但是由于复用性、扩展性都比较差，这里使用自定义属性的方式来实现。<strong>这种方式的重点在于拦截系统 View 的创建，然后解析自定义的属性，从而实现想要的效果。</strong></p><ul><li>拦截View的创建</li></ul><p>需要使用 LayoutInflater 的 setFactory 方法，具体就不多做介绍了，不了解的自己去了解一下： <a href="https://blog.csdn.net/lmj623565791/article/details/51503977" target="_blank" rel="noopener">Android 探究 LayoutInflater setFactory</a></p><p>需要</p><ul><li><p>解析自定义属性</p><p>我们为系统控件扩展了自定义属性，在 attrs 中声明：</p><pre><code class="xml">&lt;resources&gt;    &lt;!-- X方向上的位移 --&gt;    &lt;attr name=&quot;translationXIn&quot; format=&quot;float&quot; /&gt;    &lt;attr name=&quot;translationXOut&quot; format=&quot;float&quot; /&gt;    &lt;!-- Y方向上的位移 --&gt;    &lt;attr name=&quot;translationYIn&quot; format=&quot;float&quot; /&gt;    &lt;attr name=&quot;translationYOut&quot; format=&quot;float&quot; /&gt;&lt;/resources&gt;</code></pre><p>然后我们拦截到系统的 View 后，尝试从中去解析这些自定义的 View；解析到对应的自定义属性后，通过给 View 设置 tag 的方式，将用户设置的信息进行保存：</p><pre><code class="xml">&lt;resources&gt;    &lt;item name=&quot;parallax_tag&quot; type=&quot;id&quot;/&gt;&lt;/resources&gt;</code></pre><pre><code class="java"> private int[] mParallaxAttrs = new int[]{            R.attr.translationXIn, R.attr.translationXOut,            R.attr.translationYIn, R.attr.translationYOut    };private void analysisAttrs(View view, Context context, AttributeSet attrs) {    TypedArray array = context.obtainStyledAttributes(attrs, mParallaxAttrs);    // 主动去解析自定义的几个属性，如果能够拿到，就去遍历解析    if (array != null &amp;&amp; array.getIndexCount() != 0) {        ParallaxTag parallaxTag = new ParallaxTag();        for (int i = 0; i &lt; array.getIndexCount(); i++) {            int arrayIndex = array.getIndex(i);            switch (arrayIndex) {                case 0:                    parallaxTag.setxIn(array.getFloat(arrayIndex, 0f));                    break;                case 1:                    parallaxTag.setxOut(array.getFloat(arrayIndex, 0f));                    break;                case 2:                    parallaxTag.setyIn(array.getFloat(arrayIndex, 0f));                    break;                case 3:                    parallaxTag.setyOut(array.getFloat(arrayIndex, 0f));                    break;            }            // 要紧的问题是，解析到了以后怎么存 -&gt; 给 View 设置 tag            view.setTag(R.id.parallax_tag, parallaxTag);            // 将准备操作的 View 放入集合中            mParallaxViews.add(view);        }        array.recycle();    }}</code></pre></li></ul><p>以上动作在 ViewPager 关联的 Fragment 中实现，这样只需要在 ViewPager 的滑动监听中去取到当前 Fragment 的 View 集合，然后分别为左右两侧的 Fragment 设置进入和划出效果即可。</p><pre><code class="java">addOnPageChangeListener(new OnPageChangeListener() {    @Override    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {        // 同时设置左右两侧的 fragment，左边退出，右边进入        ParallaxFragment outFragment = mFragments.get(position);        List&lt;View&gt; outFragmentParallaxViews = outFragment.getParallaxViews();        for (View view : outFragmentParallaxViews) {            ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);            view.setTranslationX(( -positionOffsetPixels) * parallaxTag.getxOut());            view.setTranslationY(( -positionOffsetPixels) * parallaxTag.getyOut());        }        try {            ParallaxFragment inFragment = mFragments.get(position + 1);            outFragmentParallaxViews = inFragment.getParallaxViews();            for (View view : outFragmentParallaxViews) {                ParallaxTag parallaxTag = (ParallaxTag) view.getTag(R.id.parallax_tag);                view.setTranslationX(                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getxIn());                view.setTranslationY(                  (getMeasuredWidth() - positionOffsetPixels) * parallaxTag.getyIn());            }        } catch (Exception e) {}    }    @Override    public void onPageSelected(int position) {    }    @Override    public void onPageScrollStateChanged(int state) {    }});</code></pre><p>好啦，说到这里就差不多结束了，完结撒花~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近简单学了一个自定义 View 的小效果，本身代码并不算多，但是还是有些新东西，本着好记性不如烂笔头的想法，还是要记录下来备忘，说不上什么时候就会用到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>MeasureSpec 那点事儿</title>
    <link href="http://joeljt.top/2019/04/10/Android-MeasureSpec/"/>
    <id>http://joeljt.top/2019/04/10/Android-MeasureSpec/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-04-10T11:54:51.189Z</updated>
    
    <content type="html"><![CDATA[<p>在自定义 View 的学习过程中，不管怎么样都绕不过 MeasureSpec  的学习；拖拖拉拉很久，在数不清的看了忘，忘了看之后，还是决定写篇博客记录一下，毕竟有效的输出才是检验输入的不二法门。</p><a id="more"></a><p>废话不多说，下面进入正题。</p><h3 id="MeasureSpec-定义"><a href="#MeasureSpec-定义" class="headerlink" title="MeasureSpec 定义"></a>MeasureSpec 定义</h3><p>关于 MeasureSpec 的定义，官方解释如下：</p><blockquote><p>A MeasureSpec encapsulates the layout requirements passed from parent to child. Each MeasureSpec represents a requirement for either the width or the height. </p></blockquote><p>大意就是，MeasureSpec 封装了父布局传递给子布局的布局要求，每个 MeasureSpec 由 <code>mode</code> 和 <code>size</code> 组成，包含了父布局对子布局相应的宽高要求。</p><p>MeasureSpec 有三种模式：UNSPECIFIED、EXACTLY、AT_MOST。</p><ul><li><p>UNSPECIFIED</p><p>父布局不对子布局做任何限制，它想多大就多大；一般自定义 View 中用不到；</p><blockquote><p>常见于系统内部控件，例如 ListView、ScrollView</p></blockquote></li><li><p>EXACTLY</p><p>父布局对子布局的宽高大小有明确的要求，不管子布局想要多大，它都不能超过父布局对它的限制；</p><blockquote><p>指定的大小如 100dp，或者 match_parent(实质上就是屏幕大小)，都是确切的尺寸</p></blockquote></li><li><p>AT_MOST</p><p>子布局想要多大就可以多大，但是一般来说不会超过父布局的尺寸；</p><blockquote><p>一般对应的父布局尺寸为 wrap_content，父布局无法确定子布局的尺寸</p></blockquote></li></ul><p>为了节约内存占用，MeasureSpec 本身就是一个 32 位的 int 值，这个类就是负责将 &lt;size, mode&gt; 的元组转换为 int 值，高 2 位表示 specMode，低 30 位表示 specSize。</p><p><strong>一个 View 的大小并不是由它自己确定的，而是由其自身的 LayoutParams 以及父布局的 MeasureSpec 确定的。</strong></p><p>那 MeasureSpec 是什么，最初的 MeasureSpec 又是哪里来的？</p><h3 id="MeasureSpec-缘起"><a href="#MeasureSpec-缘起" class="headerlink" title="MeasureSpec 缘起"></a>MeasureSpec 缘起</h3><p>由于 View 的绘制流程入口在 ViewRootImpl 类中，我们最终在 performTraversals 方法中找到如下代码：</p><pre><code class="java">    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);         int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);         // Ask host how big it wants to be         performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</code></pre><p>很明显在执行测量的最初，系统是通过 <code>getRootMeasureSpec</code> 方法获取到宽高的 MeasureSpec 信息的。</p><pre><code class="java">private static int getRootMeasureSpec(int windowSize, int rootDimension) {    int measureSpec;    switch (rootDimension) {        case ViewGroup.LayoutParams.MATCH_PARENT:            // Window can&#39;t resize. Force root view to be windowSize.            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);            break;        case ViewGroup.LayoutParams.WRAP_CONTENT:            // Window can resize. Set max size for root view.            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);            break;        default:            // Window wants to be an exact size. Force root view to be that size.            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);            break;    }    return measureSpec;}</code></pre><p>很明显，通过这个方法我们可以发现，在 View 测量的入口，specSize 是固定的 windowSize，而 MATCH_PARENT 对应的测量模式是 EXACTLY，WRAP_CONTENT 对应的测量模式是 AT_MOST。我们会发现，每个 MeasureSpec 都是通过 <code>MeasureSpec.makeMeasureSpec</code> 生成的。</p><p>SpecMode 和 SpecSize 组成了 MeasureSpec，MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象创建，并提供了对应的打包、解包方法：</p><pre><code class="java">public static int makeMeasureSpec(int size, int mode) {    if (sUseBrokenMakeMeasureSpec) {        // 二进制的 + ，不是十进制          // 使用一个32位的二进制数，其中：32和31位代表测量模式（mode）、后30位代表测量大小（size）        // 例如size=100(就是十进制的 4)，mode=AT_MOST，measureSpec=100+1000...00=1000..00100          return size + mode;    } else {        return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);    }}public static int getMode(int measureSpec) {      // MODE_MASK = 运算遮罩 = 11 00000000000(11后跟30个0)      // 原理：保留measureSpec的高2位（即测量模式）、使用0替换后30位    return (measureSpec &amp; MODE_MASK);}public static int getSize(int measureSpec) {    // 原理：同上，将 MASK 取反，得到 00 1111111111(00后跟30个1)     // 将 32,31 替换成 0 也就是去掉了 mode，只保留后30位的size    return (measureSpec &amp; ~MODE_MASK);}</code></pre><p>现在我们得到了 MeasureSpec，现在来看看父布局是怎么通过 MeasureSpec 支配子布局的。</p><p>以下代码截取自 LinearLayout 的 measureVertical 方法：</p><pre><code class="java">final LayoutParams lp = (LayoutParams) child.getLayoutParams();final int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(        Math.max(0, childWidth), MeasureSpec.EXACTLY);final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,        mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin,        lp.height);// 传到各个子 View 的 MeasureSpec 就是在这里生成的child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</code></pre><p>我们可以发现，由于是测量竖直方向的线性布局，布局的宽度是固定的，所以直接调用 MeasureSpec 生成宽度的规格，同时为其指定测量模式为 MeasureSpec.EXACTLY；高度因为比较复杂，调用了 <code>getChildMeasureSpec</code> 生成，传入了当前 LinearLayout 的父布局为其指定的 MeasureSpec 以及当前子 View 的 LayoutParams：</p><pre><code class="java">/** * ViewGroup#getChildMeasureSpec *  * @param spec 父布局的 MeasureSpec * @param padding 子布局的 margin+padding * @param childDimension 子布局的高度信息，lp.height * @return */public static int getChildMeasureSpec(int spec, int padding, int childDimension) {      // 获取父布局，也就是 LinearLayout 的测量模式以及测量大小    int specMode = MeasureSpec.getMode(spec);    int specSize = MeasureSpec.getSize(spec);      // 记录一下除去 padding 的测量大小，但是不一定会用，具体要看父布局的 mode 以及子布局自身的 size     int size = Math.max(0, specSize - padding);      // 当前 child 的 size 和 mode    int resultSize = 0;    int resultMode = 0;    // 判断一下父布局的测量规格，看看是 match 还是 wrap    switch (specMode) {        // 如果是 EXACTLY，说明父布局是有固定大小的，或者是定死的 100dp，或者是 match_parent 的屏幕宽度        case MeasureSpec.EXACTLY: // 值为 -2                // 在这种情况下，如果子布局的高度信息是有确定值的，那说明用户声明了固定的 100dp 等信息                 // 那就让子布局的宽高信息固定，同时设置测量模式同样为 EXACTLY            if (childDimension &gt;= 0) {                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {                // 如果子布局想要充满父布局，那就让它和父布局一样大，然后设置测量模式同样为 EXACTLY                resultSize = size;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {                // 子布局想自己决定自己的大小，但是它最大不能超过父布局，所以模式是 AT_MOST                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;        // 如果是 AT_MOST，说明父布局是包裹内容，那子布局不能超过父布局的大小        case MeasureSpec.AT_MOST:            if (childDimension &gt;= 0) {                // 全部同上                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {                  // 父布局都不知道自己的大小，只能告诉子布局最大不能超过自己，所以模式只能是 AT_MOST                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;        // 父布局不对子布局做任何限制，想多大多大，一般多见于ListView、GridView        case MeasureSpec.UNSPECIFIED:            if (childDimension &gt;= 0) {                // Child wants a specific size... let him have it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {                // Child wants to be our size... find out how big it should                // be                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;                resultMode = MeasureSpec.UNSPECIFIED;            } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size.... find out how                // big it should be                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;                resultMode = MeasureSpec.UNSPECIFIED;            }            break;    }    // 用父布局的 MeasureSpec 和 child 的 lp，为其生成自己的测量规格    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);}</code></pre><h3 id="做个小总结"><a href="#做个小总结" class="headerlink" title="做个小总结"></a>做个小总结</h3><p>说到这里，大家也应该能理解「一个 View 的大小是由它的父布局和它自身共同决定的」是什么意思了。</p><p>这里简单做个总结：</p><ol><li><p>MeasureSpec 的 UNSPECIFIED 测量模式一般见于系统内部，并不多见，不做过多讨论，目前已知的应用就是 ScrollView 嵌套 ListView 只能显示一行，就是由于 ScrollView 在测量子 View 的时候，向下传递的测量模式为 MeasureSpec.UNSPECIFIED ，同时 ListView 的 onMeasure 方法是这样的：</p><pre><code class="java">// 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + paddingif (heightMode == MeasureSpec.UNSPECIFIED) {       heightSize = mListPadding.top + mListPadding.bottom +              childHeight + getVerticalFadingEdgeLength() * 2;}</code></pre><p>这就导致了最终 ListView 的高度只有一行，感兴趣的可以看一下<a href="https://www.jianshu.com/p/061f734af3e9" target="_blank" rel="noopener">ScrollView 嵌套 ListView 的解决方法的原理</a>，这里就不再过多介绍了；</p></li><li><p><strong>当子 View 设置了固定值的时候，无论父布局的测量模式是什么，<em><u>子 View 的大小都遵循这个固定值，</u></em><u><em>即使超出屏幕</em></u>，且测量模式都为精确模式，即 MeasureSpec.EXACTLY</strong>；</p></li><li><p><strong>当子 View 为 match_parent 时，其 specMode 跟随父布局的 specMode</strong>，<em><u>父布局固定，那你充满父布局，你肯定也固定，就是 EXACTLY；父布局包裹内容，不能确定自己多大，那你肯定也不能知道自己多大，那就 AT_MOST</u></em>；<strong>其 specSize 也就是父布局的 size，不会超过父布局的大小；</strong></p></li><li><p><strong>当子 View 为 wrap_content 时，那它的 specMode 是 AT_MOST，specSize 就是父布局的 size，因为虽然其不能确定宽高，但是始终不能超过父布局的大小。</strong></p></li></ol><h3 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h3><p>一直贴代码，说理论多少有点枯燥，贴点图片，看看🌰</p><h4 id="父布局为-EXACTLY"><a href="#父布局为-EXACTLY" class="headerlink" title="父布局为 EXACTLY"></a>父布局为 EXACTLY</h4><ol><li><p>ViewGroup: match_parent, Child: 500dp x 500dp</p></li><li><p>ViewGroup: 300dp x 300dp, Child: 500dp x 500dp</p><blockquote><p>父布局测量规格是精确模式，测量大小是屏幕大小；</p><p>子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式</p></blockquote><pre><code class="java">// 布局如下&lt;com.ljt.rvanalysis.spec.MyLinearLayout    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;com.ljt.rvanalysis.spec.MyTextView        android:layout_width=&quot;300dp&quot;        android:layout_height=&quot;300dp&quot; /&gt;&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180646.png" alt=""></p></li><li><p>ViewGroup: match_parent, child: match_parent</p><blockquote><p>父布局、子布局均充满屏幕，测量模式都为 MeasureSpec.EXACTLY，测量大小均为屏幕大小</p></blockquote><pre><code class="JAVA">&lt;com.ljt.rvanalysis.spec.MyLinearLayout    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;com.ljt.rvanalysis.spec.MyTextView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180825.png" alt=""></p></li><li><p>ViewGroup: match_parent, child: wrap_content</p><blockquote><p>父布局充满屏幕，测量模式是精确模式，测量大小是屏幕大小；</p><p>子布局包裹内容，测量模式是 AT_MOST，但是不能超过父布局，测量大小为屏幕大小</p></blockquote><pre><code class="java">&lt;com.ljt.rvanalysis.spec.MyLinearLayout    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;com.ljt.rvanalysis.spec.MyTextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410180934.png" alt=""></p></li></ol><h4 id="父布局为-WRAP-CONTENT"><a href="#父布局为-WRAP-CONTENT" class="headerlink" title="父布局为 WRAP_CONTENT"></a>父布局为 WRAP_CONTENT</h4><ol><li><p>ViewGroup: wrap_content, child: match_parent</p><blockquote><p>父布局测量规格是 AT_MOST，测量大小是屏幕大小；</p><p>子布局测量规格 AT_MOST，但是无法超过父布局大小，测量大小也是屏幕大小；</p></blockquote><pre><code class="java">&lt;com.ljt.rvanalysis.spec.MyLinearLayout    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;com.ljt.rvanalysis.spec.MyTextView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181341.png" alt=""></p></li><li><p>ViewGroup: wrap_content, child: 300dp x 300dp</p><blockquote><p>父布局测量规格是 AT_MOST，测量大小是屏幕大小；</p><p>子 View 设置为固定值，忽视父布局的测量规格，大小就是设置的宽高，测量模式为精确模式</p></blockquote><pre><code class="java">&lt;com.ljt.rvanalysis.spec.MyLinearLayout    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;com.ljt.rvanalysis.spec.MyTextView        android:layout_width=&quot;300dp&quot;        android:layout_height=&quot;300dp&quot; /&gt;&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181429.png" alt=""></p></li><li><p>ViewGroup: wrap_content, child: wrap_content</p><blockquote><p>父布局测量规格是 AT_MOST，测量大小是屏幕大小；</p><p>子布局也不知道自己多大，测量规格是 AT_MOST，不能超过父布局，测量大小是屏幕大小；</p></blockquote><pre><code class="java">&lt;com.ljt.rvanalysis.spec.MyLinearLayout    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;com.ljt.rvanalysis.spec.MyTextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/com.ljt.rvanalysis.spec.MyLinearLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190410181519.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在自定义 View 的学习过程中，不管怎么样都绕不过 MeasureSpec  的学习；拖拖拉拉很久，在数不清的看了忘，忘了看之后，还是决定写篇博客记录一下，毕竟有效的输出才是检验输入的不二法门。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View.inflate() 的前世今生</title>
    <link href="http://joeljt.top/2019/03/29/View-inflate-analysis/"/>
    <id>http://joeljt.top/2019/03/29/View-inflate-analysis/</id>
    <published>2019-03-28T16:00:00.000Z</published>
    <updated>2019-03-29T08:47:59.124Z</updated>
    
    <content type="html"><![CDATA[<p>误用 LayoutInflater 的 inflate() 方法已经不是什么稀罕事儿了……</p><a id="more"></a><p>做 Android 开发做久了，一定会或多或少地对布局的渲染有一些懵逼：</p><blockquote><ol><li><code>View.inflate()</code> 和 <code>LayoutInflator.from().inflate()</code> 有啥区别？</li><li>调用 inflate() 方法的时候有时候传 null，有时候传 parent 是为啥？</li><li>用 LayoutInflater 有时候还可能传个 attachToRoot ，这又是个啥？</li></ol></blockquote><p>接下来我们就从源码的角度来寻找一下这几个问题的答案，后面再用几个示例来验证我们的猜想。</p><p>话不多说，Let’s go !</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>先来看一下这个方法具体做了什么：</p><pre><code class="java">/** * Inflate a view from an XML resource.  This convenience method wraps the {@link * LayoutInflater} class, which provides a full range of options for view inflation. */public static View inflate(Context context, int resource, ViewGroup root) {    LayoutInflater factory = LayoutInflater.from(context);    return factory.inflate(resource, root);}</code></pre><p>当我们查看源码，就会发现，这个方法的内部实际上就是调用了 <code>LayoutInflater</code> 的 inflate 方法。正如此方法的注释所言，这是一个方便开发者调用的 <code>LayoutInflater</code> 的包装方法，而 <code>LayoutInflater</code> 本身则为 View 的渲染提供了更多的选择。</p><p>那么我们现在的问题就变成了， <code>LayoutInflater</code> 又做了什么？</p><p>继续追踪代码，我们会发现， <code>LayoutInflator.from().inflate()</code>  是这个样子的：</p><pre><code class="java">// LayoutInflator#inflate(int, ViewGroup)public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {        return inflate(resource, root, root != null);}</code></pre><p>啥？重载？</p><pre><code class="java">// LayoutInflator#inflate(int, ViewGroup, boolean)public View inflate(int resource, ViewGroup root, boolean attachToRoot) {    final Resources res = getContext().getResources();    final XmlResourceParser parser = res.getLayout(resource);    try {        return inflate(parser, root, attachToRoot);    } finally {        parser.close();    }}</code></pre><p>这里我们看到，通过层层调用，最终会调用到 <code>LayoutInflator#inflate(int, ViewGroup, boolean)</code> 方法，很明显，这个方法会将我们传入的布局 id 转换为 XmlResourceParser，然后进行另一次，也是最后一次重载。</p><p>这个方法就厉害了，这里基本上包括了我们所有问题的答案，我们继续往下看。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>话不多说，上代码。接下来我们来逐段分析下这个 <code>inflate</code> 方法：</p><pre><code class="java">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {    final Context inflaterContext = mContext;    final AttributeSet attrs = Xml.asAttributeSet(parser);    // 默认返回结果为传入的根布局    View result = root;    // 通过 createViewFromTag() 方法找到传入的 layoutId 的根布局，并赋值给 temp    final View temp = createViewFromTag(root, name, inflaterContext, attrs);    ViewGroup.LayoutParams params = null;    // 如果传入的父布局不为空    if (root != null) {        // 为这个 root 生成一套合适的 LayoutParams        params = root.generateLayoutParams(attrs);        if (!attachToRoot) {            // 如果没有 attachToRoot，那为根布局设置 layoutparams            temp.setLayoutParams(params);        }    }    // 如果传入的父布局不为空，且想要 attachToRoot    if (root != null &amp;&amp; attachToRoot) {        // 那就将传入的布局以及 layoutparams 通过 addView 方法添加到父布局中         root.addView(temp, params);    }    // 如果传入的根布局为空，或者不想 attachToRoot，则返回要加载的 layoutId    if (root == null || !attachToRoot) {        result = temp;    }    return result;}</code></pre><p>代码也分析完了，我再来总结一下：</p><ul><li><p><code>View#inflate</code> 只是个简易的包装方法，实际上还是调用的 <code>LayoutInflater#inflate</code> ;</p></li><li><p><code>LayoutInflater#inflate</code> 由于可以自己选择 root 和 attachToRoot 的搭配（后面有解释），使用起来更加灵活；</p></li><li><p>实际上的区别只是在于 <code>root</code> 是否传空，以及 <code>attachToRoot</code> 真假与否；</p></li><li><p>当  <code>root</code> 传空时，会直接返回要加载的 <code>layoutId</code>，返回的 View 没有父布局且没有 LayoutParams；</p></li><li><p>当  <code>root</code> 不传空时，又分为 <code>attachToRoot</code> 为真或者为假：</p><ul><li><p><code>attachToRoot = true</code> </p><p>会为传入的 <code>layoutId</code> 直接设置参数，并将其添加到 <code>root</code> 中，然后将传入的 <code>root</code> 返回；</p></li><li><p><code>attachToRoot = false</code> </p><p>会为传入的 <code>layoutId</code> 设置参数，但是不会添加到 <code>root</code> ，然后返回 <code>layoutId</code> 对应的 View；</p><blockquote><p>这里需要注意的是，虽然不马上将 View 添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null；因为子 View 的 LayoutParams 需要由 parent 来确定；否则会在手动 addView 时调用 <code>generateDefaultLayoutParams()</code> 为子 View 生成一个宽高都为包裹内容的 LayoutParams，而这并不一定是我们想要的。</p></blockquote></li></ul></li></ul><h3 id="测试-amp-检验"><a href="#测试-amp-检验" class="headerlink" title="测试 &amp; 检验"></a>测试 &amp; 检验</h3><p>单说起来可能有些抽象，下面使用代码来进行具体的测试与检验。</p><h4 id="View-inflate-context-layoutId-null"><a href="#View-inflate-context-layoutId-null" class="headerlink" title="View.inflate(context, layoutId, null)"></a>View.inflate(context, layoutId, null)</h4><p>如之前所说，这实际上调用的是 <code>getLayoutInflater().inflate(layoutId, null)</code> ，结合之前的源码来看：</p><pre><code class="java">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {    View result = root;    final View temp = createViewFromTag(root, name, inflaterContext, attrs);    if (root == null || !attachToRoot) {        result = temp;    }    return result;}</code></pre><p>很明显，传入的 <code>root</code> 为空，则会直接将加载好的 xml 布局返回，而这种情况下返回的这个 View 没有参数，也没有父布局。</p><pre><code class="java">protected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.layout_test);    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, null);    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());}</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329145224.jpg" alt=""></p><p>如图所示，正如我们想的，root 传 null 时，参数以及父布局返回结果均为 null。</p><h4 id="View-inflate-context-layoutId-mParent"><a href="#View-inflate-context-layoutId-mParent" class="headerlink" title="View.inflate(context, layoutId, mParent)"></a>View.inflate(context, layoutId, mParent)</h4><p>按之前分析过的，此方法实际调用的是 <code>getLayoutInflater().inflate(layoutId, root, true)</code> ，再来看源码：</p><pre><code class="java">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {    final Context inflaterContext = mContext;    final AttributeSet attrs = Xml.asAttributeSet(parser);    View result = root;     final View temp = createViewFromTag(root, name, inflaterContext, attrs);    ViewGroup.LayoutParams params = null;    if (root != null) {        params = root.generateLayoutParams(attrs);    }    if (root != null &amp;&amp; attachToRoot) {        root.addView(temp, params);    }    return result;}</code></pre><p>如源码所示，返回的 result 会在最开始就被赋值为入参的 root，root 不为空，同时 attachToRoot 为 true，就会将加载好的布局直接通过 addView 方法添加到 root 布局中，然后将 root 返回。</p><pre><code class="java">protected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.layout_test);    LinearLayout mParent = findViewById(R.id.ll_root);    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, mParent);    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());    Log.e(&quot;Test&quot;, &quot;inflateView -&gt; &quot; + inflateView);}</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329153240.jpg" alt=""></p><p>如图示，返回的 View 正是我们传入的 mParent，对应的 id 是 ll_root，参数也不再为空。</p><p>####getLayoutInflater().inflate(layoutId, root, false) </p><p>也许会有人问了，现在要么是 root 传空，返回 layoutId 对应的布局；要么是 root 不传空，返回传入的 root 布局。那我要是想 root 不传空，但是还是返回 layoutId 对应的布局呢？</p><p>这就是 <code>View#inflate</code> 的局限了，由于它是包装方法，因此 <code>attachToRoot</code> 并不能因需定制。这时候我们完全可以自己调用 <code>getLayoutInflater().inflate(layoutId, root, false)</code> 方法，手动的将第三个参数传为 false，同时为这个方法传入目标根布局。这样，我们就可以得到一个有 LayoutParams，但是没有 <code>parentView</code> 的 <code>layoutId</code> 布局了。</p><pre><code class="java">protected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.layout_test);    LinearLayout mParent = findViewById(R.id.ll_root);    View inflateView = getLayoutInflater().inflate(R.layout.main, mParent, false);    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());}</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329155230.jpg" alt=""></p><p>与我们分析的一致，有参数，但是没有父布局，且返回的就是我们加载的布局 id。我们在之后可以通过 addView 方法手动将这个布局加入父布局中。</p><p><strong>这里还有个要注意的点</strong>，那就是 <code>params = root.generateLayoutParams(attrs);</code> 这句代码，我们会发现，为 <code>layoutId</code> 设置的 params 参数，实际上是通过 root 来生成的。这也就告诉我们，虽然不马上添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null，因为子 View 的 LayoutParams 需要由 parent 来确定；当然，传入 null 也不会有问题，因为在执行 <code>addView()</code> 方法的时候，如果当前 childView 没有参数，会调用 <code>generateDefaultLayoutParams()</code> 生成一个宽高都包裹的 LayoutParams 赋值给 childView，而这并不一定是我们想要的。</p><h4 id="attachToRoot-必须为-false！"><a href="#attachToRoot-必须为-false！" class="headerlink" title="attachToRoot 必须为 false！"></a>attachToRoot 必须为 false！</h4><p>代码写多了，大家有时候会发现这个 <code>attachToRoot</code> 也不是想怎样就怎样的，有时候它还就必须是 false，不能为 true。下面我们就来看看这些情况。</p><ul><li><p>RecylerView#onCreateViewHolder()</p><p>在为 RecyclerView 创建 ViewHolder 时，由于 View 复用的问题，是 RecyclerView 来决定什么时候展示它的子View，这个完全不由我们决定，这种情况下，attachToRoot 必须为 false：</p><pre><code class="java">public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {          LayoutInflater inflater = LayoutInflater.from(getActivity());          View view = inflater.inflate(R.layout.item, parent, false);          return new ViewHolder(view);  }</code></pre></li><li><p>Fragment#onCreateView()</p><p>由于 Fragment 需要依赖于 Activity 展示，一般在 Activity 中也会有容器布局来盛放 Fragment：</p><pre><code class="java">Fragment fragment = new Fragment();getSupportFragmentManager()        .beginTransaction()        .add(R.id.root_container, fragment)        .commit(); </code></pre><p>上述代码中的 <code>R.id.root_container</code> 便为容器，这个 View 会作为参数传递给 <code>Fragment#onCreateView()</code> :</p><pre><code class="java">public View onCreateView(LayoutInflater inflater, ViewGroup container,                          Bundle savedInstanceState) {    return inflater.inflate(R.layout.fragment_layout, parentViewGroup, false); }</code></pre><p>它也是你在 inflate() 方法中传入的 ViewGroup，FragmentManager 会将 Fragment 的 View 添加到 ViewGroup 中，言外之意就是，Fragment 对应的布局展示或者说添加进 ViewGroup 时也不是我们来控制的，而是 FragmentManager 来控制的。</p></li></ul><p>总结一下就是，<strong>当我们不为子 View 的展示负责时，attachToRoot 必须为 false；否则就会出现对应的负责人，比如上面说的 Rv 或者 FragmentManager，已经把布局 id 添加到 ViewGroup 了，我们还继续设置 attachToRoot 为 true，想要手动 addView，那必然会发生 child already has parent 的错误。</strong></p><p>以上。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://juejin.im/entry/5a1513abf265da43052e4473" target="_blank" rel="noopener">深入理解LayoutInflater.inflate()</a></li><li><a href="https://www.jianshu.com/p/cdc9d4c0826e" target="_blank" rel="noopener">LayoutInflater.inflate和View.inflate</a></li><li><a href="">Android API 28 View.java / LayoutInflater.java / ViewGroup.java</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;误用 LayoutInflater 的 inflate() 方法已经不是什么稀罕事儿了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ConstraintLayout 介绍</title>
    <link href="http://joeljt.top/2019/03/22/ConstraintLayout-learning/"/>
    <id>http://joeljt.top/2019/03/22/ConstraintLayout-learning/</id>
    <published>2019-03-21T16:00:00.000Z</published>
    <updated>2019-03-22T10:51:31.927Z</updated>
    
    <content type="html"><![CDATA[<p>不知道从什么时候开始，Android 死丢丢已经默认使用约束布局 ConstraintLayout 作为默认布局了，但是懒癌发作一直不想学习，每次都换成 LinearLayout，这次也忘记了为啥开始学习这个东西，学完发现还挺爽……写个笔记记录一下，哈哈</p><a id="more"></a><p>正文开始~</p><h4 id="相对布局"><a href="#相对布局" class="headerlink" title="相对布局"></a>相对布局</h4><h5 id="属性集合"><a href="#属性集合" class="headerlink" title="属性集合"></a>属性集合</h5><p>类似 RelativeLayout ，使用相对位置的属性来互相约束位置。具体的属性以及使用方式也类似 RelativeLayout，默认像 FrameLayout 一样堆叠在一起，使用属性讲层级关系区分开：</p><pre><code class="xml">layout_constraintLeft_toLeftOf   当前控件的左侧与某个控件的左侧对齐layout_constraintLeft_toRightOf  当前控件的左侧与某个控件的右侧对齐layout_constraintRight_toLeftOf  当前控件的右侧与某个控件的左侧对齐layout_constraintRight_toRightOf 当前控件的右侧与某个控件的右侧对齐layout_constraintStart_toEndOf   同上layout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOflayout_constraintTop_toTopOf       当前控件与某个控件顶端对齐layout_constraintTop_toBottomOf    即当前控件某个控件的下面layout_constraintBottom_toTopOf    即当前控件在某个控件的上面layout_constraintBottom_toBottomOf 当前控件与某个控件底部对齐layout_constraintBaseline_toBaselineOf 文本基线对齐</code></pre><h5 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h5><pre><code class="xml">&lt;!-- 居中对齐实现方式 --&gt;&lt;!-- 上下左右全部受 parent 约束，最后的效果就是「居中对齐」 --&gt;&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;居中对齐&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;&lt;!-- 同理，左右受 parent 约束，效果就是「水平居中对齐」--&gt;&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;水平居中对齐&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;&lt;!-- 同理，上下受 parent 约束，效果就是「垂直居中对齐」--&gt;&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;垂直居中对齐&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&gt;</code></pre><p>居中对齐很好理解，下边我们来写一个正常的 item 布局看看：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322142136.png" alt="ConstraintLayout 实现的 item 布局"></p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:padding=&quot;5dp&quot;&gt;    &lt;ImageView        android:id=&quot;@+id/iv_logo&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;@mipmap/ic_launcher&quot; /&gt;    &lt;!-- 设置标题名称 View 的左侧边缘位于 logo 的右侧 --&gt;    &lt;TextView        android:id=&quot;@+id/tv_title&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_marginLeft=&quot;10dp&quot;        android:text=&quot;虾吃虾涮（华贸店）&quot;        app:layout_constraintLeft_toRightOf=&quot;@+id/iv_logo&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;    &lt;!-- 设置价格 View 的底部靠近父布局，且顶部参考 titleView，同时左侧与 titleView 对齐 --&gt;    &lt;TextView        android:id=&quot;@+id/tv_price&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;￥64/人&quot;        android:textSize=&quot;13sp&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintLeft_toLeftOf=&quot;@id/tv_title&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_title&quot; /&gt;    &lt;!-- 设置 distanceView 紧贴屏幕右侧，且顶部与 priceView 对齐--&gt;    &lt;TextView        android:id=&quot;@+id/tv_distance&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;1.1km&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;@id/tv_price&quot; /&gt;    &lt;!-- 设置 areaView 顶部与左侧都参考 priceView，底部位置参考 ivLogo--&gt;    &lt;TextView        android:id=&quot;@+id/tv_area&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;朝阳区 大望路&quot;        android:textSize=&quot;13sp&quot;        app:layout_constraintBottom_toBottomOf=&quot;@id/iv_logo&quot;        app:layout_constraintLeft_toLeftOf=&quot;@id/tv_price&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_price&quot; /&gt;    &lt;!-- 设置 hotView 紧贴屏幕右侧，且顶部与 areaView 顶部对齐--&gt;    &lt;TextView        android:id=&quot;@+id/tv_curr_hot&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;当前人气89&quot;        android:textSize=&quot;13sp&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;@id/tv_area&quot; /&gt;    &lt;!-- dividerView 位于整个布局的最底部，且始终位于 ivLogo 底部，并保持一定距离 --&gt;    &lt;View        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;1px&quot;        android:layout_marginTop=&quot;7dp&quot;        android:background=&quot;@android:color/darker_gray&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/iv_logo&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>可以发现使用约束布局实现比普通的 RL 实现还要简单，界面完全实现扁平化，没有任何嵌套。如果使用 LL 或者 RL 来实现同样的效果，代码要复杂多少想必不用我多说。</p><h4 id="Bias-偏向"><a href="#Bias-偏向" class="headerlink" title="Bias 偏向"></a>Bias 偏向</h4><p>以上的内容就是基本使用了，把上下左右各种参考、依赖关系搞明白，本身没有多么复杂，使用起来也和 RL 差不多，下面来介绍一些新花样。</p><p><code>bias</code> 很好理解，正如其英文本意一样，它表达的是<strong>偏移</strong>。当某一布局同时受两个相反方向的约束力时，该布局就会处于约束它的那两个力量的正中央。而 <code>layout_constraintHorizontal_bias</code> 与 <code>layout_constraintVertical_bias</code> 就是用在这种时候，用来将某一方向的约束力减弱。来自两侧的约束力可以为 parent，也可以是普通 View。</p><p>文字描述可能有点抽象，具体布局文件还是更好理解一些：</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout     android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tv1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;this is a text&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;this is a text&quot;        app:layout_constraintHorizontal_bias=&quot;0.3&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/tv1&quot;        app:layout_constraintRight_toLeftOf=&quot;@id/tv3&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;this is a text&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>布局很简单，三个 TextView 并排显示，左右两个分别紧贴父布局，中间一个受左右两侧布局约束，本来应该是位于两个 TextView 正中央，但是由于设置了 <code>layout_constraintHorizontal_bias</code> 小于 0.5，所以最后效果中间的 TextView 整体偏向左侧，展示如下图：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322145701.jpg" alt=""></p><h4 id="Circle-布局"><a href="#Circle-布局" class="headerlink" title="Circle 布局"></a>Circle 布局</h4><p>这个看上去很厉害的！可以令 B 布局以 A 布局为圆心，然后用角度和半径距离来约束两个布局的位置。废话不多说，上图：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322153304.jpg" alt="">这个也很好理解，主要有三个属性：</p><pre><code>layout_constraintCircle ：      当前布局以哪个布局为圆心layout_constraintCircleRadius ：半径layout_constraintCircleAngle ： 摆放角度</code></pre><p>我反正是给谷歌跪了……</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tv_center&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        android:text=&quot;Circle Center&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;    &lt;!-- 「测试布局」以 tv_center 为圆心，位于其 135° 方向的 100dp 处 --&gt;    &lt;TextView        android:text=&quot;测试布局&quot;        app:layout_constraintCircle=&quot;@id/tv_center&quot;        app:layout_constraintCircleAngle=&quot;135&quot;        app:layout_constraintCircleRadius=&quot;100dp&quot;        android:textColor=&quot;@android:color/black&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><h4 id="替代-MATCH-PARENT-的-MATCH-CONSTRAINT"><a href="#替代-MATCH-PARENT-的-MATCH-CONSTRAINT" class="headerlink" title="替代 MATCH_PARENT 的 MATCH_CONSTRAINT"></a>替代 MATCH_PARENT 的 MATCH_CONSTRAINT</h4><p>在约束布局中，由于布局受各方约束控制，也就没有所谓的「match_parent」了。随之而来的需求则是，左边有个布局约束我，右边还有个布局约束我，然后我就想充满剩余的全部位置，「match_constraint」也就应运而生了。</p><p>说起来复杂，其实只需要把对应的 View 宽高设置为 0dp 即可，该 View 就会占据上剩余的所有可用空间。在这种情况下，谷歌给我们提供了几个额外的属性：</p><pre><code>layout_constraintWidth_min   宽度最小值layout_constraintHeight_min  高度最小值layout_constraintWidth_max   宽度最大值layout_constraintHeight_max  高度最大值layout_constraintWidth_percent   宽度占剩余位置的百分比layout_constraintHeight_percent  高度占剩余位置的百分比</code></pre><p>具体示例如下：</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button        android:id=&quot;@+id/btn1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Test Button&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt;    &lt;Button        android:id=&quot;@+id/btn2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;    &lt;Button        android:id=&quot;@+id/btn3&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constrainedWidth=&quot;true&quot;        android:text=&quot;Button&quot;        app:layout_constraintWidth_min=&quot;wrap&quot;        app:layout_constraintWidth_max=&quot;wrap&quot;        app:layout_constraintWidth_percent=&quot;0.3&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/btn1&quot;        app:layout_constraintRight_toLeftOf=&quot;@id/btn2&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322163826.jpg" alt=""></p><h4 id="Chains-链"><a href="#Chains-链" class="headerlink" title="Chains 链"></a>Chains 链</h4><p>如果几个不同的 View 两两发生关联，如下图，则这几个 View 构成了一个 Chains(链)。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322170158.jpg" alt=""></p><p>具体布局代码如下：</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button        android:id=&quot;@+id/btn1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;        app:layout_constraintRight_toLeftOf=&quot;@id/btn2&quot; /&gt;    &lt;Button        android:id=&quot;@+id/btn2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/btn1&quot;        app:layout_constraintRight_toLeftOf=&quot;@id/btn3&quot; /&gt;    &lt;Button        android:id=&quot;@+id/btn3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/btn2&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>这样这三个 Button 就形成了一个横向的 Chain，在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果：</p><p>该属性为：</p><pre><code>layout_constraintHorizontal_chainStylelayout_constraintVertical_chainStyle</code></pre><p>其取值可以为：spread、spread_inside、packed。</p><p>具体样式展示如下：</p><ol><li>spread，基本上就是按照权重等分</li></ol><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171443.jpg" alt=""></p><ol><li><p>spread_inside，也是等分展示，但是两侧吸附</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171444.jpg" alt=""></p></li><li><p>packed，整条链挤在一起，居中展示</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171442.jpg" alt=""></p></li></ol><p>官网有一个图来展示不同样式的 Chains，可以参考一下，也很形象：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322172439.jpg" alt=""></p><h4 id="虚拟辅助视图"><a href="#虚拟辅助视图" class="headerlink" title="虚拟辅助视图"></a>虚拟辅助视图</h4><p>与以往的 ViewGroup 不同，ConstraintLayout 还提供了几种辅助页面绘制的布局，这种布局一般表现为引导线之类，不会在页面上绘制，但是可以通过占位的方式，成为不同布局的约束条件。</p><h5 id="GuideLine"><a href="#GuideLine" class="headerlink" title="GuideLine"></a>GuideLine</h5><p>顾名思义，GuideLine 可以创建基于父布局 ConstraintLayout 的水平或者垂直准线，从而帮助开发者进行布局定位。</p><p>这个布局有四个基本属性，依次为：</p><pre><code class="xml">orientation 如上所述，用来表示是垂直方向还是竖直方向layout_constraintGuide_begin 距离父亲的起始位置layout_constraintGuide_end 距离父亲的结束位置layout_constraintGuide_percent 距离父亲的位置，用百分比表示经过试验，percent 优先级最高，其次是 begin，最后是 end，一般来讲使用 percent 就足够了</code></pre><p>xml 以及对应的页面效果如下：</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout                    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;!-- 假设说现在需要将 ImageView 摆放到右下角的位置，就可以使用 GL 辅助实现--&gt;    &lt;android.support.constraint.Guideline        android:id=&quot;@+id/gl_vertical&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;vertical&quot;        app:layout_constraintGuide_percent=&quot;0.8&quot;/&gt;    &lt;android.support.constraint.Guideline        android:id=&quot;@+id/gl_horizontal&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;0dp&quot;        android:orientation=&quot;horizontal&quot;        app:layout_constraintGuide_percent=&quot;0.8&quot; /&gt;    &lt;ImageView        android:src=&quot;@mipmap/ic_launcher&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/gl_vertical&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/gl_horizontal&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322174954.jpg" alt=""></p><h5 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h5><p>与 GuideLine 差不多，但是比它更灵活，可以用来约束多个布局，且自动匹配最大最小值进行约束。</p><p>Barrier 有两个基本属性：</p><ul><li><p>barrierDirection</p><blockquote><p> 取值可为 top, bottom, left, right, start, end</p></blockquote><p>用于约定栅栏拦截的 View 方向，假设说要拦截的 View 在右侧，这个属性就应该为 right 或者 end</p></li><li><p>constraint_referenced_ids</p><p>被栅栏保护，屏蔽起来的 View 集合，直接输入 viewId，用逗号分隔即可；barrier 会根据宽度或者高度最大的那个 View 来设置栅栏的边界</p></li></ul><p>可能会有些抽象，我们在开发时可能会遇到一种比较蛋疼的需求：</p><blockquote><p>姓名、性别、出生日期、手机号等字段从上到下一字排开，但是每个字段对应的值要保证彼此左侧对齐</p></blockquote><p>讲道理以前这种布局我一直不知道怎么画，但是现在有了 <code>barrier</code> 以后这问题就迎刃而解了。我们可以用 barrier 将左侧的那些字段与右侧的值拦截开，barrier 会自动识别最宽的那个字段，并将之作为 barrier 的宽度，之后每个值都用 barrier 来制造约束就可以了。</p><pre><code class="XML">&lt;android.support.constraint.ConstraintLayout     android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:padding=&quot;10dp&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tv_name&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;姓名:&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/tv_gender&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_name&quot;        android:text=&quot;性别:&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/tv_phone&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_gender&quot;        android:text=&quot;手机号:&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/tv_birthday&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_phone&quot;        android:text=&quot;出生日期:&quot;/&gt;    &lt;android.support.constraint.Barrier        android:id=&quot;@+id/barrier&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:barrierDirection=&quot;end&quot;        app:constraint_referenced_ids=&quot;tv_name,tv_phone,tv_gender,tv_birthday&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;        android:text=&quot;易烊千玺&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_name&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;        android:text=&quot;男&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_gender&quot;        android:text=&quot;13800138000&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_phone&quot;        android:text=&quot;2000年1月1日&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>显示效果如图，很完美有没有？</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322182306.jpg" alt=""></p><h5 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h5><p>Group 是一个组，用来批量控制 View 的显示与隐藏；但是注意这不是个 ViewGroup，它只是一个不执行绘制的 View，和 barrier 一样，它有一个 constraint_referenced_ids 的属性，可以将需要隐藏的 ViewId 丢进去，在需要的时候将其批量隐藏即可。</p><p>还通过上面的例子，假设现在要把性别一栏隐藏掉：</p><pre><code class="xml">&lt;android.support.constraint.Group    app:constraint_referenced_ids=&quot;tv_gender,tv_sex_value&quot;    android:visibility=&quot;gone&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;</code></pre><p>通过将性别的 key 和 value 的 id 都放进去，将其设置为 gone，则可以将该组实现隐藏：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322183030.jpg" alt=""></p><p>但是，使用 Group 控制可见性是有坑的：</p><blockquote><ol><li><p>和以前用的ViewGroup有一点不同，以前用ViewGroup约束View的时候，外层ViewGroup设置成可见，里层View设置成不可见是可以生效的，但是用Group就不能。Group约束的元素的可见性始终一致。</p></li><li><p>调用Group的setVisibility方法不会立即对它约束对子View生效，而是要等到Group所在的ConstrainLayout调用preLayout方法时才会生效。preLayout只有在第一次layout和布局发生变化时才会调用。</p></li></ol></blockquote><h4 id="Optimizer优化"><a href="#Optimizer优化" class="headerlink" title="Optimizer优化"></a>Optimizer优化</h4><p>可以通过将标签app：layout_optimizationLevel元素添加到 ConstraintLayout 来决定应用哪些优化</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout     android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    app:layout_optimizationLevel=&quot;standard|dimensions|chains&quot;/&gt;</code></pre><ul><li>none： 不执行优化</li><li>standard： 默认，仅优化直接和障碍约束</li><li>direct： 优化直接约束</li><li>barrier： 优化障碍约束</li><li>chain：优化链条约束</li><li>dimensions：优化维度测量，减少匹配约束元素的度量数量</li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://juejin.im/post/5c0bd6b05188257c3045dc50#heading-7" target="_blank" rel="noopener">ConstraintLayout 全解析</a></li><li><a href="https://mp.weixin.qq.com/s/vI-fPaNoJ7ZBlZcMkEGdLQ" target="_blank" rel="noopener">拒绝拖拽 使用ConstraintLayout优化你的布局吧</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道从什么时候开始，Android 死丢丢已经默认使用约束布局 ConstraintLayout 作为默认布局了，但是懒癌发作一直不想学习，每次都换成 LinearLayout，这次也忘记了为啥开始学习这个东西，学完发现还挺爽……写个笔记记录一下，哈哈&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信 下篇</title>
    <link href="http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-2/"/>
    <id>http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-2/</id>
    <published>2018-09-08T16:00:00.000Z</published>
    <updated>2019-03-21T10:47:37.178Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Efficient.Android.Threading 第四章读书笔记 下篇</p></blockquote><a id="more"></a><h3 id="Android-消息机制"><a href="#Android-消息机制" class="headerlink" title="Android 消息机制"></a>Android 消息机制</h3><p>迄今为止，我们介绍的线程通信都是 Java 层面的，管道、共享内存、阻塞队列等等，都是所有 Java 应用都有的机制。然而，因为阻塞线程特性的存在，这些机制对于 Android 系统都不适用，因为 UI 线程绝不允许阻塞。</p><p>因此，Android 系统为了协同 UI 线程和工作线程，定义了一套系统级别的消息机制。Android 消息机制是一个没有阻塞状态的生产者-消费者模式，UI 线程可以将耗时操作转移给工作线程在后台处理，同时生产者线程与消费者线程都不会发生阻塞。</p><p>Android 平台的消息机制相关的 API 从属于 <code>android.os</code> 包：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182551.jpg" alt="Android Message API"></p><p><code>android.os.Looper</code></p><p>唯一关联某个消费者线程的消息调度器</p><p><code>android.os.Handler</code></p><p>消费者线程的消息处理器，同时生产者线程也使用该对象将消息插入队列。一个 Looper 对象可以绑定多个 Handler 对象，但是所有的消息都是插入同一个消息队列的。</p><p><code>android.os.MessageQueue</code></p><p>消费者线程中待处理消息的链表，但是不同的消息之间并没有绑定关系。每个 Looper 对象最多只能有一个消息队列；由于每个线程只能有一个 Looper 对象，也就是说每个线程最多只能有一个消息队列。</p><p>名叫 MessageQueue, 实际上是一个 LinkedList</p><p><code>android.os.Message</code></p><p>消费者线程中待执行的消息</p><p>消息机制的工作原理大抵如下图示意：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182556.jpg" alt="消息机制示意"></p><p>生产者线程发送消息，消费者线程处理消息：</p><ol><li>插入：生产者线程使用与消费者线程相绑定的 Handler 对象，将消息插入消息队列</li><li>取出：Looper 运行在消费者线程中，按一定的顺序取出消息队列中的消息</li><li>分发：Handler 负责在消费者线程中处理消息；某个线程可以有多个 Handler 对象，Looper 可以确保每条消息能够正确分发给对应的 Handler 。</li></ol><h4 id="消息传递基本示例"><a href="#消息传递基本示例" class="headerlink" title="消息传递基本示例"></a>消息传递基本示例</h4><pre><code class="java">public class LooperActivity extends Activity {    LooperThread mLooperThread;    // 1.声明一个工作线程，扮演消费者线程角色    private static class LooperThread extends Thread {        public Handler mHandler;        public void run() {            // 2.为当前线程关联 Looper，也就是关联了 MessageQueue            Looper.prepare();            // 3.使用默认构造器，即将 Handler 与当前线程的 Looper 绑定            // 也就决定了它只能在 Looper.prepare() 后初始化，否则没有可以绑定的 Looper            mHandler = new Handler() {                // 4. 工作线程中处理分发下来的消息的回调                public void handleMessage(Message msg) {                    if(msg.what == 0) {                        doLongRunningOperation();                    }                }            };            // 5. 开启对消息队列的轮询，对消息进行分发；            // 这是个 blocking call，因此此工作线程不会结束            Looper.loop();        }        private void doLongRunningOperation() {            // Add long running operation here.        }    }    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_looper);        // 6. 开启工作线程，准备处理消息        mLooperThread = new LooperThread();        mLooperThread.start();    }    public void onClick(View v) {        // 7. Handler 初始化完成和点击事件是异步的，因次校验一下 Handler 不为空        if (mLooperThread.mHandler != null) {            // 8. 初始化一个 Message 对象，what 属性赋值为 0            Message msg = mLooperThread.mHandler.obtainMessage(0);            // 9. 向消息队列中插入消息            mLooperThread.mHandler.sendMessage(msg);        }    }    protected void onDestroy() {        super.onDestroy();        // 10. 结束 loop() 方法的阻塞状态，从而结束后台线程的执行        mLooperThread.mHandler.getLooper().quit();    }}</code></pre><h4 id="消息传递过程中涉及到的-Classes"><a href="#消息传递过程中涉及到的-Classes" class="headerlink" title="消息传递过程中涉及到的 Classes"></a>消息传递过程中涉及到的 Classes</h4><h5 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h5><p>消息队列主要由 <code>android.os.MessageQueue</code> 类来实现，其内部实现一个没有绑定关系的单向链表，用于存储一系列待处理的消息。生产者线程插入消息，之后消息会分发到对应的消费者线程去处理。一般来讲，不同的消息是按照时间戳来排序的。也就是说，时间戳值越小，在消息队列中排序顺序就越靠前。但是只有到达当前时间的消息才会被分发；如果还没有到当前时间，则会等到当前时间才会对消息进行分发。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182557.jpg" alt="消息分发的时间点"></p><p>上图展示了消息队列中按时间排序的消息是如何向下分发的，其中 t1 &lt; t2 &lt; t3，即 t1 的时间要早于 t3。现在只有一条消息越过了 <code>disptch barrier</code> , 实际上也就是当前时间点。可以被分发下去的消息所绑定的时间戳，一定比当前时间小，也就是已经到了分发的时间。</p><p>如果当前 Looper 获取消息时，消息队列中还没有消息穿越过 <code>dispatch barrier</code> ，此时消费者线程就会阻塞，直到有消息越过 <code>dispatch barrier</code> 。而生产者线程可以在任何时间、任意位置插入消息，因为消息列表的排列只和消息发送的时间有关系，如果需要插入一条立即发送的消息，则即使消息队列中有一百条待发送的消息，但它们都是一分钟后才发送，那刚插入的这条消息也会在链表的首位，也就是下一个被分发的消息。</p><h5 id="MessageQueue-IdleHandler"><a href="#MessageQueue-IdleHandler" class="headerlink" title="MessageQueue.IdleHandler"></a>MessageQueue.IdleHandler</h5><p>正常来讲，如果 Looper 获取不到应分发的消息时，线程就会阻塞等待；但是除了干等以外，还可以将这段时间利用起来，用来执行一些其他的任务。而这个任务则由 <code>android.os.MessageQueue.IdleHandler</code> 来完成。</p><pre><code class="java">/** * 当线程等待新消息，即将进入阻塞（闲置）状态时的回调接口 */public static interface IdleHandler {      boolean queueIdle();}// 具体使用：// 获取当前线程的消息队列MessageQueue myQueue = Looper.myQueue();// 声明一个 IdleHandler 对象MessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() {    @Override    public boolean queueIdle() {        return false;    }};// 与消息队列进行绑定myQueue.addIdleHandler(idleHandler);// 与消息队列解除绑定myQueue.removeIdleHandler(idleHandler);</code></pre><p>当消息队列检测到分发消息的空闲时间时，它会唤醒所有注册到当前消息队列的 IdleHandler 实例，并调用他们的 <code>queueIdle</code> 方法，而具体的回调由应用自身来进行实现。</p><p> <code>queueIdle</code> 方法返回值为布尔类型：</p><ul><li><p>true</p><p>当前 IdleHandler 实例保持存活，下次再有 time slots 时，MessageQueue 还会唤醒该实例</p></li><li><p>false</p><p>当前 IdleHandler 实例不再存活，处理完消息后就会主动调用 MessageQueue.removeIdleHandler() 将该实例与 MessageQueue 解绑</p></li></ul><h5 id="使用-IdleHandler-来终止闲置线程的运行"><a href="#使用-IdleHandler-来终止闲置线程的运行" class="headerlink" title="使用 IdleHandler 来终止闲置线程的运行"></a>使用 IdleHandler 来终止闲置线程的运行</h5><p>假定现在有多个生产者线程要连续不断的向消费者线程发送消息，那就可以在消费者线程将所有任务的处理完以偶胡，使用 IdleHandler 来终止线程的执行，从而保证该线程对象不会在内存中游荡。</p><p>在这种情况下使用 IdleHandler ，就不用追踪最后一条插入队列的消息，以期得到回收该线程的确切时间。</p><p>不过这种场景只适用于生产者线程连续不断地向消费者线程插入消息，从而保证在处理完所有消息之前，消费者线程都没有 time slots.</p><pre><code class="java">public class ConsumeAndQuitThreadActivity extends Activity {    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        final ConsumeAndQuitThread consumeAndQuitThread = new ConsumeAndQuitThread();        consumeAndQuitThread.start();        for (int i = 0; i &lt; 10; i++) {            // 由多个线程并发向消费者线程发送消息，随机模拟发送的时间            new Thread(new Runnable() {                @Override                public void run() {                    for (int i = 0; i &lt; 10; i++) {                        SystemClock.sleep(new Random().nextInt(10));                        consumeAndQuitThread.enqueueData(i);                    }                }            }).start();        }    }    /**     * 此线程为绑定了 Looper 对象的消费者线程，接收生产者线程的消息并进行处理；     * 处理完消息后，会终止 Looper.loop() 方法，结束线程的执行     */    private static class ConsumeAndQuitThread extends Thread implements MessageQueue.IdleHandler {        private static final String THREAD_NAME = &quot;ConsumeAndQuitThread&quot;;        public Handler mConsumerHandler;        private boolean mIsFirstIdle = true;        public ConsumeAndQuitThread() {            super(THREAD_NAME);        }        @Override        public void run() {            Looper.prepare();            mConsumerHandler = new Handler() {                @Override                public void handleMessage(Message msg) {                    // Consume data                }            };            // 1. 为当前线程初始化 Looper，并为该线程的消息队列绑定 IdleHandler 对象            Looper.myQueue().addIdleHandler(this);            Looper.loop();        }        @Override        public boolean queueIdle() {            // 2. 第一次 queueIdle() 的调用会发生在接收消息之前            // 因此需要让首次调用返回 true，从而保证此对象仍然与消息队列绑定            if (mIsFirstIdle) {                 mIsFirstIdle = false;                return true;            }            // 3. 结束消费者线程的执行            mConsumerHandler.getLooper().quit();            return false;        }        public void enqueueData(int i) {            mConsumerHandler.sendEmptyMessage(i);        }    }}</code></pre><h5 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h5><p>Message 是一个容器类，可以承载各种类型的数据或者一个 Runnable 对象，但是不能同时携带二者。所携带的数据会在消费者线程被处理，但任务则会在消息分发时直接得到执行，而不需要调用者做其他额外的工作。</p><p>正常来讲，Message 的插入由 Handler 来完成，因为它在插入消息时有更多的选择，更加灵活；但是实际上每条消息对象都知道自己对应的处理器是谁，也就是知道自己对应的 Handler 对象，所以一条消息可以自己实现入队操作。</p><pre><code class="java">// 通过 obtain() 传递一个 Handler 对象进去，赋值给 Message.target 属性Message m = Message.obtain(handler, runnbale);m.sendToTarget();public void sendToTarget() {    // target 是 Handler 对象，此方法会调用 Handler 的 sendMessage 方法    target.sendMessage(this);}</code></pre><p>如之前所说，Message 可以携带数据或者任务，具体如下图所示：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182601.jpg" alt=""></p><p>消息队列可以包含任何数据和任务消息的组合，消费者线程具体在处理消息的时候，也仅仅是按照消息的排序顺序，而不和消息的类型有任何关系。如果消息携带的是数据，那消费者线程就会在 handleMessage 中处理数据；如果消息携带的是任务，则该 Runnable 的 run 方法则会在消费者线程得到执行，但是不会再触发 handleMessage 方法的回调。</p><p>Message 的生命周期大概可以分为四个方面：初始化，等待，分发，回收。需要注意的是，系统并没有对消息的状态进行监听，尽管这在技术上也是可行的，所以应用在处理消息不该对该消息的当前状态做出任何假设。</p><ul><li><p>Initialized</p><p>在初始化状态下，应用程序可以使用以下方法来创建 Message 对象：</p><ul><li><p>使用构造器初始化</p><pre><code class="java">Message m = new Message();</code></pre></li><li><p>工厂方法</p><ul><li><p>空消息</p><pre><code class="java">Message m = Message.obtain();</code></pre></li><li><p>数据消息</p><pre><code class="java">Message m = Message.obtain(Handler h);Message m = Message.obtain(Handler h, int what);Message m = Message.obtain(Handler h, int what, Object o);Message m = Message.obtain(Handler h, int what, int arg1, int arg2); Message m = Message.obtain(Handler h, int what, int arg1, int arg2, Object o);</code></pre></li><li><p>任务消息</p><pre><code class="java">Message m = Message.obtain(Handler h, Runnable task);</code></pre></li><li><p>复制构造器</p><pre><code class="java">Message m = Message.obtain(Message originalMsg);</code></pre></li></ul></li></ul></li><li><p>Pending</p><p>消息已经被插入消息队列中，但还没到发送时间，正在等待分发</p></li><li><p>Disptached</p><p>在这个阶段，Looper 已经从消息队列中取出了消息，消息队列也将其移除。Looper 在 loop 方法中，会通过访问 Message.target 属性，来获取到该消息对应的 Handler ，然后将消息发送到对应的回调中进行处理。</p></li><li><p>Recycled</p><p>在这个阶段，Message 的状态被清除，该实例也回到了消息池中等待复用。在消费者线程完成数据处理后，Looper 负责 Message 的回收工作。这个回收过程由虚拟机来完成，而不应该由应用程序来主动处理。</p><blockquote><p>需要注意的是，一旦消息入队后，其携带的数据就不应该再被更改。理论上来讲，在消息被分发之前，对数据做出的更改都是有效的。但由于 Handler 机制在设计之初就没有对 Message 的处理状态进行监听，因此调用者正在对数据进行更改时，消费者线程正在处理数据，从而导致线程安全的问题。而如果该消息对象已经被回收了，问题则会更加严重，因为该对象回到消息池后，会在之后被应用程序所复用，有可能会携带之前的数据到新的消息队列中。</p></blockquote></li></ul><h5 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h5><p><code>android.os.Looper</code> 复杂将队列中的消息分发给对应的 Handler 去处理。所有越过分发栅栏的消息都可以被 Looper 所分发。所有待分发的消息一定是越过分发栅栏的，当没有消息待分发时，消费线程则会阻塞，直至有消息等待处理。</p><p>消费线程并不直接与消息队列发生关系，而是通过 Looper 作为中间者来协调消息的分发与处理：消费电车绑定 Looper，而 Looper 会绑定一个 MessageQueue。默认只有 UI 线程自带 Looper ，其他子线程需要调用者显式声明 Looper 。</p><pre><code class="java">new Thread() {    @Override    public void run() {        // prepare() 方法会初始化一个消息队列，并将其与当前线程绑定        // 在此时，该消息队列已经可以插入消息，但是无法分发到消费线程处理        Looper.prepare();        // ... ...        // 此方法为一个 blocking call，确保 run() 方法不会结束执行        // 当 run() 方法阻塞的时候，Looper 可以循环消息队列，然后向消费线程分发消息        Looper.loop();    }}.start();</code></pre><p>一个线程只能绑定一个 Looper，而 Looper 会绑定一个 MessageQueue，也就是说一个线程只能有一个消息队列；这也就保证了无论多少工作线程向主线程发送消息，主线程也只能按照一定顺序来处理消息。因此，当前执行的消息处理时间的长短会影响到之后的消息，我们在实际使用时，应该规避处理耗时过长的消息。</p><h5 id="Looper-的终止"><a href="#Looper-的终止" class="headerlink" title="Looper 的终止"></a>Looper 的终止</h5><ul><li><p>quit()</p><p>丢弃消息队列中所有未分发的消息，不管其有没有越过分发栅栏</p></li><li><p>quitSafely()</p><p>丢弃还没越过分发栅栏的消息，Looper 会等到已经处于待分发状态的消息正确分发后再结束</p></li></ul><p>终止 Looper 并不会终止线程的执行，它只是将 loop() 方法结束了；但需要注意的是，终止 Looper 后此线程将不再是 Looper 线程，既不能重新绑定新的 Looper ，也无法唤醒已经终止的 Looper。调用 Looper.prepare() 会抛异常，提示已经绑定；重新调用 Looper.loop() 会进入阻塞状态，但是消息队列中的消息不会再得到分发。</p><h5 id="UI-线程的-Looper"><a href="#UI-线程的-Looper" class="headerlink" title="UI 线程的 Looper"></a>UI 线程的 Looper</h5><p>UI 线程是唯一一个自带 Looper 的线程，其与其他线程有以下几点不同：</p><ul><li>在程序任何位置都可以通过调用 Looper.getMainLooper() 来获取 UI Looper</li><li>UI 线程的 Looper 不能被终止</li><li>Java 虚拟机通过 Looper.prepareMainLooper() 为 UI 线程初始化 Looper，此动作只能执行一次，因此尝试将 main looper 与其他子线程关联会抛异常。</li></ul><h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>Android 系统中使用 <code>android.os.Handler</code> 来协调工作线程与 UI 线程的调度，消息的插入和处理都由它来完成，具体工作包括以下几点：</p><ul><li>消息的创建</li><li>插入消息</li><li>在消费线程中处理消息</li><li>管理消息队列中的消息</li></ul><p>Handler 的工作需要 Looper 和 MQ 的支持，因此 Handler 在声明时就应该绑定 Looper 对象：</p><ol><li><p>构造器中不接收 Looper 的，该 Handler 与当前线程绑定</p><pre><code class="java">// 这种与当前线程绑定的，如果当前不是 Looper 线程，就会抛出异常new Handler();new Handler(Handler.Callback);</code></pre></li><li><p>构造器明确需要传入 Looper 对象的</p><pre><code class="java">new Handler(Looper);new Handler(Looper, Handler.Callback);</code></pre></li></ol><p>一个线程可以有多个 Handler ，不同 Handler 发送的消息可以在消息队列中共存，并不会有什么冲突；具体在分发的时候又会通过 Message 的 target 属性发送回该消息对应的 Handler：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182554.jpg" alt=""></p><blockquote><p>多个 Handler 发出的消息也不会导致并发，Message 的处理仍然是按顺序执行的。</p></blockquote><h5 id="Message-creation"><a href="#Message-creation" class="headerlink" title="Message creation"></a>Message creation</h5><p>Handler 可以通过以下几个包装方法直接获取 Message 对象，而这些对象则会和 Handler 发生绑定关系：</p><pre><code class="java">// 这些方法内部都会调用 Message.obtain() 方法，并将 Handler 传入，从而产生绑定关系Message obtainMessage(int what, int arg1, int arg2)Message obtainMessage()Message obtainMessage(int what, int arg1, int arg2, Object obj) Message obtainMessage(int what)Message obtainMessage(int what, Object obj)</code></pre><h5 id="Message-insertion"><a href="#Message-insertion" class="headerlink" title="Message insertion"></a>Message insertion</h5><p>根据消息类型的不同，Handler 插入消息的方式也略有差别。</p><pre><code class="java">// 携带任务的消息，使用 postXxx() 方法boolean post(Runnable r)boolean postAtFrontOfQueue(Runnable r)boolean postAtTime(Runnable r, Object token, long uptimeMillis) boolean postAtTime(Runnable r, long uptimeMillis)boolean postDelayed(Runnable r, long delayMillis)// 携带数据的消息或者空消息，使用 sendXxx() 方法// 默认，立即分发boolean sendMessage(Message msg) // 下一个分发boolean sendMessageAtFrontOfQueue(Message msg)// 指定某个确切的时间进行分发boolean sendMessageAtTime(Message msg, long uptimeMillis) boolean sendMessageDelayed(Message msg, long delayMillis)boolean sendEmptyMessage(int what)boolean sendEmptyMessageAtTime(int what, long uptimeMillis) boolean sendEmptyMessageDelayed(int what, long delayMillis)</code></pre><p>每条消息都有会有一个 when 属性，用来记录当前消息应该何时被分发；该属性也是唯一一个会影响分发顺序的因素。需要注意的是，尽管我们可以指定确定的时机分发，但是由于之前消息的处理也会影响到后一条消息的分发，因此这个时间还是不确定的。</p><p>向消息队列中插入消息时，有可能导致某些错误的产生：</p><ul><li><p>Message has no Handler</p><p>Message was created from a Message.obtain() method without a specified Handler.</p></li><li><p>Message has already been disptached and is being processed</p><p>The same message instance was inserted twice.</p></li><li><p>Looper has exited</p><p>Message is inserted after Looper.quit() has been called.</p></li></ul><blockquote><p>Looper 在分发消息时，会调用 Handler 的 dispatchMessage 方法。如果此方法被应用程序主动调用，那该消息会在发起调用的线程立即得到执行，而不是在消费线程执行。</p></blockquote><h5 id="Message-processing"><a href="#Message-processing" class="headerlink" title="Message processing"></a>Message processing</h5><p>Message 根据携带数据类型的不同，有不同的处理方式：</p><ul><li><p>Task messages</p><p>如果携带的是 Runnbale 对象，那等轮到该条消息分发的时候，则该 Runnable 对象的 run 方法会直接得到执行，而不会再触发 <code>Handler.handMessage()</code> 方法。</p></li><li><p>Data messages</p><p>如果消息携带的是数据的话，那处理消息则需要重写 <code>Handler.handMessage()</code> 方法（两种方式）。</p></li></ul><p>一种是正常的实现自己的 Handler ，然后重写该方法；或者在初始化 Handler 的时候直接重写该方法，但需要注意的是，如果在子线程中，该方法的重写要在消息队列就绪以后立刻声明，否则 loop() 循环开启后，就无法再声明了：</p><pre><code class="java">class ConsumerThread extends Thread{    Handler mHandler;    @Override    public void run(){        Looper.prepare();        mHandler = new Handler(){            public void handleMessage(Message msg){                // process data message here            }        };        Looper.loop();    }}</code></pre><p>另一种方式是利用 <code>Handler.Callback</code> 接口，该接口方法为一个带布尔类型返回值的 <code>handleMessage</code> 方法：</p><pre><code class="java">public interface Callback {    // true: 代表实现类处理完消息即终止    // false: 代表实现类处理完以后，还要继续下发到 Handler.handleMessage 方法    public boolean handleMessage(Message msg);}// 消息分发public void dispatchMessage(Message msg) {    if (msg.callback != null) {        handleCallback(msg);    } else {        if (mCallback != null) {            // 如果返回 true ，则不会继续向下分发了            if (mCallback.handleMessage(msg)) {                return;            }        }        handleMessage(msg);    }    }</code></pre><p>使用这种方式，调用者不再需要继承自 Handler ，而只需要将 Callback 接口的实现类当做 Handler 构造器传入即可，然后该 Handler 就会回调到 handleMessage()：</p><pre><code class="java">public class HandlerCallbackActivity extends Activity implements Handler.Callback {    Handler mUiHandler;    @Override    public void onCreate(Bundle savedInstanceState){        super.onCreate(savedInstanceState);        mUiHandler = new Handler(this); // 直接通过构造器传入，即可通过此类处理消息    }    @Override    public boolean handleMessage(Message msg){        // process msg        return true;    }}</code></pre><h4 id="与-UI-线程通信"><a href="#与-UI-线程通信" class="headerlink" title="与 UI 线程通信"></a>与 UI 线程通信</h4><p>正如之前所说，UI 线程是唯一一个自带 Looper 的线程，其他线程可以向 UI 线程发送消息，但要注意避免耗时操作，因为 UI 线程是全局的，每个任务的时长都会对全局任务的执行产生影响。</p><p>有以下几种方式将消息转交到 UI 线程处理：</p><ol><li><p>为 Handler 指定 UI 线程的 Looper</p><pre><code class="java">Runnable task = new Runnable(){...};new Handler(Looper.getMainLooper()).post(task);</code></pre><p>使用这种方式，不管调用线程，task 都会通过 UI Looper 直接插入 UI MessageQueue。</p></li><li><p>直接在 UI 线程向自身发送消息，该任务会在当前正在执行的消息处理完后得到执行</p><pre><code class="java">private void postFromUiThreadToUiThread(){    new Handler().post(new Runnable(){...})}</code></pre></li><li><p>Activity.runOnUiThread</p><pre><code class="java">private void postFromUiThreadToUiThread(){    runOnUiThread(new Runnable(){...})}</code></pre><p>如果此方法在其他线程调用，则它会将消息插入到 UI 线程的消息队列中。此方法只能由 Activity 的实例来调用，但是也可以实现自己的 runOnUIThread 方法，只要追踪 UI 线程的 ID 即可：</p><pre><code class="java">public class MyApplication extends Application{    private long mUiThreadId;    private Handler mUiHandler;    @Override    public void onCreate(){        super.onCreate();        mUiThread = Thread.currentThread().getId();        mUiHandler = new Handler();    }    public void customRunOnUiThread(Runnable action){        if(Thread.currentThread().getId() != mUiThreadId){            mUiHandler.post(action);        } else{            action.run();        }    }}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Efficient.Android.Threading 第四章读书笔记 下篇&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://joeljt.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Efficient.Android.Threading" scheme="http://joeljt.top/tags/Efficient-Android-Threading/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信 上篇</title>
    <link href="http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-1/"/>
    <id>http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-1/</id>
    <published>2018-09-08T16:00:00.000Z</published>
    <updated>2019-03-21T10:47:26.820Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Efficient.Android.Threading 第四章读书笔记 上篇</p></blockquote><a id="more"></a><p>在多进程应用中，各个任务可以并行执行协作以产出结果。因此，各个线程之间必须进行通信才能满足协作执行的目的。在 Android 系统中，可以使用传统的 Java 线程通信技术，也可以使用 Android 专属的 Handler / Looper 消息机制。基于此，本章的主要内容为：</p><ul><li>使用单向传输的管道来进行数据传输</li><li>共享内存通信</li><li>使用 <code>BlockingQueue</code> 实现生产者消费者</li><li>消息队列的具体操作</li><li>将具体任务发回 UI 线程</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道 <code>Pipes</code> 从属于 <code>java.io</code> 包，也就是说，严格意义上讲，它是属于 Java 语言范畴，而非 Android 系统的。一个管道为同一进程的两个线程提供一种交互方式，为二者建立连接，搭建一个单向传输的数据传输通道：生产者线程向管道中写入数据，同时消费者线程从中取数据。</p><p>Java 管道与 Unix 系统管道命令 <code>|</code> 相比较起来有所不同。Java 管道用来为同一进程中的不同线程提供通信服务；而 Unix 系统管道命令用来将某个命令的输入重定向为另一命令的输入。</p><p>管道在内存中表现为一个循环缓冲区，仅适用于两个连接的线程，其他线程无法接触到其中的数据。同时，管道是单向的，只允许一个线程线程写入数据，另一线程读取数据，在这种情况下，线程安全是可以确定的。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182548.jpg" alt="Pipes"></p><p>管道的典型使用场景为，并行的两个耗时任务，其中一个线程需要不停地给另一个线程传输数据。管道可以用来为 UI 线程减压，从而保证用户界面响应的及时性，从而提升用户体验。</p><p>管道可以传输二进制数据或者字节数据。其中，二进制数据的代表为 <code>PipedOutputStream</code> 和 <code>PipedInputStream</code> ，字节数据的代表为 <code>PipedWriter</code> 和 <code>PipedReader</code> 。除了传输数据类型的不同以外，以上两种类型的管道没有任何不同。管道的生命周期自两个线程建立连接开始，断开连接时生命周期结束。</p><h4 id="管道的基本使用"><a href="#管道的基本使用" class="headerlink" title="管道的基本使用"></a>管道的基本使用</h4><p>基本的管道生命周期可以归纳概括为三个步骤：建立连接，数据传输和断开连接。</p><pre><code class="java">// 1.建立连接 - int BUFFER_SIZE_IN_CHARS = 1024 * 4; // 默认为 1024，可以自定义PipedReader r = new PipedReader(BUFFER_SIZE_IN_CHARS);PipedWriter w = new PipedWriter();w.connect(r); // r.connect(w);// 2.将消费者传入线程中, 线程启动后，就准备好从管道中读取数据了Thread t = new MyReaderThread(r);t.start();// 3. 传输数据// 类似这种生产者-消费者模型的通信方式，一般都是带有阻塞机制的。// 如果管道已满，则 write() 会处于阻塞状态，直到管道中再次有空余空间；// 如果缓存为空，则 read() 会处于阻塞状态。// flush() 方法的调用是很有必要的// 因为当 read() 线程调用 wait() 后，默认会有至少一秒钟的超时时长// flush() 方法相当于 notify()，可以保证消费者马上对新加入的数据做出响应w.write(&#39;A&#39;);w.flush();int i; // 传输的数据会被转为 int 类型，以保证不同编码格式的统一性while((i = r.read()) != -1){    char c = (char)i;}// 4. 关闭连接// 如果关闭 writer, 管道关闭但缓存中的数据还会被读取到// 如果关闭 reader, 则缓存中的数据会被清除w.close();r.close();</code></pre><h4 id="管道在-Android-系统中的应用"><a href="#管道在-Android-系统中的应用" class="headerlink" title="管道在 Android 系统中的应用"></a>管道在 Android 系统中的应用</h4><p>使用管道来对用户输入进行一些简单处理：用户通过 EditText 输入内容，为了保证 UI 线程的即时性，使用管道将用户输入内容发送到工作线程进行某些耗时操作的处理：</p><pre><code class="java">private static class TextHandlerTask implements Runnable {    private final PipedReader reader;    private TextHandlerTask(PipedReader reader) {        this.reader = reader;    }    @Override    public void run() {        while (!Thread.currentThread().isInterrupted()) {            int i;            try {                while ((i = reader.read()) != -1) {                    char c = (char) i;                    Log.e(&quot;Test&quot;, &quot;char -&gt; &quot; + c);                }            } catch (IOException e) {                e.printStackTrace();            }        }    }}private PipedReader r = new PipedReader();private PipedWriter w = new PipedWriter();w.connect(r);etSearch.addTextChangedListener(new TextWatcher() {    @Override    public void onTextChanged(CharSequence s, int start, int before, int count) {        if (count &gt; before) { // 输入内容            try {                w.write(s.subSequence(before, count).toString());            } catch (IOException e) {                e.printStackTrace();            }        }    }});new Thread(new TextHandlerTask(r)).start();</code></pre><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是一种通用的线程间通信的方式。应用程序的地址空间存储在堆中，所有线程都可以对其进行访问，即某个线程操作某个数据，该数据同时可以被其他线程所读取。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg" alt="不同线程利用共享内存进行通信"></p><p>如果某个线程将其数据存储为局部变量（本地变量），那么其他线程是无法对其进行访问的。只有将数据存储在共享内存中，才能够被其他线程访问到，从而完成不同线程间的协作。以下对象一般被认为是存储在共享内存中的：<code>实例变量</code>，<code>类变量</code>，<code>方法中声明的对象</code>。</p><p>对象的引用（指针）存储在线程的栈中，但是对象其本身（占用的内存）存储在共享内存中。不同方法之间如果想要互相操作对象，则需要将对象的引用进行传递才可以实现。<code>不同的线程通过定义实例属性以及类属性来实现通信和任务协作</code>。</p><h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><p>由于线程数据安全问题的存在，不同的线程在操作同一数据时需要有阻塞机制，来保证同一时间只有一个线程对共享数据进行操作。Java 内置的唤醒机制就很好的解决了这一问题。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182553.jpg" alt="Thread signal"></p><p>当某一线程除非满足某个条件，否则无法继续执行时，该线程可以调用 wait() / await() 方法。timeout 参数表示当前线程在下次执行前，需要等待多久。</p><p>当其他线程已经将状态更改，也就是现在正在等待的线程已经满足条件了，那么当前线程会通过调用 notify() / notifyAll() 来通知等待的线程；而收到消息的线程则可以继续向下执行。</p><p>需要注意的是，很可能并不是只有一个线程在等待，但是只能有一个线程进入同步代码块，也就是说，收到通知消息的消息也并不一定可以继续向下执行。这就要求等待线程需要遵循一定的设计模式，即<code>在同步代码块中，重复检查条件是否已经满足</code>。</p><pre><code class="java">synchronized(this){    while(isConditionFulfilled == false){        wait();    }    // 代码执行到这里时，才说明状态是对的}</code></pre><p>以上代码在同步代码块中再次检查了条件是否满足。如果不满足条件，则当前线程挂起等待；当收到通知消息，等待线程被唤醒，它在执行关键代码前会再次校验同步条件是否满足，因为有可能被其他线程捷足先登，如果不满足条件，则其会继续挂起，等待下一个唤醒信号。</p><p>以上机制很好的协同了多线程的通信，但是不适合 Android 平台，因为 UI 线程绝不能挂起等待工作线程完成任务后唤醒，之后的文章中介绍 Android 消息分发机制。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>线程信令是一种低级，高度可配置的机制，尽管它可以应用在很多场景，但同时这也是一种极容易出错的技术。因此，Java 平台基于线程信令机制，重新构建了一套抽象概念，以期解决线程之间多对象的单向切换。</p><p>在这一机制中，线程的挂起和唤醒不再通过消费者和生产者本身来控制，而是通过一个带有阻塞特性的队列来完成，例如，<code>java.util.concurrent.BlockingQueue</code>。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg" alt="BlockingQueue"></p><p>阻塞队列扮演着生产者线程和消费者线程中间的协调者，内部维护一个实现了线程信令机制，可自定义大小的列表。具体使用的时候，如果队列中数据已满，则生产者线程 put() 方法会阻塞，直到消费者从队列中取出数据；如果队列为空，则消费者线程 take() 方法会阻塞，直到生产者向队列中插入数据。</p><pre><code class="java">public class ConsumerProducer{    private final int LIMIT = 10;    private BlockingQueue&lt;Integer&gt; blockingQueue =         new LinkedBlockingQueue&lt;Integer&gt;(LIMIT);    public void produce() throws InterruptedException{        int value = 0;        while(true){            blockingQueue.put(value++);        }    }    public void consume() throws InterruptedException{        while(true){            int value = blockingQueue.take();        }    }}</code></pre><p>以上是第四章前半部分内容，由于篇幅较长，准备分为两篇来记录。</p><p>接下来会介绍 Android 平台的消息分发机制，下篇再见，大家加油~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Efficient.Android.Threading 第四章读书笔记 上篇&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://joeljt.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Efficient.Android.Threading" scheme="http://joeljt.top/tags/Efficient-Android-Threading/"/>
    
  </entry>
  
  <entry>
    <title>Android 系统中的线程</title>
    <link href="http://joeljt.top/2018/08/29/Efficient-Android-Threading-chapter-3/"/>
    <id>http://joeljt.top/2018/08/29/Efficient-Android-Threading-chapter-3/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2019-03-21T10:53:39.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Efficient.Android.Threading 第三章读书笔记</p></blockquote><a id="more"></a><p>每个 Android 应用程序都会运行着很多线程，这些线程一般都与 Linux 进程绑定，并且通过 Dalvik VM 来管理各线程的内部执行。应用主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程，本章主要讨论方向：</p><ul><li>UI 线程，binder 线程，后台线程的区别</li><li>Linux thread coupling</li><li>应用程序排名会对线程的执行造成怎样的影响</li><li>执行 Linux 线程</li></ul><h3 id="Android-应用层线程"><a href="#Android-应用层线程" class="headerlink" title="Android 应用层线程"></a>Android 应用层线程</h3><p>Android 应用层主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程。</p><h4 id="UI-线程"><a href="#UI-线程" class="headerlink" title="UI 线程"></a>UI 线程</h4><p>UI 线程在应用启动时启动，生命周期与应用相同。作为 Android 应用的主线程，UI 线程主要负责 Android 组件和界面 UI 的绘制与更新。当用户尝试在其他线程更新 UI 时，系统则会抛出异常。尽管这个处理方式看上去很不友好，但却是非常必要的。因为 Android UI Toolkit 不是线程安全的，所以为了规避不必要的麻烦，runtime 只能有一个线程来操作 UI 。</p><p>UI 线程是基于消息机制的，按照事件的顺序依次执行。所有的线程都可以通过 Handler 将事件发送到 UI 线程，如果当前线程正在做着排在前面的事件，则该事件会入队等待。</p><h4 id="Binder-线程"><a href="#Binder-线程" class="headerlink" title="Binder 线程"></a>Binder 线程</h4><p>Binder 线程主要是用来为不同进程之间提供通信的。每个进程都维护一个线程池，不会频繁的新建和销毁线程，而是不断复用现有的几个线程来协同工作。Binder 线程处理来自其他进程的请求，具体包括系统服务，intents, content providers, services。大部分涉及不到进程间通信的场景，消息都是通过 UI 线程来进行处理的。一个例外是，当前应用可能提供了一个 <code>Service</code> ，其通过 AIDL 接口与其他进程实现了绑定。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>一个应用程序中，所有需要调用者显式声明的线程，都是后台线程。一般来讲，后台线程是用户手动声明的，也就是说其默认没有任何实现，全部的工作都由调用者来定义。后台线程本质上属于 UI 线程的后代，所以它继承了一部分 UI 线程的特性，比如优先级。</p><p>在 Android 应用层，UI 线程与后台线程处理的工作是完全不同的；但是在 Linux 系统层面，二者是没有任何区别的。UI 界面的更新只能通过 UI 线程来进行，并不是被 Linux 限定的，而是通过 Application Framework 层的 Window Manager 来限制的。</p><h3 id="Linux-进程与线程"><a href="#Linux-进程与线程" class="headerlink" title="Linux 进程与线程"></a>Linux 进程与线程</h3><p>Android 系统是基于 Linux 内核的，每个应用程序实际上都是一个 Linux 程序。Android 系统的每个应用都有一个隐藏的 Linux 进程，其 fork 自 Zygote 进程，有以下几个值得注意的属性：</p><ul><li><p>User ID(UID)</p><p>Linux 系统是多用户系统，在 Android 系统中，每个应用就代表一个用户，当应用安装到系统中时，会被指定一个 User ID</p></li><li><p>Process identifier (PID)</p><p>当前进程的唯一标识</p></li><li><p>Parent process identifier  (PPID)</p><p>系统启动后，每个进程都是依附于其他进程而创建的。因此，所有正在运行中的进程会构成一个进程树，所有每个应用都有一个父亲进程。就 Android 系统来讲，所有进程的父进程都是 Zygote 进程</p></li><li><p>Stack</p><p>存储本地方法的变量和指针</p></li><li><p>Heap</p><p>当前进程私有化的地址数据信息，无法被其他进程获取到</p></li></ul><p>进程和线程一个很重要的区别就是，不同进程之间无法共享地址数据，但是同一进程的不同线程可以共享数据。这就直接导致了，线程间通信速度比进程间通信速度快得多。进程间通信需要进行一些远程操作调用，而这个过程开销比较大。</p><p>一般来讲，应用启动以后，会创建不超过十个线程；第一个创建的线程便是我们所熟知的 UI 线程，之后所有的线程都是 UI 线程繁衍出来的。具体表现在，UI 线程的 PID 是 4257，之后所有线程的 PPID 都是 UI 线程的 PID：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182600.jpg" alt="adb shell ps"></p><h4 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h4><p>Linux 中线程为最小调度单元，而并非进程。一个程序中的某个线程需要和其他所有线程进行执行机会的争夺，在 Android 程序中，线程的调度都是直接交给 Linux 内核来处理的，而并非 Dalvik 虚拟机，也就是说每个线程都要和整个系统中的所有应用的所有线程做资源的争夺。</p><p>Linux 的线程调度器又被称为完全公平调度程序 <code>completely fair scheduler</code> ，原因就在于它执行调度时不只根据优先级，还会参考具体线程的执行时间来做判断。如果某个线程之前很少有机会被处理器执行，那么即使它优先级很低，那它也会优先得到执行；如果某个线程很少需要执行，那 CFS 会降低它的优先级，以保证它不会过分争抢资源。</p><p>Linux 平台主要有两种方式来影响线程的调度：</p><ol><li>更改线程优先级</li><li>更改 Android 专有的控制组 <code>control group</code></li></ol><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>线程的优先级在 Linux 中被称为友善度 <code>niceness</code> / <code>nicevalue</code> ，指的是当前线程对其他线程的友善程度。也就是说，友善度越低，即越不友善，则优先级越高。在 Android 中，Linux 线程的友善度从低到高为 -20 到 19，默认值为 0。</p><p>某个线程的优先级与初始化该线程所在的线程优先级相同，除非其被系统显式修改。一个应用可以通过以下两种方式更改线程的优先级：</p><ul><li>java.lang.Thread</li></ul><pre><code class="java">// Java 线程优先级，从 0 到 10 依次递增setPriority(int priority);</code></pre><ul><li>android.os.Process</li></ul><pre><code class="java">Process.setThreadPriority(int priority);Process.setThreadPriority(int threadId, int priority);</code></pre><h5 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h5><p>Android 平台不是单纯依赖 Linux 的 CFS 调度系统的，还对所有的线程进行控制组控制。所谓控制组，实际上是一个 Linux 容器，该容器用来管理当前容器中所有执行线程的处理器执行时间。一个应用中创建的所有线程都会属于某一个控制组。</p><p>Android 系统中定义了很多控制组，但是最重要的是前台组和后台组。</p><p>其中，前台组相较于后台组会得到更多的执行机会，后台组中所有的线程加一起，也得不到超过 10% 的执行时间，Android 系统就是利用这个特点来保证前台进程会得到更多的执行机会，从而保证性能和效果。</p><p>具体某个线程是否展示在前台，则与其所在进程的级别和类型有关系：</p><p><img src="http://p5zd0id9p.bkt.clouddn.com/18-8-30/70891310.jpg" alt=""></p><p>如图所示，如果某个进程执行在前台页面或者其他前台进程中，那么该进程创建的线程就会属于前台组，同时得到绝大部分的执行时间；而剩下的时间就会被分配给后台组来执行任务。</p><p>当用户进行应用切换操作时，某个线程的控制组也会实时跟着更新：按下 Home 键时，原本的前台进程会退居后台，其内部线程也会进入后台控制组；而原来的后台组也会来到前台，占据大部分的 cpu 执行时间。</p><p>这种方式极大的提高了前台应用的执行效率，一定程度上也降低了后台应用抢占系统资源的可能性，从而提高应用的性能。</p><p>尽管控制组可以一定程度上避免后台应用进程过分抢占资源，但是用户仍然可以在后台进程中创建大量线程来和 UI 线程抢占 cpu 资源。由于其在主线程创建，所以那些子线程与 UI 线程有着同样的优先级和控制组，所以这部分线程会极大的威胁到 UI 线程的正确执行。因此，有时候用户创建大量的后台进程来处理任务，本意可能是不影响 UI 线程正常工作，但是很有可能会适得其反。</p><p>像我们之前说到的，前台组和后台组是根据当前应用是否处于用户可见来界定划分的，也就是说，用户可见的应用程序中的后台线程，也是属于前台组的，会获得大部分的执行机会。在这种情况下，大量的后台线程就会影响到 UI 线程的工作，为解决这个问题，开发者可以通过将后台线程与其创建时的控制组，也就是 UI 线程所在的控制组，进行解耦分离。这个过程可以通过给线程设置足够低的优先级来实现，这样一来，这些后台线程会永远属于后台控制组，即使是其所在的进程当前是处于前台界面展示的。</p><pre><code class="java">// 这个方法不但可以降低优先级；// 还能保证当前线程与进程解耦分离，保证其永远处于后台控制组Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Android 系统中所有的线程类型：UI，binder，后台，本质上都属于 Linux Posix 线程。其中，UI 线程和 binder 线程是在应用启动时自动创建的，后台线程则完全是开发者按需创建的。Android 中所有的组件任务都是默认执行在 UI 线程的，但是为了避免界面效果卡顿以及 ANR 异常，长时间的耗时操作应该在后台进程中执行。尽管 UI 线程是最重要的执行线程，但是由于系统并不知道谁是 UI 线程，所以应该在开发时就明确注意，不要让后台线程喧宾夺主，扰乱 UI 线程的工作。这个效果通常来讲有两种实现方式，一是降低优先级，二是让不是那么重要的后台线程进入后台控制组执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Efficient.Android.Threading 第三章读书笔记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://joeljt.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Efficient.Android.Threading" scheme="http://joeljt.top/tags/Efficient-Android-Threading/"/>
    
  </entry>
  
  <entry>
    <title>Java 中的多线程</title>
    <link href="http://joeljt.top/2018/08/25/Efficient-Android-Threading-chapter-2/"/>
    <id>http://joeljt.top/2018/08/25/Efficient-Android-Threading-chapter-2/</id>
    <published>2018-08-24T16:00:00.000Z</published>
    <updated>2019-03-21T10:51:40.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Efficient.Android.Threading 第二章读书笔记</p></blockquote><a id="more"></a><p>所有 Android 应用都应该进行多线程编程，因为其可以大幅度的提高应用的性能以及响应效果；但是也会由此带来一系列的问题，导致编码的过程更加复杂。</p><ul><li>处理 Java 并发</li><li>在多个线程中保证共享数据的稳定性</li><li>定制以及优化不同线程的执行策略</li></ul><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><p>线程 <code>thread</code> 是 CPU 最小调度单元，一般来讲，一个应用中的任务会按代码顺序来执行。线程中待执行的代码被称作任务 <code>task</code>。一个线程可以只执行一个任务，也可以按顺序执行多个任务。</p><h4 id="线程的执行"><a href="#线程的执行" class="headerlink" title="线程的执行"></a>线程的执行</h4><p>Android 应用中的常用线程即 <code>java.lang.Thread</code>，线程生命周期的长度取决于执行任务的大小以及耗时。</p><p>线程支持执行实现了 <code>java.lang.Runnable</code> 接口的任务，具体的任务是实现在 <code>run</code> 方法中的，具体如下：</p><pre><code class="java">private class MyTask implements Runnable {     public void run() {        // 在 run 方法中直接或间接调用到的所有局部变量，都将存储在该线程本地内存堆栈中        int i = 0;     }}</code></pre><p>通过实例化和启动 Thread 对象，来启动任务的执行：</p><pre><code class="java">Thread thread = new Thread(new MyTask());thread.start();</code></pre><p>从操作系统层面来说，线程同时具有指令和堆栈指针。指令指针引用要处理的下一条指令，堆栈指针指向一个私有内存区域（对其他线程不可见），该区域用于存储当前线程的数据。当前线程的数据 <code>thread local data</code> 一般指的是在 Java 方法中定义的变量信息。</p><p>一般来讲，系统都希望能将 CPU 最大限度的利用起来，但矛盾的地方在于，同一 CPU 在同一时间只能运行一个线程。在这种情况下，为了让用户感知不同的程序正在同时运行，就必须让 CPU 忙起来，在不同的线程之间来回切换，进行任务的执行，这个过程被称为线程的调度<code>scheduler</code>。在 Java 中，线程调度的基准是线程的优先级 <code>priority</code> ，优先级默认为 5，范围为 1-8 。</p><p>但是，如果线程的调度是完全基于优先级的话，就有可能导致低优先级的线程任务永远得不到执行，也就是所谓的饥饿致死。为解决这个问题，Java 调度器在执行线程调度时，还会将线程的执行时间列入考虑的范围。</p><p>每次不同线程的切换被称为上下文切换 <code>context switch</code> 。每次进行上下文切换时，CPU 会先将当前正在执行的线程状态进行保存，以方便下一次恢复当前线程的执行；其后暂停当前线程，同时恢复另一线程的执行。</p><p>具体的线程调度可以通过下图进行理解，图中的 C 就是上下文切换的过程。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182552.jpg" alt="线程调度示例"></p><h4 id="单线程应用"><a href="#单线程应用" class="headerlink" title="单线程应用"></a>单线程应用</h4><p>每个应用至少会有一个线程，也就是我们所熟知的主线程，默认情况下，编写的代码都将在这个线程中进行执行。</p><p>单线程编程是最简单的编码方式，但是很多情况下这种方式并不能满足我们的需求，因此，我们就需要将代码分别运行在不同的线程中，从而保证代码执行的高效性以及程序的性能。</p><h4 id="多线程应用"><a href="#多线程应用" class="headerlink" title="多线程应用"></a>多线程应用</h4><p>如果执行线程的数量超过处理器数量，则无法实现真正的并发，但调度程序在要处理的线程之间快速切换，以便将每个代码路径拆分为按顺序处理的执行间隔。尽管多线程编程会极大的提高应用的性能，但是这是有一定代价的。具体表现为：复杂性的提高，内存开销的增加，不确定的执行顺序等。</p><h5 id="复杂性提高，不确定的执行顺序"><a href="#复杂性提高，不确定的执行顺序" class="headerlink" title="复杂性提高，不确定的执行顺序"></a>复杂性提高，不确定的执行顺序</h5><p>分析单线程应用程序的执行相对简单，因为执行顺序是已知的。在多线程应用程序中，分析程序如何执行以及代码以何种顺序处理要困难得多。执行顺序在线程之间是不确定的，因为调度器将如何分配执行时间给线程是未知的。因此，多线程的执行过程是不确定的。这种不确定性不仅使代码中的错误调试变得更加困难，而且协调线程的过程中也有很大可能会引入新的错误。</p><h5 id="资源开销的增加"><a href="#资源开销的增加" class="headerlink" title="资源开销的增加"></a>资源开销的增加</h5><p>线程在内存和处理器使用方面具有开销。之前提到过，每个线程都会申请一块私有内存区域，用来存储线程数据。这片私有内存在线程创建之初就会申请出来备用，直到线程终止才会被回收并重新分配。在这个过程中，只要当前线程是存活的，即便它是闲置或是阻塞状态，也会持续占用系统资源。</p><p>处理器的开销主要来自于初始化、回收线程，以及在上下文切换中存储和恢复线程。执行的线程越多，上下文切换就越多，性能就越差。</p><h5 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h5><p>多线程程序对资源的访问还会产生一个新的问题，就是数据的共享。如果两个或更多线程同时操作某一个数据，则我们无法确定哪个线程正在对这个数据进行什么样的操作，这就导致了最后数据的不可靠性。</p><p>因为上下文切换可能发生在一个线程中不应中断的位置(比如正在对某个关键性数据进行操作时），所以必须创建代码指令的原子区域 <code>atomic region</code>。如果线程在原子区域中执行，则其他线程将被阻塞，直到在原子区域中没有其他线程执行。因此，Java中的原子区被认为是互斥的，因为它只允许访问一个线程。</p><p>可以用不同的方式创建原子区域  <code>atomic region</code>，但是最基本的同步机制是 <code>synchronized</code> 关键字 ：</p><pre><code class="java">synchronized (this) {     sharedResource++;}</code></pre><p>如果对共享资源的每次访问都是同步的，那么尽管多线程访问，数据也都将是一致的。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在多线程应用中，共享资源有可能会被多方同时访问，同时读写，这就导致了数据的不可靠性。在这种情况下，需要通过使用锁定机制来实现同步。</p><p>Android 中的锁定机制主要包括两种：</p><ul><li><p>对象内在锁定</p><p><code>synchronized</code> 关键字</p></li><li><p>显式锁</p><p><code>java.util.concurrent.locks.ReentrantLock</code><br><code>java.util.concurrent.locks.ReentrantReadWriteLock</code></p></li></ul><h4 id="内在锁和Java监视器"><a href="#内在锁和Java监视器" class="headerlink" title="内在锁和Java监视器"></a>内在锁和Java监视器</h4><p><code>synchronized</code> 关键字适用于每个 Java 对象，其内部包含一个隐式可用的锁。内部锁是互斥的，这意味着同步关键字的代码区域（临界区）中的线程执行是某一个线程独占的。当临界区被占用时，其他线程则会处于阻塞状态，在同步锁释放前，该线程代码无法继续正常执行。</p><p>内在锁充当一个监视器的角色，该监视器有三种状态：</p><ol><li><p>阻塞状态 <code>Blocked</code></p><p>当前线程要等待正在被其他线程占用的内在锁，从而处于挂起状态；</p></li><li><p>运行状态 <code>Executing</code></p><p>当前线程唯一占据内部锁并且正在临界区内执行代码；</p></li><li><p>等待状态 <code>Waiting</code></p><p>当前线程刚刚将临界区代码执行完毕，主动释放了锁；并等待下次获取内部锁；</p></li></ol><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182549.jpg" alt="Java监视器示例"></p><p>一个完整的线程锁工作流大体如下：</p><ol><li><p><code>Enter the monitor</code></p><p>某个线程尝试去操作被同步锁锁住的的代码片段，此时该线程进入 Java 监视器中，如果当前同步锁被其他线程占用，则当前线程挂起；</p></li><li><p><code>Acquire the lock</code></p><p>如果当前同步锁处于空闲状态，则阻塞状态的线程则可以获取锁，并进入同步代码块开始执行。如果有多个线程阻塞等待，则由调度器决定谁将获取锁，而并不是先来后到的；</p></li><li><p><code>Release the lock and wait</code></p><p>满足某种条件后，持有锁对象的线程会主动调用锁对象的 <code>Object.wait()</code> 将锁资源释放，然后等待满足某种条件后，重新获取执行权；</p></li><li><p><code>Acquire the lock after signal</code></p><p>如果某个等待状态的线程被调度器选择为下一个执行线程，则它会在其他线程调用 <code>Object.notify()</code> 或者 <code>Objecct.notifyAll()</code> 时，获得同步锁并进入同步代码块；需要注意的是，等待线程相比较于阻塞线程并没有绝对的优先权，因为二者都想执行这部分同步代码，也就是说最终的选择权在于调度器；</p></li><li><p><code>Release the lock and exit the monitor</code></p><p>在代码执行完毕后，线程会退出监视器，让其他真正有需要的线程做操作。</p></li></ol><p>具体的同步代码块示例：</p><pre><code class="java">// (1) synchronized (this) {     // Execute code (2)     wait(); // (3)    // Execute code (4)} // (5)</code></pre><h4 id="同步对共享资源的访问"><a href="#同步对共享资源的访问" class="headerlink" title="同步对共享资源的访问"></a>同步对共享资源的访问</h4><p>在多线程应用中，共享资源可能被多方同时获取及修改，这种情况下就需要有一个有效的同步机制，来保证多线程下数据的统一性。这种机制具体包括同步锁类型的选择，以及同步代码块范围的设定。</p><h5 id="使用内部锁"><a href="#使用内部锁" class="headerlink" title="使用内部锁"></a>使用内部锁</h5><p><code>synchronized</code> 关键字有多种使用方式：</p><ul><li><p>作用在方法上</p><pre><code class="java">synchronized void changeState() {     sharedResource++;}</code></pre></li><li><p>同步代码块，使用当前类作为同步锁</p><pre><code class="java">void changeState() {     synchronized(this) {        sharedResource++;    }}</code></pre></li><li><p>同步代码块，使用其他对象作为同步锁</p><pre><code class="java">private final Object mLock = new Object();void changeState() {     synchronized(mLock) {        sharedResource++;    } }</code></pre></li><li><p>作用于静态方法</p><pre><code class="java">synchronized static void changeState() {     staticSharedResource++;}</code></pre></li><li><p>静态方法的同步代码块，使用当前类作为同步锁</p><pre><code class="java">static void changeState() {     synchronized(this.getClass()) {        staticSharedResource++;    }}</code></pre></li></ul><p>使用 this 在代码块内作为同步锁，与直接在方法上加 <code>synchronized</code> 关键字是相同的。但是更建议使用同步代码块，因为不一定方法内的全部代码都需要保证同步，滥用同步有可能导致不必要的性能损耗。</p><p>值得注意的是，作用于静态方法的同步锁对象是当前 Class 类对象，而并非其实例对象。</p><h5 id="使用显式锁机制"><a href="#使用显式锁机制" class="headerlink" title="使用显式锁机制"></a>使用显式锁机制</h5><p><code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 类可以用来替代 <code>synchronized</code> 关键字充当监视器。这种情况下，同步代码块的锁定和解锁都是由调用者手动调用的。</p><pre><code class="java">// ReentrantLock 显式锁调用示例int sharedResource;private ReentrantLock mLock = new ReentrantLock();public void changeState(){    mLock.lock();    try{        sharedResource ++;    }    finally{        mLock.unlock();    }}</code></pre><p><code>ReentrantLock</code> 和 <code>synchronized</code> 关键字语义相同，都会将同步代码块隔离开，保证只有一个线程能够对其进行操作。二者都是一种防御性策略，假设所有并发访问都存在问题，但多线程同时读取共享变量并不是有害的。因此，synchronized 和 ReentrantLock 可能存在过度保护。</p><p><code>ReentrantReadWriteLock</code> 则允许多个线程对共享数据同时进行读取，但是仍然禁止同时读写或者同时写入。示例代码如下：</p><pre><code class="java">// ReentrantReadWriteLock 显式锁调用示例int sharedResource;private ReentrantReadWriteLock mLock = new ReentrantReadWriteLock();public void changeState() {     mLock.writeLock().lock();     try {        sharedResource++;    }    finally{        mLock.unlock();    }}public int readState(){    mLock.readLock().lock();    try{        return sharedResource;    }    finally{        mLock.readLock().unlock();    }}</code></pre><p><code>ReentrantReadWriteLock</code> 相对复杂，从而会对性能造成影响。因为相对于 <code>ReentrantLock</code> 和 <code>synchronized</code> 来讲，<code>ReentrantReadWriteLock</code> 要花费更多的时间去判断应不应该阻塞当前线程，这也相当于是让读取操作同步执行的一种妥协。实际上，<code>ReentrantReadWriteLock</code> 的典型应用应该是多个线程进行读取，但只有少量线程会进行写入操作。</p><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p>生产者消费者是线程协作的经典模型，生产者线程和消费者线程共享一个列表，当该列表为空时，生产者线程向其中添加商品；如果列表不为空，则消费者线程会将商品移除。也就是说，当列表为空时，消费者线程应该阻塞等待；当列表已满时，生产者线程应该阻塞等待。</p><p><code>ComsumerProducer</code> 类包括两个线程，一个生产者线程，一个消费者线程，二者共享一个 LinkedList 对象，分别对其进行增加和删除操作：</p><pre><code class="java">public class ConsumerProducer{    private LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();    private final int LIMIT = 10;    private Object lock = new Object();    public void produce(){        int value = 0;        while(true){            synchronized(lock){                while(list.size() == LIMIT){                    lock.wait();                }                list.add(value++);                lock.notify();            }        }    }    public void consume(){        int value = 0;        while(true){            synchronized(lock){                while(list.size() == 0){                    lock.wait();                }                list.removeFirst();                lock.notify();            }        }    } }</code></pre><p>生产者线程和消费者线程共用同一把锁，来保证共享数据 list 的一致性。当列表为满时，生产者主动挂起等待；当列表为空时，消费者主动挂起等待。两个线程在挂起的同时，又会调用 <code>lock.notify()</code> 给正在等待的对方发送信号，通知其获取同步锁并执行代码，从而完成共享数据的同步。</p><pre><code class="java">final ConsumerProducer cp = new ConsumerProducer();// producernew Thread(new Runnable(){    @Override    public void run(){        cp.produce();    }}).start();// consumernew Thread(new Runnable(){    @Override    public void run(){        cp.consume();    }}).start();</code></pre><h4 id="任务执行策略"><a href="#任务执行策略" class="headerlink" title="任务执行策略"></a>任务执行策略</h4><p>一般来讲，两种极端的执行策略如下：</p><ol><li>所有的任务都执行在同一线程上</li><li>每一个任务都对应一个线程</li></ol><p>很明显上述两种策略都过于极端：前者效率过低，后者大量的线程初始化和回收会造成大量的性能消耗。尽管如此，上述两种策略还是目前最常用的两种执行方式：</p><ol><li><p>顺序执行</p><p>各个任务按照先后顺序进行执行，各任务的执行时间不会有重叠。这样做的优势是数据绝对安全，而且只有一个线程执行，占用内存会比多线程更少；缺点在于吞吐量过低，一个任务的执行与否取决于前一个任务能否成功完成；</p></li><li><p>并发执行</p><p>所有的任务都并行执行，最大化利用 CPU ，但是会带来数据的不安全性，需要进行同步机制规避。</p></li></ol><p>一个出色的执行策略应该是顺序执行和并发执行并重的。相对独立的任务应该并发执行以提高效率，但是有相对严格执行顺序的任务则应该执行在单一线程中。</p><h5 id="并发执行设计原则"><a href="#并发执行设计原则" class="headerlink" title="并发执行设计原则"></a>并发执行设计原则</h5><ul><li>控制新线程的重复创建，而应该注意对已有线程的复用，从而降低创建、回收线程的频率</li><li>提高线程使用效率，多余的线程对于内存和处理器都是一种资源浪费</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Android应用程序应该是多线程的，以提高单处理器和多处理器平台的性能。线程可以在单个处理器上顺序执行，或者在多个处理器可用时实现真正的并发。性能的提高是以增加复杂性为代价的，同样需要维护同步机制，以保证线程之间共享资源数据的一致性。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Efficient.Android.Threading 第二章读书笔记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://joeljt.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Efficient.Android.Threading" scheme="http://joeljt.top/tags/Efficient-Android-Threading/"/>
    
  </entry>
  
  <entry>
    <title>Android View.post 浅析</title>
    <link href="http://joeljt.top/2018/08/14/android-view-post/"/>
    <id>http://joeljt.top/2018/08/14/android-view-post/</id>
    <published>2018-08-13T16:00:00.000Z</published>
    <updated>2019-03-21T10:15:31.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……</p></blockquote><a id="more"></a><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>之前的文章里写到过，我们在 onCreate() 和 onResume() 方法中无法获取 View 的宽高信息，但在平时开发中，我们经常会用到 View#post 来进行 View 宽高信息的获取。</p><p>那么问题就来了，为什么 View#post 就可以获取到宽高信息？里边那个 run() 是在什么时候执行的？具体实现原理又是什么？</p><p>带着这些疑问，我最近研究了一下 View#post 的源码。本来以为挺简单的一个东西，但是没想到坑越挖越深，最过分的是，不同的版本源码还不相同，实现原理也有细微的差别。集中攻克了一个周末以后，感觉大概理解了，索性写下篇博客进行记录备忘。</p><p>文章大概分为以下几个方面：</p><ul><li>View#post 基本使用</li><li>post() 执行过程以及源码分析</li><li>post() 中 Runnable#run 执行的时机</li><li>View#post 整体流程的简单总结</li><li>Android 7.0 里 View#post 的变动以及原因</li><li>致谢</li></ul><h3 id="View-post-基本使用"><a href="#View-post-基本使用" class="headerlink" title="View#post 基本使用"></a>View#post 基本使用</h3><p>具体代码如下：</p><pre><code class="java">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    View view = findViewById(R.id.test);    view.post(new Runnable() {        @Override        public void run() {            // 可以正常获取到 View 的宽高信息            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());        }    });}</code></pre><p>这里我们以 API 26 为例，来尝试解答一下这个问题。</p><p>实际上，Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别，具体的改动以及原因在后文会一一给出分析。</p><h3 id="post-执行过程以及源码分析"><a href="#post-执行过程以及源码分析" class="headerlink" title="post() 执行过程以及源码分析"></a>post() 执行过程以及源码分析</h3><h4 id="1-View-post-入口"><a href="#1-View-post-入口" class="headerlink" title="1. View#post 入口"></a>1. View#post 入口</h4><p>先来看 View#post 源码，重点注意注释：</p><pre><code class="java">/** * Causes the Runnable to be added to the message queue. * The runnable will be run on the user interface thread. * 将 Runnable 添加到执行队列中，其最终会在 UI 线程中执行 */public boolean post(Runnable action) {    // AttachInfo 是 View 的内部类，用来存储一些基本信息    // 此处可以暂时认为 mAttachInfo 为 null    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null) {        // attachInfo 不为空时，转而使用其内部的 Handler 对象操作        return attachInfo.mHandler.post(action);    }    // Postpone the runnable until we know on which thread it needs to run.    // Assume that the runnable will be successfully placed after attach.    // 在我们确定当前 Runnable 的目标运行线程之前，先将其推迟执行    // 假设在 attach 完成之后，此 Runnable 对象会被成功的「placed」（暂且翻译成「放置」）    // 好好理解一下这个注释，我们继续往下走    getRunQueue().post(action);    return true;}</code></pre><p>首先，明确一点：<strong>Runnable 会在 UI 线程中执行</strong>；</p><p>然后，我们来看一下这个看上去很重要的 <strong>mAttachInfo</strong> 是在哪里赋值的：</p><pre><code class="java">void dispatchAttachedToWindow(AttachInfo info, int visibility) {    mAttachInfo = info;    // Transfer all pending runnables. 转移所有待办任务    if (mRunQueue != null) {        mRunQueue.executeActions(info.mHandler);        mRunQueue = null;    }    // 回调方法    onAttachedToWindow();}</code></pre><p>先不在意除了赋值以外的其他操作，我们继续追踪 dispatchAttachedToWindow 方法，发现其最初调用是在 ViewRootImpl#performTraversals 方法。好了，记住这个结论，我们先把它放在一旁。</p><p>接下来，我们来看一看这个 <strong>getRunQueue().post()</strong> 又做了什么：</p><pre><code class="java">/** * 获取一个 RunQueue 对象，用来进行 post 操作 * Returns the queue of runnable for this view. * 注释是：为当前 View 对象返回一个执行队列，记住这个「当前 View 对象」 */private HandlerActionQueue getRunQueue() {    if (mRunQueue == null) {        mRunQueue = new HandlerActionQueue();    }    return mRunQueue;}</code></pre><h4 id="2-HandlerActionQueue-又是个啥"><a href="#2-HandlerActionQueue-又是个啥" class="headerlink" title="2. HandlerActionQueue 又是个啥"></a>2. HandlerActionQueue 又是个啥</h4><p>很明显，执行 post 方法的是 HandlerActionQueue 对象，那这又是个什么东西：</p><pre><code class="java">/** * Class used to enqueue pending work from Views when no Handler is attached. * 此类用于在当前 View 没有 Handler 依附的时候，将其待完成的任务入队 */public class HandlerActionQueue {    private HandlerAction[] mActions;    private int mCount;    // 这个就是我们在外边调用的 post 方法，最终会调用到 postDelayed 方法    public void post(Runnable action) {        postDelayed(action, 0);    }    // 将传入的 Runnable 对象存入数组中，等待调用    public void postDelayed(Runnable action, long delayMillis) {        final HandlerAction handlerAction = new HandlerAction(action, delayMillis);        synchronized (this) {            if (mActions == null) {                mActions = new HandlerAction[4];            }            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);            mCount++;        }    }    // 这里才是真的执行方法    public void executeActions(Handler handler) {        synchronized (this) {            final HandlerAction[] actions = mActions;            for (int i = 0, count = mCount; i &lt; count; i++) {                final HandlerAction handlerAction = actions[i];                handler.postDelayed(handlerAction.action, handlerAction.delay);            }            mActions = null;            mCount = 0;        }    }}</code></pre><p>通过查看 HandlerActionQueue 的源码，我们发现了一个问题：不同于在 onCreate() 直接获取 View 的宽高，我们调用 post 方法，其中的 run 方法并没有被马上执行。</p><p>这样就不难解释为什么用这种方式可以获取到宽高了。那我们可以猜测一下，这种情况下，一定是 View 完成测量后才执行了这个方法，所以我们才可以拿到宽高信息。</p><p>事实上也正是这样的，那么这个方法到底是在什么时候执行的呢？很明显，HandlerActionQueue#executeActions 才是真正完成调用的方法，那这个方法又做了些什么工作呢？</p><p><strong>根据代码可知，该方法接收一个 Handler，然后使用这个 Handler 对当前队列中的所有 Runnable 进行处理，即 post 到该 Handler 的线程中，按照优先级对这些 Runnable 依次进行处理。</strong></p><p><strong>简单来说，就是传入的 Handler 决定着这些 Runnable 的执行线程。</strong></p><p>接下来，我们来追踪这个方法的调用情况。</p><p><img src="http://upload-images.jianshu.io/upload_images/5419805-e0cf86fbea081bc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="executeActions() 的调用情况"></p><p>我们注意到，对于该方法出现了两次调用，一次在 View#dispatchAttachToWindow（就是我们最开始找到的那个方法），另一次是在 ViewRootImpl#performTraversals。</p><h4 id="3-万恶之源-performTraversals"><a href="#3-万恶之源-performTraversals" class="headerlink" title="3. 万恶之源 performTraversals()"></a>3. 万恶之源 performTraversals()</h4><p>很明显，所有的证据都指向了 performTraversals ，那么下面我们就来重点分析一下这个方法。</p><p>如果你了解过 View 的测绘流程，那你对这个方法一定不会陌生，因为这个方法就是 View 绘制流程的起点。</p><pre><code class="java">private void performTraversals() {    // 此处的 host 是根布局 DecorView，用递归的方式一层一层的调用 dispatchAttachedToWindow    // mAttachInfo 是不是很眼熟，就是最开始 View#post 的第一层判断    // 这个 mAttachInfo 在 ViewRootImpl 的构造器中初始化的，其持有 ViewRootImpl 的 Handler 对象    host.dispatchAttachedToWindow(mAttachInfo, 0);    getRunQueue().executeActions(mAttachInfo.mHandler);    // 绘制流程就从这里开始    performMeasure();    performLayout();    performDraw();}</code></pre><p>我们先从 dispatchAttachedToWindow 开始，我们之前已经看过这个方法的源码了：</p><pre><code class="java">void dispatchAttachedToWindow(AttachInfo info, int visibility) {    mAttachInfo = info;    // Transfer all pending runnables. 转移所有待办任务    if (mRunQueue != null) {        mRunQueue.executeActions(info.mHandler);        mRunQueue = null;    }    // 回调方法    onAttachedToWindow();}</code></pre><p><strong>现在来进行分析：</strong></p><ol><li>我们已经知道了此方法是从根视图开始递归向下调用的，那么递归到最深处，就会轮到最开始我们调用 post 方法的 View 对象来执行该方法，也就是该方法内的所有属性，都是我们 findViewById 获得的那个 View 对象的属性；</li><li>而且我们也知道，第一个参数 AttachInfo 就是 ViewRootImpl 中初始化的 AttachInfo，它持有当前 ViewRootImpl 的 Handler 对象引用，并将该引用传给了 executeActions()。此时，我们再来回顾一下 <strong>executeActions()</strong> 方法的作用，<strong>传入的 Handler 决定着队列里这些 Runnable 的执行线程</strong>。</li></ol><p>很明显，此处的 mRunQueue 就是我们最开始调用 post() 时，调用 View#getRunQueue 返回的那个对象，这个对象中有准备获取View高度的 Runnable 对象，也就是说 <strong>mRunQueue 通过调用 executeActions() 将当前 View 的所有 Runnable ，都会转由 ViewRootImpl 的 Handler 来处理！</strong>而在完成这个工作之后，当前 View 也显示地将 mRunQueue 置空，因为所有的待办任务都已经交给 ViewRootImpl 去处理了。</p><p>现在再回过头看代码的注释，就差不多可以理解了：</p><pre><code class="java">// Postpone the runnable until we know on which thread it needs to run.// Assume that the runnable will be successfully placed after attach.// 所有的 Runnable 都会在 attach 之后被正确的放到其应该运行的线程上去getRunQueue().post(action);// Transfer all pending runnables.// 转移所有待办任务(到 ViewRootImpl 中进行处理)if (mRunQueue != null) {    mRunQueue.executeActions(info.mHandler);    mRunQueue = null;}</code></pre><p>dispatch 方法执行完了，我们继续回来走 performTraversals() ，接下来一句是：</p><pre><code class="java">// 有之前的经验，我们知道这句话的意思是// 使用 mAttachInfo.mHandler 来处理 getRunQueue() 中的 Runnable 任务getRunQueue().executeActions(mAttachInfo.mHandler);</code></pre><p>要明确的一点是，此时我们处在 ViewRootImpl 类中，此处的 getRunQueue() 方法有别于 View#post：</p><pre><code class="java">// ViewRootImpl#getRunQueue// 使用 ThreadLocal 来存储每个线程自身的执行队列 HandlerActionQueuestatic HandlerActionQueue getRunQueue() {    // sRunQueues 是 ThreadLocal&lt;HandlerActionQueue&gt; 对象    HandlerActionQueue rq = sRunQueues.get();    if (rq != null) {        return rq;    }    rq = new HandlerActionQueue();    sRunQueues.set(rq);    return rq;}// View#post// 为当前 View 返回一个执行队列，但是在 dispatchAttachToWindow 时转到 UI 线程去private HandlerActionQueue getRunQueue() {    if (mRunQueue == null) {        mRunQueue = new HandlerActionQueue();    }    return mRunQueue;}</code></pre><p>说回 performTraversals() ，很明显 getRunQueue() 是 UI 线程执行队列的第一次初始化，也就是说当前这个任务队列里并没有待执行任务！</p><p>但是需要注意的是，<strong>当前没有执行任务（</strong>HandlerActionQueue<strong>），不代表 Handler 消息队列中没有消息</strong>，这是两个概念，需要注意区分开。</p><p>总结一下：</p><ol><li>View#post 方法调用时，会为当前 View 对象初始化一个 HandlerActionQueue ，并将 Runnable 入队存储；</li><li>等在 ViewRootImpl#performTraversals 中递归调用到 View#dispatchAttachedToWindow 时，会将 ViewRootImpl 的 Handler 对象传下来，然后通过这个 Handler 将最初的 Runnable 发送到 UI 线程（消息队列中）等待执行，并将 View 的 HandlerActionQueue 对象置空，方便回收；</li><li>ViewRootImpl#performTraversals 继续执行，才会为 UI 线程首次初始化 HandlerActionQueue 对象，并通过 ThreadLocal 进行存储，方便之后的复用，但需要注意的是，此处初始化的队列中是没有任何 Runnable 对象的；</li><li>然后 ViewRootImpl#performTraversals 继续执行，开始 View 的测量流程。</li></ol><h3 id="View-post-中-Runnable-run-执行的时机"><a href="#View-post-中-Runnable-run-执行的时机" class="headerlink" title="View#post 中 Runnable#run 执行的时机"></a>View#post 中 Runnable#run 执行的时机</h3><p>但现在的问题是，无论怎么说，<strong>HandlerActionQueue#executeActions 都是先于 View 测绘流程的</strong>，为什么在还没有完成测量的时候，就可以拿到宽高信息？</p><p>我们都知道，Android 系统是基于消息机制运行的，所有的事件、行为，都是基于 Handler 消息机制在运行的。所以，当 ViewRootImpl#performTraversals 在执行的时候，也一定是基于某个消息的。而且，HandlerActionQueue#executeActions 执行的时候，也只是通过 Handler 将 Runnable post 到了 UI 线程等待执行（还记得 View#post 的注释吗？）。</p><p>不出意外的话，此时 UI 线程正忙着执行 ViewRootImpl#performTraversal ，等该方法执行完毕，View 已经完成了测量流程，此时再去执行 Runnable#run ，也就自然可以获取到 View 的宽高信息了。</p><p>下面用具体的实例佐证一下我们的猜想。</p><pre><code class="JAVA">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    final ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();    // 等待 Add 到父布局中    view = new View(this) {        @Override        protected void onLayout( ... ... ) {            super.onLayout(changed, left, top, right, bottom);            Log.e(&quot;Test&quot;, &quot;执行了onLayout()&quot;);        }    };    // 自己声明的 Handler     mHandler.post(new Runnable() {        @Override        public void run() {            Log.e(&quot;Test&quot;, &quot;mHandler.post ---- &gt; &quot; + view.getHeight());        }    });    // onCreate() 中 mAttachInfo 还未被赋值，这里会交给 ViewRootImpl 的 Handler 来处理    // 即加入消息队列，等待执行    view.post(new Runnable() {        @Override        public void run() {            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());        }    });    viewGroup.addView(view);}</code></pre><p>最终打印日志如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5419805-ec13fe6929791de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>也就是说：</p><ol><li>Handler#post 首先执行，其 post 的时间点在 onCreate() 方法内，在消息队列中的位置一定比 performTraversals() 靠前；</li><li>ViewRootImpl#performTraversal 执行，过程中执行了 View#dispatchAttachedToWindow 方法，将最初的 Runnable 入队后进行测量流程，完成了 layout 过程；</li><li>之后才执行了最初的 View#post 方法，也就说明了，在 View#dispatchAttachedToWindow 中使用 ViewRootImpl 的 Handler postDelay 的 Runnable 对象，在主线程消息队列中，确实是排在 ViewRootImpl#performTraversal 之后的</li></ol><h3 id="View-post-整体流程的简单总结"><a href="#View-post-整体流程的简单总结" class="headerlink" title="View#post 整体流程的简单总结"></a>View#post 整体流程的简单总结</h3><p>最后大概总结一下：</p><p>当我们使用 View#post 时，会有两种情况：</p><ol><li>在当前 View attach 到 Window 之前，会自己先维护一个 HandlerActionQueue 对象，用来存储当前的 Runnable 对象，然后等到 Attach 到 Window 的时候 (也就是 ViewRootImpl 执行到 performTraversal 方法时) ，会统一将 Runnable 转交给 ViewRootImpl 处理；</li><li>而在 View#dispatchAttachedToWindow 时，也会为当前 View 初始化一个 AttachInfo 对象，该对象持有 ViewRootImpl 的引用，当 View 有此对象后，后续的所有 Runnable 都将直接交给 ViewRootImpl 处理；</li><li>而 ViewRootImpl 也会在执行 performTraversal 方法，也会调用 ViewRootImpl#getRunQueue ，利用 ThreadLocal 来为主线程维护一个 HandlerActionQueue 对象，至此，ViewRootImpl 内部都将使用该队列来进行 Runnable 任务的短期维护；</li><li>但需要注意的是，各个 View 调用的 post 方法，仍然是由各自的 HandlerActionQueue 对象来入队任务的，然后在 View#dispatchAttachedToWindow 的时候转移给 ViewRootImpl 去处理。</li></ol><h3 id="Android-7-0-里-View-post-的变动以及原因"><a href="#Android-7-0-里-View-post-的变动以及原因" class="headerlink" title="Android 7.0 里 View#post 的变动以及原因"></a>Android 7.0 里 View#post 的变动以及原因</h3><p>View#post 说到这里大概就差不多了，文章开篇的时候说到：</p><blockquote><p>Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别</p></blockquote><p>下面来简单对比一下具体的差别，顺便分析一下具体为什么要这样改动。</p><p>实际上这个方法的改动主要是为了解决一个 bug，这个 bug 就是：<strong>在 View 被 attach 到 window 之前，从子线程调用的 View#post ，永远无法得到执行。</strong></p><p>具体原因，我们来看一下 API23 版本的 View#post，就大概都明白了：</p><pre><code class="java">// Android API23 View#postpublic boolean post(Runnable action) {    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null) {        return attachInfo.mHandler.post(action);    }    // Assume that post will succeed later    // 注意此处，不同于我们之前介绍的，这里是直接使用 ViewRootImpl#getRunQueue 来入队任务的    ViewRootImpl.getRunQueue().post(action);    return true;}</code></pre><p>我们可以看到，不同于我们之前介绍的，API23 版本中，View#post 在没有 attach 到 window 之前，也就是 mAttachInfo 是 null 的时候，不是自己维护任务队列，而是直接使用 ViewRootImpl#getRunQueue 来入队任务的。</p><p>再来看一下 ViewRootImpl#getRunQueue 方法，我们就会发现问题出在哪里了：</p><pre><code class="java">static final ThreadLocal&lt;RunQueue&gt; sRunQueues = new ThreadLocal&lt;RunQueue&gt;();static RunQueue getRunQueue() {    RunQueue rq = sRunQueues.get();    if (rq != null) {        return rq;    }    rq = new RunQueue();    sRunQueues.set(rq);    return rq;}</code></pre><p>没错，这个队列的保存与获取，是通过以线程为 key 值来存取对象 ThreadLocal 来维护的。而在这个版本的源码中，executeActions() 方法的执行，只有一次调用，那就是 ViewRootImpl#performTraversal 中（感兴趣的可以去 23 版本的源码中查看，这里就不贴图了），与此同时，该方法肯定是执行在主线程中的。</p><p>现在的问题就变成了：<strong>我在子线程中 post 了一个 runnable，并且系统以该子线程为 key 将队列存了起来等待执行；但是在具体执行的时候，系统却是去主线程中寻找待执行的 Runnable，那么当然是永远都得不到执行的了。</strong></p><p>而在<strong>具体 attach 到 window 之后</strong>，View 的 mAttachInfo 持有 ViewRootImpl 引用，会直接将所有的 Runnable 转交给 ViewRootImpl 的 Handler 处理，也<strong>就都能得到妥善处理，就与线程无关了。</strong></p><p>除此以外，ViewRootImpl 使用 ThreadLocal 来存储队列信息，在某些情境下，还会导致内存泄漏。详细信息可以参考：<a href="https://blog.csdn.net/a740169405/article/details/69668957" target="_blank" rel="noopener">https://blog.csdn.net/a740169405/article/details/69668957</a></p><p>所以，<strong>Google 工程师为了解决这两个问题（内存泄漏的问题更严重一些），就在 View#post 方法中使用 View 对象来进行队列的存储，然后在 attach 到 window 的时候，通过持有 ViewRootImpl 引用的 AttachInfo 对象直接将 View 对象的 Runnable 处理掉，就完美解决了这些问题。</strong></p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>下边是自己研究的时候具体参考过的文章，给各位前辈加个鸡腿：</p><h5 id="https-blog-csdn-net-a740169405-article-details-69668957"><a href="#https-blog-csdn-net-a740169405-article-details-69668957" class="headerlink" title="https://blog.csdn.net/a740169405/article/details/69668957"></a><a href="https://blog.csdn.net/a740169405/article/details/69668957" target="_blank" rel="noopener">https://blog.csdn.net/a740169405/article/details/69668957</a></h5><h5 id="https-blog-csdn-net-scnuxisan225-article-details-49815269"><a href="#https-blog-csdn-net-scnuxisan225-article-details-49815269" class="headerlink" title="https://blog.csdn.net/scnuxisan225/article/details/49815269"></a><a href="https://blog.csdn.net/scnuxisan225/article/details/49815269" target="_blank" rel="noopener">https://blog.csdn.net/scnuxisan225/article/details/49815269</a></h5><h5 id="https-www-cnblogs-com-plokmju-p-7481727-html"><a href="#https-www-cnblogs-com-plokmju-p-7481727-html" class="headerlink" title="https://www.cnblogs.com/plokmju/p/7481727.html"></a><a href="https://www.cnblogs.com/plokmju/p/7481727.html" target="_blank" rel="noopener">https://www.cnblogs.com/plokmju/p/7481727.html</a></h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>为何 Android 在 onCreate 中获取不到宽高</title>
    <link href="http://joeljt.top/2018/08/13/can-not-get-height-in-onCreate/"/>
    <id>http://joeljt.top/2018/08/13/can-not-get-height-in-onCreate/</id>
    <published>2018-08-12T16:00:00.000Z</published>
    <updated>2019-03-21T10:50:48.542Z</updated>
    
    <content type="html"><![CDATA[<p>经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。</p><a id="more"></a><p>具体代码如下：</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    @BindView(R.id.tv_test)    private TextView mTextView;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mTv.getHeight(); // 0    }    @Override    protected void onResume() {        super.onResume();        mTv.getHeight(); // 0    }}</code></pre><p>要弄清这个问题，首先需要知道代码中涉及到的方法具体做了什么工作，以及具体 View 是在什么时候完成测量的。</p><h3 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView()"></a>setContentView()</h3><p>很明显，我们在 onCreate() 方法中调用了 setContentView() 方法，而<strong>设置布局</strong>这个动作会给你一种可以获取到宽高的错觉；那么我们从源码的角度来看看，setContentView() 到底干了点什么。</p><pre><code class="java">// 1. AppCompatDelegate 的抽象方法，根据注释，会调用到 Activity 的实现方法中public abstract void setContentView(@LayoutRes int resId);// 2. Activity 的实现方法public void setContentView(@LayoutRes int layoutResID) {    // Window 是一个抽象类，其唯一实现类是 PhoneWindow    getWindow().setContentView(layoutResID);    initWindowDecorActionBar();}@Overridepublic void setContentView(int layoutResID) {    if (mContentParent == null) {        // 3. 初始化 DecorView        installDecor();    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {        mContentParent.removeAllViews();    }    ... ...}private void installDecor() {    mForceDecorInstall = false;    if (mDecor == null) {        // 4. 第一次加载窗口，mDecor 为空时，生成一个 DecorView 对象        // generateDecor(-1) : return new DecorView()        mDecor = generateDecor(-1);        ... ...    } else {        mDecor.setWindow(this);    }    if (mContentParent == null) {        // 5. 初始化父布局        mContentParent = generateLayout(mDecor);    }}// 继续跟踪到 generateLayout(mDecor) 方法内部protected ViewGroup generateLayout(DecorView decor) {    // 此处根据设置的主题进行一些基础设置，没什么决定性作用    TypedArray a = getWindowStyle();    ... ...    // 接下来的一大段代码是根据各种主题设置默认布局，篇幅原因，此处有大量源码删减    int layoutResource;    int features = getLocalFeatures();    if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) {        layoutResource = R.layout.screen_swipe_dismiss;        setCloseOnSwipeEnabled(true);    } else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) {        if (mIsFloating) {            TypedValue res = new TypedValue();            getContext().getTheme().resolveAttribute(                R.attr.dialogTitleDecorLayout, res, true);            layoutResource = res.resourceId;        } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) {            layoutResource = a.getResourceId(                R.styleable.Window_windowActionBarFullscreenDecorLayout,                R.layout.screen_action_bar);        } else {            layoutResource = R.layout.screen_title;        }    } else {        // 默认布局样式        layoutResource = R.layout.screen_simple;    }    // 6. 重点来了：将对应的布局加载到 DecorView 中    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);    return contentParent;}void onResourcesLoaded(LayoutInflater inflater, int layoutResource) {    // 加载资源文件    final View root = inflater.inflate(layoutResource, null);    ... ...    // 7. 将 View 加载到当前 DecorView 中    addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));}public void addView(View child, int index, LayoutParams params) {    // 页面发生变化的话，请求重新摆放布局以及重新绘制    // 注意，此处的 requestLayout 是 View 的方法    requestLayout();    invalidate(true);    addViewInner(child, index, params, false);}</code></pre><p>说出来你可能不信，但是 setContentView() 到这里就差不多结束了。</p><p>很明显，我们并没有发现任何关于 View 的测量的代码，最后的 requestLayout() 和 invalidate() 也和 View 的 measure() 关系不大，毕竟还没测量，哪里谈得上 layout 和 draw 呢？</p><p>所以， setContentView() 和 View 的测量没啥关系，那么在其之后也就自然获取不到 View 宽高的值了。</p><h3 id="测量流程到底是从哪里开始的"><a href="#测量流程到底是从哪里开始的" class="headerlink" title="测量流程到底是从哪里开始的"></a>测量流程到底是从哪里开始的</h3><p>有了上面的经验，我们已经知道，setContentView() 并不会触发 View 的测量，而只是为 DecorView 指定了布局；那么接下来的问题就是，测量流程到底是从哪里开始的呢？</p><p>我们简单回顾一下 Activity 的启动流程，然后来找到这个答案。</p><pre><code class="java">public void handleMessage(Message msg) {    switch (msg.what) {        case LAUNCH_ACTIVITY: {            // 1. ActivityThread 内部类 H，处理 LAUNCH_ACTIVITY 的消息            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);        } break; }// 2. 直接从 ActivityThread 的 handleLaunchActivity() 开始了private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {    // 3. 执行 performLaunchActivity() 方法    Activity a = performLaunchActivity(r, customIntent);    if (a != null) {        r.createdConfig = new Configuration(mConfiguration);        reportSizeConfigurations(r);        Bundle oldState = r.state;        // 4. 执行 handleResumeActivity() 方法        handleResumeActivity(r.token, false, r.isForward,                             !r.activity.mFinished &amp;&amp; !r.startsNotResumed,                             r.lastProcessedSeq, reason);    }}// 3. performLaunchActivity()private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {    // 基于反射，利用 Instrumentation 对象创建当前 Activity 的实例    Activity activity = null;    try {        java.lang.ClassLoader cl = appContext.getClassLoader();        activity = mInstrumentation.newActivity(            cl, component.getClassName(), r.intent);        StrictMode.incrementExpectedActivityCount(activity.getClass());        r.intent.setExtrasClassLoader(cl);        r.intent.prepareToEnterProcess();        if (r.state != null) {            r.state.setClassLoader(cl);        }    }    try {        if (activity != null) {            // attach() 方法做了一系列最基本的初始化            activity.attach(appContext, this, getInstrumentation(), r.token,                            r.ident, app, r.intent, r.activityInfo, title, r.parent,                            r.embeddedID, r.lastNonConfigurationInstances, config,                            r.referrer, r.voiceInteractor, window, r.configCallback);            activity.mCalled = false;            // 3.1 依然使用 Instrumentation 对象调用 Activity 的 onCreate() 方法            if (r.isPersistable()) {                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);            } else {                mInstrumentation.callActivityOnCreate(activity, r.state);            }            // 强制校验 super 调用            if (!activity.mCalled) {                throw new SuperNotCalledException(                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +                    &quot; did not call through to super.onCreate()&quot;);            }        }    }    return activity;}public void callActivityOnCreate(Activity activity, Bundle icicle,PersistableBundle persistentState) {    prePerformCreate(activity);    // 3.2 调用 Activity 的 performCreate() 方法    activity.performCreate(icicle, persistentState);    postPerformCreate(activity);}// 3.3 最终得以调用到实际实现的 onCreate()final void performCreate(Bundle icicle, PersistableBundle persistentState) {    restoreHasCurrentPermissionRequest(icicle);    onCreate(icicle, persistentState);    mActivityTransitionState.readState(icicle);    performCreateCommon();}// 4 performLaunchActivity() 执行完毕后，根据代码来看，会继续执行 handleResumeActivity()// 同样的，这个方法会调用到一个 performResumeActivity()，在该方法内部也会最终执行到 onResume() final void handleResumeActivity( ... ... ) {     // 最终会执行到 onResume()，不是重点     r = performResumeActivity(token, clearHide, reason);     if (r != null) {         final Activity a = r.activity;         if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {             r.window = r.activity.getWindow();             View decor = r.window.getDecorView();             ViewManager wm = a.getWindowManager();             // 5. 执行到 WindowManagerImpl 的 addView()             // 然后会跳转到 WindowManagerGlobal 的 addView()             if (a.mVisibleFromClient) {                 if (!a.mWindowAdded) {                     a.mWindowAdded = true;                     wm.addView(decor, l);                 }             }         }     } }public void addView( ... ... ) {     ViewRootImpl root;     synchronized (mLock) {         // 初始化一个 ViewRootImpl 的实例         root = new ViewRootImpl(view.getContext(), display);         try {             // 调用 setView，为 root 布局 setView             // 其中 view 为传下来的 DecorView 对象             // 也就是说，实际上根布局并不是我们认为的 DecorView，而是 ViewRootImpl             root.setView(view, wparams, panelParentView);         }     }}// 6. 将 DecorView 加载到 WindowManager, View 的绘制流程从此刻才开始public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {    // 请求对 View 进行测量和绘制    // 与 setContentView() 不同，此处的方法是 ViewRootImpl 的方法    requestLayout();}@Overridepublic void requestLayout() {    if (!mHandlingLayoutInLayoutRequest) {        checkThread();        mLayoutRequested = true;        // 7. 此方法内部有一个 post 了一个 Runnable 对象        // 在其中又调用一个 doTraversal() 方法；        // 再之后又会调用到 performTraversals() 方法，然后 View 的测绘流程就从此处开始了        scheduleTraversals();    }}private void performTraversals() {    ... ...    // Ask host how big it wants to be    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);    ... ...    performLayout(lp, mWidth, mHeight);    ... ...    performDraw();    ... ...}</code></pre><p>问题到这里就差不多得到了解答，View 的测绘流程是在 performTraversals() 才开始的；而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的宽高信息也就很容易理解了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 字体变色</title>
    <link href="http://joeljt.top/2018/08/12/color-track-textview/"/>
    <id>http://joeljt.top/2018/08/12/color-track-textview/</id>
    <published>2018-08-11T16:00:00.000Z</published>
    <updated>2019-03-21T10:33:43.994Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>主要技术点：Canvas.clipRect()</p></blockquote><p>实际上，这个方法可以理解成裁剪画布；</p><p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p><p>而这块区域，就是接下来将要进行绘制的区域。</p><p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p><pre><code class="java">@Overrideprotected void onDraw(Canvas canvas) {    // 绘制前一半内容    drawText(canvas, mChangePaint, 0, getWidth()/2);    // 使用另一颜色的画笔绘制后一半内容    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());}private void drawText(Canvas canvas, Paint paint, int start, int end) {    paint.setTextSize(getTextSize());    // 保存当前画布状态    canvas.save();    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制    Rect rect = new Rect(start, 0, end, getHeight());    canvas.clipRect(rect);    // 获取文字的基本宽高信息    String text = getText().toString();    Rect textBounds = new Rect();    paint.getTextBounds(text, 0, text.length(), textBounds);    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();    // 获取起始位置    int x = getWidth() / 2 - textBounds.width() / 2;    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;    canvas.drawText(text, x, y, paint);    // 清空画布属性，方便接下来绘制变色的部分    canvas.restore();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;主要技术点：Canvas.clipRect()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，这个方法可以理解成裁剪画布；&lt;/p&gt;
&lt;p&gt;方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下
      
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>解决可视化工具对于 MySQL 8.0 + 无法连接的问题</title>
    <link href="http://joeljt.top/2018/05/28/bug-of-mysql/"/>
    <id>http://joeljt.top/2018/05/28/bug-of-mysql/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。</p><a id="more"></a><p>同时还更改了加密方式，之前版本的加密方式是「mysql_native_password」，8.0 之后的加密规则更改为「caching_sha2_password 」，这里需要把用户密码加密规则更改为原来的加密方式即可。</p><p>具体方法步骤如下，记录备忘：</p><blockquote><p> 打开终端，输入命令</p></blockquote><pre><code class="mysql">mysql -u root -p</code></pre><blockquote><p>需要注意的是，MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，至少 8 个字符；密码是在最开始安装 MySQL 的时候设置的，如果忘记了，上网查询解决方法。</p></blockquote><blockquote><p>输入密码后，进入 &gt;mysql 的命令行模式</p></blockquote><pre><code class="mysql"># 切换到 mysql 数据库use mysql;# 设置用户密码永不过期alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;your pwd&#39; password expire never;# 用「mysql_native_password」加密方式更新 root 用户密码alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;your pwd&#39;;# 刷新flush privileges;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Canvas.drawPath() 简单使用记录</title>
    <link href="http://joeljt.top/2018/05/28/Canvas.drawPath()/"/>
    <id>http://joeljt.top/2018/05/28/Canvas.drawPath()/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2019-03-21T10:55:48.335Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>Path类将多种复合路径（多个轮廓，如直线段、二次曲线、立方曲线）封装在其内部的几何路径。</p><p>也就是说，我们可以使用 drawPath() 来绘制一个多边形或者不规则图形。</p></blockquote><p>下面以等边三角形为例：</p><pre><code class="java">// 假设在固定大小内绘制一个等边三角形private void drawTriangle(Canvas canvas, Paint paint) {    Path mPath = new Path();    // moveTo 移动到某一点，用于确定下笔坐标    mPath.moveTo(getWidth() / 2, 0);    // 连线到某一点，开始绘制，目标点 y 坐标是长直角边的长度    // 等边三角形，从顶点向下做高，短直角边:斜边:长直角边 = 1:2:√3    mPath.lineTo(0, getWidth() / 2 * Math.sqrt(3)));    mPath.lineTo(getWidth(), getWidth() / 2 * Math.sqrt(3)));    // 闭合多边形，即连线回到起始点，完成绘制    mPath.close();    canvas.drawPath(mPath, mPaint);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Path类将多种复合路径（多个轮廓，如直线段、二次曲线、立方曲线）封装在其内部的几何路径。&lt;/p&gt;
&lt;p&gt;也就是说，我们可以使用 drawPath() 来绘制一个多边形或者不规则图形。&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Paint .measureText() VS .getTextBounds()</title>
    <link href="http://joeljt.top/2018/03/29/Android%20Paint-%20.measureText()%20VS%20.getTextBounds()/"/>
    <id>http://joeljt.top/2018/03/29/Android Paint- .measureText() VS .getTextBounds()/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-11-26T10:43:06.981Z</updated>
    
    <content type="html"><![CDATA[<p>两个方法可以用来测量文字宽高信息的，只不过 <strong>.getTextBounds()</strong> 还可以获得高度信息，因为其使用一个 Rect 对象对宽高信息进行存储；而 <strong>.measureText()</strong> 则只是返回宽度信息。</p><a id="more"></a><p>具体使用方法如下：</p><pre><code class="java">final String someText = &quot;Hello. I&#39;m some text!&quot;;Paint mPaint = new Paint();// .measureText()float measuredWidth = mPaint.measureText(someText);// .getTextBounds()Rect mBounds = new Rect();mPaint.getTextBounds(someText, 0, someText.length, mBounds);int measuredWidth = mBounds.width();int measuredHeight = mBounds.height();</code></pre><p>但是，当我们把两个结果打印出来，我们会发现，对于同一个文本信息，使用两个方法得到的宽度是不同的：</p><pre><code class="java">// 打印宽度信息Log.d(&quot;Test&quot;, String.format(        &quot;Text is &#39;%s&#39;, measureText %f, getTextBounds %d&quot;,        someText,        measuredWidth,        mBounds.width())    );// 打印结果如下// Text is &#39;Hello. I&#39;m some text!&#39;, measureText 115.000000, getTextBounds 105</code></pre><p>经过一系列的探究和资料查看，最后得到的结论是：</p><blockquote><p>二者返回结果确实不同，且 measureText() 返回结果会略微大于 getTextBounds() 所得到的宽度信息</p><p>measureText() 会在文本的左右两侧加上一些额外的宽度，这部分额外的宽度叫做 Glyph’s AdvanceX （具体应该是属于字型方面的范畴，我猜测这部分宽度是类似字间距之类的东西）</p><p>getTextBounds() 返回的则是当前文本所需要的最小宽度，也就是整个文本外切矩形的宽度</p></blockquote><p>实际上，这两个方法在具体调用时虽然都是不同的方法，但在 native 层的测量算法都是一致的，只不过在最后返回时，measureText() 会在左右两侧加上一些额外的宽度值，而 getTextBounds() 则是返回需要的最小宽度而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个方法可以用来测量文字宽高信息的，只不过 &lt;strong&gt;.getTextBounds()&lt;/strong&gt; 还可以获得高度信息，因为其使用一个 Rect 对象对宽高信息进行存储；而 &lt;strong&gt;.measureText()&lt;/strong&gt; 则只是返回宽度信息。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字体变色效果实现分析</title>
    <link href="http://joeljt.top/2018/03/19/TrackColorTextView/"/>
    <id>http://joeljt.top/2018/03/19/TrackColorTextView/</id>
    <published>2018-03-18T16:00:00.000Z</published>
    <updated>2018-11-26T10:40:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要技术点：Canvas.clipRect()</p></blockquote><p>实际上，这个方法可以理解成裁剪画布；</p><p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p><p>而这块区域，就是接下来将要进行绘制的区域。</p><p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p><pre><code class="java">@Overrideprotected void onDraw(Canvas canvas) {    // 绘制前一半内容    drawText(canvas, mChangePaint, 0, getWidth()/2);    // 使用另一颜色的画笔绘制后一半内容    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());}private void drawText(Canvas canvas, Paint paint, int start, int end) {    paint.setTextSize(getTextSize());    // 保存当前画布状态    canvas.save();    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制    Rect rect = new Rect(start, 0, end, getHeight());    canvas.clipRect(rect);    // 获取文字的基本宽高信息    String text = getText().toString();    Rect textBounds = new Rect();    paint.getTextBounds(text, 0, text.length(), textBounds);    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();    // 获取起始位置    int x = getWidth() / 2 - textBounds.width() / 2;    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;    canvas.drawText(text, x, y, paint);    // 清空画布属性，方便接下来绘制变色的部分    canvas.restore();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;主要技术点：Canvas.clipRect()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，这个方法可以理解成裁剪画布；&lt;/p&gt;
&lt;p&gt;方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中多态的具体应用</title>
    <link href="http://joeljt.top/2018/03/09/polymorphism-of-java/"/>
    <id>http://joeljt.top/2018/03/09/polymorphism-of-java/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例</p><pre><code>// 父类public class Parent {    public int aInt = -1;    public void func1() {        System.err.print(&quot; Parent func1 &quot;);    }    public void func2() {        System.err.print(&quot; Parent func2 &quot;);    }}</code></pre><pre><code>// 子类public class Child extends Parent {    public int aInt = 1;    public void func1() {        System.err.print(&quot; Child func1 &quot;);    }    public void func3() {        System.err.print(&quot; Child func3 &quot;);    }}</code></pre><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><pre><code>// test main()public static void main(String[] args) {    Child child = new Child();    child.func1();    child.func2();    child.func3();    Parent parent = new Child();    parent.func1();    parent.func2();    parent.func3();}</code></pre><p>如上所示，将对象声明为Child对象时，三个方法都编译通过，且输入结果如下：</p><pre><code>Child func1Parent func2Child func3</code></pre><p>Child类重写了父类的func1()方法，则在运行时匹配了子类自身的重写方法，即，「运行时遵循右侧声明」。<br>但是，如果将对象声明为Parent对象时，parent.fun3()则会报错，因为「编译期遵循左侧实例」，当前对象被声明为Parent实例，而Parent中没有func3()方法，所以编译不通过。同时也正因为「运行时遵循右侧声明」，所以其运行结果如下：</p><pre><code>Child func1 // 尽管声明为Parent实例，但实际调用Child的方法Parent func2</code></pre><p>综上所述，在多态使用时，成员函数遵循两个原则，即「编译期遵循左侧实例，运行时遵循右侧声明」</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><pre><code>// test main()public static void main(String[] args) {    Parent parent = new Child();    Child child = new Child();    System.err.println(parent.aInt);    System.err.println(child.aInt);}</code></pre><p>运行结果如下：</p><pre><code>-11</code></pre><p>可以发现，打印结果与成员函数有所不同。因为如果是成员函数，运行时遵循右侧声明的话，打印结果应该相等，同为1才对。因此，成员变量在多态情境下的使用，无论编译还是运行，通通遵循左侧实例。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>成员函数<br>编译时遵循左侧实例，运行时遵循右侧声明</li><li>成员变量<br>编译或者运行一律遵循左侧实例</li></ul><p>其实也比较好理解，编译期间，当前类下不存在的成员函数或成员变量，肯定是无法被实例对象获取到的；<br>而在运行时，java中子类可以重写父类的方法，因此成员函数运行时会正确指向子类的方法，但是，子类并不可以重写父类的变量，当子类与父类有同名变量时，需要使用this和super关键字进行区分。在这种情况下，成员变量的访问则不可能像方法一样使用多态访问，因此只能是遵循左侧的实例了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 父类
public class Parent {
    public int aInt = -1;
    public void func1() {
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://joeljt.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
