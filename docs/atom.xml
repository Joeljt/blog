<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe&#39;s blog</title>
  
  <subtitle>emmmmm</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joeljt.top/"/>
  <updated>2019-03-29T08:47:59.124Z</updated>
  <id>http://joeljt.top/</id>
  
  <author>
    <name>joe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>View.inflate() 的前世今生</title>
    <link href="http://joeljt.top/2019/03/29/View-inflate-analysis/"/>
    <id>http://joeljt.top/2019/03/29/View-inflate-analysis/</id>
    <published>2019-03-28T16:00:00.000Z</published>
    <updated>2019-03-29T08:47:59.124Z</updated>
    
    <content type="html"><![CDATA[<p>误用 LayoutInflater 的 inflate() 方法已经不是什么稀罕事儿了……</p><a id="more"></a><p>做 Android 开发做久了，一定会或多或少地对布局的渲染有一些懵逼：</p><blockquote><ol><li><code>View.inflate()</code> 和 <code>LayoutInflator.from().inflate()</code> 有啥区别？</li><li>调用 inflate() 方法的时候有时候传 null，有时候传 parent 是为啥？</li><li>用 LayoutInflater 有时候还可能传个 attachToRoot ，这又是个啥？</li></ol></blockquote><p>接下来我们就从源码的角度来寻找一下这几个问题的答案，后面再用几个示例来验证我们的猜想。</p><p>话不多说，Let’s go !</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>先来看一下这个方法具体做了什么：</p><pre><code class="java">/** * Inflate a view from an XML resource.  This convenience method wraps the {@link * LayoutInflater} class, which provides a full range of options for view inflation. */public static View inflate(Context context, int resource, ViewGroup root) {    LayoutInflater factory = LayoutInflater.from(context);    return factory.inflate(resource, root);}</code></pre><p>当我们查看源码，就会发现，这个方法的内部实际上就是调用了 <code>LayoutInflater</code> 的 inflate 方法。正如此方法的注释所言，这是一个方便开发者调用的 <code>LayoutInflater</code> 的包装方法，而 <code>LayoutInflater</code> 本身则为 View 的渲染提供了更多的选择。</p><p>那么我们现在的问题就变成了， <code>LayoutInflater</code> 又做了什么？</p><p>继续追踪代码，我们会发现， <code>LayoutInflator.from().inflate()</code>  是这个样子的：</p><pre><code class="java">// LayoutInflator#inflate(int, ViewGroup)public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {        return inflate(resource, root, root != null);}</code></pre><p>啥？重载？</p><pre><code class="java">// LayoutInflator#inflate(int, ViewGroup, boolean)public View inflate(int resource, ViewGroup root, boolean attachToRoot) {    final Resources res = getContext().getResources();    final XmlResourceParser parser = res.getLayout(resource);    try {        return inflate(parser, root, attachToRoot);    } finally {        parser.close();    }}</code></pre><p>这里我们看到，通过层层调用，最终会调用到 <code>LayoutInflator#inflate(int, ViewGroup, boolean)</code> 方法，很明显，这个方法会将我们传入的布局 id 转换为 XmlResourceParser，然后进行另一次，也是最后一次重载。</p><p>这个方法就厉害了，这里基本上包括了我们所有问题的答案，我们继续往下看。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>话不多说，上代码。接下来我们来逐段分析下这个 <code>inflate</code> 方法：</p><pre><code class="java">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {    final Context inflaterContext = mContext;    final AttributeSet attrs = Xml.asAttributeSet(parser);    // 默认返回结果为传入的根布局    View result = root;    // 通过 createViewFromTag() 方法找到传入的 layoutId 的根布局，并赋值给 temp    final View temp = createViewFromTag(root, name, inflaterContext, attrs);    ViewGroup.LayoutParams params = null;    // 如果传入的父布局不为空    if (root != null) {        // 为这个 root 生成一套合适的 LayoutParams        params = root.generateLayoutParams(attrs);        if (!attachToRoot) {            // 如果没有 attachToRoot，那为根布局设置 layoutparams            temp.setLayoutParams(params);        }    }    // 如果传入的父布局不为空，且想要 attachToRoot    if (root != null &amp;&amp; attachToRoot) {        // 那就将传入的布局以及 layoutparams 通过 addView 方法添加到父布局中         root.addView(temp, params);    }    // 如果传入的根布局为空，或者不想 attachToRoot，则返回要加载的 layoutId    if (root == null || !attachToRoot) {        result = temp;    }    return result;}</code></pre><p>代码也分析完了，我再来总结一下：</p><ul><li><p><code>View#inflate</code> 只是个简易的包装方法，实际上还是调用的 <code>LayoutInflater#inflate</code> ;</p></li><li><p><code>LayoutInflater#inflate</code> 由于可以自己选择 root 和 attachToRoot 的搭配（后面有解释），使用起来更加灵活；</p></li><li><p>实际上的区别只是在于 <code>root</code> 是否传空，以及 <code>attachToRoot</code> 真假与否；</p></li><li><p>当  <code>root</code> 传空时，会直接返回要加载的 <code>layoutId</code>，返回的 View 没有父布局且没有 LayoutParams；</p></li><li><p>当  <code>root</code> 不传空时，又分为 <code>attachToRoot</code> 为真或者为假：</p><ul><li><p><code>attachToRoot = true</code> </p><p>会为传入的 <code>layoutId</code> 直接设置参数，并将其添加到 <code>root</code> 中，然后将传入的 <code>root</code> 返回；</p></li><li><p><code>attachToRoot = false</code> </p><p>会为传入的 <code>layoutId</code> 设置参数，但是不会添加到 <code>root</code> ，然后返回 <code>layoutId</code> 对应的 View；</p><blockquote><p>这里需要注意的是，虽然不马上将 View 添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null；因为子 View 的 LayoutParams 需要由 parent 来确定；否则会在手动 addView 时调用 <code>generateDefaultLayoutParams()</code> 为子 View 生成一个宽高都为包裹内容的 LayoutParams，而这并不一定是我们想要的。</p></blockquote></li></ul></li></ul><h3 id="测试-amp-检验"><a href="#测试-amp-检验" class="headerlink" title="测试 &amp; 检验"></a>测试 &amp; 检验</h3><p>单说起来可能有些抽象，下面使用代码来进行具体的测试与检验。</p><h4 id="View-inflate-context-layoutId-null"><a href="#View-inflate-context-layoutId-null" class="headerlink" title="View.inflate(context, layoutId, null)"></a>View.inflate(context, layoutId, null)</h4><p>如之前所说，这实际上调用的是 <code>getLayoutInflater().inflate(layoutId, null)</code> ，结合之前的源码来看：</p><pre><code class="java">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {    View result = root;    final View temp = createViewFromTag(root, name, inflaterContext, attrs);    if (root == null || !attachToRoot) {        result = temp;    }    return result;}</code></pre><p>很明显，传入的 <code>root</code> 为空，则会直接将加载好的 xml 布局返回，而这种情况下返回的这个 View 没有参数，也没有父布局。</p><pre><code class="java">protected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.layout_test);    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, null);    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());}</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329145224.jpg" alt=""></p><p>如图所示，正如我们想的，root 传 null 时，参数以及父布局返回结果均为 null。</p><h4 id="View-inflate-context-layoutId-mParent"><a href="#View-inflate-context-layoutId-mParent" class="headerlink" title="View.inflate(context, layoutId, mParent)"></a>View.inflate(context, layoutId, mParent)</h4><p>按之前分析过的，此方法实际调用的是 <code>getLayoutInflater().inflate(layoutId, root, true)</code> ，再来看源码：</p><pre><code class="java">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {    final Context inflaterContext = mContext;    final AttributeSet attrs = Xml.asAttributeSet(parser);    View result = root;     final View temp = createViewFromTag(root, name, inflaterContext, attrs);    ViewGroup.LayoutParams params = null;    if (root != null) {        params = root.generateLayoutParams(attrs);    }    if (root != null &amp;&amp; attachToRoot) {        root.addView(temp, params);    }    return result;}</code></pre><p>如源码所示，返回的 result 会在最开始就被赋值为入参的 root，root 不为空，同时 attachToRoot 为 true，就会将加载好的布局直接通过 addView 方法添加到 root 布局中，然后将 root 返回。</p><pre><code class="java">protected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.layout_test);    LinearLayout mParent = findViewById(R.id.ll_root);    View inflateView = View.inflate(this, R.layout.layout_basic_use_item, mParent);    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());    Log.e(&quot;Test&quot;, &quot;inflateView -&gt; &quot; + inflateView);}</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329153240.jpg" alt=""></p><p>如图示，返回的 View 正是我们传入的 mParent，对应的 id 是 ll_root，参数也不再为空。</p><p>####getLayoutInflater().inflate(layoutId, root, false) </p><p>也许会有人问了，现在要么是 root 传空，返回 layoutId 对应的布局；要么是 root 不传空，返回传入的 root 布局。那我要是想 root 不传空，但是还是返回 layoutId 对应的布局呢？</p><p>这就是 <code>View#inflate</code> 的局限了，由于它是包装方法，因此 <code>attachToRoot</code> 并不能因需定制。这时候我们完全可以自己调用 <code>getLayoutInflater().inflate(layoutId, root, false)</code> 方法，手动的将第三个参数传为 false，同时为这个方法传入目标根布局。这样，我们就可以得到一个有 LayoutParams，但是没有 <code>parentView</code> 的 <code>layoutId</code> 布局了。</p><pre><code class="java">protected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.layout_test);    LinearLayout mParent = findViewById(R.id.ll_root);    View inflateView = getLayoutInflater().inflate(R.layout.main, mParent, false);    Log.e(&quot;Test&quot;, &quot;LayoutParams -&gt; &quot; + inflateView.getLayoutParams());    Log.e(&quot;Test&quot;, &quot;Parent -&gt; &quot; + inflateView.getParent());}</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190329155230.jpg" alt=""></p><p>与我们分析的一致，有参数，但是没有父布局，且返回的就是我们加载的布局 id。我们在之后可以通过 addView 方法手动将这个布局加入父布局中。</p><p><strong>这里还有个要注意的点</strong>，那就是 <code>params = root.generateLayoutParams(attrs);</code> 这句代码，我们会发现，为 <code>layoutId</code> 设置的 params 参数，实际上是通过 root 来生成的。这也就告诉我们，虽然不马上添加到 parent 中，但是这里最好也传上 parent，而不是粗暴的传入 null，因为子 View 的 LayoutParams 需要由 parent 来确定；当然，传入 null 也不会有问题，因为在执行 <code>addView()</code> 方法的时候，如果当前 childView 没有参数，会调用 <code>generateDefaultLayoutParams()</code> 生成一个宽高都包裹的 LayoutParams 赋值给 childView，而这并不一定是我们想要的。</p><h4 id="attachToRoot-必须为-false！"><a href="#attachToRoot-必须为-false！" class="headerlink" title="attachToRoot 必须为 false！"></a>attachToRoot 必须为 false！</h4><p>代码写多了，大家有时候会发现这个 <code>attachToRoot</code> 也不是想怎样就怎样的，有时候它还就必须是 false，不能为 true。下面我们就来看看这些情况。</p><ul><li><p>RecylerView#onCreateViewHolder()</p><p>在为 RecyclerView 创建 ViewHolder 时，由于 View 复用的问题，是 RecyclerView 来决定什么时候展示它的子View，这个完全不由我们决定，这种情况下，attachToRoot 必须为 false：</p><pre><code class="java">public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {          LayoutInflater inflater = LayoutInflater.from(getActivity());          View view = inflater.inflate(R.layout.item, parent, false);          return new ViewHolder(view);  }</code></pre></li><li><p>Fragment#onCreateView()</p><p>由于 Fragment 需要依赖于 Activity 展示，一般在 Activity 中也会有容器布局来盛放 Fragment：</p><pre><code class="java">Fragment fragment = new Fragment();getSupportFragmentManager()        .beginTransaction()        .add(R.id.root_container, fragment)        .commit(); </code></pre><p>上述代码中的 <code>R.id.root_container</code> 便为容器，这个 View 会作为参数传递给 <code>Fragment#onCreateView()</code> :</p><pre><code class="java">public View onCreateView(LayoutInflater inflater, ViewGroup container,                          Bundle savedInstanceState) {    return inflater.inflate(R.layout.fragment_layout, parentViewGroup, false); }</code></pre><p>它也是你在 inflate() 方法中传入的 ViewGroup，FragmentManager 会将 Fragment 的 View 添加到 ViewGroup 中，言外之意就是，Fragment 对应的布局展示或者说添加进 ViewGroup 时也不是我们来控制的，而是 FragmentManager 来控制的。</p></li></ul><p>总结一下就是，<strong>当我们不为子 View 的展示负责时，attachToRoot 必须为 false；否则就会出现对应的负责人，比如上面说的 Rv 或者 FragmentManager，已经把布局 id 添加到 ViewGroup 了，我们还继续设置 attachToRoot 为 true，想要手动 addView，那必然会发生 child already has parent 的错误。</strong></p><p>以上。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://juejin.im/entry/5a1513abf265da43052e4473" target="_blank" rel="noopener">深入理解LayoutInflater.inflate()</a></li><li><a href="https://www.jianshu.com/p/cdc9d4c0826e" target="_blank" rel="noopener">LayoutInflater.inflate和View.inflate</a></li><li><a href="">Android API 28 View.java / LayoutInflater.java / ViewGroup.java</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;误用 LayoutInflater 的 inflate() 方法已经不是什么稀罕事儿了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ConstraintLayout 介绍</title>
    <link href="http://joeljt.top/2019/03/22/ConstraintLayout-learning/"/>
    <id>http://joeljt.top/2019/03/22/ConstraintLayout-learning/</id>
    <published>2019-03-21T16:00:00.000Z</published>
    <updated>2019-03-22T10:51:31.927Z</updated>
    
    <content type="html"><![CDATA[<p>不知道从什么时候开始，Android 死丢丢已经默认使用约束布局 ConstraintLayout 作为默认布局了，但是懒癌发作一直不想学习，每次都换成 LinearLayout，这次也忘记了为啥开始学习这个东西，学完发现还挺爽……写个笔记记录一下，哈哈</p><a id="more"></a><p>正文开始~</p><h4 id="相对布局"><a href="#相对布局" class="headerlink" title="相对布局"></a>相对布局</h4><h5 id="属性集合"><a href="#属性集合" class="headerlink" title="属性集合"></a>属性集合</h5><p>类似 RelativeLayout ，使用相对位置的属性来互相约束位置。具体的属性以及使用方式也类似 RelativeLayout，默认像 FrameLayout 一样堆叠在一起，使用属性讲层级关系区分开：</p><pre><code class="xml">layout_constraintLeft_toLeftOf   当前控件的左侧与某个控件的左侧对齐layout_constraintLeft_toRightOf  当前控件的左侧与某个控件的右侧对齐layout_constraintRight_toLeftOf  当前控件的右侧与某个控件的左侧对齐layout_constraintRight_toRightOf 当前控件的右侧与某个控件的右侧对齐layout_constraintStart_toEndOf   同上layout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOflayout_constraintTop_toTopOf       当前控件与某个控件顶端对齐layout_constraintTop_toBottomOf    即当前控件某个控件的下面layout_constraintBottom_toTopOf    即当前控件在某个控件的上面layout_constraintBottom_toBottomOf 当前控件与某个控件底部对齐layout_constraintBaseline_toBaselineOf 文本基线对齐</code></pre><h5 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h5><pre><code class="xml">&lt;!-- 居中对齐实现方式 --&gt;&lt;!-- 上下左右全部受 parent 约束，最后的效果就是「居中对齐」 --&gt;&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;居中对齐&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;&lt;!-- 同理，左右受 parent 约束，效果就是「水平居中对齐」--&gt;&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;水平居中对齐&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;&lt;!-- 同理，上下受 parent 约束，效果就是「垂直居中对齐」--&gt;&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;垂直居中对齐&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&gt;</code></pre><p>居中对齐很好理解，下边我们来写一个正常的 item 布局看看：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322142136.png" alt="ConstraintLayout 实现的 item 布局"></p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:padding=&quot;5dp&quot;&gt;    &lt;ImageView        android:id=&quot;@+id/iv_logo&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;@mipmap/ic_launcher&quot; /&gt;    &lt;!-- 设置标题名称 View 的左侧边缘位于 logo 的右侧 --&gt;    &lt;TextView        android:id=&quot;@+id/tv_title&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_marginLeft=&quot;10dp&quot;        android:text=&quot;虾吃虾涮（华贸店）&quot;        app:layout_constraintLeft_toRightOf=&quot;@+id/iv_logo&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;    &lt;!-- 设置价格 View 的底部靠近父布局，且顶部参考 titleView，同时左侧与 titleView 对齐 --&gt;    &lt;TextView        android:id=&quot;@+id/tv_price&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;￥64/人&quot;        android:textSize=&quot;13sp&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintLeft_toLeftOf=&quot;@id/tv_title&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_title&quot; /&gt;    &lt;!-- 设置 distanceView 紧贴屏幕右侧，且顶部与 priceView 对齐--&gt;    &lt;TextView        android:id=&quot;@+id/tv_distance&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;1.1km&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;@id/tv_price&quot; /&gt;    &lt;!-- 设置 areaView 顶部与左侧都参考 priceView，底部位置参考 ivLogo--&gt;    &lt;TextView        android:id=&quot;@+id/tv_area&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;朝阳区 大望路&quot;        android:textSize=&quot;13sp&quot;        app:layout_constraintBottom_toBottomOf=&quot;@id/iv_logo&quot;        app:layout_constraintLeft_toLeftOf=&quot;@id/tv_price&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_price&quot; /&gt;    &lt;!-- 设置 hotView 紧贴屏幕右侧，且顶部与 areaView 顶部对齐--&gt;    &lt;TextView        android:id=&quot;@+id/tv_curr_hot&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;当前人气89&quot;        android:textSize=&quot;13sp&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;@id/tv_area&quot; /&gt;    &lt;!-- dividerView 位于整个布局的最底部，且始终位于 ivLogo 底部，并保持一定距离 --&gt;    &lt;View        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;1px&quot;        android:layout_marginTop=&quot;7dp&quot;        android:background=&quot;@android:color/darker_gray&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/iv_logo&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>可以发现使用约束布局实现比普通的 RL 实现还要简单，界面完全实现扁平化，没有任何嵌套。如果使用 LL 或者 RL 来实现同样的效果，代码要复杂多少想必不用我多说。</p><h4 id="Bias-偏向"><a href="#Bias-偏向" class="headerlink" title="Bias 偏向"></a>Bias 偏向</h4><p>以上的内容就是基本使用了，把上下左右各种参考、依赖关系搞明白，本身没有多么复杂，使用起来也和 RL 差不多，下面来介绍一些新花样。</p><p><code>bias</code> 很好理解，正如其英文本意一样，它表达的是<strong>偏移</strong>。当某一布局同时受两个相反方向的约束力时，该布局就会处于约束它的那两个力量的正中央。而 <code>layout_constraintHorizontal_bias</code> 与 <code>layout_constraintVertical_bias</code> 就是用在这种时候，用来将某一方向的约束力减弱。来自两侧的约束力可以为 parent，也可以是普通 View。</p><p>文字描述可能有点抽象，具体布局文件还是更好理解一些：</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout     android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tv1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;this is a text&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;this is a text&quot;        app:layout_constraintHorizontal_bias=&quot;0.3&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/tv1&quot;        app:layout_constraintRight_toLeftOf=&quot;@id/tv3&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;this is a text&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>布局很简单，三个 TextView 并排显示，左右两个分别紧贴父布局，中间一个受左右两侧布局约束，本来应该是位于两个 TextView 正中央，但是由于设置了 <code>layout_constraintHorizontal_bias</code> 小于 0.5，所以最后效果中间的 TextView 整体偏向左侧，展示如下图：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322145701.jpg" alt=""></p><h4 id="Circle-布局"><a href="#Circle-布局" class="headerlink" title="Circle 布局"></a>Circle 布局</h4><p>这个看上去很厉害的！可以令 B 布局以 A 布局为圆心，然后用角度和半径距离来约束两个布局的位置。废话不多说，上图：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322153304.jpg" alt="">这个也很好理解，主要有三个属性：</p><pre><code>layout_constraintCircle ：      当前布局以哪个布局为圆心layout_constraintCircleRadius ：半径layout_constraintCircleAngle ： 摆放角度</code></pre><p>我反正是给谷歌跪了……</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tv_center&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        android:text=&quot;Circle Center&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;    &lt;!-- 「测试布局」以 tv_center 为圆心，位于其 135° 方向的 100dp 处 --&gt;    &lt;TextView        android:text=&quot;测试布局&quot;        app:layout_constraintCircle=&quot;@id/tv_center&quot;        app:layout_constraintCircleAngle=&quot;135&quot;        app:layout_constraintCircleRadius=&quot;100dp&quot;        android:textColor=&quot;@android:color/black&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><h4 id="替代-MATCH-PARENT-的-MATCH-CONSTRAINT"><a href="#替代-MATCH-PARENT-的-MATCH-CONSTRAINT" class="headerlink" title="替代 MATCH_PARENT 的 MATCH_CONSTRAINT"></a>替代 MATCH_PARENT 的 MATCH_CONSTRAINT</h4><p>在约束布局中，由于布局受各方约束控制，也就没有所谓的「match_parent」了。随之而来的需求则是，左边有个布局约束我，右边还有个布局约束我，然后我就想充满剩余的全部位置，「match_constraint」也就应运而生了。</p><p>说起来复杂，其实只需要把对应的 View 宽高设置为 0dp 即可，该 View 就会占据上剩余的所有可用空间。在这种情况下，谷歌给我们提供了几个额外的属性：</p><pre><code>layout_constraintWidth_min   宽度最小值layout_constraintHeight_min  高度最小值layout_constraintWidth_max   宽度最大值layout_constraintHeight_max  高度最大值layout_constraintWidth_percent   宽度占剩余位置的百分比layout_constraintHeight_percent  高度占剩余位置的百分比</code></pre><p>具体示例如下：</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button        android:id=&quot;@+id/btn1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Test Button&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt;    &lt;Button        android:id=&quot;@+id/btn2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;    &lt;Button        android:id=&quot;@+id/btn3&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constrainedWidth=&quot;true&quot;        android:text=&quot;Button&quot;        app:layout_constraintWidth_min=&quot;wrap&quot;        app:layout_constraintWidth_max=&quot;wrap&quot;        app:layout_constraintWidth_percent=&quot;0.3&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/btn1&quot;        app:layout_constraintRight_toLeftOf=&quot;@id/btn2&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322163826.jpg" alt=""></p><h4 id="Chains-链"><a href="#Chains-链" class="headerlink" title="Chains 链"></a>Chains 链</h4><p>如果几个不同的 View 两两发生关联，如下图，则这几个 View 构成了一个 Chains(链)。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322170158.jpg" alt=""></p><p>具体布局代码如下：</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button        android:id=&quot;@+id/btn1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;        app:layout_constraintRight_toLeftOf=&quot;@id/btn2&quot; /&gt;    &lt;Button        android:id=&quot;@+id/btn2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/btn1&quot;        app:layout_constraintRight_toLeftOf=&quot;@id/btn3&quot; /&gt;    &lt;Button        android:id=&quot;@+id/btn3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/btn2&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>这样这三个 Button 就形成了一个横向的 Chain，在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果：</p><p>该属性为：</p><pre><code>layout_constraintHorizontal_chainStylelayout_constraintVertical_chainStyle</code></pre><p>其取值可以为：spread、spread_inside、packed。</p><p>具体样式展示如下：</p><ol><li>spread，基本上就是按照权重等分</li></ol><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171443.jpg" alt=""></p><ol><li><p>spread_inside，也是等分展示，但是两侧吸附</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171444.jpg" alt=""></p></li><li><p>packed，整条链挤在一起，居中展示</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322171442.jpg" alt=""></p></li></ol><p>官网有一个图来展示不同样式的 Chains，可以参考一下，也很形象：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322172439.jpg" alt=""></p><h4 id="虚拟辅助视图"><a href="#虚拟辅助视图" class="headerlink" title="虚拟辅助视图"></a>虚拟辅助视图</h4><p>与以往的 ViewGroup 不同，ConstraintLayout 还提供了几种辅助页面绘制的布局，这种布局一般表现为引导线之类，不会在页面上绘制，但是可以通过占位的方式，成为不同布局的约束条件。</p><h5 id="GuideLine"><a href="#GuideLine" class="headerlink" title="GuideLine"></a>GuideLine</h5><p>顾名思义，GuideLine 可以创建基于父布局 ConstraintLayout 的水平或者垂直准线，从而帮助开发者进行布局定位。</p><p>这个布局有四个基本属性，依次为：</p><pre><code class="xml">orientation 如上所述，用来表示是垂直方向还是竖直方向layout_constraintGuide_begin 距离父亲的起始位置layout_constraintGuide_end 距离父亲的结束位置layout_constraintGuide_percent 距离父亲的位置，用百分比表示经过试验，percent 优先级最高，其次是 begin，最后是 end，一般来讲使用 percent 就足够了</code></pre><p>xml 以及对应的页面效果如下：</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout                    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;!-- 假设说现在需要将 ImageView 摆放到右下角的位置，就可以使用 GL 辅助实现--&gt;    &lt;android.support.constraint.Guideline        android:id=&quot;@+id/gl_vertical&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;vertical&quot;        app:layout_constraintGuide_percent=&quot;0.8&quot;/&gt;    &lt;android.support.constraint.Guideline        android:id=&quot;@+id/gl_horizontal&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;0dp&quot;        android:orientation=&quot;horizontal&quot;        app:layout_constraintGuide_percent=&quot;0.8&quot; /&gt;    &lt;ImageView        android:src=&quot;@mipmap/ic_launcher&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/gl_vertical&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/gl_horizontal&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322174954.jpg" alt=""></p><h5 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h5><p>与 GuideLine 差不多，但是比它更灵活，可以用来约束多个布局，且自动匹配最大最小值进行约束。</p><p>Barrier 有两个基本属性：</p><ul><li><p>barrierDirection</p><blockquote><p> 取值可为 top, bottom, left, right, start, end</p></blockquote><p>用于约定栅栏拦截的 View 方向，假设说要拦截的 View 在右侧，这个属性就应该为 right 或者 end</p></li><li><p>constraint_referenced_ids</p><p>被栅栏保护，屏蔽起来的 View 集合，直接输入 viewId，用逗号分隔即可；barrier 会根据宽度或者高度最大的那个 View 来设置栅栏的边界</p></li></ul><p>可能会有些抽象，我们在开发时可能会遇到一种比较蛋疼的需求：</p><blockquote><p>姓名、性别、出生日期、手机号等字段从上到下一字排开，但是每个字段对应的值要保证彼此左侧对齐</p></blockquote><p>讲道理以前这种布局我一直不知道怎么画，但是现在有了 <code>barrier</code> 以后这问题就迎刃而解了。我们可以用 barrier 将左侧的那些字段与右侧的值拦截开，barrier 会自动识别最宽的那个字段，并将之作为 barrier 的宽度，之后每个值都用 barrier 来制造约束就可以了。</p><pre><code class="XML">&lt;android.support.constraint.ConstraintLayout     android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:padding=&quot;10dp&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tv_name&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;姓名:&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/tv_gender&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_name&quot;        android:text=&quot;性别:&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/tv_phone&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_gender&quot;        android:text=&quot;手机号:&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/tv_birthday&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_phone&quot;        android:text=&quot;出生日期:&quot;/&gt;    &lt;android.support.constraint.Barrier        android:id=&quot;@+id/barrier&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:barrierDirection=&quot;end&quot;        app:constraint_referenced_ids=&quot;tv_name,tv_phone,tv_gender,tv_birthday&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;        android:text=&quot;易烊千玺&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_name&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;        android:text=&quot;男&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_gender&quot;        android:text=&quot;13800138000&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/barrier&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/tv_phone&quot;        android:text=&quot;2000年1月1日&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>显示效果如图，很完美有没有？</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322182306.jpg" alt=""></p><h5 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h5><p>Group 是一个组，用来批量控制 View 的显示与隐藏；但是注意这不是个 ViewGroup，它只是一个不执行绘制的 View，和 barrier 一样，它有一个 constraint_referenced_ids 的属性，可以将需要隐藏的 ViewId 丢进去，在需要的时候将其批量隐藏即可。</p><p>还通过上面的例子，假设现在要把性别一栏隐藏掉：</p><pre><code class="xml">&lt;android.support.constraint.Group    app:constraint_referenced_ids=&quot;tv_gender,tv_sex_value&quot;    android:visibility=&quot;gone&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;</code></pre><p>通过将性别的 key 和 value 的 id 都放进去，将其设置为 gone，则可以将该组实现隐藏：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190322183030.jpg" alt=""></p><p>但是，使用 Group 控制可见性是有坑的：</p><blockquote><ol><li><p>和以前用的ViewGroup有一点不同，以前用ViewGroup约束View的时候，外层ViewGroup设置成可见，里层View设置成不可见是可以生效的，但是用Group就不能。Group约束的元素的可见性始终一致。</p></li><li><p>调用Group的setVisibility方法不会立即对它约束对子View生效，而是要等到Group所在的ConstrainLayout调用preLayout方法时才会生效。preLayout只有在第一次layout和布局发生变化时才会调用。</p></li></ol></blockquote><h4 id="Optimizer优化"><a href="#Optimizer优化" class="headerlink" title="Optimizer优化"></a>Optimizer优化</h4><p>可以通过将标签app：layout_optimizationLevel元素添加到 ConstraintLayout 来决定应用哪些优化</p><pre><code class="xml">&lt;android.support.constraint.ConstraintLayout     android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    app:layout_optimizationLevel=&quot;standard|dimensions|chains&quot;/&gt;</code></pre><ul><li>none： 不执行优化</li><li>standard： 默认，仅优化直接和障碍约束</li><li>direct： 优化直接约束</li><li>barrier： 优化障碍约束</li><li>chain：优化链条约束</li><li>dimensions：优化维度测量，减少匹配约束元素的度量数量</li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://juejin.im/post/5c0bd6b05188257c3045dc50#heading-7" target="_blank" rel="noopener">ConstraintLayout 全解析</a></li><li><a href="https://mp.weixin.qq.com/s/vI-fPaNoJ7ZBlZcMkEGdLQ" target="_blank" rel="noopener">拒绝拖拽 使用ConstraintLayout优化你的布局吧</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道从什么时候开始，Android 死丢丢已经默认使用约束布局 ConstraintLayout 作为默认布局了，但是懒癌发作一直不想学习，每次都换成 LinearLayout，这次也忘记了为啥开始学习这个东西，学完发现还挺爽……写个笔记记录一下，哈哈&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信 下篇</title>
    <link href="http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-2/"/>
    <id>http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-2/</id>
    <published>2018-09-08T16:00:00.000Z</published>
    <updated>2019-03-21T10:47:37.178Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Efficient.Android.Threading 第四章读书笔记 下篇</p></blockquote><a id="more"></a><h3 id="Android-消息机制"><a href="#Android-消息机制" class="headerlink" title="Android 消息机制"></a>Android 消息机制</h3><p>迄今为止，我们介绍的线程通信都是 Java 层面的，管道、共享内存、阻塞队列等等，都是所有 Java 应用都有的机制。然而，因为阻塞线程特性的存在，这些机制对于 Android 系统都不适用，因为 UI 线程绝不允许阻塞。</p><p>因此，Android 系统为了协同 UI 线程和工作线程，定义了一套系统级别的消息机制。Android 消息机制是一个没有阻塞状态的生产者-消费者模式，UI 线程可以将耗时操作转移给工作线程在后台处理，同时生产者线程与消费者线程都不会发生阻塞。</p><p>Android 平台的消息机制相关的 API 从属于 <code>android.os</code> 包：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182551.jpg" alt="Android Message API"></p><p><code>android.os.Looper</code></p><p>唯一关联某个消费者线程的消息调度器</p><p><code>android.os.Handler</code></p><p>消费者线程的消息处理器，同时生产者线程也使用该对象将消息插入队列。一个 Looper 对象可以绑定多个 Handler 对象，但是所有的消息都是插入同一个消息队列的。</p><p><code>android.os.MessageQueue</code></p><p>消费者线程中待处理消息的链表，但是不同的消息之间并没有绑定关系。每个 Looper 对象最多只能有一个消息队列；由于每个线程只能有一个 Looper 对象，也就是说每个线程最多只能有一个消息队列。</p><p>名叫 MessageQueue, 实际上是一个 LinkedList</p><p><code>android.os.Message</code></p><p>消费者线程中待执行的消息</p><p>消息机制的工作原理大抵如下图示意：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182556.jpg" alt="消息机制示意"></p><p>生产者线程发送消息，消费者线程处理消息：</p><ol><li>插入：生产者线程使用与消费者线程相绑定的 Handler 对象，将消息插入消息队列</li><li>取出：Looper 运行在消费者线程中，按一定的顺序取出消息队列中的消息</li><li>分发：Handler 负责在消费者线程中处理消息；某个线程可以有多个 Handler 对象，Looper 可以确保每条消息能够正确分发给对应的 Handler 。</li></ol><h4 id="消息传递基本示例"><a href="#消息传递基本示例" class="headerlink" title="消息传递基本示例"></a>消息传递基本示例</h4><pre><code class="java">public class LooperActivity extends Activity {    LooperThread mLooperThread;    // 1.声明一个工作线程，扮演消费者线程角色    private static class LooperThread extends Thread {        public Handler mHandler;        public void run() {            // 2.为当前线程关联 Looper，也就是关联了 MessageQueue            Looper.prepare();            // 3.使用默认构造器，即将 Handler 与当前线程的 Looper 绑定            // 也就决定了它只能在 Looper.prepare() 后初始化，否则没有可以绑定的 Looper            mHandler = new Handler() {                // 4. 工作线程中处理分发下来的消息的回调                public void handleMessage(Message msg) {                    if(msg.what == 0) {                        doLongRunningOperation();                    }                }            };            // 5. 开启对消息队列的轮询，对消息进行分发；            // 这是个 blocking call，因此此工作线程不会结束            Looper.loop();        }        private void doLongRunningOperation() {            // Add long running operation here.        }    }    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_looper);        // 6. 开启工作线程，准备处理消息        mLooperThread = new LooperThread();        mLooperThread.start();    }    public void onClick(View v) {        // 7. Handler 初始化完成和点击事件是异步的，因次校验一下 Handler 不为空        if (mLooperThread.mHandler != null) {            // 8. 初始化一个 Message 对象，what 属性赋值为 0            Message msg = mLooperThread.mHandler.obtainMessage(0);            // 9. 向消息队列中插入消息            mLooperThread.mHandler.sendMessage(msg);        }    }    protected void onDestroy() {        super.onDestroy();        // 10. 结束 loop() 方法的阻塞状态，从而结束后台线程的执行        mLooperThread.mHandler.getLooper().quit();    }}</code></pre><h4 id="消息传递过程中涉及到的-Classes"><a href="#消息传递过程中涉及到的-Classes" class="headerlink" title="消息传递过程中涉及到的 Classes"></a>消息传递过程中涉及到的 Classes</h4><h5 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h5><p>消息队列主要由 <code>android.os.MessageQueue</code> 类来实现，其内部实现一个没有绑定关系的单向链表，用于存储一系列待处理的消息。生产者线程插入消息，之后消息会分发到对应的消费者线程去处理。一般来讲，不同的消息是按照时间戳来排序的。也就是说，时间戳值越小，在消息队列中排序顺序就越靠前。但是只有到达当前时间的消息才会被分发；如果还没有到当前时间，则会等到当前时间才会对消息进行分发。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182557.jpg" alt="消息分发的时间点"></p><p>上图展示了消息队列中按时间排序的消息是如何向下分发的，其中 t1 &lt; t2 &lt; t3，即 t1 的时间要早于 t3。现在只有一条消息越过了 <code>disptch barrier</code> , 实际上也就是当前时间点。可以被分发下去的消息所绑定的时间戳，一定比当前时间小，也就是已经到了分发的时间。</p><p>如果当前 Looper 获取消息时，消息队列中还没有消息穿越过 <code>dispatch barrier</code> ，此时消费者线程就会阻塞，直到有消息越过 <code>dispatch barrier</code> 。而生产者线程可以在任何时间、任意位置插入消息，因为消息列表的排列只和消息发送的时间有关系，如果需要插入一条立即发送的消息，则即使消息队列中有一百条待发送的消息，但它们都是一分钟后才发送，那刚插入的这条消息也会在链表的首位，也就是下一个被分发的消息。</p><h5 id="MessageQueue-IdleHandler"><a href="#MessageQueue-IdleHandler" class="headerlink" title="MessageQueue.IdleHandler"></a>MessageQueue.IdleHandler</h5><p>正常来讲，如果 Looper 获取不到应分发的消息时，线程就会阻塞等待；但是除了干等以外，还可以将这段时间利用起来，用来执行一些其他的任务。而这个任务则由 <code>android.os.MessageQueue.IdleHandler</code> 来完成。</p><pre><code class="java">/** * 当线程等待新消息，即将进入阻塞（闲置）状态时的回调接口 */public static interface IdleHandler {      boolean queueIdle();}// 具体使用：// 获取当前线程的消息队列MessageQueue myQueue = Looper.myQueue();// 声明一个 IdleHandler 对象MessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() {    @Override    public boolean queueIdle() {        return false;    }};// 与消息队列进行绑定myQueue.addIdleHandler(idleHandler);// 与消息队列解除绑定myQueue.removeIdleHandler(idleHandler);</code></pre><p>当消息队列检测到分发消息的空闲时间时，它会唤醒所有注册到当前消息队列的 IdleHandler 实例，并调用他们的 <code>queueIdle</code> 方法，而具体的回调由应用自身来进行实现。</p><p> <code>queueIdle</code> 方法返回值为布尔类型：</p><ul><li><p>true</p><p>当前 IdleHandler 实例保持存活，下次再有 time slots 时，MessageQueue 还会唤醒该实例</p></li><li><p>false</p><p>当前 IdleHandler 实例不再存活，处理完消息后就会主动调用 MessageQueue.removeIdleHandler() 将该实例与 MessageQueue 解绑</p></li></ul><h5 id="使用-IdleHandler-来终止闲置线程的运行"><a href="#使用-IdleHandler-来终止闲置线程的运行" class="headerlink" title="使用 IdleHandler 来终止闲置线程的运行"></a>使用 IdleHandler 来终止闲置线程的运行</h5><p>假定现在有多个生产者线程要连续不断的向消费者线程发送消息，那就可以在消费者线程将所有任务的处理完以偶胡，使用 IdleHandler 来终止线程的执行，从而保证该线程对象不会在内存中游荡。</p><p>在这种情况下使用 IdleHandler ，就不用追踪最后一条插入队列的消息，以期得到回收该线程的确切时间。</p><p>不过这种场景只适用于生产者线程连续不断地向消费者线程插入消息，从而保证在处理完所有消息之前，消费者线程都没有 time slots.</p><pre><code class="java">public class ConsumeAndQuitThreadActivity extends Activity {    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        final ConsumeAndQuitThread consumeAndQuitThread = new ConsumeAndQuitThread();        consumeAndQuitThread.start();        for (int i = 0; i &lt; 10; i++) {            // 由多个线程并发向消费者线程发送消息，随机模拟发送的时间            new Thread(new Runnable() {                @Override                public void run() {                    for (int i = 0; i &lt; 10; i++) {                        SystemClock.sleep(new Random().nextInt(10));                        consumeAndQuitThread.enqueueData(i);                    }                }            }).start();        }    }    /**     * 此线程为绑定了 Looper 对象的消费者线程，接收生产者线程的消息并进行处理；     * 处理完消息后，会终止 Looper.loop() 方法，结束线程的执行     */    private static class ConsumeAndQuitThread extends Thread implements MessageQueue.IdleHandler {        private static final String THREAD_NAME = &quot;ConsumeAndQuitThread&quot;;        public Handler mConsumerHandler;        private boolean mIsFirstIdle = true;        public ConsumeAndQuitThread() {            super(THREAD_NAME);        }        @Override        public void run() {            Looper.prepare();            mConsumerHandler = new Handler() {                @Override                public void handleMessage(Message msg) {                    // Consume data                }            };            // 1. 为当前线程初始化 Looper，并为该线程的消息队列绑定 IdleHandler 对象            Looper.myQueue().addIdleHandler(this);            Looper.loop();        }        @Override        public boolean queueIdle() {            // 2. 第一次 queueIdle() 的调用会发生在接收消息之前            // 因此需要让首次调用返回 true，从而保证此对象仍然与消息队列绑定            if (mIsFirstIdle) {                 mIsFirstIdle = false;                return true;            }            // 3. 结束消费者线程的执行            mConsumerHandler.getLooper().quit();            return false;        }        public void enqueueData(int i) {            mConsumerHandler.sendEmptyMessage(i);        }    }}</code></pre><h5 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h5><p>Message 是一个容器类，可以承载各种类型的数据或者一个 Runnable 对象，但是不能同时携带二者。所携带的数据会在消费者线程被处理，但任务则会在消息分发时直接得到执行，而不需要调用者做其他额外的工作。</p><p>正常来讲，Message 的插入由 Handler 来完成，因为它在插入消息时有更多的选择，更加灵活；但是实际上每条消息对象都知道自己对应的处理器是谁，也就是知道自己对应的 Handler 对象，所以一条消息可以自己实现入队操作。</p><pre><code class="java">// 通过 obtain() 传递一个 Handler 对象进去，赋值给 Message.target 属性Message m = Message.obtain(handler, runnbale);m.sendToTarget();public void sendToTarget() {    // target 是 Handler 对象，此方法会调用 Handler 的 sendMessage 方法    target.sendMessage(this);}</code></pre><p>如之前所说，Message 可以携带数据或者任务，具体如下图所示：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182601.jpg" alt=""></p><p>消息队列可以包含任何数据和任务消息的组合，消费者线程具体在处理消息的时候，也仅仅是按照消息的排序顺序，而不和消息的类型有任何关系。如果消息携带的是数据，那消费者线程就会在 handleMessage 中处理数据；如果消息携带的是任务，则该 Runnable 的 run 方法则会在消费者线程得到执行，但是不会再触发 handleMessage 方法的回调。</p><p>Message 的生命周期大概可以分为四个方面：初始化，等待，分发，回收。需要注意的是，系统并没有对消息的状态进行监听，尽管这在技术上也是可行的，所以应用在处理消息不该对该消息的当前状态做出任何假设。</p><ul><li><p>Initialized</p><p>在初始化状态下，应用程序可以使用以下方法来创建 Message 对象：</p><ul><li><p>使用构造器初始化</p><pre><code class="java">Message m = new Message();</code></pre></li><li><p>工厂方法</p><ul><li><p>空消息</p><pre><code class="java">Message m = Message.obtain();</code></pre></li><li><p>数据消息</p><pre><code class="java">Message m = Message.obtain(Handler h);Message m = Message.obtain(Handler h, int what);Message m = Message.obtain(Handler h, int what, Object o);Message m = Message.obtain(Handler h, int what, int arg1, int arg2); Message m = Message.obtain(Handler h, int what, int arg1, int arg2, Object o);</code></pre></li><li><p>任务消息</p><pre><code class="java">Message m = Message.obtain(Handler h, Runnable task);</code></pre></li><li><p>复制构造器</p><pre><code class="java">Message m = Message.obtain(Message originalMsg);</code></pre></li></ul></li></ul></li><li><p>Pending</p><p>消息已经被插入消息队列中，但还没到发送时间，正在等待分发</p></li><li><p>Disptached</p><p>在这个阶段，Looper 已经从消息队列中取出了消息，消息队列也将其移除。Looper 在 loop 方法中，会通过访问 Message.target 属性，来获取到该消息对应的 Handler ，然后将消息发送到对应的回调中进行处理。</p></li><li><p>Recycled</p><p>在这个阶段，Message 的状态被清除，该实例也回到了消息池中等待复用。在消费者线程完成数据处理后，Looper 负责 Message 的回收工作。这个回收过程由虚拟机来完成，而不应该由应用程序来主动处理。</p><blockquote><p>需要注意的是，一旦消息入队后，其携带的数据就不应该再被更改。理论上来讲，在消息被分发之前，对数据做出的更改都是有效的。但由于 Handler 机制在设计之初就没有对 Message 的处理状态进行监听，因此调用者正在对数据进行更改时，消费者线程正在处理数据，从而导致线程安全的问题。而如果该消息对象已经被回收了，问题则会更加严重，因为该对象回到消息池后，会在之后被应用程序所复用，有可能会携带之前的数据到新的消息队列中。</p></blockquote></li></ul><h5 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h5><p><code>android.os.Looper</code> 复杂将队列中的消息分发给对应的 Handler 去处理。所有越过分发栅栏的消息都可以被 Looper 所分发。所有待分发的消息一定是越过分发栅栏的，当没有消息待分发时，消费线程则会阻塞，直至有消息等待处理。</p><p>消费线程并不直接与消息队列发生关系，而是通过 Looper 作为中间者来协调消息的分发与处理：消费电车绑定 Looper，而 Looper 会绑定一个 MessageQueue。默认只有 UI 线程自带 Looper ，其他子线程需要调用者显式声明 Looper 。</p><pre><code class="java">new Thread() {    @Override    public void run() {        // prepare() 方法会初始化一个消息队列，并将其与当前线程绑定        // 在此时，该消息队列已经可以插入消息，但是无法分发到消费线程处理        Looper.prepare();        // ... ...        // 此方法为一个 blocking call，确保 run() 方法不会结束执行        // 当 run() 方法阻塞的时候，Looper 可以循环消息队列，然后向消费线程分发消息        Looper.loop();    }}.start();</code></pre><p>一个线程只能绑定一个 Looper，而 Looper 会绑定一个 MessageQueue，也就是说一个线程只能有一个消息队列；这也就保证了无论多少工作线程向主线程发送消息，主线程也只能按照一定顺序来处理消息。因此，当前执行的消息处理时间的长短会影响到之后的消息，我们在实际使用时，应该规避处理耗时过长的消息。</p><h5 id="Looper-的终止"><a href="#Looper-的终止" class="headerlink" title="Looper 的终止"></a>Looper 的终止</h5><ul><li><p>quit()</p><p>丢弃消息队列中所有未分发的消息，不管其有没有越过分发栅栏</p></li><li><p>quitSafely()</p><p>丢弃还没越过分发栅栏的消息，Looper 会等到已经处于待分发状态的消息正确分发后再结束</p></li></ul><p>终止 Looper 并不会终止线程的执行，它只是将 loop() 方法结束了；但需要注意的是，终止 Looper 后此线程将不再是 Looper 线程，既不能重新绑定新的 Looper ，也无法唤醒已经终止的 Looper。调用 Looper.prepare() 会抛异常，提示已经绑定；重新调用 Looper.loop() 会进入阻塞状态，但是消息队列中的消息不会再得到分发。</p><h5 id="UI-线程的-Looper"><a href="#UI-线程的-Looper" class="headerlink" title="UI 线程的 Looper"></a>UI 线程的 Looper</h5><p>UI 线程是唯一一个自带 Looper 的线程，其与其他线程有以下几点不同：</p><ul><li>在程序任何位置都可以通过调用 Looper.getMainLooper() 来获取 UI Looper</li><li>UI 线程的 Looper 不能被终止</li><li>Java 虚拟机通过 Looper.prepareMainLooper() 为 UI 线程初始化 Looper，此动作只能执行一次，因此尝试将 main looper 与其他子线程关联会抛异常。</li></ul><h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>Android 系统中使用 <code>android.os.Handler</code> 来协调工作线程与 UI 线程的调度，消息的插入和处理都由它来完成，具体工作包括以下几点：</p><ul><li>消息的创建</li><li>插入消息</li><li>在消费线程中处理消息</li><li>管理消息队列中的消息</li></ul><p>Handler 的工作需要 Looper 和 MQ 的支持，因此 Handler 在声明时就应该绑定 Looper 对象：</p><ol><li><p>构造器中不接收 Looper 的，该 Handler 与当前线程绑定</p><pre><code class="java">// 这种与当前线程绑定的，如果当前不是 Looper 线程，就会抛出异常new Handler();new Handler(Handler.Callback);</code></pre></li><li><p>构造器明确需要传入 Looper 对象的</p><pre><code class="java">new Handler(Looper);new Handler(Looper, Handler.Callback);</code></pre></li></ol><p>一个线程可以有多个 Handler ，不同 Handler 发送的消息可以在消息队列中共存，并不会有什么冲突；具体在分发的时候又会通过 Message 的 target 属性发送回该消息对应的 Handler：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182554.jpg" alt=""></p><blockquote><p>多个 Handler 发出的消息也不会导致并发，Message 的处理仍然是按顺序执行的。</p></blockquote><h5 id="Message-creation"><a href="#Message-creation" class="headerlink" title="Message creation"></a>Message creation</h5><p>Handler 可以通过以下几个包装方法直接获取 Message 对象，而这些对象则会和 Handler 发生绑定关系：</p><pre><code class="java">// 这些方法内部都会调用 Message.obtain() 方法，并将 Handler 传入，从而产生绑定关系Message obtainMessage(int what, int arg1, int arg2)Message obtainMessage()Message obtainMessage(int what, int arg1, int arg2, Object obj) Message obtainMessage(int what)Message obtainMessage(int what, Object obj)</code></pre><h5 id="Message-insertion"><a href="#Message-insertion" class="headerlink" title="Message insertion"></a>Message insertion</h5><p>根据消息类型的不同，Handler 插入消息的方式也略有差别。</p><pre><code class="java">// 携带任务的消息，使用 postXxx() 方法boolean post(Runnable r)boolean postAtFrontOfQueue(Runnable r)boolean postAtTime(Runnable r, Object token, long uptimeMillis) boolean postAtTime(Runnable r, long uptimeMillis)boolean postDelayed(Runnable r, long delayMillis)// 携带数据的消息或者空消息，使用 sendXxx() 方法// 默认，立即分发boolean sendMessage(Message msg) // 下一个分发boolean sendMessageAtFrontOfQueue(Message msg)// 指定某个确切的时间进行分发boolean sendMessageAtTime(Message msg, long uptimeMillis) boolean sendMessageDelayed(Message msg, long delayMillis)boolean sendEmptyMessage(int what)boolean sendEmptyMessageAtTime(int what, long uptimeMillis) boolean sendEmptyMessageDelayed(int what, long delayMillis)</code></pre><p>每条消息都有会有一个 when 属性，用来记录当前消息应该何时被分发；该属性也是唯一一个会影响分发顺序的因素。需要注意的是，尽管我们可以指定确定的时机分发，但是由于之前消息的处理也会影响到后一条消息的分发，因此这个时间还是不确定的。</p><p>向消息队列中插入消息时，有可能导致某些错误的产生：</p><ul><li><p>Message has no Handler</p><p>Message was created from a Message.obtain() method without a specified Handler.</p></li><li><p>Message has already been disptached and is being processed</p><p>The same message instance was inserted twice.</p></li><li><p>Looper has exited</p><p>Message is inserted after Looper.quit() has been called.</p></li></ul><blockquote><p>Looper 在分发消息时，会调用 Handler 的 dispatchMessage 方法。如果此方法被应用程序主动调用，那该消息会在发起调用的线程立即得到执行，而不是在消费线程执行。</p></blockquote><h5 id="Message-processing"><a href="#Message-processing" class="headerlink" title="Message processing"></a>Message processing</h5><p>Message 根据携带数据类型的不同，有不同的处理方式：</p><ul><li><p>Task messages</p><p>如果携带的是 Runnbale 对象，那等轮到该条消息分发的时候，则该 Runnable 对象的 run 方法会直接得到执行，而不会再触发 <code>Handler.handMessage()</code> 方法。</p></li><li><p>Data messages</p><p>如果消息携带的是数据的话，那处理消息则需要重写 <code>Handler.handMessage()</code> 方法（两种方式）。</p></li></ul><p>一种是正常的实现自己的 Handler ，然后重写该方法；或者在初始化 Handler 的时候直接重写该方法，但需要注意的是，如果在子线程中，该方法的重写要在消息队列就绪以后立刻声明，否则 loop() 循环开启后，就无法再声明了：</p><pre><code class="java">class ConsumerThread extends Thread{    Handler mHandler;    @Override    public void run(){        Looper.prepare();        mHandler = new Handler(){            public void handleMessage(Message msg){                // process data message here            }        };        Looper.loop();    }}</code></pre><p>另一种方式是利用 <code>Handler.Callback</code> 接口，该接口方法为一个带布尔类型返回值的 <code>handleMessage</code> 方法：</p><pre><code class="java">public interface Callback {    // true: 代表实现类处理完消息即终止    // false: 代表实现类处理完以后，还要继续下发到 Handler.handleMessage 方法    public boolean handleMessage(Message msg);}// 消息分发public void dispatchMessage(Message msg) {    if (msg.callback != null) {        handleCallback(msg);    } else {        if (mCallback != null) {            // 如果返回 true ，则不会继续向下分发了            if (mCallback.handleMessage(msg)) {                return;            }        }        handleMessage(msg);    }    }</code></pre><p>使用这种方式，调用者不再需要继承自 Handler ，而只需要将 Callback 接口的实现类当做 Handler 构造器传入即可，然后该 Handler 就会回调到 handleMessage()：</p><pre><code class="java">public class HandlerCallbackActivity extends Activity implements Handler.Callback {    Handler mUiHandler;    @Override    public void onCreate(Bundle savedInstanceState){        super.onCreate(savedInstanceState);        mUiHandler = new Handler(this); // 直接通过构造器传入，即可通过此类处理消息    }    @Override    public boolean handleMessage(Message msg){        // process msg        return true;    }}</code></pre><h4 id="与-UI-线程通信"><a href="#与-UI-线程通信" class="headerlink" title="与 UI 线程通信"></a>与 UI 线程通信</h4><p>正如之前所说，UI 线程是唯一一个自带 Looper 的线程，其他线程可以向 UI 线程发送消息，但要注意避免耗时操作，因为 UI 线程是全局的，每个任务的时长都会对全局任务的执行产生影响。</p><p>有以下几种方式将消息转交到 UI 线程处理：</p><ol><li><p>为 Handler 指定 UI 线程的 Looper</p><pre><code class="java">Runnable task = new Runnable(){...};new Handler(Looper.getMainLooper()).post(task);</code></pre><p>使用这种方式，不管调用线程，task 都会通过 UI Looper 直接插入 UI MessageQueue。</p></li><li><p>直接在 UI 线程向自身发送消息，该任务会在当前正在执行的消息处理完后得到执行</p><pre><code class="java">private void postFromUiThreadToUiThread(){    new Handler().post(new Runnable(){...})}</code></pre></li><li><p>Activity.runOnUiThread</p><pre><code class="java">private void postFromUiThreadToUiThread(){    runOnUiThread(new Runnable(){...})}</code></pre><p>如果此方法在其他线程调用，则它会将消息插入到 UI 线程的消息队列中。此方法只能由 Activity 的实例来调用，但是也可以实现自己的 runOnUIThread 方法，只要追踪 UI 线程的 ID 即可：</p><pre><code class="java">public class MyApplication extends Application{    private long mUiThreadId;    private Handler mUiHandler;    @Override    public void onCreate(){        super.onCreate();        mUiThread = Thread.currentThread().getId();        mUiHandler = new Handler();    }    public void customRunOnUiThread(Runnable action){        if(Thread.currentThread().getId() != mUiThreadId){            mUiHandler.post(action);        } else{            action.run();        }    }}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Efficient.Android.Threading 第四章读书笔记 下篇&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://joeljt.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Efficient.Android.Threading" scheme="http://joeljt.top/tags/Efficient-Android-Threading/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信 上篇</title>
    <link href="http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-1/"/>
    <id>http://joeljt.top/2018/09/09/Efficient-Android-Threading-chapter-4-1/</id>
    <published>2018-09-08T16:00:00.000Z</published>
    <updated>2019-03-21T10:47:26.820Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Efficient.Android.Threading 第四章读书笔记 上篇</p></blockquote><a id="more"></a><p>在多进程应用中，各个任务可以并行执行协作以产出结果。因此，各个线程之间必须进行通信才能满足协作执行的目的。在 Android 系统中，可以使用传统的 Java 线程通信技术，也可以使用 Android 专属的 Handler / Looper 消息机制。基于此，本章的主要内容为：</p><ul><li>使用单向传输的管道来进行数据传输</li><li>共享内存通信</li><li>使用 <code>BlockingQueue</code> 实现生产者消费者</li><li>消息队列的具体操作</li><li>将具体任务发回 UI 线程</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道 <code>Pipes</code> 从属于 <code>java.io</code> 包，也就是说，严格意义上讲，它是属于 Java 语言范畴，而非 Android 系统的。一个管道为同一进程的两个线程提供一种交互方式，为二者建立连接，搭建一个单向传输的数据传输通道：生产者线程向管道中写入数据，同时消费者线程从中取数据。</p><p>Java 管道与 Unix 系统管道命令 <code>|</code> 相比较起来有所不同。Java 管道用来为同一进程中的不同线程提供通信服务；而 Unix 系统管道命令用来将某个命令的输入重定向为另一命令的输入。</p><p>管道在内存中表现为一个循环缓冲区，仅适用于两个连接的线程，其他线程无法接触到其中的数据。同时，管道是单向的，只允许一个线程线程写入数据，另一线程读取数据，在这种情况下，线程安全是可以确定的。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182548.jpg" alt="Pipes"></p><p>管道的典型使用场景为，并行的两个耗时任务，其中一个线程需要不停地给另一个线程传输数据。管道可以用来为 UI 线程减压，从而保证用户界面响应的及时性，从而提升用户体验。</p><p>管道可以传输二进制数据或者字节数据。其中，二进制数据的代表为 <code>PipedOutputStream</code> 和 <code>PipedInputStream</code> ，字节数据的代表为 <code>PipedWriter</code> 和 <code>PipedReader</code> 。除了传输数据类型的不同以外，以上两种类型的管道没有任何不同。管道的生命周期自两个线程建立连接开始，断开连接时生命周期结束。</p><h4 id="管道的基本使用"><a href="#管道的基本使用" class="headerlink" title="管道的基本使用"></a>管道的基本使用</h4><p>基本的管道生命周期可以归纳概括为三个步骤：建立连接，数据传输和断开连接。</p><pre><code class="java">// 1.建立连接 - int BUFFER_SIZE_IN_CHARS = 1024 * 4; // 默认为 1024，可以自定义PipedReader r = new PipedReader(BUFFER_SIZE_IN_CHARS);PipedWriter w = new PipedWriter();w.connect(r); // r.connect(w);// 2.将消费者传入线程中, 线程启动后，就准备好从管道中读取数据了Thread t = new MyReaderThread(r);t.start();// 3. 传输数据// 类似这种生产者-消费者模型的通信方式，一般都是带有阻塞机制的。// 如果管道已满，则 write() 会处于阻塞状态，直到管道中再次有空余空间；// 如果缓存为空，则 read() 会处于阻塞状态。// flush() 方法的调用是很有必要的// 因为当 read() 线程调用 wait() 后，默认会有至少一秒钟的超时时长// flush() 方法相当于 notify()，可以保证消费者马上对新加入的数据做出响应w.write(&#39;A&#39;);w.flush();int i; // 传输的数据会被转为 int 类型，以保证不同编码格式的统一性while((i = r.read()) != -1){    char c = (char)i;}// 4. 关闭连接// 如果关闭 writer, 管道关闭但缓存中的数据还会被读取到// 如果关闭 reader, 则缓存中的数据会被清除w.close();r.close();</code></pre><h4 id="管道在-Android-系统中的应用"><a href="#管道在-Android-系统中的应用" class="headerlink" title="管道在 Android 系统中的应用"></a>管道在 Android 系统中的应用</h4><p>使用管道来对用户输入进行一些简单处理：用户通过 EditText 输入内容，为了保证 UI 线程的即时性，使用管道将用户输入内容发送到工作线程进行某些耗时操作的处理：</p><pre><code class="java">private static class TextHandlerTask implements Runnable {    private final PipedReader reader;    private TextHandlerTask(PipedReader reader) {        this.reader = reader;    }    @Override    public void run() {        while (!Thread.currentThread().isInterrupted()) {            int i;            try {                while ((i = reader.read()) != -1) {                    char c = (char) i;                    Log.e(&quot;Test&quot;, &quot;char -&gt; &quot; + c);                }            } catch (IOException e) {                e.printStackTrace();            }        }    }}private PipedReader r = new PipedReader();private PipedWriter w = new PipedWriter();w.connect(r);etSearch.addTextChangedListener(new TextWatcher() {    @Override    public void onTextChanged(CharSequence s, int start, int before, int count) {        if (count &gt; before) { // 输入内容            try {                w.write(s.subSequence(before, count).toString());            } catch (IOException e) {                e.printStackTrace();            }        }    }});new Thread(new TextHandlerTask(r)).start();</code></pre><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是一种通用的线程间通信的方式。应用程序的地址空间存储在堆中，所有线程都可以对其进行访问，即某个线程操作某个数据，该数据同时可以被其他线程所读取。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg" alt="不同线程利用共享内存进行通信"></p><p>如果某个线程将其数据存储为局部变量（本地变量），那么其他线程是无法对其进行访问的。只有将数据存储在共享内存中，才能够被其他线程访问到，从而完成不同线程间的协作。以下对象一般被认为是存储在共享内存中的：<code>实例变量</code>，<code>类变量</code>，<code>方法中声明的对象</code>。</p><p>对象的引用（指针）存储在线程的栈中，但是对象其本身（占用的内存）存储在共享内存中。不同方法之间如果想要互相操作对象，则需要将对象的引用进行传递才可以实现。<code>不同的线程通过定义实例属性以及类属性来实现通信和任务协作</code>。</p><h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><p>由于线程数据安全问题的存在，不同的线程在操作同一数据时需要有阻塞机制，来保证同一时间只有一个线程对共享数据进行操作。Java 内置的唤醒机制就很好的解决了这一问题。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182553.jpg" alt="Thread signal"></p><p>当某一线程除非满足某个条件，否则无法继续执行时，该线程可以调用 wait() / await() 方法。timeout 参数表示当前线程在下次执行前，需要等待多久。</p><p>当其他线程已经将状态更改，也就是现在正在等待的线程已经满足条件了，那么当前线程会通过调用 notify() / notifyAll() 来通知等待的线程；而收到消息的线程则可以继续向下执行。</p><p>需要注意的是，很可能并不是只有一个线程在等待，但是只能有一个线程进入同步代码块，也就是说，收到通知消息的消息也并不一定可以继续向下执行。这就要求等待线程需要遵循一定的设计模式，即<code>在同步代码块中，重复检查条件是否已经满足</code>。</p><pre><code class="java">synchronized(this){    while(isConditionFulfilled == false){        wait();    }    // 代码执行到这里时，才说明状态是对的}</code></pre><p>以上代码在同步代码块中再次检查了条件是否满足。如果不满足条件，则当前线程挂起等待；当收到通知消息，等待线程被唤醒，它在执行关键代码前会再次校验同步条件是否满足，因为有可能被其他线程捷足先登，如果不满足条件，则其会继续挂起，等待下一个唤醒信号。</p><p>以上机制很好的协同了多线程的通信，但是不适合 Android 平台，因为 UI 线程绝不能挂起等待工作线程完成任务后唤醒，之后的文章中介绍 Android 消息分发机制。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>线程信令是一种低级，高度可配置的机制，尽管它可以应用在很多场景，但同时这也是一种极容易出错的技术。因此，Java 平台基于线程信令机制，重新构建了一套抽象概念，以期解决线程之间多对象的单向切换。</p><p>在这一机制中，线程的挂起和唤醒不再通过消费者和生产者本身来控制，而是通过一个带有阻塞特性的队列来完成，例如，<code>java.util.concurrent.BlockingQueue</code>。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182555.jpg" alt="BlockingQueue"></p><p>阻塞队列扮演着生产者线程和消费者线程中间的协调者，内部维护一个实现了线程信令机制，可自定义大小的列表。具体使用的时候，如果队列中数据已满，则生产者线程 put() 方法会阻塞，直到消费者从队列中取出数据；如果队列为空，则消费者线程 take() 方法会阻塞，直到生产者向队列中插入数据。</p><pre><code class="java">public class ConsumerProducer{    private final int LIMIT = 10;    private BlockingQueue&lt;Integer&gt; blockingQueue =         new LinkedBlockingQueue&lt;Integer&gt;(LIMIT);    public void produce() throws InterruptedException{        int value = 0;        while(true){            blockingQueue.put(value++);        }    }    public void consume() throws InterruptedException{        while(true){            int value = blockingQueue.take();        }    }}</code></pre><p>以上是第四章前半部分内容，由于篇幅较长，准备分为两篇来记录。</p><p>接下来会介绍 Android 平台的消息分发机制，下篇再见，大家加油~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Efficient.Android.Threading 第四章读书笔记 上篇&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://joeljt.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Efficient.Android.Threading" scheme="http://joeljt.top/tags/Efficient-Android-Threading/"/>
    
  </entry>
  
  <entry>
    <title>Android 系统中的线程</title>
    <link href="http://joeljt.top/2018/08/29/Efficient-Android-Threading-chapter-3/"/>
    <id>http://joeljt.top/2018/08/29/Efficient-Android-Threading-chapter-3/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2019-03-21T10:53:39.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Efficient.Android.Threading 第三章读书笔记</p></blockquote><a id="more"></a><p>每个 Android 应用程序都会运行着很多线程，这些线程一般都与 Linux 进程绑定，并且通过 Dalvik VM 来管理各线程的内部执行。应用主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程，本章主要讨论方向：</p><ul><li>UI 线程，binder 线程，后台线程的区别</li><li>Linux thread coupling</li><li>应用程序排名会对线程的执行造成怎样的影响</li><li>执行 Linux 线程</li></ul><h3 id="Android-应用层线程"><a href="#Android-应用层线程" class="headerlink" title="Android 应用层线程"></a>Android 应用层线程</h3><p>Android 应用层主要包括 UI 线程，binder 线程，以及自己按需创建的后台线程。</p><h4 id="UI-线程"><a href="#UI-线程" class="headerlink" title="UI 线程"></a>UI 线程</h4><p>UI 线程在应用启动时启动，生命周期与应用相同。作为 Android 应用的主线程，UI 线程主要负责 Android 组件和界面 UI 的绘制与更新。当用户尝试在其他线程更新 UI 时，系统则会抛出异常。尽管这个处理方式看上去很不友好，但却是非常必要的。因为 Android UI Toolkit 不是线程安全的，所以为了规避不必要的麻烦，runtime 只能有一个线程来操作 UI 。</p><p>UI 线程是基于消息机制的，按照事件的顺序依次执行。所有的线程都可以通过 Handler 将事件发送到 UI 线程，如果当前线程正在做着排在前面的事件，则该事件会入队等待。</p><h4 id="Binder-线程"><a href="#Binder-线程" class="headerlink" title="Binder 线程"></a>Binder 线程</h4><p>Binder 线程主要是用来为不同进程之间提供通信的。每个进程都维护一个线程池，不会频繁的新建和销毁线程，而是不断复用现有的几个线程来协同工作。Binder 线程处理来自其他进程的请求，具体包括系统服务，intents, content providers, services。大部分涉及不到进程间通信的场景，消息都是通过 UI 线程来进行处理的。一个例外是，当前应用可能提供了一个 <code>Service</code> ，其通过 AIDL 接口与其他进程实现了绑定。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>一个应用程序中，所有需要调用者显式声明的线程，都是后台线程。一般来讲，后台线程是用户手动声明的，也就是说其默认没有任何实现，全部的工作都由调用者来定义。后台线程本质上属于 UI 线程的后代，所以它继承了一部分 UI 线程的特性，比如优先级。</p><p>在 Android 应用层，UI 线程与后台线程处理的工作是完全不同的；但是在 Linux 系统层面，二者是没有任何区别的。UI 界面的更新只能通过 UI 线程来进行，并不是被 Linux 限定的，而是通过 Application Framework 层的 Window Manager 来限制的。</p><h3 id="Linux-进程与线程"><a href="#Linux-进程与线程" class="headerlink" title="Linux 进程与线程"></a>Linux 进程与线程</h3><p>Android 系统是基于 Linux 内核的，每个应用程序实际上都是一个 Linux 程序。Android 系统的每个应用都有一个隐藏的 Linux 进程，其 fork 自 Zygote 进程，有以下几个值得注意的属性：</p><ul><li><p>User ID(UID)</p><p>Linux 系统是多用户系统，在 Android 系统中，每个应用就代表一个用户，当应用安装到系统中时，会被指定一个 User ID</p></li><li><p>Process identifier (PID)</p><p>当前进程的唯一标识</p></li><li><p>Parent process identifier  (PPID)</p><p>系统启动后，每个进程都是依附于其他进程而创建的。因此，所有正在运行中的进程会构成一个进程树，所有每个应用都有一个父亲进程。就 Android 系统来讲，所有进程的父进程都是 Zygote 进程</p></li><li><p>Stack</p><p>存储本地方法的变量和指针</p></li><li><p>Heap</p><p>当前进程私有化的地址数据信息，无法被其他进程获取到</p></li></ul><p>进程和线程一个很重要的区别就是，不同进程之间无法共享地址数据，但是同一进程的不同线程可以共享数据。这就直接导致了，线程间通信速度比进程间通信速度快得多。进程间通信需要进行一些远程操作调用，而这个过程开销比较大。</p><p>一般来讲，应用启动以后，会创建不超过十个线程；第一个创建的线程便是我们所熟知的 UI 线程，之后所有的线程都是 UI 线程繁衍出来的。具体表现在，UI 线程的 PID 是 4257，之后所有线程的 PPID 都是 UI 线程的 PID：</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182600.jpg" alt="adb shell ps"></p><h4 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h4><p>Linux 中线程为最小调度单元，而并非进程。一个程序中的某个线程需要和其他所有线程进行执行机会的争夺，在 Android 程序中，线程的调度都是直接交给 Linux 内核来处理的，而并非 Dalvik 虚拟机，也就是说每个线程都要和整个系统中的所有应用的所有线程做资源的争夺。</p><p>Linux 的线程调度器又被称为完全公平调度程序 <code>completely fair scheduler</code> ，原因就在于它执行调度时不只根据优先级，还会参考具体线程的执行时间来做判断。如果某个线程之前很少有机会被处理器执行，那么即使它优先级很低，那它也会优先得到执行；如果某个线程很少需要执行，那 CFS 会降低它的优先级，以保证它不会过分争抢资源。</p><p>Linux 平台主要有两种方式来影响线程的调度：</p><ol><li>更改线程优先级</li><li>更改 Android 专有的控制组 <code>control group</code></li></ol><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>线程的优先级在 Linux 中被称为友善度 <code>niceness</code> / <code>nicevalue</code> ，指的是当前线程对其他线程的友善程度。也就是说，友善度越低，即越不友善，则优先级越高。在 Android 中，Linux 线程的友善度从低到高为 -20 到 19，默认值为 0。</p><p>某个线程的优先级与初始化该线程所在的线程优先级相同，除非其被系统显式修改。一个应用可以通过以下两种方式更改线程的优先级：</p><ul><li>java.lang.Thread</li></ul><pre><code class="java">// Java 线程优先级，从 0 到 10 依次递增setPriority(int priority);</code></pre><ul><li>android.os.Process</li></ul><pre><code class="java">Process.setThreadPriority(int priority);Process.setThreadPriority(int threadId, int priority);</code></pre><h5 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h5><p>Android 平台不是单纯依赖 Linux 的 CFS 调度系统的，还对所有的线程进行控制组控制。所谓控制组，实际上是一个 Linux 容器，该容器用来管理当前容器中所有执行线程的处理器执行时间。一个应用中创建的所有线程都会属于某一个控制组。</p><p>Android 系统中定义了很多控制组，但是最重要的是前台组和后台组。</p><p>其中，前台组相较于后台组会得到更多的执行机会，后台组中所有的线程加一起，也得不到超过 10% 的执行时间，Android 系统就是利用这个特点来保证前台进程会得到更多的执行机会，从而保证性能和效果。</p><p>具体某个线程是否展示在前台，则与其所在进程的级别和类型有关系：</p><p><img src="http://p5zd0id9p.bkt.clouddn.com/18-8-30/70891310.jpg" alt=""></p><p>如图所示，如果某个进程执行在前台页面或者其他前台进程中，那么该进程创建的线程就会属于前台组，同时得到绝大部分的执行时间；而剩下的时间就会被分配给后台组来执行任务。</p><p>当用户进行应用切换操作时，某个线程的控制组也会实时跟着更新：按下 Home 键时，原本的前台进程会退居后台，其内部线程也会进入后台控制组；而原来的后台组也会来到前台，占据大部分的 cpu 执行时间。</p><p>这种方式极大的提高了前台应用的执行效率，一定程度上也降低了后台应用抢占系统资源的可能性，从而提高应用的性能。</p><p>尽管控制组可以一定程度上避免后台应用进程过分抢占资源，但是用户仍然可以在后台进程中创建大量线程来和 UI 线程抢占 cpu 资源。由于其在主线程创建，所以那些子线程与 UI 线程有着同样的优先级和控制组，所以这部分线程会极大的威胁到 UI 线程的正确执行。因此，有时候用户创建大量的后台进程来处理任务，本意可能是不影响 UI 线程正常工作，但是很有可能会适得其反。</p><p>像我们之前说到的，前台组和后台组是根据当前应用是否处于用户可见来界定划分的，也就是说，用户可见的应用程序中的后台线程，也是属于前台组的，会获得大部分的执行机会。在这种情况下，大量的后台线程就会影响到 UI 线程的工作，为解决这个问题，开发者可以通过将后台线程与其创建时的控制组，也就是 UI 线程所在的控制组，进行解耦分离。这个过程可以通过给线程设置足够低的优先级来实现，这样一来，这些后台线程会永远属于后台控制组，即使是其所在的进程当前是处于前台界面展示的。</p><pre><code class="java">// 这个方法不但可以降低优先级；// 还能保证当前线程与进程解耦分离，保证其永远处于后台控制组Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Android 系统中所有的线程类型：UI，binder，后台，本质上都属于 Linux Posix 线程。其中，UI 线程和 binder 线程是在应用启动时自动创建的，后台线程则完全是开发者按需创建的。Android 中所有的组件任务都是默认执行在 UI 线程的，但是为了避免界面效果卡顿以及 ANR 异常，长时间的耗时操作应该在后台进程中执行。尽管 UI 线程是最重要的执行线程，但是由于系统并不知道谁是 UI 线程，所以应该在开发时就明确注意，不要让后台线程喧宾夺主，扰乱 UI 线程的工作。这个效果通常来讲有两种实现方式，一是降低优先级，二是让不是那么重要的后台线程进入后台控制组执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Efficient.Android.Threading 第三章读书笔记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://joeljt.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Efficient.Android.Threading" scheme="http://joeljt.top/tags/Efficient-Android-Threading/"/>
    
  </entry>
  
  <entry>
    <title>Java 中的多线程</title>
    <link href="http://joeljt.top/2018/08/25/Efficient-Android-Threading-chapter-2/"/>
    <id>http://joeljt.top/2018/08/25/Efficient-Android-Threading-chapter-2/</id>
    <published>2018-08-24T16:00:00.000Z</published>
    <updated>2019-03-21T10:51:40.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Efficient.Android.Threading 第二章读书笔记</p></blockquote><a id="more"></a><p>所有 Android 应用都应该进行多线程编程，因为其可以大幅度的提高应用的性能以及响应效果；但是也会由此带来一系列的问题，导致编码的过程更加复杂。</p><ul><li>处理 Java 并发</li><li>在多个线程中保证共享数据的稳定性</li><li>定制以及优化不同线程的执行策略</li></ul><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><p>线程 <code>thread</code> 是 CPU 最小调度单元，一般来讲，一个应用中的任务会按代码顺序来执行。线程中待执行的代码被称作任务 <code>task</code>。一个线程可以只执行一个任务，也可以按顺序执行多个任务。</p><h4 id="线程的执行"><a href="#线程的执行" class="headerlink" title="线程的执行"></a>线程的执行</h4><p>Android 应用中的常用线程即 <code>java.lang.Thread</code>，线程生命周期的长度取决于执行任务的大小以及耗时。</p><p>线程支持执行实现了 <code>java.lang.Runnable</code> 接口的任务，具体的任务是实现在 <code>run</code> 方法中的，具体如下：</p><pre><code class="java">private class MyTask implements Runnable {     public void run() {        // 在 run 方法中直接或间接调用到的所有局部变量，都将存储在该线程本地内存堆栈中        int i = 0;     }}</code></pre><p>通过实例化和启动 Thread 对象，来启动任务的执行：</p><pre><code class="java">Thread thread = new Thread(new MyTask());thread.start();</code></pre><p>从操作系统层面来说，线程同时具有指令和堆栈指针。指令指针引用要处理的下一条指令，堆栈指针指向一个私有内存区域（对其他线程不可见），该区域用于存储当前线程的数据。当前线程的数据 <code>thread local data</code> 一般指的是在 Java 方法中定义的变量信息。</p><p>一般来讲，系统都希望能将 CPU 最大限度的利用起来，但矛盾的地方在于，同一 CPU 在同一时间只能运行一个线程。在这种情况下，为了让用户感知不同的程序正在同时运行，就必须让 CPU 忙起来，在不同的线程之间来回切换，进行任务的执行，这个过程被称为线程的调度<code>scheduler</code>。在 Java 中，线程调度的基准是线程的优先级 <code>priority</code> ，优先级默认为 5，范围为 1-8 。</p><p>但是，如果线程的调度是完全基于优先级的话，就有可能导致低优先级的线程任务永远得不到执行，也就是所谓的饥饿致死。为解决这个问题，Java 调度器在执行线程调度时，还会将线程的执行时间列入考虑的范围。</p><p>每次不同线程的切换被称为上下文切换 <code>context switch</code> 。每次进行上下文切换时，CPU 会先将当前正在执行的线程状态进行保存，以方便下一次恢复当前线程的执行；其后暂停当前线程，同时恢复另一线程的执行。</p><p>具体的线程调度可以通过下图进行理解，图中的 C 就是上下文切换的过程。</p><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182552.jpg" alt="线程调度示例"></p><h4 id="单线程应用"><a href="#单线程应用" class="headerlink" title="单线程应用"></a>单线程应用</h4><p>每个应用至少会有一个线程，也就是我们所熟知的主线程，默认情况下，编写的代码都将在这个线程中进行执行。</p><p>单线程编程是最简单的编码方式，但是很多情况下这种方式并不能满足我们的需求，因此，我们就需要将代码分别运行在不同的线程中，从而保证代码执行的高效性以及程序的性能。</p><h4 id="多线程应用"><a href="#多线程应用" class="headerlink" title="多线程应用"></a>多线程应用</h4><p>如果执行线程的数量超过处理器数量，则无法实现真正的并发，但调度程序在要处理的线程之间快速切换，以便将每个代码路径拆分为按顺序处理的执行间隔。尽管多线程编程会极大的提高应用的性能，但是这是有一定代价的。具体表现为：复杂性的提高，内存开销的增加，不确定的执行顺序等。</p><h5 id="复杂性提高，不确定的执行顺序"><a href="#复杂性提高，不确定的执行顺序" class="headerlink" title="复杂性提高，不确定的执行顺序"></a>复杂性提高，不确定的执行顺序</h5><p>分析单线程应用程序的执行相对简单，因为执行顺序是已知的。在多线程应用程序中，分析程序如何执行以及代码以何种顺序处理要困难得多。执行顺序在线程之间是不确定的，因为调度器将如何分配执行时间给线程是未知的。因此，多线程的执行过程是不确定的。这种不确定性不仅使代码中的错误调试变得更加困难，而且协调线程的过程中也有很大可能会引入新的错误。</p><h5 id="资源开销的增加"><a href="#资源开销的增加" class="headerlink" title="资源开销的增加"></a>资源开销的增加</h5><p>线程在内存和处理器使用方面具有开销。之前提到过，每个线程都会申请一块私有内存区域，用来存储线程数据。这片私有内存在线程创建之初就会申请出来备用，直到线程终止才会被回收并重新分配。在这个过程中，只要当前线程是存活的，即便它是闲置或是阻塞状态，也会持续占用系统资源。</p><p>处理器的开销主要来自于初始化、回收线程，以及在上下文切换中存储和恢复线程。执行的线程越多，上下文切换就越多，性能就越差。</p><h5 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h5><p>多线程程序对资源的访问还会产生一个新的问题，就是数据的共享。如果两个或更多线程同时操作某一个数据，则我们无法确定哪个线程正在对这个数据进行什么样的操作，这就导致了最后数据的不可靠性。</p><p>因为上下文切换可能发生在一个线程中不应中断的位置(比如正在对某个关键性数据进行操作时），所以必须创建代码指令的原子区域 <code>atomic region</code>。如果线程在原子区域中执行，则其他线程将被阻塞，直到在原子区域中没有其他线程执行。因此，Java中的原子区被认为是互斥的，因为它只允许访问一个线程。</p><p>可以用不同的方式创建原子区域  <code>atomic region</code>，但是最基本的同步机制是 <code>synchronized</code> 关键字 ：</p><pre><code class="java">synchronized (this) {     sharedResource++;}</code></pre><p>如果对共享资源的每次访问都是同步的，那么尽管多线程访问，数据也都将是一致的。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在多线程应用中，共享资源有可能会被多方同时访问，同时读写，这就导致了数据的不可靠性。在这种情况下，需要通过使用锁定机制来实现同步。</p><p>Android 中的锁定机制主要包括两种：</p><ul><li><p>对象内在锁定</p><p><code>synchronized</code> 关键字</p></li><li><p>显式锁</p><p><code>java.util.concurrent.locks.ReentrantLock</code><br><code>java.util.concurrent.locks.ReentrantReadWriteLock</code></p></li></ul><h4 id="内在锁和Java监视器"><a href="#内在锁和Java监视器" class="headerlink" title="内在锁和Java监视器"></a>内在锁和Java监视器</h4><p><code>synchronized</code> 关键字适用于每个 Java 对象，其内部包含一个隐式可用的锁。内部锁是互斥的，这意味着同步关键字的代码区域（临界区）中的线程执行是某一个线程独占的。当临界区被占用时，其他线程则会处于阻塞状态，在同步锁释放前，该线程代码无法继续正常执行。</p><p>内在锁充当一个监视器的角色，该监视器有三种状态：</p><ol><li><p>阻塞状态 <code>Blocked</code></p><p>当前线程要等待正在被其他线程占用的内在锁，从而处于挂起状态；</p></li><li><p>运行状态 <code>Executing</code></p><p>当前线程唯一占据内部锁并且正在临界区内执行代码；</p></li><li><p>等待状态 <code>Waiting</code></p><p>当前线程刚刚将临界区代码执行完毕，主动释放了锁；并等待下次获取内部锁；</p></li></ol><p><img src="https://raw.githubusercontent.com/Joeljt/BlogImage/master/20190321182549.jpg" alt="Java监视器示例"></p><p>一个完整的线程锁工作流大体如下：</p><ol><li><p><code>Enter the monitor</code></p><p>某个线程尝试去操作被同步锁锁住的的代码片段，此时该线程进入 Java 监视器中，如果当前同步锁被其他线程占用，则当前线程挂起；</p></li><li><p><code>Acquire the lock</code></p><p>如果当前同步锁处于空闲状态，则阻塞状态的线程则可以获取锁，并进入同步代码块开始执行。如果有多个线程阻塞等待，则由调度器决定谁将获取锁，而并不是先来后到的；</p></li><li><p><code>Release the lock and wait</code></p><p>满足某种条件后，持有锁对象的线程会主动调用锁对象的 <code>Object.wait()</code> 将锁资源释放，然后等待满足某种条件后，重新获取执行权；</p></li><li><p><code>Acquire the lock after signal</code></p><p>如果某个等待状态的线程被调度器选择为下一个执行线程，则它会在其他线程调用 <code>Object.notify()</code> 或者 <code>Objecct.notifyAll()</code> 时，获得同步锁并进入同步代码块；需要注意的是，等待线程相比较于阻塞线程并没有绝对的优先权，因为二者都想执行这部分同步代码，也就是说最终的选择权在于调度器；</p></li><li><p><code>Release the lock and exit the monitor</code></p><p>在代码执行完毕后，线程会退出监视器，让其他真正有需要的线程做操作。</p></li></ol><p>具体的同步代码块示例：</p><pre><code class="java">// (1) synchronized (this) {     // Execute code (2)     wait(); // (3)    // Execute code (4)} // (5)</code></pre><h4 id="同步对共享资源的访问"><a href="#同步对共享资源的访问" class="headerlink" title="同步对共享资源的访问"></a>同步对共享资源的访问</h4><p>在多线程应用中，共享资源可能被多方同时获取及修改，这种情况下就需要有一个有效的同步机制，来保证多线程下数据的统一性。这种机制具体包括同步锁类型的选择，以及同步代码块范围的设定。</p><h5 id="使用内部锁"><a href="#使用内部锁" class="headerlink" title="使用内部锁"></a>使用内部锁</h5><p><code>synchronized</code> 关键字有多种使用方式：</p><ul><li><p>作用在方法上</p><pre><code class="java">synchronized void changeState() {     sharedResource++;}</code></pre></li><li><p>同步代码块，使用当前类作为同步锁</p><pre><code class="java">void changeState() {     synchronized(this) {        sharedResource++;    }}</code></pre></li><li><p>同步代码块，使用其他对象作为同步锁</p><pre><code class="java">private final Object mLock = new Object();void changeState() {     synchronized(mLock) {        sharedResource++;    } }</code></pre></li><li><p>作用于静态方法</p><pre><code class="java">synchronized static void changeState() {     staticSharedResource++;}</code></pre></li><li><p>静态方法的同步代码块，使用当前类作为同步锁</p><pre><code class="java">static void changeState() {     synchronized(this.getClass()) {        staticSharedResource++;    }}</code></pre></li></ul><p>使用 this 在代码块内作为同步锁，与直接在方法上加 <code>synchronized</code> 关键字是相同的。但是更建议使用同步代码块，因为不一定方法内的全部代码都需要保证同步，滥用同步有可能导致不必要的性能损耗。</p><p>值得注意的是，作用于静态方法的同步锁对象是当前 Class 类对象，而并非其实例对象。</p><h5 id="使用显式锁机制"><a href="#使用显式锁机制" class="headerlink" title="使用显式锁机制"></a>使用显式锁机制</h5><p><code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 类可以用来替代 <code>synchronized</code> 关键字充当监视器。这种情况下，同步代码块的锁定和解锁都是由调用者手动调用的。</p><pre><code class="java">// ReentrantLock 显式锁调用示例int sharedResource;private ReentrantLock mLock = new ReentrantLock();public void changeState(){    mLock.lock();    try{        sharedResource ++;    }    finally{        mLock.unlock();    }}</code></pre><p><code>ReentrantLock</code> 和 <code>synchronized</code> 关键字语义相同，都会将同步代码块隔离开，保证只有一个线程能够对其进行操作。二者都是一种防御性策略，假设所有并发访问都存在问题，但多线程同时读取共享变量并不是有害的。因此，synchronized 和 ReentrantLock 可能存在过度保护。</p><p><code>ReentrantReadWriteLock</code> 则允许多个线程对共享数据同时进行读取，但是仍然禁止同时读写或者同时写入。示例代码如下：</p><pre><code class="java">// ReentrantReadWriteLock 显式锁调用示例int sharedResource;private ReentrantReadWriteLock mLock = new ReentrantReadWriteLock();public void changeState() {     mLock.writeLock().lock();     try {        sharedResource++;    }    finally{        mLock.unlock();    }}public int readState(){    mLock.readLock().lock();    try{        return sharedResource;    }    finally{        mLock.readLock().unlock();    }}</code></pre><p><code>ReentrantReadWriteLock</code> 相对复杂，从而会对性能造成影响。因为相对于 <code>ReentrantLock</code> 和 <code>synchronized</code> 来讲，<code>ReentrantReadWriteLock</code> 要花费更多的时间去判断应不应该阻塞当前线程，这也相当于是让读取操作同步执行的一种妥协。实际上，<code>ReentrantReadWriteLock</code> 的典型应用应该是多个线程进行读取，但只有少量线程会进行写入操作。</p><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p>生产者消费者是线程协作的经典模型，生产者线程和消费者线程共享一个列表，当该列表为空时，生产者线程向其中添加商品；如果列表不为空，则消费者线程会将商品移除。也就是说，当列表为空时，消费者线程应该阻塞等待；当列表已满时，生产者线程应该阻塞等待。</p><p><code>ComsumerProducer</code> 类包括两个线程，一个生产者线程，一个消费者线程，二者共享一个 LinkedList 对象，分别对其进行增加和删除操作：</p><pre><code class="java">public class ConsumerProducer{    private LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();    private final int LIMIT = 10;    private Object lock = new Object();    public void produce(){        int value = 0;        while(true){            synchronized(lock){                while(list.size() == LIMIT){                    lock.wait();                }                list.add(value++);                lock.notify();            }        }    }    public void consume(){        int value = 0;        while(true){            synchronized(lock){                while(list.size() == 0){                    lock.wait();                }                list.removeFirst();                lock.notify();            }        }    } }</code></pre><p>生产者线程和消费者线程共用同一把锁，来保证共享数据 list 的一致性。当列表为满时，生产者主动挂起等待；当列表为空时，消费者主动挂起等待。两个线程在挂起的同时，又会调用 <code>lock.notify()</code> 给正在等待的对方发送信号，通知其获取同步锁并执行代码，从而完成共享数据的同步。</p><pre><code class="java">final ConsumerProducer cp = new ConsumerProducer();// producernew Thread(new Runnable(){    @Override    public void run(){        cp.produce();    }}).start();// consumernew Thread(new Runnable(){    @Override    public void run(){        cp.consume();    }}).start();</code></pre><h4 id="任务执行策略"><a href="#任务执行策略" class="headerlink" title="任务执行策略"></a>任务执行策略</h4><p>一般来讲，两种极端的执行策略如下：</p><ol><li>所有的任务都执行在同一线程上</li><li>每一个任务都对应一个线程</li></ol><p>很明显上述两种策略都过于极端：前者效率过低，后者大量的线程初始化和回收会造成大量的性能消耗。尽管如此，上述两种策略还是目前最常用的两种执行方式：</p><ol><li><p>顺序执行</p><p>各个任务按照先后顺序进行执行，各任务的执行时间不会有重叠。这样做的优势是数据绝对安全，而且只有一个线程执行，占用内存会比多线程更少；缺点在于吞吐量过低，一个任务的执行与否取决于前一个任务能否成功完成；</p></li><li><p>并发执行</p><p>所有的任务都并行执行，最大化利用 CPU ，但是会带来数据的不安全性，需要进行同步机制规避。</p></li></ol><p>一个出色的执行策略应该是顺序执行和并发执行并重的。相对独立的任务应该并发执行以提高效率，但是有相对严格执行顺序的任务则应该执行在单一线程中。</p><h5 id="并发执行设计原则"><a href="#并发执行设计原则" class="headerlink" title="并发执行设计原则"></a>并发执行设计原则</h5><ul><li>控制新线程的重复创建，而应该注意对已有线程的复用，从而降低创建、回收线程的频率</li><li>提高线程使用效率，多余的线程对于内存和处理器都是一种资源浪费</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Android应用程序应该是多线程的，以提高单处理器和多处理器平台的性能。线程可以在单个处理器上顺序执行，或者在多个处理器可用时实现真正的并发。性能的提高是以增加复杂性为代价的，同样需要维护同步机制，以保证线程之间共享资源数据的一致性。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Efficient.Android.Threading 第二章读书笔记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://joeljt.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Efficient.Android.Threading" scheme="http://joeljt.top/tags/Efficient-Android-Threading/"/>
    
  </entry>
  
  <entry>
    <title>Android View.post 浅析</title>
    <link href="http://joeljt.top/2018/08/14/android-view-post/"/>
    <id>http://joeljt.top/2018/08/14/android-view-post/</id>
    <published>2018-08-13T16:00:00.000Z</published>
    <updated>2019-03-21T10:15:31.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……</p></blockquote><a id="more"></a><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>之前的文章里写到过，我们在 onCreate() 和 onResume() 方法中无法获取 View 的宽高信息，但在平时开发中，我们经常会用到 View#post 来进行 View 宽高信息的获取。</p><p>那么问题就来了，为什么 View#post 就可以获取到宽高信息？里边那个 run() 是在什么时候执行的？具体实现原理又是什么？</p><p>带着这些疑问，我最近研究了一下 View#post 的源码。本来以为挺简单的一个东西，但是没想到坑越挖越深，最过分的是，不同的版本源码还不相同，实现原理也有细微的差别。集中攻克了一个周末以后，感觉大概理解了，索性写下篇博客进行记录备忘。</p><p>文章大概分为以下几个方面：</p><ul><li>View#post 基本使用</li><li>post() 执行过程以及源码分析</li><li>post() 中 Runnable#run 执行的时机</li><li>View#post 整体流程的简单总结</li><li>Android 7.0 里 View#post 的变动以及原因</li><li>致谢</li></ul><h3 id="View-post-基本使用"><a href="#View-post-基本使用" class="headerlink" title="View#post 基本使用"></a>View#post 基本使用</h3><p>具体代码如下：</p><pre><code class="java">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    View view = findViewById(R.id.test);    view.post(new Runnable() {        @Override        public void run() {            // 可以正常获取到 View 的宽高信息            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());        }    });}</code></pre><p>这里我们以 API 26 为例，来尝试解答一下这个问题。</p><p>实际上，Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别，具体的改动以及原因在后文会一一给出分析。</p><h3 id="post-执行过程以及源码分析"><a href="#post-执行过程以及源码分析" class="headerlink" title="post() 执行过程以及源码分析"></a>post() 执行过程以及源码分析</h3><h4 id="1-View-post-入口"><a href="#1-View-post-入口" class="headerlink" title="1. View#post 入口"></a>1. View#post 入口</h4><p>先来看 View#post 源码，重点注意注释：</p><pre><code class="java">/** * Causes the Runnable to be added to the message queue. * The runnable will be run on the user interface thread. * 将 Runnable 添加到执行队列中，其最终会在 UI 线程中执行 */public boolean post(Runnable action) {    // AttachInfo 是 View 的内部类，用来存储一些基本信息    // 此处可以暂时认为 mAttachInfo 为 null    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null) {        // attachInfo 不为空时，转而使用其内部的 Handler 对象操作        return attachInfo.mHandler.post(action);    }    // Postpone the runnable until we know on which thread it needs to run.    // Assume that the runnable will be successfully placed after attach.    // 在我们确定当前 Runnable 的目标运行线程之前，先将其推迟执行    // 假设在 attach 完成之后，此 Runnable 对象会被成功的「placed」（暂且翻译成「放置」）    // 好好理解一下这个注释，我们继续往下走    getRunQueue().post(action);    return true;}</code></pre><p>首先，明确一点：<strong>Runnable 会在 UI 线程中执行</strong>；</p><p>然后，我们来看一下这个看上去很重要的 <strong>mAttachInfo</strong> 是在哪里赋值的：</p><pre><code class="java">void dispatchAttachedToWindow(AttachInfo info, int visibility) {    mAttachInfo = info;    // Transfer all pending runnables. 转移所有待办任务    if (mRunQueue != null) {        mRunQueue.executeActions(info.mHandler);        mRunQueue = null;    }    // 回调方法    onAttachedToWindow();}</code></pre><p>先不在意除了赋值以外的其他操作，我们继续追踪 dispatchAttachedToWindow 方法，发现其最初调用是在 ViewRootImpl#performTraversals 方法。好了，记住这个结论，我们先把它放在一旁。</p><p>接下来，我们来看一看这个 <strong>getRunQueue().post()</strong> 又做了什么：</p><pre><code class="java">/** * 获取一个 RunQueue 对象，用来进行 post 操作 * Returns the queue of runnable for this view. * 注释是：为当前 View 对象返回一个执行队列，记住这个「当前 View 对象」 */private HandlerActionQueue getRunQueue() {    if (mRunQueue == null) {        mRunQueue = new HandlerActionQueue();    }    return mRunQueue;}</code></pre><h4 id="2-HandlerActionQueue-又是个啥"><a href="#2-HandlerActionQueue-又是个啥" class="headerlink" title="2. HandlerActionQueue 又是个啥"></a>2. HandlerActionQueue 又是个啥</h4><p>很明显，执行 post 方法的是 HandlerActionQueue 对象，那这又是个什么东西：</p><pre><code class="java">/** * Class used to enqueue pending work from Views when no Handler is attached. * 此类用于在当前 View 没有 Handler 依附的时候，将其待完成的任务入队 */public class HandlerActionQueue {    private HandlerAction[] mActions;    private int mCount;    // 这个就是我们在外边调用的 post 方法，最终会调用到 postDelayed 方法    public void post(Runnable action) {        postDelayed(action, 0);    }    // 将传入的 Runnable 对象存入数组中，等待调用    public void postDelayed(Runnable action, long delayMillis) {        final HandlerAction handlerAction = new HandlerAction(action, delayMillis);        synchronized (this) {            if (mActions == null) {                mActions = new HandlerAction[4];            }            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);            mCount++;        }    }    // 这里才是真的执行方法    public void executeActions(Handler handler) {        synchronized (this) {            final HandlerAction[] actions = mActions;            for (int i = 0, count = mCount; i &lt; count; i++) {                final HandlerAction handlerAction = actions[i];                handler.postDelayed(handlerAction.action, handlerAction.delay);            }            mActions = null;            mCount = 0;        }    }}</code></pre><p>通过查看 HandlerActionQueue 的源码，我们发现了一个问题：不同于在 onCreate() 直接获取 View 的宽高，我们调用 post 方法，其中的 run 方法并没有被马上执行。</p><p>这样就不难解释为什么用这种方式可以获取到宽高了。那我们可以猜测一下，这种情况下，一定是 View 完成测量后才执行了这个方法，所以我们才可以拿到宽高信息。</p><p>事实上也正是这样的，那么这个方法到底是在什么时候执行的呢？很明显，HandlerActionQueue#executeActions 才是真正完成调用的方法，那这个方法又做了些什么工作呢？</p><p><strong>根据代码可知，该方法接收一个 Handler，然后使用这个 Handler 对当前队列中的所有 Runnable 进行处理，即 post 到该 Handler 的线程中，按照优先级对这些 Runnable 依次进行处理。</strong></p><p><strong>简单来说，就是传入的 Handler 决定着这些 Runnable 的执行线程。</strong></p><p>接下来，我们来追踪这个方法的调用情况。</p><p><img src="http://upload-images.jianshu.io/upload_images/5419805-e0cf86fbea081bc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="executeActions() 的调用情况"></p><p>我们注意到，对于该方法出现了两次调用，一次在 View#dispatchAttachToWindow（就是我们最开始找到的那个方法），另一次是在 ViewRootImpl#performTraversals。</p><h4 id="3-万恶之源-performTraversals"><a href="#3-万恶之源-performTraversals" class="headerlink" title="3. 万恶之源 performTraversals()"></a>3. 万恶之源 performTraversals()</h4><p>很明显，所有的证据都指向了 performTraversals ，那么下面我们就来重点分析一下这个方法。</p><p>如果你了解过 View 的测绘流程，那你对这个方法一定不会陌生，因为这个方法就是 View 绘制流程的起点。</p><pre><code class="java">private void performTraversals() {    // 此处的 host 是根布局 DecorView，用递归的方式一层一层的调用 dispatchAttachedToWindow    // mAttachInfo 是不是很眼熟，就是最开始 View#post 的第一层判断    // 这个 mAttachInfo 在 ViewRootImpl 的构造器中初始化的，其持有 ViewRootImpl 的 Handler 对象    host.dispatchAttachedToWindow(mAttachInfo, 0);    getRunQueue().executeActions(mAttachInfo.mHandler);    // 绘制流程就从这里开始    performMeasure();    performLayout();    performDraw();}</code></pre><p>我们先从 dispatchAttachedToWindow 开始，我们之前已经看过这个方法的源码了：</p><pre><code class="java">void dispatchAttachedToWindow(AttachInfo info, int visibility) {    mAttachInfo = info;    // Transfer all pending runnables. 转移所有待办任务    if (mRunQueue != null) {        mRunQueue.executeActions(info.mHandler);        mRunQueue = null;    }    // 回调方法    onAttachedToWindow();}</code></pre><p><strong>现在来进行分析：</strong></p><ol><li>我们已经知道了此方法是从根视图开始递归向下调用的，那么递归到最深处，就会轮到最开始我们调用 post 方法的 View 对象来执行该方法，也就是该方法内的所有属性，都是我们 findViewById 获得的那个 View 对象的属性；</li><li>而且我们也知道，第一个参数 AttachInfo 就是 ViewRootImpl 中初始化的 AttachInfo，它持有当前 ViewRootImpl 的 Handler 对象引用，并将该引用传给了 executeActions()。此时，我们再来回顾一下 <strong>executeActions()</strong> 方法的作用，<strong>传入的 Handler 决定着队列里这些 Runnable 的执行线程</strong>。</li></ol><p>很明显，此处的 mRunQueue 就是我们最开始调用 post() 时，调用 View#getRunQueue 返回的那个对象，这个对象中有准备获取View高度的 Runnable 对象，也就是说 <strong>mRunQueue 通过调用 executeActions() 将当前 View 的所有 Runnable ，都会转由 ViewRootImpl 的 Handler 来处理！</strong>而在完成这个工作之后，当前 View 也显示地将 mRunQueue 置空，因为所有的待办任务都已经交给 ViewRootImpl 去处理了。</p><p>现在再回过头看代码的注释，就差不多可以理解了：</p><pre><code class="java">// Postpone the runnable until we know on which thread it needs to run.// Assume that the runnable will be successfully placed after attach.// 所有的 Runnable 都会在 attach 之后被正确的放到其应该运行的线程上去getRunQueue().post(action);// Transfer all pending runnables.// 转移所有待办任务(到 ViewRootImpl 中进行处理)if (mRunQueue != null) {    mRunQueue.executeActions(info.mHandler);    mRunQueue = null;}</code></pre><p>dispatch 方法执行完了，我们继续回来走 performTraversals() ，接下来一句是：</p><pre><code class="java">// 有之前的经验，我们知道这句话的意思是// 使用 mAttachInfo.mHandler 来处理 getRunQueue() 中的 Runnable 任务getRunQueue().executeActions(mAttachInfo.mHandler);</code></pre><p>要明确的一点是，此时我们处在 ViewRootImpl 类中，此处的 getRunQueue() 方法有别于 View#post：</p><pre><code class="java">// ViewRootImpl#getRunQueue// 使用 ThreadLocal 来存储每个线程自身的执行队列 HandlerActionQueuestatic HandlerActionQueue getRunQueue() {    // sRunQueues 是 ThreadLocal&lt;HandlerActionQueue&gt; 对象    HandlerActionQueue rq = sRunQueues.get();    if (rq != null) {        return rq;    }    rq = new HandlerActionQueue();    sRunQueues.set(rq);    return rq;}// View#post// 为当前 View 返回一个执行队列，但是在 dispatchAttachToWindow 时转到 UI 线程去private HandlerActionQueue getRunQueue() {    if (mRunQueue == null) {        mRunQueue = new HandlerActionQueue();    }    return mRunQueue;}</code></pre><p>说回 performTraversals() ，很明显 getRunQueue() 是 UI 线程执行队列的第一次初始化，也就是说当前这个任务队列里并没有待执行任务！</p><p>但是需要注意的是，<strong>当前没有执行任务（</strong>HandlerActionQueue<strong>），不代表 Handler 消息队列中没有消息</strong>，这是两个概念，需要注意区分开。</p><p>总结一下：</p><ol><li>View#post 方法调用时，会为当前 View 对象初始化一个 HandlerActionQueue ，并将 Runnable 入队存储；</li><li>等在 ViewRootImpl#performTraversals 中递归调用到 View#dispatchAttachedToWindow 时，会将 ViewRootImpl 的 Handler 对象传下来，然后通过这个 Handler 将最初的 Runnable 发送到 UI 线程（消息队列中）等待执行，并将 View 的 HandlerActionQueue 对象置空，方便回收；</li><li>ViewRootImpl#performTraversals 继续执行，才会为 UI 线程首次初始化 HandlerActionQueue 对象，并通过 ThreadLocal 进行存储，方便之后的复用，但需要注意的是，此处初始化的队列中是没有任何 Runnable 对象的；</li><li>然后 ViewRootImpl#performTraversals 继续执行，开始 View 的测量流程。</li></ol><h3 id="View-post-中-Runnable-run-执行的时机"><a href="#View-post-中-Runnable-run-执行的时机" class="headerlink" title="View#post 中 Runnable#run 执行的时机"></a>View#post 中 Runnable#run 执行的时机</h3><p>但现在的问题是，无论怎么说，<strong>HandlerActionQueue#executeActions 都是先于 View 测绘流程的</strong>，为什么在还没有完成测量的时候，就可以拿到宽高信息？</p><p>我们都知道，Android 系统是基于消息机制运行的，所有的事件、行为，都是基于 Handler 消息机制在运行的。所以，当 ViewRootImpl#performTraversals 在执行的时候，也一定是基于某个消息的。而且，HandlerActionQueue#executeActions 执行的时候，也只是通过 Handler 将 Runnable post 到了 UI 线程等待执行（还记得 View#post 的注释吗？）。</p><p>不出意外的话，此时 UI 线程正忙着执行 ViewRootImpl#performTraversal ，等该方法执行完毕，View 已经完成了测量流程，此时再去执行 Runnable#run ，也就自然可以获取到 View 的宽高信息了。</p><p>下面用具体的实例佐证一下我们的猜想。</p><pre><code class="JAVA">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    final ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();    // 等待 Add 到父布局中    view = new View(this) {        @Override        protected void onLayout( ... ... ) {            super.onLayout(changed, left, top, right, bottom);            Log.e(&quot;Test&quot;, &quot;执行了onLayout()&quot;);        }    };    // 自己声明的 Handler     mHandler.post(new Runnable() {        @Override        public void run() {            Log.e(&quot;Test&quot;, &quot;mHandler.post ---- &gt; &quot; + view.getHeight());        }    });    // onCreate() 中 mAttachInfo 还未被赋值，这里会交给 ViewRootImpl 的 Handler 来处理    // 即加入消息队列，等待执行    view.post(new Runnable() {        @Override        public void run() {            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());        }    });    viewGroup.addView(view);}</code></pre><p>最终打印日志如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5419805-ec13fe6929791de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>也就是说：</p><ol><li>Handler#post 首先执行，其 post 的时间点在 onCreate() 方法内，在消息队列中的位置一定比 performTraversals() 靠前；</li><li>ViewRootImpl#performTraversal 执行，过程中执行了 View#dispatchAttachedToWindow 方法，将最初的 Runnable 入队后进行测量流程，完成了 layout 过程；</li><li>之后才执行了最初的 View#post 方法，也就说明了，在 View#dispatchAttachedToWindow 中使用 ViewRootImpl 的 Handler postDelay 的 Runnable 对象，在主线程消息队列中，确实是排在 ViewRootImpl#performTraversal 之后的</li></ol><h3 id="View-post-整体流程的简单总结"><a href="#View-post-整体流程的简单总结" class="headerlink" title="View#post 整体流程的简单总结"></a>View#post 整体流程的简单总结</h3><p>最后大概总结一下：</p><p>当我们使用 View#post 时，会有两种情况：</p><ol><li>在当前 View attach 到 Window 之前，会自己先维护一个 HandlerActionQueue 对象，用来存储当前的 Runnable 对象，然后等到 Attach 到 Window 的时候 (也就是 ViewRootImpl 执行到 performTraversal 方法时) ，会统一将 Runnable 转交给 ViewRootImpl 处理；</li><li>而在 View#dispatchAttachedToWindow 时，也会为当前 View 初始化一个 AttachInfo 对象，该对象持有 ViewRootImpl 的引用，当 View 有此对象后，后续的所有 Runnable 都将直接交给 ViewRootImpl 处理；</li><li>而 ViewRootImpl 也会在执行 performTraversal 方法，也会调用 ViewRootImpl#getRunQueue ，利用 ThreadLocal 来为主线程维护一个 HandlerActionQueue 对象，至此，ViewRootImpl 内部都将使用该队列来进行 Runnable 任务的短期维护；</li><li>但需要注意的是，各个 View 调用的 post 方法，仍然是由各自的 HandlerActionQueue 对象来入队任务的，然后在 View#dispatchAttachedToWindow 的时候转移给 ViewRootImpl 去处理。</li></ol><h3 id="Android-7-0-里-View-post-的变动以及原因"><a href="#Android-7-0-里-View-post-的变动以及原因" class="headerlink" title="Android 7.0 里 View#post 的变动以及原因"></a>Android 7.0 里 View#post 的变动以及原因</h3><p>View#post 说到这里大概就差不多了，文章开篇的时候说到：</p><blockquote><p>Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别</p></blockquote><p>下面来简单对比一下具体的差别，顺便分析一下具体为什么要这样改动。</p><p>实际上这个方法的改动主要是为了解决一个 bug，这个 bug 就是：<strong>在 View 被 attach 到 window 之前，从子线程调用的 View#post ，永远无法得到执行。</strong></p><p>具体原因，我们来看一下 API23 版本的 View#post，就大概都明白了：</p><pre><code class="java">// Android API23 View#postpublic boolean post(Runnable action) {    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null) {        return attachInfo.mHandler.post(action);    }    // Assume that post will succeed later    // 注意此处，不同于我们之前介绍的，这里是直接使用 ViewRootImpl#getRunQueue 来入队任务的    ViewRootImpl.getRunQueue().post(action);    return true;}</code></pre><p>我们可以看到，不同于我们之前介绍的，API23 版本中，View#post 在没有 attach 到 window 之前，也就是 mAttachInfo 是 null 的时候，不是自己维护任务队列，而是直接使用 ViewRootImpl#getRunQueue 来入队任务的。</p><p>再来看一下 ViewRootImpl#getRunQueue 方法，我们就会发现问题出在哪里了：</p><pre><code class="java">static final ThreadLocal&lt;RunQueue&gt; sRunQueues = new ThreadLocal&lt;RunQueue&gt;();static RunQueue getRunQueue() {    RunQueue rq = sRunQueues.get();    if (rq != null) {        return rq;    }    rq = new RunQueue();    sRunQueues.set(rq);    return rq;}</code></pre><p>没错，这个队列的保存与获取，是通过以线程为 key 值来存取对象 ThreadLocal 来维护的。而在这个版本的源码中，executeActions() 方法的执行，只有一次调用，那就是 ViewRootImpl#performTraversal 中（感兴趣的可以去 23 版本的源码中查看，这里就不贴图了），与此同时，该方法肯定是执行在主线程中的。</p><p>现在的问题就变成了：<strong>我在子线程中 post 了一个 runnable，并且系统以该子线程为 key 将队列存了起来等待执行；但是在具体执行的时候，系统却是去主线程中寻找待执行的 Runnable，那么当然是永远都得不到执行的了。</strong></p><p>而在<strong>具体 attach 到 window 之后</strong>，View 的 mAttachInfo 持有 ViewRootImpl 引用，会直接将所有的 Runnable 转交给 ViewRootImpl 的 Handler 处理，也<strong>就都能得到妥善处理，就与线程无关了。</strong></p><p>除此以外，ViewRootImpl 使用 ThreadLocal 来存储队列信息，在某些情境下，还会导致内存泄漏。详细信息可以参考：<a href="https://blog.csdn.net/a740169405/article/details/69668957" target="_blank" rel="noopener">https://blog.csdn.net/a740169405/article/details/69668957</a></p><p>所以，<strong>Google 工程师为了解决这两个问题（内存泄漏的问题更严重一些），就在 View#post 方法中使用 View 对象来进行队列的存储，然后在 attach 到 window 的时候，通过持有 ViewRootImpl 引用的 AttachInfo 对象直接将 View 对象的 Runnable 处理掉，就完美解决了这些问题。</strong></p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>下边是自己研究的时候具体参考过的文章，给各位前辈加个鸡腿：</p><h5 id="https-blog-csdn-net-a740169405-article-details-69668957"><a href="#https-blog-csdn-net-a740169405-article-details-69668957" class="headerlink" title="https://blog.csdn.net/a740169405/article/details/69668957"></a><a href="https://blog.csdn.net/a740169405/article/details/69668957" target="_blank" rel="noopener">https://blog.csdn.net/a740169405/article/details/69668957</a></h5><h5 id="https-blog-csdn-net-scnuxisan225-article-details-49815269"><a href="#https-blog-csdn-net-scnuxisan225-article-details-49815269" class="headerlink" title="https://blog.csdn.net/scnuxisan225/article/details/49815269"></a><a href="https://blog.csdn.net/scnuxisan225/article/details/49815269" target="_blank" rel="noopener">https://blog.csdn.net/scnuxisan225/article/details/49815269</a></h5><h5 id="https-www-cnblogs-com-plokmju-p-7481727-html"><a href="#https-www-cnblogs-com-plokmju-p-7481727-html" class="headerlink" title="https://www.cnblogs.com/plokmju/p/7481727.html"></a><a href="https://www.cnblogs.com/plokmju/p/7481727.html" target="_blank" rel="noopener">https://www.cnblogs.com/plokmju/p/7481727.html</a></h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>为何 Android 在 onCreate 中获取不到宽高</title>
    <link href="http://joeljt.top/2018/08/13/can-not-get-height-in-onCreate/"/>
    <id>http://joeljt.top/2018/08/13/can-not-get-height-in-onCreate/</id>
    <published>2018-08-12T16:00:00.000Z</published>
    <updated>2019-03-21T10:50:48.542Z</updated>
    
    <content type="html"><![CDATA[<p>经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。</p><a id="more"></a><p>具体代码如下：</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    @BindView(R.id.tv_test)    private TextView mTextView;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mTv.getHeight(); // 0    }    @Override    protected void onResume() {        super.onResume();        mTv.getHeight(); // 0    }}</code></pre><p>要弄清这个问题，首先需要知道代码中涉及到的方法具体做了什么工作，以及具体 View 是在什么时候完成测量的。</p><h3 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView()"></a>setContentView()</h3><p>很明显，我们在 onCreate() 方法中调用了 setContentView() 方法，而<strong>设置布局</strong>这个动作会给你一种可以获取到宽高的错觉；那么我们从源码的角度来看看，setContentView() 到底干了点什么。</p><pre><code class="java">// 1. AppCompatDelegate 的抽象方法，根据注释，会调用到 Activity 的实现方法中public abstract void setContentView(@LayoutRes int resId);// 2. Activity 的实现方法public void setContentView(@LayoutRes int layoutResID) {    // Window 是一个抽象类，其唯一实现类是 PhoneWindow    getWindow().setContentView(layoutResID);    initWindowDecorActionBar();}@Overridepublic void setContentView(int layoutResID) {    if (mContentParent == null) {        // 3. 初始化 DecorView        installDecor();    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {        mContentParent.removeAllViews();    }    ... ...}private void installDecor() {    mForceDecorInstall = false;    if (mDecor == null) {        // 4. 第一次加载窗口，mDecor 为空时，生成一个 DecorView 对象        // generateDecor(-1) : return new DecorView()        mDecor = generateDecor(-1);        ... ...    } else {        mDecor.setWindow(this);    }    if (mContentParent == null) {        // 5. 初始化父布局        mContentParent = generateLayout(mDecor);    }}// 继续跟踪到 generateLayout(mDecor) 方法内部protected ViewGroup generateLayout(DecorView decor) {    // 此处根据设置的主题进行一些基础设置，没什么决定性作用    TypedArray a = getWindowStyle();    ... ...    // 接下来的一大段代码是根据各种主题设置默认布局，篇幅原因，此处有大量源码删减    int layoutResource;    int features = getLocalFeatures();    if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) {        layoutResource = R.layout.screen_swipe_dismiss;        setCloseOnSwipeEnabled(true);    } else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) {        if (mIsFloating) {            TypedValue res = new TypedValue();            getContext().getTheme().resolveAttribute(                R.attr.dialogTitleDecorLayout, res, true);            layoutResource = res.resourceId;        } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) {            layoutResource = a.getResourceId(                R.styleable.Window_windowActionBarFullscreenDecorLayout,                R.layout.screen_action_bar);        } else {            layoutResource = R.layout.screen_title;        }    } else {        // 默认布局样式        layoutResource = R.layout.screen_simple;    }    // 6. 重点来了：将对应的布局加载到 DecorView 中    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);    return contentParent;}void onResourcesLoaded(LayoutInflater inflater, int layoutResource) {    // 加载资源文件    final View root = inflater.inflate(layoutResource, null);    ... ...    // 7. 将 View 加载到当前 DecorView 中    addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));}public void addView(View child, int index, LayoutParams params) {    // 页面发生变化的话，请求重新摆放布局以及重新绘制    // 注意，此处的 requestLayout 是 View 的方法    requestLayout();    invalidate(true);    addViewInner(child, index, params, false);}</code></pre><p>说出来你可能不信，但是 setContentView() 到这里就差不多结束了。</p><p>很明显，我们并没有发现任何关于 View 的测量的代码，最后的 requestLayout() 和 invalidate() 也和 View 的 measure() 关系不大，毕竟还没测量，哪里谈得上 layout 和 draw 呢？</p><p>所以， setContentView() 和 View 的测量没啥关系，那么在其之后也就自然获取不到 View 宽高的值了。</p><h3 id="测量流程到底是从哪里开始的"><a href="#测量流程到底是从哪里开始的" class="headerlink" title="测量流程到底是从哪里开始的"></a>测量流程到底是从哪里开始的</h3><p>有了上面的经验，我们已经知道，setContentView() 并不会触发 View 的测量，而只是为 DecorView 指定了布局；那么接下来的问题就是，测量流程到底是从哪里开始的呢？</p><p>我们简单回顾一下 Activity 的启动流程，然后来找到这个答案。</p><pre><code class="java">public void handleMessage(Message msg) {    switch (msg.what) {        case LAUNCH_ACTIVITY: {            // 1. ActivityThread 内部类 H，处理 LAUNCH_ACTIVITY 的消息            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);        } break; }// 2. 直接从 ActivityThread 的 handleLaunchActivity() 开始了private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {    // 3. 执行 performLaunchActivity() 方法    Activity a = performLaunchActivity(r, customIntent);    if (a != null) {        r.createdConfig = new Configuration(mConfiguration);        reportSizeConfigurations(r);        Bundle oldState = r.state;        // 4. 执行 handleResumeActivity() 方法        handleResumeActivity(r.token, false, r.isForward,                             !r.activity.mFinished &amp;&amp; !r.startsNotResumed,                             r.lastProcessedSeq, reason);    }}// 3. performLaunchActivity()private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {    // 基于反射，利用 Instrumentation 对象创建当前 Activity 的实例    Activity activity = null;    try {        java.lang.ClassLoader cl = appContext.getClassLoader();        activity = mInstrumentation.newActivity(            cl, component.getClassName(), r.intent);        StrictMode.incrementExpectedActivityCount(activity.getClass());        r.intent.setExtrasClassLoader(cl);        r.intent.prepareToEnterProcess();        if (r.state != null) {            r.state.setClassLoader(cl);        }    }    try {        if (activity != null) {            // attach() 方法做了一系列最基本的初始化            activity.attach(appContext, this, getInstrumentation(), r.token,                            r.ident, app, r.intent, r.activityInfo, title, r.parent,                            r.embeddedID, r.lastNonConfigurationInstances, config,                            r.referrer, r.voiceInteractor, window, r.configCallback);            activity.mCalled = false;            // 3.1 依然使用 Instrumentation 对象调用 Activity 的 onCreate() 方法            if (r.isPersistable()) {                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);            } else {                mInstrumentation.callActivityOnCreate(activity, r.state);            }            // 强制校验 super 调用            if (!activity.mCalled) {                throw new SuperNotCalledException(                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +                    &quot; did not call through to super.onCreate()&quot;);            }        }    }    return activity;}public void callActivityOnCreate(Activity activity, Bundle icicle,PersistableBundle persistentState) {    prePerformCreate(activity);    // 3.2 调用 Activity 的 performCreate() 方法    activity.performCreate(icicle, persistentState);    postPerformCreate(activity);}// 3.3 最终得以调用到实际实现的 onCreate()final void performCreate(Bundle icicle, PersistableBundle persistentState) {    restoreHasCurrentPermissionRequest(icicle);    onCreate(icicle, persistentState);    mActivityTransitionState.readState(icicle);    performCreateCommon();}// 4 performLaunchActivity() 执行完毕后，根据代码来看，会继续执行 handleResumeActivity()// 同样的，这个方法会调用到一个 performResumeActivity()，在该方法内部也会最终执行到 onResume() final void handleResumeActivity( ... ... ) {     // 最终会执行到 onResume()，不是重点     r = performResumeActivity(token, clearHide, reason);     if (r != null) {         final Activity a = r.activity;         if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {             r.window = r.activity.getWindow();             View decor = r.window.getDecorView();             ViewManager wm = a.getWindowManager();             // 5. 执行到 WindowManagerImpl 的 addView()             // 然后会跳转到 WindowManagerGlobal 的 addView()             if (a.mVisibleFromClient) {                 if (!a.mWindowAdded) {                     a.mWindowAdded = true;                     wm.addView(decor, l);                 }             }         }     } }public void addView( ... ... ) {     ViewRootImpl root;     synchronized (mLock) {         // 初始化一个 ViewRootImpl 的实例         root = new ViewRootImpl(view.getContext(), display);         try {             // 调用 setView，为 root 布局 setView             // 其中 view 为传下来的 DecorView 对象             // 也就是说，实际上根布局并不是我们认为的 DecorView，而是 ViewRootImpl             root.setView(view, wparams, panelParentView);         }     }}// 6. 将 DecorView 加载到 WindowManager, View 的绘制流程从此刻才开始public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {    // 请求对 View 进行测量和绘制    // 与 setContentView() 不同，此处的方法是 ViewRootImpl 的方法    requestLayout();}@Overridepublic void requestLayout() {    if (!mHandlingLayoutInLayoutRequest) {        checkThread();        mLayoutRequested = true;        // 7. 此方法内部有一个 post 了一个 Runnable 对象        // 在其中又调用一个 doTraversal() 方法；        // 再之后又会调用到 performTraversals() 方法，然后 View 的测绘流程就从此处开始了        scheduleTraversals();    }}private void performTraversals() {    ... ...    // Ask host how big it wants to be    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);    ... ...    performLayout(lp, mWidth, mHeight);    ... ...    performDraw();    ... ...}</code></pre><p>问题到这里就差不多得到了解答，View 的测绘流程是在 performTraversals() 才开始的；而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的宽高信息也就很容易理解了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 字体变色</title>
    <link href="http://joeljt.top/2018/08/12/color-track-textview/"/>
    <id>http://joeljt.top/2018/08/12/color-track-textview/</id>
    <published>2018-08-11T16:00:00.000Z</published>
    <updated>2019-03-21T10:33:43.994Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>主要技术点：Canvas.clipRect()</p></blockquote><p>实际上，这个方法可以理解成裁剪画布；</p><p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p><p>而这块区域，就是接下来将要进行绘制的区域。</p><p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p><pre><code class="java">@Overrideprotected void onDraw(Canvas canvas) {    // 绘制前一半内容    drawText(canvas, mChangePaint, 0, getWidth()/2);    // 使用另一颜色的画笔绘制后一半内容    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());}private void drawText(Canvas canvas, Paint paint, int start, int end) {    paint.setTextSize(getTextSize());    // 保存当前画布状态    canvas.save();    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制    Rect rect = new Rect(start, 0, end, getHeight());    canvas.clipRect(rect);    // 获取文字的基本宽高信息    String text = getText().toString();    Rect textBounds = new Rect();    paint.getTextBounds(text, 0, text.length(), textBounds);    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();    // 获取起始位置    int x = getWidth() / 2 - textBounds.width() / 2;    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;    canvas.drawText(text, x, y, paint);    // 清空画布属性，方便接下来绘制变色的部分    canvas.restore();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;主要技术点：Canvas.clipRect()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，这个方法可以理解成裁剪画布；&lt;/p&gt;
&lt;p&gt;方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下
      
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Canvas.drawPath() 简单使用记录</title>
    <link href="http://joeljt.top/2018/05/28/Canvas.drawPath()/"/>
    <id>http://joeljt.top/2018/05/28/Canvas.drawPath()/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2019-03-21T10:55:48.335Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>Path类将多种复合路径（多个轮廓，如直线段、二次曲线、立方曲线）封装在其内部的几何路径。</p><p>也就是说，我们可以使用 drawPath() 来绘制一个多边形或者不规则图形。</p></blockquote><p>下面以等边三角形为例：</p><pre><code class="java">// 假设在固定大小内绘制一个等边三角形private void drawTriangle(Canvas canvas, Paint paint) {    Path mPath = new Path();    // moveTo 移动到某一点，用于确定下笔坐标    mPath.moveTo(getWidth() / 2, 0);    // 连线到某一点，开始绘制，目标点 y 坐标是长直角边的长度    // 等边三角形，从顶点向下做高，短直角边:斜边:长直角边 = 1:2:√3    mPath.lineTo(0, getWidth() / 2 * Math.sqrt(3)));    mPath.lineTo(getWidth(), getWidth() / 2 * Math.sqrt(3)));    // 闭合多边形，即连线回到起始点，完成绘制    mPath.close();    canvas.drawPath(mPath, mPaint);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Path类将多种复合路径（多个轮廓，如直线段、二次曲线、立方曲线）封装在其内部的几何路径。&lt;/p&gt;
&lt;p&gt;也就是说，我们可以使用 drawPath() 来绘制一个多边形或者不规则图形。&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>解决可视化工具对于 MySQL 8.0 + 无法连接的问题</title>
    <link href="http://joeljt.top/2018/05/28/bug-of-mysql/"/>
    <id>http://joeljt.top/2018/05/28/bug-of-mysql/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。</p><a id="more"></a><p>同时还更改了加密方式，之前版本的加密方式是「mysql_native_password」，8.0 之后的加密规则更改为「caching_sha2_password 」，这里需要把用户密码加密规则更改为原来的加密方式即可。</p><p>具体方法步骤如下，记录备忘：</p><blockquote><p> 打开终端，输入命令</p></blockquote><pre><code class="mysql">mysql -u root -p</code></pre><blockquote><p>需要注意的是，MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，至少 8 个字符；密码是在最开始安装 MySQL 的时候设置的，如果忘记了，上网查询解决方法。</p></blockquote><blockquote><p>输入密码后，进入 &gt;mysql 的命令行模式</p></blockquote><pre><code class="mysql"># 切换到 mysql 数据库use mysql;# 设置用户密码永不过期alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;your pwd&#39; password expire never;# 用「mysql_native_password」加密方式更新 root 用户密码alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;your pwd&#39;;# 刷新flush privileges;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Paint .measureText() VS .getTextBounds()</title>
    <link href="http://joeljt.top/2018/03/29/Android%20Paint-%20.measureText()%20VS%20.getTextBounds()/"/>
    <id>http://joeljt.top/2018/03/29/Android Paint- .measureText() VS .getTextBounds()/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-11-26T10:43:06.981Z</updated>
    
    <content type="html"><![CDATA[<p>两个方法可以用来测量文字宽高信息的，只不过 <strong>.getTextBounds()</strong> 还可以获得高度信息，因为其使用一个 Rect 对象对宽高信息进行存储；而 <strong>.measureText()</strong> 则只是返回宽度信息。</p><a id="more"></a><p>具体使用方法如下：</p><pre><code class="java">final String someText = &quot;Hello. I&#39;m some text!&quot;;Paint mPaint = new Paint();// .measureText()float measuredWidth = mPaint.measureText(someText);// .getTextBounds()Rect mBounds = new Rect();mPaint.getTextBounds(someText, 0, someText.length, mBounds);int measuredWidth = mBounds.width();int measuredHeight = mBounds.height();</code></pre><p>但是，当我们把两个结果打印出来，我们会发现，对于同一个文本信息，使用两个方法得到的宽度是不同的：</p><pre><code class="java">// 打印宽度信息Log.d(&quot;Test&quot;, String.format(        &quot;Text is &#39;%s&#39;, measureText %f, getTextBounds %d&quot;,        someText,        measuredWidth,        mBounds.width())    );// 打印结果如下// Text is &#39;Hello. I&#39;m some text!&#39;, measureText 115.000000, getTextBounds 105</code></pre><p>经过一系列的探究和资料查看，最后得到的结论是：</p><blockquote><p>二者返回结果确实不同，且 measureText() 返回结果会略微大于 getTextBounds() 所得到的宽度信息</p><p>measureText() 会在文本的左右两侧加上一些额外的宽度，这部分额外的宽度叫做 Glyph’s AdvanceX （具体应该是属于字型方面的范畴，我猜测这部分宽度是类似字间距之类的东西）</p><p>getTextBounds() 返回的则是当前文本所需要的最小宽度，也就是整个文本外切矩形的宽度</p></blockquote><p>实际上，这两个方法在具体调用时虽然都是不同的方法，但在 native 层的测量算法都是一致的，只不过在最后返回时，measureText() 会在左右两侧加上一些额外的宽度值，而 getTextBounds() 则是返回需要的最小宽度而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个方法可以用来测量文字宽高信息的，只不过 &lt;strong&gt;.getTextBounds()&lt;/strong&gt; 还可以获得高度信息，因为其使用一个 Rect 对象对宽高信息进行存储；而 &lt;strong&gt;.measureText()&lt;/strong&gt; 则只是返回宽度信息。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字体变色效果实现分析</title>
    <link href="http://joeljt.top/2018/03/19/TrackColorTextView/"/>
    <id>http://joeljt.top/2018/03/19/TrackColorTextView/</id>
    <published>2018-03-18T16:00:00.000Z</published>
    <updated>2018-11-26T10:40:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要技术点：Canvas.clipRect()</p></blockquote><p>实际上，这个方法可以理解成裁剪画布；</p><p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p><p>而这块区域，就是接下来将要进行绘制的区域。</p><p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p><pre><code class="java">@Overrideprotected void onDraw(Canvas canvas) {    // 绘制前一半内容    drawText(canvas, mChangePaint, 0, getWidth()/2);    // 使用另一颜色的画笔绘制后一半内容    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());}private void drawText(Canvas canvas, Paint paint, int start, int end) {    paint.setTextSize(getTextSize());    // 保存当前画布状态    canvas.save();    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制    Rect rect = new Rect(start, 0, end, getHeight());    canvas.clipRect(rect);    // 获取文字的基本宽高信息    String text = getText().toString();    Rect textBounds = new Rect();    paint.getTextBounds(text, 0, text.length(), textBounds);    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();    // 获取起始位置    int x = getWidth() / 2 - textBounds.width() / 2;    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;    canvas.drawText(text, x, y, paint);    // 清空画布属性，方便接下来绘制变色的部分    canvas.restore();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;主要技术点：Canvas.clipRect()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，这个方法可以理解成裁剪画布；&lt;/p&gt;
&lt;p&gt;方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>抽象类和接口的区别</title>
    <link href="http://joeljt.top/2018/03/09/differ-of-abstract-interface/"/>
    <id>http://joeljt.top/2018/03/09/differ-of-abstract-interface/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>先来一个问题，java中允许多继承吗？</p><h2 id="抽象类-单继承"><a href="#抽象类-单继承" class="headerlink" title="抽象类 - 单继承"></a>抽象类 - 单继承</h2><ul><li>关键字为abstract, extends, 被类所继承</li><li>不可以被final修饰</li><li>抽象方法不可以被private修饰，但其他三个不受限制</li><li>抽象方法一定存在于抽象类中，但是抽象类中不一定有抽象方法</li><li>抽象类的子类必须全部重写抽象方法，如果只重写部分抽象方法，则该子类同样为抽象方法</li><li>抽象类中不一定全部都是抽象方法，方法可以有方法体</li><li>抽象类不可以实例化对象</li><li>抽象类可以实现接口，因为接口的内容也都是抽象的</li></ul><h2 id="接口-多实现"><a href="#接口-多实现" class="headerlink" title="接口 - 多实现"></a>接口 - 多实现</h2><ul><li>关键字为interface, implements, 被类所实现</li><li>同样不可以被final修饰</li><li>接口只允许三种成员存在：<ol><li>公共的静态常量 public final static</li><li>公共的抽象方法 public abstract</li><li>静态内部类 static class</li></ol></li><li>由上可知，接口的作用域必须为public</li><li>接口的抽象方法也必须全部被实现类所重写，否则实现类为抽象类</li><li>不同的接口之间为继承关系，而且可以多继承</li><li>接口不可以实例化对象</li><li>接口不可以继承抽象类，因为抽象类中有可能存在非抽象方法，与接口的概念相悖</li></ul><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><ul><li>每个类只能继承一个抽象类，但是可以实现多个接口</li><li>抽象类可以有非抽象方法，接口全部为抽象方法</li><li>从作用域角度看，抽象类中抽象方法不能为private，而接口强制为public abstract</li><li>抽象类可以实现接口，但是接口不能继承抽象类</li><li>不同的接口可以多继承，但是不同的抽象类只能单继承</li></ul><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来一个问题，java中允许多继承吗？&lt;/p&gt;
&lt;h2 id=&quot;抽象类-单继承&quot;&gt;&lt;a href=&quot;#抽象类-单继承&quot; class=&quot;headerlink&quot; title=&quot;抽象类 - 单继承&quot;&gt;&lt;/a&gt;抽象类 - 单继承&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键字为abstract,
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://joeljt.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java中多态的具体应用</title>
    <link href="http://joeljt.top/2018/03/09/polymorphism-of-java/"/>
    <id>http://joeljt.top/2018/03/09/polymorphism-of-java/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例</p><pre><code>// 父类public class Parent {    public int aInt = -1;    public void func1() {        System.err.print(&quot; Parent func1 &quot;);    }    public void func2() {        System.err.print(&quot; Parent func2 &quot;);    }}</code></pre><pre><code>// 子类public class Child extends Parent {    public int aInt = 1;    public void func1() {        System.err.print(&quot; Child func1 &quot;);    }    public void func3() {        System.err.print(&quot; Child func3 &quot;);    }}</code></pre><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><pre><code>// test main()public static void main(String[] args) {    Child child = new Child();    child.func1();    child.func2();    child.func3();    Parent parent = new Child();    parent.func1();    parent.func2();    parent.func3();}</code></pre><p>如上所示，将对象声明为Child对象时，三个方法都编译通过，且输入结果如下：</p><pre><code>Child func1Parent func2Child func3</code></pre><p>Child类重写了父类的func1()方法，则在运行时匹配了子类自身的重写方法，即，「运行时遵循右侧声明」。<br>但是，如果将对象声明为Parent对象时，parent.fun3()则会报错，因为「编译期遵循左侧实例」，当前对象被声明为Parent实例，而Parent中没有func3()方法，所以编译不通过。同时也正因为「运行时遵循右侧声明」，所以其运行结果如下：</p><pre><code>Child func1 // 尽管声明为Parent实例，但实际调用Child的方法Parent func2</code></pre><p>综上所述，在多态使用时，成员函数遵循两个原则，即「编译期遵循左侧实例，运行时遵循右侧声明」</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><pre><code>// test main()public static void main(String[] args) {    Parent parent = new Child();    Child child = new Child();    System.err.println(parent.aInt);    System.err.println(child.aInt);}</code></pre><p>运行结果如下：</p><pre><code>-11</code></pre><p>可以发现，打印结果与成员函数有所不同。因为如果是成员函数，运行时遵循右侧声明的话，打印结果应该相等，同为1才对。因此，成员变量在多态情境下的使用，无论编译还是运行，通通遵循左侧实例。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>成员函数<br>编译时遵循左侧实例，运行时遵循右侧声明</li><li>成员变量<br>编译或者运行一律遵循左侧实例</li></ul><p>其实也比较好理解，编译期间，当前类下不存在的成员函数或成员变量，肯定是无法被实例对象获取到的；<br>而在运行时，java中子类可以重写父类的方法，因此成员函数运行时会正确指向子类的方法，但是，子类并不可以重写父类的变量，当子类与父类有同名变量时，需要使用this和super关键字进行区分。在这种情况下，成员变量的访问则不可能像方法一样使用多态访问，因此只能是遵循左侧的实例了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 父类
public class Parent {
    public int aInt = -1;
    public void func1() {
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://joeljt.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>自定义 TextView</title>
    <link href="http://joeljt.top/2018/03/07/TextView/"/>
    <id>http://joeljt.top/2018/03/07/TextView/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-11-26T10:42:37.807Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p>一个参数</p><p>在代码中初始化时使用</p></li><li><p>两个参数</p><p>在布局文件中使用时，会经过这个方法；第二个参数 <strong>attrs</strong> 就是传入的自定义属性</p></li><li><p>三个参数</p><p>同样是在布局文件中使用，但是当文件中使用到 style 文件时才会使用，第三个参数是 style 文件</p></li></ul><h3 id="测量规格"><a href="#测量规格" class="headerlink" title="测量规格"></a>测量规格</h3><p>MeasureSpec 是一个 32 位的 int 值，前 2 位表示 SpecMode，后 30 位表示 SpecSize。</p><p>MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象内存分配，同样在使用到具体的属性时，可以通过解包的方式来获取原始值。</p><pre><code> @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        // 具体在测量控件大小时，宽高的 MeasureSpec 都是由父布局一层层传递下来的        // MeasureSpec 可以理解为是父 View 对子 View 的的测量要求        super.onMeasure(widthMeasureSpec, heightMeasureSpec);    }</code></pre><ul><li><p>MeasureSpec 的三种情况</p><ul><li><p>AT_MOST</p><p>父容器指定了一个可用大小，即 SpecSize，当前子 View 大小不能超过这个值</p><p>对应布局文件中的 wrap_content</p></li><li><p>EXACTLY</p><p>父容器已经测量出 View 所需要的精确大小，子 View 最终的大小就是测量到的值</p><p>对应布局文件中的 match_parent 或者固定数值</p></li><li><p>UNSECIFIED</p><p>一般系统的控件才会使用到这个，自己自定义 View 的话，很少用到</p></li></ul></li><li><p>ScrollView 嵌套 ListView 的解决方法的原理</p><pre><code>public class ListViewForScrollView extends ListView {    public ListViewForScrollView(Context context) {        super(context);    }    public ListViewForScrollView(Context context, AttributeSet attrs) {        super(context, attrs);    }    public ListViewForScrollView(Context context, AttributeSet attrs,        int defStyle) {        super(context, attrs, defStyle);    }    @Override    /**     * 重写该方法，达到使ListView适应ScrollView的效果     */    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        // 打包方法，重新构造 heightMeasureSpec        int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,        MeasureSpec.AT_MOST);        super.onMeasure(widthMeasureSpec, expandSpec);    }}</code></pre><p>我们知道，Android 的测绘机制是一个递归的流程，从最顶层的开始，依次递归向下测量子 View ，即调用 measureChild() 方法，一层层测量后，最后再测量最外层的 ViewGroup .</p><p>查看 ScrollView 的源码：</p><pre><code>@Override    protected void measureChild(View child, int parentWidthMeasureSpec,            int parentHeightMeasureSpec) {        ViewGroup.LayoutParams lp = child.getLayoutParams();        int childWidthMeasureSpec;        int childHeightMeasureSpec;        childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft                + mPaddingRight, lp.width);        final int verticalPadding = mPaddingTop + mPaddingBottom;        // ScrollView 在具体测量子 View 时，向下传递的测量规格为 MeasureSpec.UNSPECIFIED        childHeightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(                Math.max(0, MeasureSpec.getSize(parentHeightMeasureSpec) - verticalPadding),                MeasureSpec.UNSPECIFIED);        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);    }</code></pre><p>理论上讲，这时候代码会走到 ListView 的 onMeasure() 方法中：</p><pre><code>@Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec);        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);        int heightSize = MeasureSpec.getSize(heightMeasureSpec);        int childHeight = 0;        ... ...        // 获取 ListView 的高度，此时应该只有一个条目的高度        childHeight = child.getMeasuredHeight();         ... ...        // 重点就在这里        // 如果测量模式为 MeasureSpec.UNSPECIFIED，则最终的高度就是已测量的高度 + padding        if (heightMode == MeasureSpec.UNSPECIFIED) {            heightSize = mListPadding.top + mListPadding.bottom + childHeight +                    getVerticalFadingEdgeLength() * 2;        }        // 如果为 AT_MOST ，则会调用 measureHeightOfChildren() 方法，重新计算 View 高度        if (heightMode == MeasureSpec.AT_MOST) {            heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1);        }        setMeasuredDimension(widthSize, heightSize);    }</code></pre><p>而至于 Integer.MAX_VALUE &gt;&gt; 2，则是因为 SpecSize 是一个 30 位的值，使用 Integer.MAX_VALUE 是希望这个值尽可能的大，在后续为各个条目指定测量模式时，因为传下来的是 AT_MOST, 因此 resultSize 即为传下来的 Integer.MAX_VALUE &gt;&gt; 2，保证每个条目的高度自适应。</p><pre><code class="java">public static int getChildMeasureSpec(int spec, int padding, int childDimension) {        int specMode = MeasureSpec.getMode(spec);        int specSize = MeasureSpec.getSize(spec);        int size = Math.max(0, specSize - padding);        int resultSize = 0;        int resultMode = 0;        switch (specMode) {                 // Parent has imposed a maximum size on us            case MeasureSpec.AT_MOST:                if (childDimension &gt;= 0) {                    // Child wants a specific size... so be it                    resultSize = childDimension;                    resultMode = MeasureSpec.EXACTLY;                } else if (childDimension == LayoutParams.MATCH_PARENT) {                    // Child wants to be our size, but our size is not fixed.                    // Constrain child to not be bigger than us.                    resultSize = size;                    resultMode = MeasureSpec.AT_MOST;                } else if (childDimension == LayoutParams.WRAP_CONTENT) {                    // Child wants to determine its own size. It can&#39;t be                    // bigger than us.                    resultSize = size;                    resultMode = MeasureSpec.AT_MOST;                }                break;        }        //noinspection ResourceType        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);}</code></pre><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;构造方法&quot;&gt;&lt;a href=&quot;#构造方法&quot; class=&quot;headerlink&quot; title=&quot;构造方法&quot;&gt;&lt;/a&gt;构造方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个参数&lt;/p&gt;
&lt;p&gt;在代码中初始化时使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个参数&lt;/p&gt;
&lt;p&gt;在
      
    
    </summary>
    
    
      <category term="android" scheme="http://joeljt.top/tags/android/"/>
    
  </entry>
  
</feed>
