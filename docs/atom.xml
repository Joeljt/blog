<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe&#39;s blog</title>
  
  <subtitle>emmmmm</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joeljt.top/"/>
  <updated>2018-08-16T05:20:09.758Z</updated>
  <id>http://joeljt.top/</id>
  
  <author>
    <name>joe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android View.post 浅析</title>
    <link href="http://joeljt.top/2018/08/14/android_view_post/"/>
    <id>http://joeljt.top/2018/08/14/android_view_post/</id>
    <published>2018-08-13T16:00:00.000Z</published>
    <updated>2018-08-16T05:20:09.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……</p></blockquote><a id="more"></a><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>之前的文章里写到过，我们在 onCreate() 和 onResume() 方法中无法获取 View 的宽高信息，但在平时开发中，我们经常会用到 View#post 来进行 View 宽高信息的获取。</p><p>那么问题就来了，为什么 View#post 就可以获取到宽高信息？里边那个 run() 是在什么时候执行的？具体实现原理又是什么？</p><p>带着这些疑问，我最近研究了一下 View#post 的源码。本来以为挺简单的一个东西，但是没想到坑越挖越深，最过分的是，不同的版本源码还不相同，实现原理也有细微的差别。集中攻克了一个周末以后，感觉大概理解了，索性写下篇博客进行记录备忘。</p><p>文章大概分为以下几个方面：</p><ul><li>View#post 基本使用</li><li>post() 执行过程以及源码分析</li><li>post() 中 Runnable#run 执行的时机</li><li>View#post 整体流程的简单总结</li><li>Android 7.0 里 View#post 的变动以及原因</li><li>致谢</li></ul><h3 id="View-post-基本使用"><a href="#View-post-基本使用" class="headerlink" title="View#post 基本使用"></a>View#post 基本使用</h3><p>具体代码如下：</p><pre><code class="java">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    View view = findViewById(R.id.test);    view.post(new Runnable() {        @Override        public void run() {            // 可以正常获取到 View 的宽高信息            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());        }    });}</code></pre><p>这里我们以 API 26 为例，来尝试解答一下这个问题。</p><p>实际上，Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别，具体的改动以及原因在后文会一一给出分析。</p><h3 id="post-执行过程以及源码分析"><a href="#post-执行过程以及源码分析" class="headerlink" title="post() 执行过程以及源码分析"></a>post() 执行过程以及源码分析</h3><h4 id="1-View-post-入口"><a href="#1-View-post-入口" class="headerlink" title="1. View#post 入口"></a>1. View#post 入口</h4><p>先来看 View#post 源码，重点注意注释：</p><pre><code class="java">/** * Causes the Runnable to be added to the message queue. * The runnable will be run on the user interface thread. * 将 Runnable 添加到执行队列中，其最终会在 UI 线程中执行 */public boolean post(Runnable action) {    // AttachInfo 是 View 的内部类，用来存储一些基本信息    // 此处可以暂时认为 mAttachInfo 为 null    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null) {        // attachInfo 不为空时，转而使用其内部的 Handler 对象操作        return attachInfo.mHandler.post(action);    }    // Postpone the runnable until we know on which thread it needs to run.    // Assume that the runnable will be successfully placed after attach.    // 在我们确定当前 Runnable 的目标运行线程之前，先将其推迟执行    // 假设在 attach 完成之后，此 Runnable 对象会被成功的「placed」（暂且翻译成「放置」）    // 好好理解一下这个注释，我们继续往下走    getRunQueue().post(action);    return true;}</code></pre><p>首先，明确一点：<strong>Runnable 会在 UI 线程中执行</strong>；</p><p>然后，我们来看一下这个看上去很重要的 <strong>mAttachInfo</strong> 是在哪里赋值的：</p><pre><code class="java">void dispatchAttachedToWindow(AttachInfo info, int visibility) {    mAttachInfo = info;    // Transfer all pending runnables. 转移所有待办任务    if (mRunQueue != null) {        mRunQueue.executeActions(info.mHandler);        mRunQueue = null;    }    // 回调方法    onAttachedToWindow();}</code></pre><p>先不在意除了赋值以外的其他操作，我们继续追踪 dispatchAttachedToWindow 方法，发现其最初调用是在 ViewRootImpl#performTraversals 方法。好了，记住这个结论，我们先把它放在一旁。</p><p>接下来，我们来看一看这个 <strong>getRunQueue().post()</strong> 又做了什么：</p><pre><code class="java">/** * 获取一个 RunQueue 对象，用来进行 post 操作 * Returns the queue of runnable for this view. * 注释是：为当前 View 对象返回一个执行队列，记住这个「当前 View 对象」 */private HandlerActionQueue getRunQueue() {    if (mRunQueue == null) {        mRunQueue = new HandlerActionQueue();    }    return mRunQueue;}</code></pre><h4 id="2-HandlerActionQueue-又是个啥"><a href="#2-HandlerActionQueue-又是个啥" class="headerlink" title="2. HandlerActionQueue 又是个啥"></a>2. HandlerActionQueue 又是个啥</h4><p>很明显，执行 post 方法的是 HandlerActionQueue 对象，那这又是个什么东西：</p><pre><code class="java">/** * Class used to enqueue pending work from Views when no Handler is attached. * 此类用于在当前 View 没有 Handler 依附的时候，将其待完成的任务入队 */public class HandlerActionQueue {    private HandlerAction[] mActions;    private int mCount;    // 这个就是我们在外边调用的 post 方法，最终会调用到 postDelayed 方法    public void post(Runnable action) {        postDelayed(action, 0);    }    // 将传入的 Runnable 对象存入数组中，等待调用    public void postDelayed(Runnable action, long delayMillis) {        final HandlerAction handlerAction = new HandlerAction(action, delayMillis);        synchronized (this) {            if (mActions == null) {                mActions = new HandlerAction[4];            }            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);            mCount++;        }    }    // 这里才是真的执行方法    public void executeActions(Handler handler) {        synchronized (this) {            final HandlerAction[] actions = mActions;            for (int i = 0, count = mCount; i &lt; count; i++) {                final HandlerAction handlerAction = actions[i];                handler.postDelayed(handlerAction.action, handlerAction.delay);            }            mActions = null;            mCount = 0;        }    }}</code></pre><p>通过查看 HandlerActionQueue 的源码，我们发现了一个问题：不同于在 onCreate() 直接获取 View 的宽高，我们调用 post 方法，其中的 run 方法并没有被马上执行。</p><p>这样就不难解释为什么用这种方式可以获取到宽高了。那我们可以猜测一下，这种情况下，一定是 View 完成测量后才执行了这个方法，所以我们才可以拿到宽高信息。</p><p>事实上也正是这样的，那么这个方法到底是在什么时候执行的呢？很明显，HandlerActionQueue#executeActions 才是真正完成调用的方法，那这个方法又做了些什么工作呢？</p><p><strong>根据代码可知，该方法接收一个 Handler，然后使用这个 Handler 对当前队列中的所有 Runnable 进行处理，即 post 到该 Handler 的线程中，按照优先级对这些 Runnable 依次进行处理。</strong></p><p><strong>简单来说，就是传入的 Handler 决定着这些 Runnable 的执行线程。</strong></p><p>接下来，我们来追踪这个方法的调用情况。</p><p><img src="http://upload-images.jianshu.io/upload_images/5419805-e0cf86fbea081bc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="executeActions() 的调用情况"></p><p>我们注意到，对于该方法出现了两次调用，一次在 View#dispatchAttachToWindow（就是我们最开始找到的那个方法），另一次是在 ViewRootImpl#performTraversals。</p><h4 id="3-万恶之源-performTraversals"><a href="#3-万恶之源-performTraversals" class="headerlink" title="3. 万恶之源 performTraversals()"></a>3. 万恶之源 performTraversals()</h4><p>很明显，所有的证据都指向了 performTraversals ，那么下面我们就来重点分析一下这个方法。</p><p>如果你了解过 View 的测绘流程，那你对这个方法一定不会陌生，因为这个方法就是 View 绘制流程的起点。</p><pre><code class="java">private void performTraversals() {    // 此处的 host 是根布局 DecorView，用递归的方式一层一层的调用 dispatchAttachedToWindow    // mAttachInfo 是不是很眼熟，就是最开始 View#post 的第一层判断    // 这个 mAttachInfo 在 ViewRootImpl 的构造器中初始化的，其持有 ViewRootImpl 的 Handler 对象    host.dispatchAttachedToWindow(mAttachInfo, 0);    getRunQueue().executeActions(mAttachInfo.mHandler);    // 绘制流程就从这里开始    performMeasure();    performLayout();    performDraw();}</code></pre><p>我们先从 dispatchAttachedToWindow 开始，我们之前已经看过这个方法的源码了：</p><pre><code class="java">void dispatchAttachedToWindow(AttachInfo info, int visibility) {    mAttachInfo = info;    // Transfer all pending runnables. 转移所有待办任务    if (mRunQueue != null) {        mRunQueue.executeActions(info.mHandler);        mRunQueue = null;    }    // 回调方法    onAttachedToWindow();}</code></pre><p><strong>现在来进行分析：</strong></p><ol><li>我们已经知道了此方法是从根视图开始递归向下调用的，那么递归到最深处，就会轮到最开始我们调用 post 方法的 View 对象来执行该方法，也就是该方法内的所有属性，都是我们 findViewById 获得的那个 View 对象的属性；</li><li>而且我们也知道，第一个参数 AttachInfo 就是 ViewRootImpl 中初始化的 AttachInfo，它持有当前 ViewRootImpl 的 Handler 对象引用，并将该引用传给了 executeActions()。此时，我们再来回顾一下 <strong>executeActions()</strong> 方法的作用，<strong>传入的 Handler 决定着队列里这些 Runnable 的执行线程</strong>。</li></ol><p>很明显，此处的 mRunQueue 就是我们最开始调用 post() 时，调用 View#getRunQueue 返回的那个对象，这个对象中有准备获取View高度的 Runnable 对象，也就是说 <strong>mRunQueue 通过调用 executeActions() 将当前 View 的所有 Runnable ，都会转由 ViewRootImpl 的 Handler 来处理！</strong>而在完成这个工作之后，当前 View 也显示地将 mRunQueue 置空，因为所有的待办任务都已经交给 ViewRootImpl 去处理了。</p><p>现在再回过头看代码的注释，就差不多可以理解了：</p><pre><code class="java">// Postpone the runnable until we know on which thread it needs to run.// Assume that the runnable will be successfully placed after attach.// 所有的 Runnable 都会在 attach 之后被正确的放到其应该运行的线程上去getRunQueue().post(action);// Transfer all pending runnables.// 转移所有待办任务(到 ViewRootImpl 中进行处理)if (mRunQueue != null) {    mRunQueue.executeActions(info.mHandler);    mRunQueue = null;}</code></pre><p>dispatch 方法执行完了，我们继续回来走 performTraversals() ，接下来一句是：</p><pre><code class="java">// 有之前的经验，我们知道这句话的意思是// 使用 mAttachInfo.mHandler 来处理 getRunQueue() 中的 Runnable 任务getRunQueue().executeActions(mAttachInfo.mHandler);</code></pre><p>要明确的一点是，此时我们处在 ViewRootImpl 类中，此处的 getRunQueue() 方法有别于 View#post：</p><pre><code class="java">// ViewRootImpl#getRunQueue// 使用 ThreadLocal 来存储每个线程自身的执行队列 HandlerActionQueuestatic HandlerActionQueue getRunQueue() {    // sRunQueues 是 ThreadLocal&lt;HandlerActionQueue&gt; 对象    HandlerActionQueue rq = sRunQueues.get();    if (rq != null) {        return rq;    }    rq = new HandlerActionQueue();    sRunQueues.set(rq);    return rq;}// View#post// 为当前 View 返回一个执行队列，但是在 dispatchAttachToWindow 时转到 UI 线程去private HandlerActionQueue getRunQueue() {    if (mRunQueue == null) {        mRunQueue = new HandlerActionQueue();    }    return mRunQueue;}</code></pre><p>说回 performTraversals() ，很明显 getRunQueue() 是 UI 线程执行队列的第一次初始化，也就是说当前这个任务队列里并没有待执行任务！</p><p>但是需要注意的是，<strong>当前没有执行任务（</strong>HandlerActionQueue<strong>），不代表 Handler 消息队列中没有消息</strong>，这是两个概念，需要注意区分开。</p><p>总结一下：</p><ol><li>View#post 方法调用时，会为当前 View 对象初始化一个 HandlerActionQueue ，并将 Runnable 入队存储；</li><li>等在 ViewRootImpl#performTraversals 中递归调用到 View#dispatchAttachedToWindow 时，会将 ViewRootImpl 的 Handler 对象传下来，然后通过这个 Handler 将最初的 Runnable 发送到 UI 线程（消息队列中）等待执行，并将 View 的 HandlerActionQueue 对象置空，方便回收；</li><li>ViewRootImpl#performTraversals 继续执行，才会为 UI 线程首次初始化 HandlerActionQueue 对象，并通过 ThreadLocal 进行存储，方便之后的复用，但需要注意的是，此处初始化的队列中是没有任何 Runnable 对象的；</li><li>然后 ViewRootImpl#performTraversals 继续执行，开始 View 的测量流程。</li></ol><h3 id="View-post-中-Runnable-run-执行的时机"><a href="#View-post-中-Runnable-run-执行的时机" class="headerlink" title="View#post 中 Runnable#run 执行的时机"></a>View#post 中 Runnable#run 执行的时机</h3><p>但现在的问题是，无论怎么说，<strong>HandlerActionQueue#executeActions 都是先于 View 测绘流程的</strong>，为什么在还没有完成测量的时候，就可以拿到宽高信息？</p><p>我们都知道，Android 系统是基于消息机制运行的，所有的事件、行为，都是基于 Handler 消息机制在运行的。所以，当 ViewRootImpl#performTraversals 在执行的时候，也一定是基于某个消息的。而且，HandlerActionQueue#executeActions 执行的时候，也只是通过 Handler 将 Runnable post 到了 UI 线程等待执行（还记得 View#post 的注释吗？）。</p><p>不出意外的话，此时 UI 线程正忙着执行 ViewRootImpl#performTraversal ，等该方法执行完毕，View 已经完成了测量流程，此时再去执行 Runnable#run ，也就自然可以获取到 View 的宽高信息了。</p><p>下面用具体的实例佐证一下我们的猜想。</p><pre><code class="JAVA">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    final ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();    // 等待 Add 到父布局中    view = new View(this) {        @Override        protected void onLayout( ... ... ) {            super.onLayout(changed, left, top, right, bottom);            Log.e(&quot;Test&quot;, &quot;执行了onLayout()&quot;);        }    };    // 自己声明的 Handler     mHandler.post(new Runnable() {        @Override        public void run() {            Log.e(&quot;Test&quot;, &quot;mHandler.post ---- &gt; &quot; + view.getHeight());        }    });    // onCreate() 中 mAttachInfo 还未被赋值，这里会交给 ViewRootImpl 的 Handler 来处理    // 即加入消息队列，等待执行    view.post(new Runnable() {        @Override        public void run() {            Log.e(&quot;Test&quot;, &quot;view.post ---- &gt; &quot; + view.getHeight());        }    });    viewGroup.addView(view);}</code></pre><p>最终打印日志如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5419805-ec13fe6929791de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>也就是说：</p><ol><li>Handler#post 首先执行，其 post 的时间点在 onCreate() 方法内，在消息队列中的位置一定比 performTraversals() 靠前；</li><li>ViewRootImpl#performTraversal 执行，过程中执行了 View#dispatchAttachedToWindow 方法，将最初的 Runnable 入队后进行测量流程，完成了 layout 过程；</li><li>之后才执行了最初的 View#post 方法，也就说明了，在 View#dispatchAttachedToWindow 中使用 ViewRootImpl 的 Handler postDelay 的 Runnable 对象，在主线程消息队列中，确实是排在 ViewRootImpl#performTraversal 之后的</li></ol><h3 id="View-post-整体流程的简单总结"><a href="#View-post-整体流程的简单总结" class="headerlink" title="View#post 整体流程的简单总结"></a>View#post 整体流程的简单总结</h3><p>最后大概总结一下：</p><p>当我们使用 View#post 时，会有两种情况：</p><ol><li>在当前 View attach 到 Window 之前，会自己先维护一个 HandlerActionQueue 对象，用来存储当前的 Runnable 对象，然后等到 Attach 到 Window 的时候 (也就是 ViewRootImpl 执行到 performTraversal 方法时) ，会统一将 Runnable 转交给 ViewRootImpl 处理；</li><li>而在 View#dispatchAttachedToWindow 时，也会为当前 View 初始化一个 AttachInfo 对象，该对象持有 ViewRootImpl 的引用，当 View 有此对象后，后续的所有 Runnable 都将直接交给 ViewRootImpl 处理；</li><li>而 ViewRootImpl 也会在执行 performTraversal 方法，也会调用 ViewRootImpl#getRunQueue ，利用 ThreadLocal 来为主线程维护一个 HandlerActionQueue 对象，至此，ViewRootImpl 内部都将使用该队列来进行 Runnable 任务的短期维护；</li><li>但需要注意的是，各个 View 调用的 post 方法，仍然是由各自的 HandlerActionQueue 对象来入队任务的，然后在 View#dispatchAttachedToWindow 的时候转移给 ViewRootImpl 去处理。</li></ol><h3 id="Android-7-0-里-View-post-的变动以及原因"><a href="#Android-7-0-里-View-post-的变动以及原因" class="headerlink" title="Android 7.0 里 View#post 的变动以及原因"></a>Android 7.0 里 View#post 的变动以及原因</h3><p>View#post 说到这里大概就差不多了，文章开篇的时候说到：</p><blockquote><p>Android 系统以 API 24 为界，之前之后的版本，对此处的实现有细微的差别</p></blockquote><p>下面来简单对比一下具体的差别，顺便分析一下具体为什么要这样改动。</p><p>实际上这个方法的改动主要是为了解决一个 bug，这个 bug 就是：<strong>在 View 被 attach 到 window 之前，从子线程调用的 View#post ，永远无法得到执行。</strong></p><p>具体原因，我们来看一下 API23 版本的 View#post，就大概都明白了：</p><pre><code class="java">// Android API23 View#postpublic boolean post(Runnable action) {    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null) {        return attachInfo.mHandler.post(action);    }    // Assume that post will succeed later    // 注意此处，不同于我们之前介绍的，这里是直接使用 ViewRootImpl#getRunQueue 来入队任务的    ViewRootImpl.getRunQueue().post(action);    return true;}</code></pre><p>我们可以看到，不同于我们之前介绍的，API23 版本中，View#post 在没有 attach 到 window 之前，也就是 mAttachInfo 是 null 的时候，不是自己维护任务队列，而是直接使用 ViewRootImpl#getRunQueue 来入队任务的。</p><p>再来看一下 ViewRootImpl#getRunQueue 方法，我们就会发现问题出在哪里了：</p><pre><code class="java">static final ThreadLocal&lt;RunQueue&gt; sRunQueues = new ThreadLocal&lt;RunQueue&gt;();static RunQueue getRunQueue() {    RunQueue rq = sRunQueues.get();    if (rq != null) {        return rq;    }    rq = new RunQueue();    sRunQueues.set(rq);    return rq;}</code></pre><p>没错，这个队列的保存与获取，是通过以线程为 key 值来存取对象 ThreadLocal 来维护的。而在这个版本的源码中，executeActions() 方法的执行，只有一次调用，那就是 ViewRootImpl#performTraversal 中（感兴趣的可以去 23 版本的源码中查看，这里就不贴图了），与此同时，该方法肯定是执行在主线程中的。</p><p>现在的问题就变成了：<strong>我在子线程中 post 了一个 runnable，并且系统以该子线程为 key 将队列存了起来等待执行；但是在具体执行的时候，系统却是去主线程中寻找待执行的 Runnable，那么当然是永远都得不到执行的了。</strong></p><p>而在<strong>具体 attach 到 window 之后</strong>，View 的 mAttachInfo 持有 ViewRootImpl 引用，会直接将所有的 Runnable 转交给 ViewRootImpl 的 Handler 处理，也<strong>就都能得到妥善处理，就与线程无关了。</strong></p><p>除此以外，ViewRootImpl 使用 ThreadLocal 来存储队列信息，在某些情境下，还会导致内存泄漏。详细信息可以参考：<a href="https://blog.csdn.net/a740169405/article/details/69668957" target="_blank" rel="noopener">https://blog.csdn.net/a740169405/article/details/69668957</a></p><p>所以，<strong>Google 工程师为了解决这两个问题（内存泄漏的问题更严重一些），就在 View#post 方法中使用 View 对象来进行队列的存储，然后在 attach 到 window 的时候，通过持有 ViewRootImpl 引用的 AttachInfo 对象直接将 View 对象的 Runnable 处理掉，就完美解决了这些问题。</strong></p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>下边是自己研究的时候具体参考过的文章，给各位前辈加个鸡腿：</p><h5 id="https-blog-csdn-net-a740169405-article-details-69668957"><a href="#https-blog-csdn-net-a740169405-article-details-69668957" class="headerlink" title="https://blog.csdn.net/a740169405/article/details/69668957"></a><a href="https://blog.csdn.net/a740169405/article/details/69668957" target="_blank" rel="noopener">https://blog.csdn.net/a740169405/article/details/69668957</a></h5><h5 id="https-blog-csdn-net-scnuxisan225-article-details-49815269"><a href="#https-blog-csdn-net-scnuxisan225-article-details-49815269" class="headerlink" title="https://blog.csdn.net/scnuxisan225/article/details/49815269"></a><a href="https://blog.csdn.net/scnuxisan225/article/details/49815269" target="_blank" rel="noopener">https://blog.csdn.net/scnuxisan225/article/details/49815269</a></h5><h5 id="https-www-cnblogs-com-plokmju-p-7481727-html"><a href="#https-www-cnblogs-com-plokmju-p-7481727-html" class="headerlink" title="https://www.cnblogs.com/plokmju/p/7481727.html"></a><a href="https://www.cnblogs.com/plokmju/p/7481727.html" target="_blank" rel="noopener">https://www.cnblogs.com/plokmju/p/7481727.html</a></h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;研究这个问题的契机很偶然，本来是在研究 View 的测绘流程，结果不知道为什么，就莫名其妙钻到这个牛角尖里来了……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://joeljt.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>onCreate() 和 onResume() 里获取不到 View 的高度</title>
    <link href="http://joeljt.top/2018/08/13/can_not_get_height_in_onCreate/"/>
    <id>http://joeljt.top/2018/08/13/can_not_get_height_in_onCreate/</id>
    <published>2018-08-12T16:00:00.000Z</published>
    <updated>2018-08-16T03:49:30.369Z</updated>
    
    <content type="html"><![CDATA[<p>经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。</p><a id="more"></a><p>具体代码如下：</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    @BindView(R.id.tv_test)    private TextView mTextView;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mTv.getHeight(); // 0    }    @Override    protected void onResume() {        super.onResume();        mTv.getHeight(); // 0    }}</code></pre><p>要弄清这个问题，首先需要知道代码中涉及到的方法具体做了什么工作，以及具体 View 是在什么时候完成测量的。</p><h3 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView()"></a>setContentView()</h3><p>很明显，我们在 onCreate() 方法中调用了 setContentView() 方法，而<strong>设置布局</strong>这个动作会给你一种可以获取到宽高的错觉；那么我们从源码的角度来看看，setContentView() 到底干了点什么。</p><pre><code class="java">// 1. AppCompatDelegate 的抽象方法，根据注释，会调用到 Activity 的实现方法中public abstract void setContentView(@LayoutRes int resId);// 2. Activity 的实现方法public void setContentView(@LayoutRes int layoutResID) {    // Window 是一个抽象类，其唯一实现类是 PhoneWindow    getWindow().setContentView(layoutResID);    initWindowDecorActionBar();}@Overridepublic void setContentView(int layoutResID) {    if (mContentParent == null) {        // 3. 初始化 DecorView        installDecor();    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {        mContentParent.removeAllViews();    }    ... ...}private void installDecor() {    mForceDecorInstall = false;    if (mDecor == null) {        // 4. 第一次加载窗口，mDecor 为空时，生成一个 DecorView 对象        // generateDecor(-1) : return new DecorView()        mDecor = generateDecor(-1);        ... ...    } else {        mDecor.setWindow(this);    }    if (mContentParent == null) {        // 5. 初始化父布局        mContentParent = generateLayout(mDecor);    }}// 继续跟踪到 generateLayout(mDecor) 方法内部protected ViewGroup generateLayout(DecorView decor) {    // 此处根据设置的主题进行一些基础设置，没什么决定性作用    TypedArray a = getWindowStyle();    ... ...    // 接下来的一大段代码是根据各种主题设置默认布局，篇幅原因，此处有大量源码删减    int layoutResource;    int features = getLocalFeatures();    if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) {        layoutResource = R.layout.screen_swipe_dismiss;        setCloseOnSwipeEnabled(true);    } else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) {        if (mIsFloating) {            TypedValue res = new TypedValue();            getContext().getTheme().resolveAttribute(                R.attr.dialogTitleDecorLayout, res, true);            layoutResource = res.resourceId;        } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) {            layoutResource = a.getResourceId(                R.styleable.Window_windowActionBarFullscreenDecorLayout,                R.layout.screen_action_bar);        } else {            layoutResource = R.layout.screen_title;        }    } else {        // 默认布局样式        layoutResource = R.layout.screen_simple;    }    // 6. 重点来了：将对应的布局加载到 DecorView 中    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);    return contentParent;}void onResourcesLoaded(LayoutInflater inflater, int layoutResource) {    // 加载资源文件    final View root = inflater.inflate(layoutResource, null);    ... ...    // 7. 将 View 加载到当前 DecorView 中    addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));}public void addView(View child, int index, LayoutParams params) {    // 页面发生变化的话，请求重新摆放布局以及重新绘制    // 注意，此处的 requestLayout 是 View 的方法    requestLayout();    invalidate(true);    addViewInner(child, index, params, false);}</code></pre><p>说出来你可能不信，但是 setContentView() 到这里就差不多结束了。</p><p>很明显，我们并没有发现任何关于 View 的测量的代码，最后的 requestLayout() 和 invalidate() 也和 View 的 measure() 关系不大，毕竟还没测量，哪里谈得上 layout 和 draw 呢？</p><p>所以， setContentView() 和 View 的测量没啥关系，那么在其之后也就自然获取不到 View 宽高的值了。</p><h3 id="测量流程到底是从哪里开始的"><a href="#测量流程到底是从哪里开始的" class="headerlink" title="测量流程到底是从哪里开始的"></a>测量流程到底是从哪里开始的</h3><p>有了上面的经验，我们已经知道，setContentView() 并不会触发 View 的测量，而只是为 DecorView 指定了布局；那么接下来的问题就是，测量流程到底是从哪里开始的呢？</p><p>我们简单回顾一下 Activity 的启动流程，然后来找到这个答案。</p><pre><code class="java">public void handleMessage(Message msg) {    switch (msg.what) {        case LAUNCH_ACTIVITY: {            // 1. ActivityThread 内部类 H，处理 LAUNCH_ACTIVITY 的消息            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);        } break; }// 2. 直接从 ActivityThread 的 handleLaunchActivity() 开始了private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {    // 3. 执行 performLaunchActivity() 方法    Activity a = performLaunchActivity(r, customIntent);    if (a != null) {        r.createdConfig = new Configuration(mConfiguration);        reportSizeConfigurations(r);        Bundle oldState = r.state;        // 4. 执行 handleResumeActivity() 方法        handleResumeActivity(r.token, false, r.isForward,                             !r.activity.mFinished &amp;&amp; !r.startsNotResumed,                             r.lastProcessedSeq, reason);    }}// 3. performLaunchActivity()private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {    // 基于反射，利用 Instrumentation 对象创建当前 Activity 的实例    Activity activity = null;    try {        java.lang.ClassLoader cl = appContext.getClassLoader();        activity = mInstrumentation.newActivity(            cl, component.getClassName(), r.intent);        StrictMode.incrementExpectedActivityCount(activity.getClass());        r.intent.setExtrasClassLoader(cl);        r.intent.prepareToEnterProcess();        if (r.state != null) {            r.state.setClassLoader(cl);        }    }    try {        if (activity != null) {            // attach() 方法做了一系列最基本的初始化            activity.attach(appContext, this, getInstrumentation(), r.token,                            r.ident, app, r.intent, r.activityInfo, title, r.parent,                            r.embeddedID, r.lastNonConfigurationInstances, config,                            r.referrer, r.voiceInteractor, window, r.configCallback);            activity.mCalled = false;            // 3.1 依然使用 Instrumentation 对象调用 Activity 的 onCreate() 方法            if (r.isPersistable()) {                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);            } else {                mInstrumentation.callActivityOnCreate(activity, r.state);            }            // 强制校验 super 调用            if (!activity.mCalled) {                throw new SuperNotCalledException(                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +                    &quot; did not call through to super.onCreate()&quot;);            }        }    }    return activity;}public void callActivityOnCreate(Activity activity, Bundle icicle,PersistableBundle persistentState) {    prePerformCreate(activity);    // 3.2 调用 Activity 的 performCreate() 方法    activity.performCreate(icicle, persistentState);    postPerformCreate(activity);}// 3.3 最终得以调用到实际实现的 onCreate()final void performCreate(Bundle icicle, PersistableBundle persistentState) {    restoreHasCurrentPermissionRequest(icicle);    onCreate(icicle, persistentState);    mActivityTransitionState.readState(icicle);    performCreateCommon();}// 4 performLaunchActivity() 执行完毕后，根据代码来看，会继续执行 handleResumeActivity()// 同样的，这个方法会调用到一个 performResumeActivity()，在该方法内部也会最终执行到 onResume() final void handleResumeActivity( ... ... ) {     // 最终会执行到 onResume()，不是重点     r = performResumeActivity(token, clearHide, reason);     if (r != null) {         final Activity a = r.activity;         if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {             r.window = r.activity.getWindow();             View decor = r.window.getDecorView();             ViewManager wm = a.getWindowManager();             // 5. 执行到 WindowManagerImpl 的 addView()             // 然后会跳转到 WindowManagerGlobal 的 addView()             if (a.mVisibleFromClient) {                 if (!a.mWindowAdded) {                     a.mWindowAdded = true;                     wm.addView(decor, l);                 }             }         }     } }public void addView( ... ... ) {     ViewRootImpl root;     synchronized (mLock) {         // 初始化一个 ViewRootImpl 的实例         root = new ViewRootImpl(view.getContext(), display);         try {             // 调用 setView，为 root 布局 setView             // 其中 view 为传下来的 DecorView 对象             // 也就是说，实际上根布局并不是我们认为的 DecorView，而是 ViewRootImpl             root.setView(view, wparams, panelParentView);         }     }}// 6. 将 DecorView 加载到 WindowManager, View 的绘制流程从此刻才开始public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {    // 请求对 View 进行测量和绘制    // 与 setContentView() 不同，此处的方法是 ViewRootImpl 的方法    requestLayout();}@Overridepublic void requestLayout() {    if (!mHandlingLayoutInLayoutRequest) {        checkThread();        mLayoutRequested = true;        // 7. 此方法内部有一个 post 了一个 Runnable 对象        // 在其中又调用一个 doTraversal() 方法；        // 再之后又会调用到 performTraversals() 方法，然后 View 的测绘流程就从此处开始了        scheduleTraversals();    }}private void performTraversals() {    ... ...    // Ask host how big it wants to be    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);    ... ...    performLayout(lp, mWidth, mHeight);    ... ...    performDraw();    ... ...}</code></pre><p>问题到这里就差不多得到了解答，View 的测绘流程是在 performTraversals() 才开始的；而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的宽高信息也就很容易理解了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历过一段时间的开发以后，我们都会发现 onCreate() 和 onResume() 里无法获取到 View 的宽高信息，但是为什么呢？明明 setContentView 了不是吗？今天我们就来看一下这个问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字体变色效果实现分析</title>
    <link href="http://joeljt.top/2018/08/12/color_track_textview/"/>
    <id>http://joeljt.top/2018/08/12/color_track_textview/</id>
    <published>2018-08-11T16:00:00.000Z</published>
    <updated>2018-08-16T03:44:53.747Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>主要技术点：Canvas.clipRect()</p></blockquote><p>实际上，这个方法可以理解成裁剪画布；</p><p>方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下顶点两个坐标作为参数，用于确认一块区域；</p><p>而这块区域，就是接下来将要进行绘制的区域。</p><p>通过对画布进行不断的裁剪，同时对左右两侧使用不同颜色的画笔对相同的文字进行绘制，来实现一个文本两种颜色的效果。</p><pre><code class="java">@Overrideprotected void onDraw(Canvas canvas) {    // 绘制前一半内容    drawText(canvas, mChangePaint, 0, getWidth()/2);    // 使用另一颜色的画笔绘制后一半内容    drawText(canvas, mOriginPaint, getWidth() / 2, getWidth());}private void drawText(Canvas canvas, Paint paint, int start, int end) {    paint.setTextSize(getTextSize());    // 保存当前画布状态    canvas.save();    // 使用 .clipRect() 方法切割画布，然后使用不同颜色的画笔对目标文字进行绘制    Rect rect = new Rect(start, 0, end, getHeight());    canvas.clipRect(rect);    // 获取文字的基本宽高信息    String text = getText().toString();    Rect textBounds = new Rect();    paint.getTextBounds(text, 0, text.length(), textBounds);    Paint.FontMetricsInt metrics = paint.getFontMetricsInt();    // 获取起始位置    int x = getWidth() / 2 - textBounds.width() / 2;    int y = getHeight() / 2 + (metrics.bottom - metrics.top) / 2 - metrics.bottom;    canvas.drawText(text, x, y, paint);    // 清空画布属性，方便接下来绘制变色的部分    canvas.restore();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;主要技术点：Canvas.clipRect()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，这个方法可以理解成裁剪画布；&lt;/p&gt;
&lt;p&gt;方法接收一个 Rect 对象，而 Rect 对象同样接收左上顶点和右下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解决可视化工具对于 MySQL 8.0 + 无法连接的问题</title>
    <link href="http://joeljt.top/2018/05/28/bug_of_mysql/"/>
    <id>http://joeljt.top/2018/05/28/bug_of_mysql/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。</p><a id="more"></a><p>同时还更改了加密方式，之前版本的加密方式是「mysql_native_password」，8.0 之后的加密规则更改为「caching_sha2_password 」，这里需要把用户密码加密规则更改为原来的加密方式即可。</p><p>具体方法步骤如下，记录备忘：</p><blockquote><p> 打开终端，输入命令</p></blockquote><pre><code class="mysql">mysql -u root -p</code></pre><blockquote><p>需要注意的是，MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，至少 8 个字符；密码是在最开始安装 MySQL 的时候设置的，如果忘记了，上网查询解决方法。</p></blockquote><blockquote><p>输入密码后，进入 &gt;mysql 的命令行模式</p></blockquote><pre><code class="mysql"># 切换到 mysql 数据库use mysql;# 设置用户密码永不过期alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;your pwd&#39; password expire never;# 用「mysql_native_password」加密方式更新 root 用户密码alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;your pwd&#39;;# 刷新flush privileges;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL 8.0 版本去除了 password 字段，改用 authentication_string 字段，导致网上可以搜到的各种问题的各种解决方法完全没有效果。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>抽象类和接口的区别</title>
    <link href="http://joeljt.top/2018/03/09/differ_of_abstract_interface/"/>
    <id>http://joeljt.top/2018/03/09/differ_of_abstract_interface/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>先来一个问题，java中允许多继承吗？</p><h2 id="抽象类-单继承"><a href="#抽象类-单继承" class="headerlink" title="抽象类 - 单继承"></a>抽象类 - 单继承</h2><ul><li>关键字为abstract, extends, 被类所继承</li><li>不可以被final修饰</li><li>抽象方法不可以被private修饰，但其他三个不受限制</li><li>抽象方法一定存在于抽象类中，但是抽象类中不一定有抽象方法</li><li>抽象类的子类必须全部重写抽象方法，如果只重写部分抽象方法，则该子类同样为抽象方法</li><li>抽象类中不一定全部都是抽象方法，方法可以有方法体</li><li>抽象类不可以实例化对象</li><li>抽象类可以实现接口，因为接口的内容也都是抽象的</li></ul><h2 id="接口-多实现"><a href="#接口-多实现" class="headerlink" title="接口 - 多实现"></a>接口 - 多实现</h2><ul><li>关键字为interface, implements, 被类所实现</li><li>同样不可以被final修饰</li><li>接口只允许三种成员存在：<ol><li>公共的静态常量 public final static</li><li>公共的抽象方法 public abstract</li><li>静态内部类 static class</li></ol></li><li>由上可知，接口的作用域必须为public</li><li>接口的抽象方法也必须全部被实现类所重写，否则实现类为抽象类</li><li>不同的接口之间为继承关系，而且可以多继承</li><li>接口不可以实例化对象</li><li>接口不可以继承抽象类，因为抽象类中有可能存在非抽象方法，与接口的概念相悖</li></ul><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><ul><li>每个类只能继承一个抽象类，但是可以实现多个接口</li><li>抽象类可以有非抽象方法，接口全部为抽象方法</li><li>从作用域角度看，抽象类中抽象方法不能为private，而接口强制为public abstract</li><li>抽象类可以实现接口，但是接口不能继承抽象类</li><li>不同的接口可以多继承，但是不同的抽象类只能单继承</li></ul><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来一个问题，java中允许多继承吗？&lt;/p&gt;
&lt;h2 id=&quot;抽象类-单继承&quot;&gt;&lt;a href=&quot;#抽象类-单继承&quot; class=&quot;headerlink&quot; title=&quot;抽象类 - 单继承&quot;&gt;&lt;/a&gt;抽象类 - 单继承&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键字为abstract,
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://joeljt.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java中多态的具体应用</title>
    <link href="http://joeljt.top/2018/03/09/polymorphism_of_java/"/>
    <id>http://joeljt.top/2018/03/09/polymorphism_of_java/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-08-14T10:11:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例</p><pre><code>// 父类public class Parent {    public int aInt = -1;    public void func1() {        System.err.print(&quot; Parent func1 &quot;);    }    public void func2() {        System.err.print(&quot; Parent func2 &quot;);    }}</code></pre><pre><code>// 子类public class Child extends Parent {    public int aInt = 1;    public void func1() {        System.err.print(&quot; Child func1 &quot;);    }    public void func3() {        System.err.print(&quot; Child func3 &quot;);    }}</code></pre><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><pre><code>// test main()public static void main(String[] args) {    Child child = new Child();    child.func1();    child.func2();    child.func3();    Parent parent = new Child();    parent.func1();    parent.func2();    parent.func3();}</code></pre><p>如上所示，将对象声明为Child对象时，三个方法都编译通过，且输入结果如下：</p><pre><code>Child func1Parent func2Child func3</code></pre><p>Child类重写了父类的func1()方法，则在运行时匹配了子类自身的重写方法，即，「运行时遵循右侧声明」。<br>但是，如果将对象声明为Parent对象时，parent.fun3()则会报错，因为「编译期遵循左侧实例」，当前对象被声明为Parent实例，而Parent中没有func3()方法，所以编译不通过。同时也正因为「运行时遵循右侧声明」，所以其运行结果如下：</p><pre><code>Child func1 // 尽管声明为Parent实例，但实际调用Child的方法Parent func2</code></pre><p>综上所述，在多态使用时，成员函数遵循两个原则，即「编译期遵循左侧实例，运行时遵循右侧声明」</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><pre><code>// test main()public static void main(String[] args) {    Parent parent = new Child();    Child child = new Child();    System.err.println(parent.aInt);    System.err.println(child.aInt);}</code></pre><p>运行结果如下：</p><pre><code>-11</code></pre><p>可以发现，打印结果与成员函数有所不同。因为如果是成员函数，运行时遵循右侧声明的话，打印结果应该相等，同为1才对。因此，成员变量在多态情境下的使用，无论编译还是运行，通通遵循左侧实例。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>成员函数<br>编译时遵循左侧实例，运行时遵循右侧声明</li><li>成员变量<br>编译或者运行一律遵循左侧实例</li></ul><p>其实也比较好理解，编译期间，当前类下不存在的成员函数或成员变量，肯定是无法被实例对象获取到的；<br>而在运行时，java中子类可以重写父类的方法，因此成员函数运行时会正确指向子类的方法，但是，子类并不可以重写父类的变量，当子类与父类有同名变量时，需要使用this和super关键字进行区分。在这种情况下，成员变量的访问则不可能像方法一样使用多态访问，因此只能是遵循左侧的实例了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际使用多态时，关于成员变量和成员函数的调用，在编译期和运行时有所不同，具体代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 父类
public class Parent {
    public int aInt = -1;
    public void func1() {
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://joeljt.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
