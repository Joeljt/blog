---
title: 内部类
tags: java基础
date: 2018/03/22
---

匿名内部类了解一下？其实你每天都在用。

<!-- more -->

## 概念

将一个类声明在另一个类的内部，则将这个类成为内部类。其与外部类互相访问规则如下：

* 内部类可以访问外部类的一切成员，包括私有成员；
* 外部类若想访问内部类的成员，则必须声明内部类的实例对象。

这个规则可以这么理解，外部类和内部类就像父母和孩子：不管孩子要什么，父母总是会满足；但孩子有独立意识后，父母想了解孩子，就必须先得到孩子的同意才可以。

虽说有了规则限制，但内部类又可以划分为普通内部类，静态内部类以及匿名内部类，因此在实际使用的时候，难免还是会有迷惑的地方。下面，用伪代码进行一下区别展示。



## 普通内部类的调用

```java
class Outer{
    private int value = 10;
    class Inner{
        private int value = 20;
        void showValue(){
            int value = 30;
            System.out.print("this is funcValue -> " + value); //30
            System.out.print("this is innerValue -> " + this.value); //20
            System.out.print("this is outerValue -> " + Outer.this.value); //10
        } 
    }
}

public class Test {
    public static void main(String[] str) {
        // 普通内部类，实例化内部类对象时，需要先实例化Outer类对象，然后用Outer类对象实例化Inner类对象
        Outer.Inner inner = new Outer().new Inner(); 
        inner.showValue();
    }
}
```



## 静态内部类的调用

当一个类为内部成员时，其便可以像其他内部属性、方法一样，被各种成员修饰符所修饰。

静态内部类有两个需要注意的点：

* 因为被声明为静态，所以只能访问外部类中同样的静态属性、方法等；
* 当一个类为静态内部类时，外部类对其的调用方式也会发生不同

```java
class Outer{
  	 private static int outStaticValue = 10;
  	 private int outValue = 11;
     static class Inner{
        void showValue(){
            System.out.print("this is static Inner " + outStaticValue); // 可以访问
            System.out.print("this is static Inner " + outValue); // 编译不通过
        } 
    }
}

public class Test {
    public static void main(String[] str) {
        // 静态内部类，实例化静态内部类对象时，直接通过Outer.Inner获取内部类即可
        Outer.Inner inner = new Outer.Inner(); 
        inner.showValue();
    }
}
```



## 匿名内部类的调用

我们都熟悉匿名对象的用法，最简单的如 new Object().toString()，便是匿名对象的基本使用了。

同理，匿名内部类也是类似的。

但是也有不同，那就是声明匿名内部类，要求类必须继承一个抽象类或者实现一个接口。

下面看一下正常逻辑实现，以及匿名内部类实现的代码示例。

*  正常逻辑实现调用

```java
abstract class ParentClass{
    abstract void show();  
}

class Outer{
    class Inner extends ParentClass{
		@Override
        void show() {}
    } 
    void func(){
		new Inner().show();
    }
}

public class Test {
    public static void main(String[] str) {
        // 正常逻辑实现调用
        new Outer().func();
    }
}
```

* 匿名内部类实现方式

```java
abstract class ParentClass{
    abstract void show();  
}

class Outer{
    void func(){
		new ParentClass(){
            @override
            void show() {}
		}.show();
    }
}

public class Test {
    public static void main(String[] str) {
        new Outer().func();
    }
}
```



其实匿名内部类很简单，说到底就是new Parent(){实现父类或者接口的抽象方法}

是不是觉得很眼熟？没错，我们基本上每天都在用：

```java
mButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {}
        });
```

View.OnClickListener是一个抽象接口，我们这种实现方式，其实就是匿名内部类的实现。



## 定义在方法中的内部类

除了以上三种常见的形态，内部类还可以声明在局部，比如方法体内部：

```java
class Outer{
    void show(){
        class InnerFunc(){
            void showMsg(){}
        }
      	new InnerFunc().showMsg();
    }
}

public class Test {
    public static void main(String[] str) {
        new Outer().show(); // 这样就可以调用定义在方法内部的类了
    }
}
```

但是这种形式在日常开发中使用并不多，至少我没有用过。说到这里，感觉这个有点类似于python的在方法中声明方法：

```python
def outerFunc():
    def innerFunc():
        return "this is innerFunc"
    return innerFunc
```

内部类总结大概就要结束啦，以后想到再补充。


以上。